// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module ash.mojom;

import "components/signin/public/interfaces/account_id.mojom";
import "skia/public/interfaces/bitmap.mojom";

// Matches session_manager::SessionState.
enum SessionState {
  // Default value, when session state hasn't been initialized yet.
  UNKNOWN,

  // Running out of box UI.
  OOBE,

  // Running login UI (primary user) but user sign in hasn't completed yet.
  LOGIN_PRIMARY,

  // Running login UI (primary or secondary user), user sign in has been
  // completed but login UI hasn't been hidden yet. This means that either
  // some session initialization is happening or user has to go through some
  // UI flow on the same login UI like select avatar, agree to terms of
  // service etc.
  LOGGED_IN_NOT_ACTIVE,

  // A user(s) has logged in *and* login UI is hidden i.e. user session is
  // not blocked.
  ACTIVE,

  // The session screen is locked.
  LOCKED,

  // Same as SESSION_STATE_LOGIN_PRIMARY but for multi-profiles sign in i.e.
  // when there's at least one user already active in the session.
  LOGIN_SECONDARY,
};

// Matches user_manager::UserType.
enum UserType {
  // Regular user, has a user name and password.
  REGULAR,

  // Guest user, logs in without authentication.
  GUEST,

  // Public account user, logs in without authentication. Available only if
  // enabled through policy.
  PUBLIC_ACCOUNT,

  // Supervised user, logs in only with local authentication.
  SUPERVISED,

  // Kiosk app robot, logs in without authentication.
  KIOSK,

  // Child user, with supervised options.
  CHILD,

  // Android app in kiosk mode, logs in without authentication.
  ARC_KIOSK,

  // Active Directory user. Authenticates against Active Directory server.
  ACTIVE_DIRECTORY,
};

// Info about a user session in ash.
struct UserSession {
  // A user session id for the user session. It is generated by session manager
  // (chrome) when a user session starts and never changes during the lifetime
  // of the session manager. The number starts at 1 for the first user session
  // and incremented by one for each subsequent user session.
  uint32 session_id;

  UserType type;
  signin.mojom.AccountId account_id;
  string display_name;
  string display_email;
  skia.mojom.Bitmap avatar;
};

// Matches ash::AddUserSessionPolicy.
enum AddUserSessionPolicy {
  // Adding a user session is allowed.
  ALLOWED,

  // Disallowed due to primary user's policy.
  ERROR_NOT_ALLOWED_PRIMARY_USER,

  // Disallowed due to no eligible users.
  ERROR_NO_ELIGIBLE_USERS,

  // Disallowed due to reaching maximum supported user.
  ERROR_MAXIMUM_USERS_REACHED,
};

// Info about an ash session.
struct SessionInfo {
  // Maximum possible number of logged in users in ash.
  uint32 max_users;

  // Whether the screen can be locked.
  bool can_lock_screen;

  // Whether the screen should be locked automatically before suspending.
  bool should_lock_screen_automatically;

  // Sets whether adding a user session to ash is allowed.
  AddUserSessionPolicy add_user_session_policy;

  // Current state of the ash session.
  SessionState state;
};

// Interface for ash client (e.g. Chrome) to set session info for ash.
interface SessionController {
  // Sets the client interface.
  SetClient(SessionControllerClient client);

  // Sets the ash session info.
  SetSessionInfo(SessionInfo info);

  // Updates a user session. This is called when a user session is added or
  // its meta data (e.g. name, avatar) is changed. There is no method to remove
  // a user session because ash/chrome does not support that. All users are
  // logged out at the same time.
  UpdateUserSession(UserSession user_session);

  // Sets the order of user sessions. The order is keyed by the session id.
  // Currently, session manager set a LRU order with the first one being the
  // active user session.
  SetUserSessionOrder(array<uint32> user_session_ids);
};

// Interface for ash to request session service from its client (e.g. Chrome).
interface SessionControllerClient {
  // Requests to lock screen.
  RequestLockScreen();

  // Switch to the active user with |account_id| (if the user has already signed
  // in).
  SwitchActiveUser(signin.mojom.AccountId account_id);

  // Switch the active user to the next or previous user.
  CycleActiveUser(bool next_user);
};
