<!DOCTYPE html>
<!--
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/ui/base/draw_helpers.html">
<link rel="import" href="/tracing/ui/base/heading.html">
<link rel="import" href="/tracing/ui/base/ui.html">
<link rel="import" href="/tracing/ui/tracks/track.html">

<style>
.x-axis-track {
  height: 12px;
}

.x-axis-track.tall-mode {
  height: 30px;
}
</style>

<script>
'use strict';

tr.exportTo('tr.ui.tracks', function() {
  /**
   * A track that displays the x-axis.
   * @constructor
   * @extends {Track}
   */
  var XAxisTrack = tr.ui.b.define('x-axis-track', tr.ui.tracks.Track);

  XAxisTrack.prototype = {
    __proto__: tr.ui.tracks.Track.prototype,

    decorate: function(viewport) {
      tr.ui.tracks.Track.prototype.decorate.call(this, viewport);
      Polymer.dom(this).classList.add('x-axis-track');
      this.strings_secs_ = [];
      this.strings_msecs_ = [];
      this.strings_usecs_ = [];
      this.strings_nsecs_ = [];

      this.viewportChange_ = this.viewportChange_.bind(this);
      viewport.addEventListener('change', this.viewportChange_);

      var heading = document.createElement('tr-ui-b-heading');
      heading.arrowVisible = false;
      Polymer.dom(this).appendChild(heading);
    },

    detach: function() {
      tr.ui.tracks.Track.prototype.detach.call(this);
      this.viewport.removeEventListener('change',
          this.viewportChange_);
    },

    viewportChange_: function() {
      if (this.viewport.interestRange.isEmpty)
        Polymer.dom(this).classList.remove('tall-mode');
      else
        Polymer.dom(this).classList.add('tall-mode');
    },

    draw: function(type, viewLWorld, viewRWorld) {
      switch (type) {
        case tr.ui.tracks.DrawType.GRID:
          this.drawGrid_(viewLWorld, viewRWorld);
          break;
        case tr.ui.tracks.DrawType.MARKERS:
          if (!this.viewport.interestRange.isEmpty)
            this.viewport.interestRange.draw(this.context(),
                viewLWorld, viewRWorld);
          break;
      }
    },

    drawGrid_: function(viewLWorld, viewRWorld) {
      var ctx = this.context();
      var pixelRatio = window.devicePixelRatio || 1;

      var canvasBounds = ctx.canvas.getBoundingClientRect();
      var trackBounds = this.getBoundingClientRect();
      var width = canvasBounds.width * pixelRatio;
      var height = trackBounds.height * pixelRatio;

      var hasInterestRange = !this.viewport.interestRange.isEmpty;

      var xAxisHeightPx = hasInterestRange ? (height * 2) / 5 : height;

      var vp = this.viewport;
      var dt = vp.currentDisplayTransform;

      vp.updateMajorMarkData(viewLWorld, viewRWorld);
      var majorMarkDistanceWorld = vp.majorMarkWorldPositions.length > 1 ?
          vp.majorMarkWorldPositions[1] - vp.majorMarkWorldPositions[0] : 0;

      var numTicksPerMajor = 5;
      var minorMarkDistanceWorld = majorMarkDistanceWorld / numTicksPerMajor;
      var minorMarkDistancePx = dt.xWorldVectorToView(minorMarkDistanceWorld);

      var minorTickHeight = Math.floor(xAxisHeightPx * 0.25);

      ctx.save();

      var pixelRatio = window.devicePixelRatio || 1;
      ctx.lineWidth = Math.round(pixelRatio);

      // Apply subpixel translate to get crisp lines.
      // http://www.mobtowers.com/html5-canvas-crisp-lines-every-time/
      var crispLineCorrection = (ctx.lineWidth % 2) / 2;
      ctx.translate(crispLineCorrection, -crispLineCorrection);

      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      ctx.font = (9 * pixelRatio) + 'px sans-serif';

      var tickLabels = [];
      ctx.beginPath();
      for (var i = 0; i < vp.majorMarkWorldPositions.length; i++) {
        var curXWorld = vp.majorMarkWorldPositions[i];
        var curXView = dt.xWorldToView(curXWorld);
        var displayText = vp.majorMarkUnit.format(
            curXWorld, {deltaValue: majorMarkDistanceWorld});
        ctx.fillText(displayText, curXView + (2 * pixelRatio), 0);

        // Draw major mark.
        tr.ui.b.drawLine(ctx, curXView, 0, curXView, xAxisHeightPx);

        // Draw minor marks.
        if (minorMarkDistancePx) {
          for (var j = 1; j < numTicksPerMajor; ++j) {
            var xView = Math.floor(curXView + minorMarkDistancePx * j);
            tr.ui.b.drawLine(ctx,
                xView, xAxisHeightPx - minorTickHeight,
                xView, xAxisHeightPx);
          }
        }
      }

      // Draw bottom bar.
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      tr.ui.b.drawLine(ctx, 0, height, width, height);
      ctx.stroke();

      // Give distance between directly adjacent markers.
      if (!hasInterestRange)
        return;

      // Draw middle bar.
      tr.ui.b.drawLine(ctx, 0, xAxisHeightPx, width, xAxisHeightPx);
      ctx.stroke();

      // Distance Variables.
      var displayDistance;
      var displayTextColor = 'rgb(0,0,0)';

      // Arrow Variables.
      var arrowSpacing = 10 * pixelRatio;
      var arrowColor = 'rgb(128,121,121)';
      var arrowPosY = xAxisHeightPx * 1.75;
      var arrowWidthView = 3 * pixelRatio;
      var arrowLengthView = 10 * pixelRatio;
      var spaceForArrowsView = 2 * (arrowWidthView + arrowSpacing);

      ctx.textBaseline = 'middle';
      ctx.font = (14 * pixelRatio) + 'px sans-serif';
      var textPosY = arrowPosY;

      var interestRange = vp.interestRange;

      // If the range is zero, draw it's min timestamp next to the line.
      if (interestRange.range === 0) {
        var markerWorld = interestRange.min;
        var markerView = dt.xWorldToView(markerWorld);

        var textToDraw = vp.majorMarkUnit.format(markerWorld);
        var textLeftView = markerView + 4 * pixelRatio;
        var textWidthView = ctx.measureText(textToDraw).width;

        // Put text to the left in case it gets cut off.
        if (textLeftView + textWidthView > width)
          textLeftView = markerView - 4 * pixelRatio - textWidthView;

        ctx.fillStyle = displayTextColor;
        ctx.fillText(textToDraw, textLeftView, textPosY);
        return;
      }

      var leftMarker = interestRange.min;
      var rightMarker = interestRange.max;

      var leftMarkerView = dt.xWorldToView(leftMarker);
      var rightMarkerView = dt.xWorldToView(rightMarker);

      var distanceBetweenMarkers = interestRange.range;
      var distanceBetweenMarkersView =
          dt.xWorldVectorToView(distanceBetweenMarkers);
      var positionInMiddleOfMarkersView =
          leftMarkerView + (distanceBetweenMarkersView / 2);

      var textToDraw = vp.majorMarkUnit.format(distanceBetweenMarkers);
      var textWidthView = ctx.measureText(textToDraw).width;
      var spaceForArrowsAndTextView =
          textWidthView + spaceForArrowsView + arrowSpacing;

      // Set text positions.
      var textLeftView = positionInMiddleOfMarkersView - textWidthView / 2;
      var textRightView = textLeftView + textWidthView;

      if (spaceForArrowsAndTextView > distanceBetweenMarkersView) {
        // Print the display distance text right of the 2 markers.
        textLeftView = rightMarkerView + 2 * arrowSpacing;

        // Put text to the left in case it gets cut off.
        if (textLeftView + textWidthView > width)
          textLeftView = leftMarkerView - 2 * arrowSpacing - textWidthView;

        ctx.fillStyle = displayTextColor;
        ctx.fillText(textToDraw, textLeftView, textPosY);

        // Draw the arrows pointing from outside in and a line in between.
        ctx.strokeStyle = arrowColor;
        ctx.beginPath();
        tr.ui.b.drawLine(ctx, leftMarkerView, arrowPosY, rightMarkerView,
            arrowPosY);
        ctx.stroke();

        ctx.fillStyle = arrowColor;
        tr.ui.b.drawArrow(ctx,
            leftMarkerView - 1.5 * arrowSpacing, arrowPosY,
            leftMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
        tr.ui.b.drawArrow(ctx,
            rightMarkerView + 1.5 * arrowSpacing, arrowPosY,
            rightMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
      } else if (spaceForArrowsView <= distanceBetweenMarkersView) {
        var leftArrowStart;
        var rightArrowStart;
        if (spaceForArrowsAndTextView <= distanceBetweenMarkersView) {
          // Print the display distance text.
          ctx.fillStyle = displayTextColor;
          ctx.fillText(textToDraw, textLeftView, textPosY);

          leftArrowStart = textLeftView - arrowSpacing;
          rightArrowStart = textRightView + arrowSpacing;
        } else {
          leftArrowStart = positionInMiddleOfMarkersView;
          rightArrowStart = positionInMiddleOfMarkersView;
        }

        // Draw the arrows pointing inside out.
        ctx.strokeStyle = arrowColor;
        ctx.fillStyle = arrowColor;
        tr.ui.b.drawArrow(ctx,
            leftArrowStart, arrowPosY,
            leftMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
        tr.ui.b.drawArrow(ctx,
            rightArrowStart, arrowPosY,
            rightMarkerView, arrowPosY,
            arrowLengthView, arrowWidthView);
      }

      ctx.restore();
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loVY Lower Y bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVY Upper Y bound of the interval to search, in
     *     viewspace.
     * @param {Selection} selection Selection to which to add results.
     */
    addIntersectingEventsInRangeToSelection: function(
        loVX, hiVX, loY, hiY, selection) {
      // Does nothing. There's nothing interesting to pick on the xAxis
      // track.
    },

    addAllEventsMatchingFilterToSelection: function(filter, selection) {
    }
  };

  return {
    XAxisTrack,
  };
});
</script>
