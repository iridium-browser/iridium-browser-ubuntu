// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef WebGestureEvent_h
#define WebGestureEvent_h

#include "WebFloatSize.h"
#include "WebGestureDevice.h"
#include "WebInputEvent.h"

namespace blink {

// See WebInputEvent.h for details why this pack is here.
#pragma pack(push, 4)

// WebGestureEvent ---------------------------------------------------------

class WebGestureEvent : public WebInputEvent {
 public:
  enum ScrollUnits {
    PrecisePixels = 0,  // generated by high precision devices.
    Pixels,             // large pixel jump duration; should animate to delta.
    Page                // page (visible viewport) based scrolling.
  };

  enum InertialPhaseState {
    UnknownMomentumPhase = 0,  // No phase information.
    NonMomentumPhase,          // Regular scrolling phase.
    MomentumPhase,             // Momentum phase.
  };

  int x;
  int y;
  int globalX;
  int globalY;
  WebGestureDevice sourceDevice;

  // If the WebGestureEvent has sourceDevice=WebGestureDeviceTouchscreen, this
  // field contains the unique identifier for the touch event that released
  // this event at TouchDispositionGestureFilter. If the WebGestureEvents was
  // not released through a touch event (e.g. timer-released gesture events or
  // gesture events with sourceDevice!=WebGestureDeviceTouchscreen), the field
  // contains 0. See crbug.com/618738.
  uint32_t uniqueTouchEventId;

  // This field exists to allow BrowserPlugin to mark GestureScroll events as
  // 'resent' to handle the case where an event is not consumed when first
  // encountered; it should be handled differently by the plugin when it is
  // sent for thesecond time. No code within Blink touches this, other than to
  // plumb it through event conversions.
  int resendingPluginId;

  union {
    // Tap information must be set for GestureTap, GestureTapUnconfirmed,
    // and GestureDoubleTap events.
    struct {
      int tapCount;
      float width;
      float height;
    } tap;

    struct {
      float width;
      float height;
    } tapDown;

    struct {
      float width;
      float height;
    } showPress;

    struct {
      float width;
      float height;
    } longPress;

    struct {
      float firstFingerWidth;
      float firstFingerHeight;
    } twoFingerTap;

    struct {
      // Initial motion that triggered the scroll.
      // May be redundant with deltaX/deltaY in the first scrollUpdate.
      float deltaXHint;
      float deltaYHint;
      // Default initialized to ScrollUnits::PrecisePixels.
      ScrollUnits deltaHintUnits;
      // If true, this event will skip hit testing to find a scroll
      // target and instead just scroll the viewport.
      bool targetViewport;
      // The state of inertial phase scrolling. OSX has unique phases for normal
      // and momentum scroll events. Should always be UnknownMomentumPhase for
      // touch based input as it generates GestureFlingStart instead.
      InertialPhaseState inertialPhase;
      // True if this event was synthesized in order to force a hit test;
      // avoiding scroll latching behavior until crbug.com/526463 is fully
      // implemented.
      bool synthetic;

      // number of pointers down.
      int pointerCount;
    } scrollBegin;

    struct {
      float deltaX;
      float deltaY;
      float velocityX;
      float velocityY;
      // Whether any previous GestureScrollUpdate in the current scroll
      // sequence was suppressed (e.g., the causal touchmove was
      // preventDefault'ed). This bit is particularly useful for
      // determining whether the observed scroll update sequence captures
      // the entirety of the generative motion.
      bool previousUpdateInSequencePrevented;
      bool preventPropagation;
      InertialPhaseState inertialPhase;
      // Default initialized to ScrollUnits::PrecisePixels.
      ScrollUnits deltaUnits;
    } scrollUpdate;

    struct {
      // The original delta units the scrollBegin and scrollUpdates
      // were sent as.
      ScrollUnits deltaUnits;
      // The state of inertial phase scrolling. OSX has unique phases for normal
      // and momentum scroll events. Should always be UnknownMomentumPhase for
      // touch based input as it generates GestureFlingStart instead.
      InertialPhaseState inertialPhase;
      // True if this event was synthesized in order to generate the proper
      // GSB/GSU/GSE matching sequences. This is a temporary so that a future
      // GSB will generate a hit test so latching behavior is avoided
      // until crbug.com/526463 is fully implemented.
      bool synthetic;
    } scrollEnd;

    struct {
      float velocityX;
      float velocityY;
      // If true, this event will skip hit testing to find a scroll
      // target and instead just scroll the viewport.
      bool targetViewport;
    } flingStart;

    struct {
      // If set to true, don't treat flingCancel
      // as a part of fling boost events sequence.
      bool preventBoosting;
    } flingCancel;

    struct {
      bool zoomDisabled;
      float scale;
    } pinchUpdate;
  } data;

  WebGestureEvent(Type type, int modifiers, double timeStampSeconds)
      : WebInputEvent(sizeof(WebGestureEvent),
                      type,
                      modifiers,
                      timeStampSeconds),
        sourceDevice(WebGestureDeviceUninitialized),
        resendingPluginId(-1) {}

  WebGestureEvent()
      : WebInputEvent(sizeof(WebGestureEvent)),
        sourceDevice(WebGestureDeviceUninitialized),
        resendingPluginId(-1) {}

#if INSIDE_BLINK
  BLINK_PLATFORM_EXPORT float deltaXInRootFrame() const;
  BLINK_PLATFORM_EXPORT float deltaYInRootFrame() const;
  BLINK_PLATFORM_EXPORT ScrollUnits deltaUnits() const;
  BLINK_PLATFORM_EXPORT WebFloatPoint positionInRootFrame() const;
  BLINK_PLATFORM_EXPORT float pinchScale() const;
  BLINK_PLATFORM_EXPORT InertialPhaseState inertialPhase() const;
  BLINK_PLATFORM_EXPORT bool synthetic() const;

  BLINK_PLATFORM_EXPORT float velocityX() const;
  BLINK_PLATFORM_EXPORT float velocityY() const;

  BLINK_PLATFORM_EXPORT WebFloatSize tapAreaInRootFrame() const;
  BLINK_PLATFORM_EXPORT int tapCount() const;

  BLINK_PLATFORM_EXPORT void applyTouchAdjustment(
      WebFloatPoint rootFrameCoords);

  // Sets any scaled values to be their computed values and sets |frameScale|
  // back to 1 and |translateX|, |translateY| back to 0.
  BLINK_PLATFORM_EXPORT void flattenTransform();

  bool preventPropagation() const {
    // TODO(tdresser) Once we've decided if we're getting rid of scroll
    // chaining, we should remove all scroll chaining related logic. See
    // crbug.com/526462 for details.
    DCHECK(m_type == WebInputEvent::GestureScrollUpdate);
    return true;
  }

  bool isScrollEvent() const {
    switch (m_type) {
      case GestureScrollBegin:
      case GestureScrollEnd:
      case GestureScrollUpdate:
      case GestureFlingStart:
      case GesturePinchBegin:
      case GesturePinchEnd:
      case GesturePinchUpdate:
        return true;
      case GestureTap:
      case GestureTapUnconfirmed:
      case GestureTapDown:
      case GestureShowPress:
      case GestureTapCancel:
      case GestureTwoFingerTap:
      case GestureLongPress:
      case GestureLongTap:
        return false;
      default:
        NOTREACHED();
        return false;
    }
  }

#endif
};

#pragma pack(pop)

}  // namespace blink

#endif  // WebGestureEvent_h
