require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"../audits/aria-allowed-attr":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class ARIAAllowedAttr extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Accessibility',
      name: 'aria-allowed-attr',
      description: 'Element aria-* roles are valid',
      requiredArtifacts: ['Accessibility']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const rule =
        artifacts.Accessibility.violations.find(result => result.id === 'aria-allowed-attr');

    return ARIAAllowedAttr.generateAuditResult({
      rawValue: typeof rule === 'undefined',
      debugString: this.createDebugString(rule),
      extendedInfo: {
        formatter: Formatter.SUPPORTED_FORMATS.ACCESSIBILITY,
        value: rule
      }
    });
  }

  static createDebugString(rule) {
    if (typeof rule === 'undefined') {
      return '';
    }

    const elementsStr = rule.nodes.length === 1 ? 'element' : 'elements';
    return `${rule.help} (Failed on ${rule.nodes.length} ${elementsStr})`;
  }
}

module.exports = ARIAAllowedAttr;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/aria-valid-attr":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class ARIAValidAttr extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Accessibility',
      name: 'aria-valid-attr',
      description: 'Element aria-* attributes are valid ARIA attributes',
      requiredArtifacts: ['Accessibility']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const rule =
        artifacts.Accessibility.violations.find(result => result.id === 'aria-valid-attr');

    return ARIAValidAttr.generateAuditResult({
      rawValue: typeof rule === 'undefined',
      debugString: this.createDebugString(rule),
      extendedInfo: {
        formatter: Formatter.SUPPORTED_FORMATS.ACCESSIBILITY,
        value: rule
      }
    });
  }

  static createDebugString(rule) {
    if (typeof rule === 'undefined') {
      return '';
    }

    const elementsStr = rule.nodes.length === 1 ? 'element' : 'elements';
    return `${rule.help} (Failed on ${rule.nodes.length} ${elementsStr})`;
  }
}

module.exports = ARIAValidAttr;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/audit":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const DEFAULT_PASS = 'defaultPass';

class Audit {
  /**
   * @return {!String}
   */
  static get DEFAULT_PASS() {
    return DEFAULT_PASS;
  }

  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    throw new Error('Audit meta information must be overridden.');
  }

  /**
   * @param {!AuditResultInput} result
   * @return {!AuditResult}
   */
  static generateAuditResult(result) {
    if (typeof result.rawValue === 'undefined') {
      throw new Error('generateAuditResult requires a rawValue');
    }

    const score = typeof result.score === 'undefined' ? result.rawValue : result.score;
    let displayValue = result.displayValue;
    if (typeof displayValue === 'undefined') {
      displayValue = result.rawValue ? result.rawValue : '';
    }

    // The same value or true should be '' it doesn't add value to the report
    if (displayValue === score) {
      displayValue = '';
    }

    return {
      score,
      displayValue: `${displayValue}`,
      rawValue: result.rawValue,
      debugString: result.debugString,
      optimalValue: result.optimalValue,
      extendedInfo: result.extendedInfo,
      name: this.meta.name,
      category: this.meta.category,
      description: this.meta.description,
      helpText: this.meta.helpText
    };
  }
}

module.exports = Audit;

},{}],"../audits/cache-start-url":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class CacheStartUrl extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'cache-start-url',
      description: 'Cache contains start_url from manifest (alpha)',
      requiredArtifacts: ['CacheContents', 'Manifest', 'URL']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    let cacheHasStartUrl = false;
    const manifest = artifacts.Manifest && artifacts.Manifest.value;
    const cacheContents = artifacts.CacheContents;

    if (!(manifest && manifest.start_url && manifest.start_url.value)) {
      return CacheStartUrl.generateAuditResult({
        rawValue: false,
        debugString: 'start_url not present in Manifest'
      });
    }

    if (!(Array.isArray(cacheContents) && artifacts.URL &&
          artifacts.URL.finalUrl)) {
      return CacheStartUrl.generateAuditResult({
        rawValue: false,
        debugString: 'No cache or URL detected'
      });
    }

    // Remove any UTM strings.
    const startURL = manifest.start_url.value;
    const altStartURL = startURL
        .replace(/\?utm_([^=]*)=([^&]|$)*/, '')
        .replace(/\?$/, '');

    // Now find the start_url in the cacheContents. This test is less than ideal since the Service
    // Worker can rewrite a request from the start URL to anything else in the cache, and so a TODO
    // here would be to resolve this more completely by asking the Service Worker about the start
    // URL. However that would also necessitate the cache contents gatherer relying on the manifest
    // gather rather than being independent of it.
    cacheHasStartUrl = cacheContents.find(req => {
      return (startURL === req || altStartURL === req);
    });

    return CacheStartUrl.generateAuditResult({
      rawValue: (cacheHasStartUrl !== undefined)
    });
  }
}

module.exports = CacheStartUrl;

},{"./audit":"../audits/audit"}],"../audits/color-contrast":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class ColorContrast extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Accessibility',
      name: 'color-contrast',
      description: 'Background and foreground colors have a sufficient contrast ratio',
      requiredArtifacts: ['Accessibility']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const rule =
        artifacts.Accessibility.violations.find(result => result.id === 'color-contrast');

    return ColorContrast.generateAuditResult({
      rawValue: typeof rule === 'undefined',
      debugString: this.createDebugString(rule),
      extendedInfo: {
        formatter: Formatter.SUPPORTED_FORMATS.ACCESSIBILITY,
        value: rule
      }
    });
  }

  static createDebugString(rule) {
    if (typeof rule === 'undefined') {
      return '';
    }

    const elementsStr = rule.nodes.length === 1 ? 'element' : 'elements';
    return `${rule.help} (Failed on ${rule.nodes.length} ${elementsStr})`;
  }
}

module.exports = ColorContrast;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/content-width":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class ContentWidth extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Mobile Friendly',
      name: 'content-width',
      description: 'Content is sized correctly for the viewport',
      requiredArtifacts: ['ContentWidth']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    if (typeof artifacts.ContentWidth === 'undefined' ||
        typeof artifacts.ContentWidth.scrollWidth === 'undefined' ||
        typeof artifacts.ContentWidth.viewportWidth === 'undefined') {
      return ContentWidth.generateAuditResult({
        rawValue: false,
        debugString: 'Unable to find scroll and viewport widths.'
      });
    }

    const widthsMatch =
        artifacts.ContentWidth.scrollWidth === artifacts.ContentWidth.viewportWidth;

    return ContentWidth.generateAuditResult({
      rawValue: widthsMatch,
      debugString: this.createDebugString(widthsMatch, artifacts.ContentWidth)
    });
  }

  static createDebugString(match, artifact) {
    if (match) {
      return '';
    }

    return 'The content scroll size is ' + artifact.scrollWidth + 'px, ' +
        'whereas the viewport size is ' + artifact.viewportWidth + 'px.';
  }
}

module.exports = ContentWidth;

},{"./audit":"../audits/audit"}],"../audits/critical-request-chains":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class CriticalRequestChains extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Performance',
      name: 'critical-request-chains',
      description: 'Critical Request Chains',
      optimalValue: 0,
      requiredArtifacts: ['networkRecords']
    };
  }

  /**
   * Audits the page to give a score for First Meaningful Paint.
   * @param {!Artifacts} artifacts The artifacts from the gather phase.
   * @return {!AuditResult} The score from the audit, ranging from 0-100.
   */
  static audit(artifacts) {
    const networkRecords = artifacts.networkRecords[Audit.DEFAULT_PASS];
    return artifacts.requestCriticalRequestChains(networkRecords).then(chains => {
      let chainCount = 0;
      function walk(node, depth) {
        const children = Object.keys(node);

        // Since a leaf node indicates the end of a chain, we can inspect the number
        // of child nodes, and, if the count is zero, increment the count.
        if (children.length === 0) {
          chainCount++;
        }

        children.forEach(id => {
          const child = node[id];
          walk(child.children, depth + 1);
        }, '');
      }

      walk(chains, 0);

      return CriticalRequestChains.generateAuditResult({
        rawValue: chainCount,
        optimalValue: this.meta.optimalValue,
        extendedInfo: {
          formatter: Formatter.SUPPORTED_FORMATS.CRITICAL_REQUEST_CHAINS,
          value: chains
        }
      });
    });
  }
}

module.exports = CriticalRequestChains;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/estimated-input-latency":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Audit = require('./audit');
const TracingProcessor = require('../lib/traces/tracing-processor');
const Formatter = require('../formatters/formatter');

// Parameters (in ms) for log-normal CDF scoring. To see the curve:
// https://www.desmos.com/calculator/srv0hqhf7d
const SCORING_POINT_OF_DIMINISHING_RETURNS = 50;
const SCORING_MEDIAN = 100;

class EstimatedInputLatency extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Performance',
      name: 'estimated-input-latency',
      description: 'Estimated Input Latency',
      optimalValue: SCORING_POINT_OF_DIMINISHING_RETURNS.toLocaleString() + 'ms',
      requiredArtifacts: ['traceContents']
    };
  }

  static calculate(speedline, trace) {
    // Use speedline's first paint as start of range for input latency check.
    const startTime = speedline.first;

    const tracingProcessor = new TracingProcessor();
    const model = tracingProcessor.init(trace);
    const latencyPercentiles = TracingProcessor.getRiskToResponsiveness(model, trace, startTime);

    const ninetieth = latencyPercentiles.find(result => result.percentile === 0.9);
    const rawValue = parseFloat(ninetieth.time.toFixed(1));

    // Use the CDF of a log-normal distribution for scoring.
    //  10th Percentile ≈ 58ms
    //  25th Percentile ≈ 75ms
    //  Median = 100ms
    //  75th Percentile ≈ 133ms
    //  95th Percentile ≈ 199ms
    const distribution = TracingProcessor.getLogNormalDistribution(SCORING_MEDIAN,
        SCORING_POINT_OF_DIMINISHING_RETURNS);
    const score = 100 * distribution.computeComplementaryPercentile(ninetieth.time);

    return EstimatedInputLatency.generateAuditResult({
      score: Math.round(score),
      optimalValue: this.meta.optimalValue,
      rawValue,
      displayValue: `${rawValue}ms`,
      extendedInfo: {
        value: latencyPercentiles,
        formatter: Formatter.SUPPORTED_FORMATS.ESTIMATED_INPUT_LATENCY
      }
    });
  }

  /**
   * Audits the page to estimate input latency.
   * @see https://github.com/GoogleChrome/lighthouse/issues/28
   * @param {!Artifacts} artifacts The artifacts from the gather phase.
   * @return {!Promise<!AuditResult>} The score from the audit, ranging from 0-100.
   */
  static audit(artifacts) {
    const trace = artifacts.traces[this.DEFAULT_PASS];

    return artifacts.requestSpeedline(trace)
      .then(speedline => EstimatedInputLatency.calculate(speedline, trace))
      .catch(err => {
        return EstimatedInputLatency.generateAuditResult({
          rawValue: -1,
          debugString: 'Speedline unable to parse trace contents: ' + err.message
        });
      });
  }
}

module.exports = EstimatedInputLatency;

},{"../formatters/formatter":7,"../lib/traces/tracing-processor":25,"./audit":"../audits/audit"}],"../audits/first-meaningful-paint":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const TracingProcessor = require('../lib/traces/tracing-processor');
const Formatter = require('../formatters/formatter');

const FAILURE_MESSAGE = 'Navigation and first paint timings not found.';

// Parameters (in ms) for log-normal CDF scoring. To see the curve:
// https://www.desmos.com/calculator/joz3pqttdq
const SCORING_POINT_OF_DIMINISHING_RETURNS = 1600;
const SCORING_MEDIAN = 4000;

const BLOCK_FIRST_MEANINGFUL_PAINT_IF_BLANK_CHARACTERS_MORE_THAN = 200;

class FirstMeaningfulPaint extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Performance',
      name: 'first-meaningful-paint',
      description: 'First meaningful paint',
      optimalValue: SCORING_POINT_OF_DIMINISHING_RETURNS.toLocaleString() + 'ms',
      requiredArtifacts: ['traceContents']
    };
  }

  /**
   * Audits the page to give a score for First Meaningful Paint.
   * @see https://github.com/GoogleChrome/lighthouse/issues/26
   * @see https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/view
   * @param {!Artifacts} artifacts The artifacts from the gather phase.
   * @return {!Promise<!AuditResult>} The score from the audit, ranging from 0-100.
   */
  static audit(artifacts) {
    return new Promise((resolve, reject) => {
      const traceContents = artifacts.traces[this.DEFAULT_PASS].traceEvents;
      if (!traceContents || !Array.isArray(traceContents)) {
        throw new Error(FAILURE_MESSAGE);
      }
      const evts = this.collectEvents(traceContents);

      const navStart = evts.navigationStart;
      const fCP = evts.firstContentfulPaint;
      const fMPbasic = this.findFirstMeaningfulPaint(evts, {});
      const fMPpageheight = this.findFirstMeaningfulPaint(evts, {pageHeight: true});
      const fMPwebfont = this.findFirstMeaningfulPaint(evts, {webFont: true});
      const fMPfull = this.findFirstMeaningfulPaint(evts, {pageHeight: true, webFont: true});

      var data = {
        navStart,
        fmpCandidates: {
          fCP,
          fMPbasic,
          fMPpageheight,
          fMPwebfont,
          fMPfull
        }
      };

      const result = this.calculateScore(data);

      resolve(FirstMeaningfulPaint.generateAuditResult({
        score: result.score,
        rawValue: parseFloat(result.duration),
        displayValue: `${result.duration}ms`,
        debugString: result.debugString,
        optimalValue: this.meta.optimalValue,
        extendedInfo: {
          value: result.extendedInfo,
          formatter: Formatter.SUPPORTED_FORMATS.NULL
        }
      }));
    }).catch(err => {
      // Recover from trace parsing failures.
      return FirstMeaningfulPaint.generateAuditResult({
        rawValue: -1,
        debugString: err.message
      });
    });
  }

  static calculateScore(data) {
    // there are a few candidates for fMP:
    // * firstContentfulPaint: the first time that text or image content was painted.
    // * fMP basic: paint after most significant layout
    // * fMP page height: basic + scaling sigificance to page height
    // * fMP webfont: basic + waiting for in-flight webfonts to paint
    // * fMP full: considering both page height + webfont heuristics

    // Calculate the difference from navigation and save all candidates
    const timings = {};
    const timingsArr = [];
    Object.keys(data.fmpCandidates).forEach(name => {
      const evt = data.fmpCandidates[name];
      timings[name] = evt && ((evt.ts - data.navStart.ts) / 1000);
      timingsArr.push(timings[name]);
    });

    // First meaningful paint is the last timestamp observed from the candidates
    const firstMeaningfulPaint = timingsArr.reduce((maxTimestamp, curr) => max(maxTimestamp, curr));

    // Use the CDF of a log-normal distribution for scoring.
    //   < 1100ms: score≈100
    //   4000ms: score=50
    //   >= 14000ms: score≈0
    const distribution = TracingProcessor.getLogNormalDistribution(SCORING_MEDIAN,
        SCORING_POINT_OF_DIMINISHING_RETURNS);
    let score = 100 * distribution.computeComplementaryPercentile(firstMeaningfulPaint);

    // Clamp the score to 0 <= x <= 100.
    score = Math.min(100, score);
    score = Math.max(0, score);

    timings.navStart = data.navStart.ts / 1000;

    return {
      duration: `${firstMeaningfulPaint.toFixed(1)}`,
      score: Math.round(score),
      rawValue: firstMeaningfulPaint.toFixed(1),
      extendedInfo: {timings}
    };
  }

  /**
   * @param {!Array<!Object>} traceData
   */
  static collectEvents(traceData) {
    let mainFrameID;
    let navigationStart;
    let firstContentfulPaint;
    const layouts = new Map();
    const paints = [];

    // const model = new DevtoolsTimelineModel(traceData);
    // const events = model.timelineModel().mainThreadEvents();
    const events = traceData;

    // Parse the trace for our key events and sort them by timestamp.
    events.filter(e => {
      return e.cat.includes('blink.user_timing') ||
        e.name === 'FrameView::performLayout' ||
        e.name === 'Paint' ||
        e.name === 'TracingStartedInPage';
    }).sort((event0, event1) => {
      return event0.ts - event1.ts;
    }).forEach(event => {
      // Grab the page's ID from the first TracingStartedInPage in the trace
      if (event.name === 'TracingStartedInPage' && !mainFrameID) {
        mainFrameID = event.args.data.page;
      }

      // Record the navigationStart, but only once TracingStartedInPage has started
      // which is when mainFrameID exists
      if (event.name === 'navigationStart' && !!mainFrameID && !navigationStart) {
        navigationStart = event;
      }
      // firstContentfulPaint == the first time that text or image content was
      // painted. See src/third_party/WebKit/Source/core/paint/PaintTiming.h
      // COMPAT: firstContentfulPaint trace event first introduced in Chrome 49 (r370921)
      if (event.name === 'firstContentfulPaint' && event.args.frame === mainFrameID &&
          !!navigationStart && event.ts >= navigationStart.ts) {
        firstContentfulPaint = event;
      }
      // COMPAT: frame property requires Chrome 52 (r390306)
      // https://codereview.chromium.org/1922823003
      if (event.name === 'FrameView::performLayout' &&
          event.args.counters && event.args.counters.frame === mainFrameID &&
          !!navigationStart && event.ts >= navigationStart.ts) {
        layouts.set(event, event.args.counters);
      }

      if (event.name === 'Paint' && event.args.data.frame === mainFrameID &&
        !!navigationStart && event.ts >= navigationStart.ts) {
        paints.push(event);
      }
    });

    // navigationStart is currently essential to FMP calculation.
    // see: https://github.com/GoogleChrome/lighthouse/issues/753
    if (!navigationStart) {
      throw new Error('No `navigationStart` event found after `TracingStartedInPage` in trace');
    }

    return {
      navigationStart,
      firstContentfulPaint,
      layouts,
      paints
    };
  }

  static findFirstMeaningfulPaint(evts, heuristics) {
    let mostSignificantLayout;
    let significance = 0;
    let maxSignificanceSoFar = 0;
    let pending = 0;

    evts.layouts.forEach((countersObj, layoutEvent) => {
      const counter = val => countersObj[val];

      function heightRatio() {
        const ratioBefore = counter('contentsHeightBeforeLayout') / counter('visibleHeight');
        const ratioAfter = counter('contentsHeightAfterLayout') / counter('visibleHeight');
        return (max(1, ratioBefore) + max(1, ratioAfter)) / 2;
      }

      // If there are loading fonts when layout happened, the layout change accounting is postponed
      // until the font is displayed. However, icon fonts shouldn't block first meaningful paint.
      // We use a threshold that only web fonts that laid out more than 200 characters
      // should block first meaningful paint.
      //   https://docs.google.com/document/d/1BR94tJdZLsin5poeet0XoTW60M0SjvOJQttKT-JK8HI/edit#heading=h.wjx8tsc9m27r
      function hasTooManyBlankCharactersToBeMeaningful() {
        return counter('approximateBlankCharacterCount') >
            BLOCK_FIRST_MEANINGFUL_PAINT_IF_BLANK_CHARACTERS_MORE_THAN;
      }

      if (!counter('host') || counter('visibleHeight') === 0) {
        return;
      }

      const layoutCount = counter('LayoutObjectsThatHadNeverHadLayout') || 0;
      // layout significance = number of layout objects added / max(1, page height / screen height)
      significance = (heuristics.pageHeight) ? (layoutCount / heightRatio()) : layoutCount;

      if (heuristics.webFont && hasTooManyBlankCharactersToBeMeaningful()) {
        pending += significance;
      } else {
        significance += pending;
        pending = 0;
        if (significance > maxSignificanceSoFar) {
          maxSignificanceSoFar = significance;
          mostSignificantLayout = layoutEvent;
        }
      }
    });

    let paintAfterMSLayout;
    if (mostSignificantLayout) {
      paintAfterMSLayout = evts.paints.find(e => e.ts > mostSignificantLayout.ts);
    }
    return paintAfterMSLayout;
  }
}

module.exports = FirstMeaningfulPaint;

/**
 * Math.max, but with NaN values removed
 * @param {...number} _
 */
function max(_) {
  const args = [...arguments].filter(val => !isNaN(val));
  return Math.max.apply(Math, args);
}

},{"../formatters/formatter":7,"../lib/traces/tracing-processor":25,"./audit":"../audits/audit"}],"../audits/geolocation-on-start":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class GeolocationOnStart extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'UX',
      name: 'geolocation',
      description: 'Page does not automatically request geolocation',
      requiredArtifacts: ['GeolocationOnStart']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    if (typeof artifacts.GeolocationOnStart === 'undefined' ||
        artifacts.GeolocationOnStart === -1) {
      return GeolocationOnStart.generateAuditResult({
        rawValue: false,
        debugString: 'Unable to get geolocation values.'
      });
    }

    return GeolocationOnStart.generateAuditResult({
      rawValue: artifacts.GeolocationOnStart
    });
  }
}

module.exports = GeolocationOnStart;

},{"./audit":"../audits/audit"}],"../audits/image-alt":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class ImageAlt extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Accessibility',
      name: 'image-alt',
      description: 'Every image element has an alt attribute',
      requiredArtifacts: ['Accessibility']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const rule =
        artifacts.Accessibility.violations.find(result => result.id === 'image-alt');

    return ImageAlt.generateAuditResult({
      rawValue: typeof rule === 'undefined',
      debugString: this.createDebugString(rule),
      extendedInfo: {
        formatter: Formatter.SUPPORTED_FORMATS.ACCESSIBILITY,
        value: rule
      }
    });
  }

  static createDebugString(rule) {
    if (typeof rule === 'undefined') {
      return '';
    }

    const elementsStr = rule.nodes.length === 1 ? 'element' : 'elements';
    return `${rule.help} (Failed on ${rule.nodes.length} ${elementsStr})`;
  }
}

module.exports = ImageAlt;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/is-on-https":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Audit = require('./audit');

class HTTPS extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Security',
      name: 'is-on-https',
      description: 'Site is on HTTPS',
      requiredArtifacts: ['HTTPS']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    return HTTPS.generateAuditResult({
      rawValue: artifacts.HTTPS.value,
      debugString: artifacts.HTTPS.debugString
    });
  }
}

module.exports = HTTPS;

},{"./audit":"../audits/audit"}],"../audits/label":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class Label extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Accessibility',
      name: 'label',
      description: 'Every form element has a label',
      requiredArtifacts: ['Accessibility']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const rule =
        artifacts.Accessibility.violations.find(result => result.id === 'label');

    return Label.generateAuditResult({
      rawValue: typeof rule === 'undefined',
      debugString: this.createDebugString(rule),
      extendedInfo: {
        formatter: Formatter.SUPPORTED_FORMATS.ACCESSIBILITY,
        value: rule
      }
    });
  }

  static createDebugString(rule) {
    if (typeof rule === 'undefined') {
      return '';
    }

    const elementsStr = rule.nodes.length === 1 ? 'element' : 'elements';
    return `${rule.help} (Failed on ${rule.nodes.length} ${elementsStr})`;
  }
}

module.exports = Label;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/manifest-background-color":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class ManifestBackgroundColor extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-background-color',
      description: 'Manifest contains background_color',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Manifest=} manifest
   * @return {boolean}
   */
  static getBackgroundColorValue(manifest) {
    return manifest !== undefined &&
      manifest.background_color.value;
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const bgColor = ManifestBackgroundColor.getBackgroundColorValue(artifacts.Manifest.value);

    return ManifestBackgroundColor.generateAuditResult({
      rawValue: !!bgColor,
      extendedInfo: {
        value: bgColor,
        formatter: Formatter.SUPPORTED_FORMATS.NULL
      }
    });
  }
}

module.exports = ManifestBackgroundColor;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/manifest-display":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class ManifestDisplay extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-display',
      description: 'Manifest\'s display property is set',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {string|undefined} val
   * @return {boolean}
   */
  static hasRecommendedValue(val) {
    return (val === 'fullscreen' || val === 'standalone' || val === 'browser');
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const manifest = artifacts.Manifest.value;
    const displayValue = manifest && manifest.display.value;

    const hasRecommendedValue = ManifestDisplay.hasRecommendedValue(displayValue);

    return ManifestDisplay.generateAuditResult({
      rawValue: hasRecommendedValue,
      displayValue,
      debugString: 'Manifest display property should be set.'
    });
  }
}

module.exports = ManifestDisplay;

},{"./audit":"../audits/audit"}],"../audits/manifest-exists":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class ManifestExists extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-exists',
      description: 'Manifest exists',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    return ManifestExists.generateAuditResult({
      rawValue: typeof artifacts.Manifest.value !== 'undefined',
      debugString: artifacts.Manifest.debugString
    });
  }
}

module.exports = ManifestExists;

},{"./audit":"../audits/audit"}],"../audits/manifest-icons-min-144":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const icons = require('../lib/icons');

class ManifestIconsMin144 extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-icons-min-144',
      description: 'Manifest contains icons at least 144px',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const manifest = artifacts.Manifest.value;

    if (icons.doExist(manifest) === false) {
      return ManifestIconsMin144.generateAuditResult({
        rawValue: false,
        debugString: 'WARNING: No icons found in the manifest'
      });
    }

    const matchingIcons = icons.sizeAtLeast(144, /** @type {!Manifest} */ (manifest));
    const foundSizesDebug = matchingIcons.length ?
        `Found icons of sizes: ${matchingIcons}` : undefined;
    return ManifestIconsMin144.generateAuditResult({
      rawValue: !!matchingIcons.length,
      debugString: foundSizesDebug
    });
  }
}

module.exports = ManifestIconsMin144;


},{"../lib/icons":20,"./audit":"../audits/audit"}],"../audits/manifest-icons-min-192":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const icons = require('../lib/icons');

class ManifestIconsMin192 extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-icons-min-192',
      description: 'Manifest contains icons at least 192px',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const manifest = artifacts.Manifest.value;

    if (icons.doExist(manifest) === false) {
      return ManifestIconsMin192.generateAuditResult({
        rawValue: false,
        debugString: 'WARNING: No icons found in the manifest'
      });
    }

    const matchingIcons = icons.sizeAtLeast(192, /** @type {!Manifest} */ (manifest));

    const foundSizesDebug = matchingIcons.length ?
        `Found icons of sizes: ${matchingIcons}` : undefined;
    return ManifestIconsMin192.generateAuditResult({
      rawValue: !!matchingIcons.length,
      debugString: foundSizesDebug
    });
  }
}

module.exports = ManifestIconsMin192;

},{"../lib/icons":20,"./audit":"../audits/audit"}],"../audits/manifest-name":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class ManifestName extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-name',
      description: 'Manifest contains name',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    let hasName = false;
    const manifest = artifacts.Manifest.value;

    if (manifest && manifest.name) {
      hasName = (!!manifest.name.value);
    }

    return ManifestName.generateAuditResult({
      rawValue: hasName
    });
  }
}

module.exports = ManifestName;

},{"./audit":"../audits/audit"}],"../audits/manifest-short-name-length":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class ManifestShortNameLength extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-short-name-length',
      description: 'Manifest\'s short_name won\'t be truncated when displayed on homescreen',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    let isShortNameShortEnough = false;
    let debugString;
    const manifest = artifacts.Manifest.value;
    const suggestedLength = 12;

    if (manifest) {
      // When no shortname can be found we look for a name
      // Historically, Chrome recommended 12 chars as the maximum length to prevent truncation.
      // See #69 for more discussion.
      // https://developer.chrome.com/apps/manifest/name#short_name
      const manifestValue = manifest.short_name.value || manifest.name.value || '';
      isShortNameShortEnough = manifestValue && manifestValue.length <= suggestedLength;

      if (!isShortNameShortEnough) {
        debugString = `${suggestedLength} chars is the suggested maximum homescreen label length`;
        debugString += ` (Found: ${manifestValue.length} chars).`;
      }
    }

    return ManifestShortNameLength.generateAuditResult({
      rawValue: isShortNameShortEnough,
      debugString
    });
  }
}

module.exports = ManifestShortNameLength;

},{"./audit":"../audits/audit"}],"../audits/manifest-short-name":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class ManifestShortName extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-short-name',
      description: 'Manifest contains short_name',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    let hasShortName = false;
    const manifest = artifacts.Manifest.value;

    if (manifest) {
      hasShortName = !!(manifest.short_name.value || manifest.name.value);
    }

    return ManifestShortName.generateAuditResult({
      rawValue: hasShortName
    });
  }
}

module.exports = ManifestShortName;

},{"./audit":"../audits/audit"}],"../audits/manifest-start-url":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class ManifestStartUrl extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-start-url',
      description: 'Manifest contains start_url',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    let hasStartUrl = false;
    const manifest = artifacts.Manifest.value;

    if (manifest && manifest.start_url) {
      hasStartUrl = (!!manifest.start_url.value);
    }

    return ManifestStartUrl.generateAuditResult({
      rawValue: hasStartUrl
    });
  }
}

module.exports = ManifestStartUrl;

},{"./audit":"../audits/audit"}],"../audits/manifest-theme-color":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class ManifestThemeColor extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Manifest',
      name: 'manifest-theme-color',
      description: 'Manifest contains theme_color',
      requiredArtifacts: ['Manifest']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    let hasThemeColor = false;
    const manifest = artifacts.Manifest.value;

    if (manifest && manifest.theme_color) {
      hasThemeColor = (!!manifest.theme_color.value);
    }

    return ManifestThemeColor.generateAuditResult({
      rawValue: hasThemeColor
    });
  }
}

module.exports = ManifestThemeColor;

},{"./audit":"../audits/audit"}],"../audits/meta-theme-color":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const validColor = require('../lib/web-inspector').Color.parse;
const Audit = require('./audit');

class ThemeColor extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'HTML',
      name: 'theme-color-meta',
      description: 'HTML has a theme-color <meta>',
      requiredArtifacts: ['ThemeColor']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const themeColorMeta = artifacts.ThemeColor;
    if (!themeColorMeta) {
      return ThemeColor.generateAuditResult({
        rawValue: false,
        debugString: 'No valid theme-color meta tag found.'
      });
    }

    if (!validColor(themeColorMeta)) {
      return ThemeColor.generateAuditResult({
        displayValue: themeColorMeta,
        rawValue: false,
        debugString: 'The theme-color meta tag did not contain a valid CSS color.'
      });
    }

    return ThemeColor.generateAuditResult({
      displayValue: themeColorMeta,
      rawValue: true
    });
  }
}

module.exports = ThemeColor;

},{"../lib/web-inspector":26,"./audit":"../audits/audit"}],"../audits/redirects-http":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Audit = require('./audit');

class RedirectsHTTP extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Security',
      name: 'redirects-http',
      description: 'Site redirects HTTP traffic to HTTPS',
      requiredArtifacts: ['HTTPRedirect']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    if (!artifacts.HTTPRedirect ||
        !artifacts.HTTPRedirect.value) {
      return RedirectsHTTP.generateAuditResult({
        rawValue: false
      });
    }

    return RedirectsHTTP.generateAuditResult({
      rawValue: artifacts.HTTPRedirect.value,
      debugString: artifacts.HTTPRedirect.debugString
    });
  }
}

module.exports = RedirectsHTTP;

},{"./audit":"../audits/audit"}],"../audits/screenshots":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class Screenshots extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Performance',
      name: 'screenshots',
      description: 'Screenshots of all captured frames',
      requiredArtifacts: ['traceContents']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!Promise<!AuditResult>}
   */
  static audit(artifacts) {
    const trace = artifacts.traces[this.DEFAULT_PASS];
    if (typeof trace === 'undefined') {
      return Promise.resolve(Screenshots.generateAuditResult({
        rawValue: -1,
        debugString: 'No trace found to generate screenshots'
      }));
    }

    return artifacts.requestScreenshots(trace).then(screenshots => {
      if (typeof screenshots === 'undefined') {
        return Screenshots.generateAuditResult({
          rawValue: -1,
          debugString: 'No screenshot artifact'
        });
      }

      return Screenshots.generateAuditResult({
        rawValue: screenshots.length || 0,
        extendedInfo: {
          formatter: Formatter.SUPPORTED_FORMATS.NULL,
          value: screenshots
        }
      });
    });
  }
}

module.exports = Screenshots;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/service-worker":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const url = require('url');
const Audit = require('./audit');

/**
 * @param {string} targetURL
 * @return {string}
 */
function getOrigin(targetURL) {
  const parsedURL = url.parse(targetURL);
  return `${parsedURL.protocol}//${parsedURL.hostname}` +
      (parsedURL.port ? `:${parsedURL.port}` : '');
}

/**
 * @param {!Array<!ServiceWorkerVersion>} versions
 * @param {string} url
 * @return {(!ServiceWorkerVersion|undefined)}
 */
function getActivatedServiceWorker(versions, url) {
  const origin = getOrigin(url);
  return versions.find(v => v.status === 'activated' && getOrigin(v.scriptURL) === origin);
}

class ServiceWorker extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Offline',
      name: 'service-worker',
      description: 'Has a registered Service Worker',
      requiredArtifacts: ['URL', 'ServiceWorker']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    if (!artifacts.ServiceWorker.versions) {
      // Error in ServiceWorker gatherer.
      return ServiceWorker.generateAuditResult({
        rawValue: false,
        debugString: artifacts.ServiceWorker.debugString
      });
    }

    // Find active service worker for this URL. Match against
    // artifacts.URL.finalUrl so audit accounts for any redirects.
    const version = getActivatedServiceWorker(
        artifacts.ServiceWorker.versions, artifacts.URL.finalUrl);
    const debugString = version ? undefined : 'No active service worker found for this origin.';

    return ServiceWorker.generateAuditResult({
      rawValue: !!version,
      debugString: debugString
    });
  }
}

module.exports = ServiceWorker;

},{"./audit":"../audits/audit","url":204}],"../audits/speed-index-metric":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const TracingProcessor = require('../lib/traces/tracing-processor');
const Formatter = require('../formatters/formatter');

// Parameters (in ms) for log-normal CDF scoring. To see the curve:
// https://www.desmos.com/calculator/mdgjzchijg
const SCORING_POINT_OF_DIMINISHING_RETURNS = 1250;
const SCORING_MEDIAN = 5500;

class SpeedIndexMetric extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Performance',
      name: 'speed-index-metric',
      description: 'Perceptual Speed Index',
      optimalValue: SCORING_POINT_OF_DIMINISHING_RETURNS.toLocaleString(),
      requiredArtifacts: ['traceContents']
    };
  }

  /**
   * Audits the page to give a score for the Speed Index.
   * @see  https://github.com/GoogleChrome/lighthouse/issues/197
   * @param {!Artifacts} artifacts The artifacts from the gather phase.
   * @return {!Promise<!AuditResult>} The score from the audit, ranging from 0-100.
   */
  static audit(artifacts) {
    const trace = artifacts.traces[this.DEFAULT_PASS];
    if (typeof trace === 'undefined') {
      return SpeedIndexMetric.generateAuditResult({
        rawValue: -1,
        debugString: 'No trace found to generate screenshots'
      });
    }

    // run speedline
    return artifacts.requestSpeedline(trace).then(speedline => {
      if (speedline.frames.length === 0) {
        return SpeedIndexMetric.generateAuditResult({
          rawValue: -1,
          debugString: 'Trace unable to find visual progress frames.'
        });
      }

      if (speedline.speedIndex === 0) {
        return SpeedIndexMetric.generateAuditResult({
          rawValue: -1,
          debugString: 'Error in Speedline calculating Speed Index (speedIndex of 0).'
        });
      }

      // Use the CDF of a log-normal distribution for scoring.
      //  10th Percentile = 2,240
      //  25th Percentile = 3,430
      //  Median = 5,500
      //  75th Percentile = 8,820
      //  95th Percentile = 17,400
      const distribution = TracingProcessor.getLogNormalDistribution(SCORING_MEDIAN,
        SCORING_POINT_OF_DIMINISHING_RETURNS);
      let score = 100 * distribution.computeComplementaryPercentile(speedline.perceptualSpeedIndex);

      // Clamp the score to 0 <= x <= 100.
      score = Math.min(100, score);
      score = Math.max(0, score);

      const extendedInfo = {
        first: speedline.first,
        complete: speedline.complete,
        duration: speedline.duration,
        frames: speedline.frames.map(frame => {
          return {
            timestamp: frame.getTimeStamp(),
            progress: frame.getPerceptualProgress()
          };
        })
      };

      return SpeedIndexMetric.generateAuditResult({
        score: Math.round(score),
        rawValue: Math.round(speedline.perceptualSpeedIndex),
        optimalValue: this.meta.optimalValue,
        extendedInfo: {
          formatter: Formatter.SUPPORTED_FORMATS.SPEEDLINE,
          value: extendedInfo
        }
      });
    }).catch(err => {
      return SpeedIndexMetric.generateAuditResult({
        rawValue: -1,
        debugString: err.message
      });
    });
  }
}

module.exports = SpeedIndexMetric;

},{"../formatters/formatter":7,"../lib/traces/tracing-processor":25,"./audit":"../audits/audit"}],"../audits/tabindex":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');

class TabIndex extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Accessibility',
      name: 'tab-index',
      description: 'No element has a tabindex attribute greater than 0',
      requiredArtifacts: ['Accessibility']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const rule =
        artifacts.Accessibility.violations.find(result => result.id === 'tabindex');

    return TabIndex.generateAuditResult({
      rawValue: typeof rule === 'undefined',
      debugString: this.createDebugString(rule),
      extendedInfo: {
        formatter: Formatter.SUPPORTED_FORMATS.ACCESSIBILITY,
        value: rule
      }
    });
  }

  static createDebugString(rule) {
    if (typeof rule === 'undefined') {
      return '';
    }

    const elementsStr = rule.nodes.length === 1 ? 'element' : 'elements';
    return `${rule.help} (Failed on ${rule.nodes.length} ${elementsStr})`;
  }
}

module.exports = TabIndex;

},{"../formatters/formatter":7,"./audit":"../audits/audit"}],"../audits/time-to-interactive":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const TracingProcessor = require('../lib/traces/tracing-processor');
const FMPMetric = require('./first-meaningful-paint');
const Formatter = require('../formatters/formatter');

// Parameters (in ms) for log-normal CDF scoring. To see the curve:
//   https://www.desmos.com/calculator/jlrx14q4w8
const SCORING_POINT_OF_DIMINISHING_RETURNS = 1700;
const SCORING_MEDIAN = 5000;

class TTIMetric extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Performance',
      name: 'time-to-interactive',
      description: 'Time To Interactive (alpha)',
      optimalValue: SCORING_POINT_OF_DIMINISHING_RETURNS.toLocaleString(),
      requiredArtifacts: ['traceContents']
    };
  }

  /**
   * Identify the time the page is "interactive"
   * @see https://docs.google.com/document/d/1oiy0_ych1v2ADhyG_QW7Ps4BNER2ShlJjx2zCbVzVyY/edit#
   *
   * The user thinks the page is ready - (They believe the page is done enough to start interacting with)
   *   - Layout has stabilized & key webfonts are visible.
   *     AKA: First meaningful paint has fired.
   *   - Page is nearly visually complete
   *     Visual completion is 85%
   *
   * The page is actually ready for user:
   *   - domContentLoadedEventEnd has fired
   *     Definition: HTML parsing has finished, all DOMContentLoaded handlers have run.
   *     No risk of DCL event handlers changing the page
   *     No surprises of inactive buttons/actions as DOM element event handlers should be bound
   *   - The main thread is available enough to handle user input
   *     first 500ms window where Est Input Latency is <50ms at the 90% percentile.
   *
   * WARNING: This metric WILL change its calculation. If you rely on its numbers now, know that they
   * will be changing in the future to a more accurate number.
   *
   * @param {!Artifacts} artifacts The artifacts from the gather phase.
   * @return {!Promise<!AuditResult>} The score from the audit, ranging from 0-100.
   */
  static audit(artifacts) {
    const trace = artifacts.traces[Audit.DEFAULT_PASS];
    const pendingSpeedline = artifacts.requestSpeedline(trace);
    const pendingFMP = FMPMetric.audit(artifacts);

    // We start looking at Math.Max(FMPMetric, visProgress[0.85])
    return Promise.all([pendingSpeedline, pendingFMP]).then(results => {
      const speedline = results[0];
      const fmpResult = results[1];
      if (fmpResult.rawValue === -1) {
        return generateError(fmpResult.debugString);
      }
      const fmpTiming = parseFloat(fmpResult.rawValue);
      const timings = fmpResult.extendedInfo && fmpResult.extendedInfo.value &&
          fmpResult.extendedInfo.value.timings;

      // Process the trace
      const tracingProcessor = new TracingProcessor();
      const trace = artifacts.traces[Audit.DEFAULT_PASS];
      const model = tracingProcessor.init(trace);
      const endOfTraceTime = model.bounds.max;

      // TODO: Wait for DOMContentLoadedEndEvent
      // TODO: Wait for UA loading indicator to be done

      // TODO CHECK these units are the same
      const fMPts = timings.fMPfull + timings.navStart;

      // look at speedline results for 85% starting at FMP
      let visuallyReadyTiming = 0;

      if (speedline.frames) {
        const eightyFivePctVC = speedline.frames.find(frame => {
          return frame.getTimeStamp() >= fMPts && frame.getProgress() >= 85;
        });

        if (eightyFivePctVC) {
          // TODO CHECK these units are the same
          visuallyReadyTiming = eightyFivePctVC.getTimeStamp() - timings.navStart;
        }
      }

      // Find first 500ms window where Est Input Latency is <50ms at the 90% percentile.
      let startTime = Math.max(fmpTiming, visuallyReadyTiming) - 50;
      let endTime;
      let currentLatency = Infinity;
      const percentiles = [0.9]; // [0.75, 0.9, 0.99, 1];
      const threshold = 50;
      const foundLatencies = [];

      // When we've found a latency that's good enough, we're good.
      while (currentLatency > threshold) {
        // While latency is too high, increment just 50ms and look again.
        startTime += 50;
        endTime = startTime + 500;
        // If there's no more room in the trace to look, we're done.
        if (endTime > endOfTraceTime) {
          return generateError('Entire trace was found to be busy.');
        }
        // Get our expected latency for the time window
        const latencies = TracingProcessor.getRiskToResponsiveness(
          model, trace, startTime, endTime, percentiles);
        const estLatency = latencies[0].time.toFixed(2);
        foundLatencies.push({
          estLatency: estLatency,
          startTime: startTime.toFixed(1)
        });

        // Grab this latency and try the threshold again
        currentLatency = estLatency;
      }
      const timeToInteractive = parseFloat(startTime.toFixed(1));

      // Use the CDF of a log-normal distribution for scoring.
      //   < 1200ms: score≈100
      //   5000ms: score=50
      //   >= 15000ms: score≈0
      const distribution = TracingProcessor.getLogNormalDistribution(SCORING_MEDIAN,
          SCORING_POINT_OF_DIMINISHING_RETURNS);
      let score = 100 * distribution.computeComplementaryPercentile(startTime);

      // Clamp the score to 0 <= x <= 100.
      score = Math.min(100, score);
      score = Math.max(0, score);
      score = Math.round(score);

      const extendedInfo = {
        timings: {
          fMP: fmpTiming.toFixed(1),
          visuallyReady: visuallyReadyTiming.toFixed(1),
          mainThreadAvail: startTime.toFixed(1)
        },
        expectedLatencyAtTTI: currentLatency,
        foundLatencies
      };

      return TTIMetric.generateAuditResult({
        score,
        rawValue: timeToInteractive,
        displayValue: `${timeToInteractive}ms`,
        optimalValue: this.meta.optimalValue,
        debugString: speedline.debugString,
        extendedInfo: {
          value: extendedInfo,
          formatter: Formatter.SUPPORTED_FORMATS.NULL
        }
      });
    }).catch(err => {
      return generateError(err);
    });
  }
}

module.exports = TTIMetric;

function generateError(err) {
  return TTIMetric.generateAuditResult({
    value: -1,
    rawValue: -1,
    optimalValue: TTIMetric.meta.optimalValue,
    debugString: err.message || err
  });
}

},{"../formatters/formatter":7,"../lib/traces/tracing-processor":25,"./audit":"../audits/audit","./first-meaningful-paint":"../audits/first-meaningful-paint"}],"../audits/user-timings":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');
const Formatter = require('../formatters/formatter');
const TimelineModel = require('../lib/traces/devtools-timeline-model');

const FAILURE_MESSAGE = 'Trace data not found.';

/**
 * @param {!Array<!Object>} traceData
 * @return {!Array<!UserTimingsExtendedInfo>}
 */
function filterTrace(traceData) {
  const userTimings = [];
  const measuresStartTimes = {};
  let traceStartFound = false;
  let navigationStartTime;

  // Fetch blink.user_timing events from the tracing data
  const timelineModel = new TimelineModel(traceData);
  const modeledTraceData = timelineModel.timelineModel();

  // Get all blink.user_timing events
  // The event phases we are interested in are mark and instant events (R, i, I)
  // and duration events which correspond to measures (B, b, E, e).
  // @see https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview#
  modeledTraceData.mainThreadEvents()
  .filter(ut => {
    if (ut.name === 'TracingStartedInPage' || ut.name === 'navigationStart') {
      return true;
    }

    if (ut.hasCategory('blink.user_timing')) {
      // reject these "userTiming" events that aren't really UserTiming, by nuking ones with frame data (or requestStart)
      // https://cs.chromium.org/search/?q=trace_event.*?user_timing&sq=package:chromium&type=cs
      return !(ut.name === 'requestStart' || ut.args.frame !== undefined);
    }

    return false;
  })
  .forEach(ut => {
    // Mark events fall under phases R and I (or i)
    if (ut.phase === 'R' || ut.phase.toUpperCase() === 'I') {
      // We only care about trace events that have to do with the page
      // Sometimes other frames can show up in the frame beforehand
      if (ut.name === 'TracingStartedInPage' && !traceStartFound) {
        traceStartFound = true;
        return;
      }

      // Once TraceingStartedInPage has begun, the next navigationStart event
      // marks the start of navigation
      // Make sure to not record such events hereafter
      if (ut.name === 'navigationStart' && traceStartFound && !navigationStartTime) {
        navigationStartTime = ut.startTime;
      }

      // Add user timings event to array
      if (ut.name !== 'navigationStart') {
        userTimings.push({
          name: ut.name,
          isMark: true,        // defines type of performance metric
          args: ut.args,
          startTime: ut.startTime
        });
      }
    } else if (ut.phase.toLowerCase() === 'b') {
      // Beginning of measure event, keep track of this events start time
      measuresStartTimes[ut.name] = ut.startTime;
    } else if (ut.phase.toLowerCase() === 'e') {
      // End of measure event
      // Add to the array of events
      userTimings.push({
        name: ut.name,
        isMark: false,
        args: ut.args,
        startTime: measuresStartTimes[ut.name],
        duration: ut.startTime - measuresStartTimes[ut.name],
        endTime: ut.startTime
      });
    }
  });

  userTimings.forEach(ut => {
    ut.startTime -= navigationStartTime;
    if (!ut.isMark) {
      ut.endTime -= navigationStartTime;
      ut.duration = ut.duration;
    }
  });

  return userTimings;
}

class UserTimings extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Performance',
      name: 'user-timings',
      description: 'User Timing marks and measures',
      requiredArtifacts: ['traceContents']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    return new Promise((resolve, reject) => {
      const traceContents =
        artifacts.traces[this.DEFAULT_PASS] &&
        artifacts.traces[this.DEFAULT_PASS].traceEvents;
      if (!traceContents || !Array.isArray(traceContents)) {
        throw new Error(FAILURE_MESSAGE);
      }

      const userTimings = filterTrace(traceContents);
      resolve(UserTimings.generateAuditResult({
        rawValue: userTimings.length,
        extendedInfo: {
          formatter: Formatter.SUPPORTED_FORMATS.USER_TIMINGS,
          value: userTimings
        }
      }));
    }).catch(err => {
      return UserTimings.generateAuditResult({
        rawValue: -1,
        debugString: err.message
      });
    });
  }
}

module.exports = UserTimings;

},{"../formatters/formatter":7,"../lib/traces/devtools-timeline-model":24,"./audit":"../audits/audit"}],"../audits/viewport":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Audit = require('./audit');

class Viewport extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Mobile Friendly',
      name: 'viewport',
      description: 'HTML has a viewport <meta>',
      requiredArtifacts: ['Viewport']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    const hasMobileViewport = typeof artifacts.Viewport === 'string' &&
        artifacts.Viewport.includes('width=');
    return Viewport.generateAuditResult({
      rawValue: !!hasMobileViewport
    });
  }
}

module.exports = Viewport;

},{"./audit":"../audits/audit"}],"../audits/without-javascript":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Audit = require('./audit');

class WithoutJavaScript extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'JavaScript',
      name: 'without-javascript',
      description: 'Page contains some content when its scripts are not available',
      requiredArtifacts: ['HTMLWithoutJavaScript']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    let bodyHasContent = true;
    let debugString;
    if (artifacts.HTMLWithoutJavaScript.trim() === '') {
      bodyHasContent = false;
      debugString = 'The page body should render some content if its scripts are not available.';
    }

    return WithoutJavaScript.generateAuditResult({
      rawValue: bodyHasContent,
      debugString
    });
  }
}

module.exports = WithoutJavaScript;

},{"./audit":"../audits/audit"}],"../audits/works-offline":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Audit = require('./audit');

class WorksOffline extends Audit {
  /**
   * @return {!AuditMeta}
   */
  static get meta() {
    return {
      category: 'Offline',
      name: 'works-offline',
      description: 'URL responds with a 200 when offline',
      requiredArtifacts: ['Offline']
    };
  }

  /**
   * @param {!Artifacts} artifacts
   * @return {!AuditResult}
   */
  static audit(artifacts) {
    return WorksOffline.generateAuditResult({
      rawValue: artifacts.Offline === 200
    });
  }
}

module.exports = WorksOffline;

},{"./audit":"../audits/audit"}],"./computed/computed-artifact":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

class ComputedArtifact {
  constructor() {
    this.cache = new Map();
  }

  /* eslint-disable no-unused-vars */

  /**
   * Override to implement a computed artifact. Can return a Promise or the
   * computed artifact itself.
   * @param {!Object} artifact Input to computation.
   * @return {!Promise|!Object|!Array}
   */
  compute_(artifact) {
    throw new Error('compute_() not implemented for computed artifact ' + this.name);
  }

  /* eslint-enable no-unused-vars */

  /**
   * Request a computed artifact, caching the result on the input artifact.
   * @param {!OBject} artifact
   * @return {!Promise}
   */
  request(artifact) {
    if (this.cache.has(artifact)) {
      return Promise.resolve(this.cache.get(artifact));
    }

    return Promise.resolve(this.compute_(artifact)).then(computedArtifact => {
      this.cache.set(artifact, computedArtifact);
      return computedArtifact;
    });
  }
}

module.exports = ComputedArtifact;

},{}],"./computed/critical-request-chains":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const ComputedArtifact = require('./computed-artifact');
const WebInspector = require('../../lib/web-inspector');

const includes = (arr, elm) => arr.indexOf(elm) > -1;

class CriticalRequestChains extends ComputedArtifact {

  get name() {
    return 'CriticalRequestChains';
  }

  /**
   * For now, we use network priorities as a proxy for "render-blocking"/critical-ness.
   * It's imperfect, but there is not a higher-fidelity signal available yet.
   * @see https://docs.google.com/document/d/1bCDuq9H1ih9iNjgzyAL0gpwNFiEP4TZS-YLRp_RuMlc
   * @param  {any} request
   */
  isCritical(request) {
    // XHRs are fetched at High priority, but we exclude them, as they are unlikely to be critical
    const resourceTypeCategory = request._resourceType && request._resourceType._category;
    if (resourceTypeCategory === WebInspector.resourceTypes.XHR._category) {
      return false;
    }

    // Treat favicons as non-critical resources
    if (request.mimeType === 'image/x-icon' ||
        (request.parsedURL && request.parsedURL.lastPathComponent === 'favicon.ico')) {
      return false;
    }

    return includes(['VeryHigh', 'High', 'Medium'], request.priority());
  }

  compute_(networkRecords) {
    // Build a map of requestID -> Node.
    const requestIdToRequests = new Map();
    for (const request of networkRecords) {
      requestIdToRequests.set(request.requestId, request);
    }

    // Get all the critical requests.
    /** @type {!Array<NetworkRequest>} */
    const criticalRequests = networkRecords.filter(req => this.isCritical(req));

    const flattenRequest = request => {
      return {
        url: request._url,
        startTime: request.startTime,
        endTime: request.endTime,
        responseReceivedTime: request.responseReceivedTime,
        transferSize: request.transferSize
      };
    };

    // Create a tree of critical requests.
    const criticalRequestChains = {};
    for (const request of criticalRequests) {
      // Work back from this request up to the root. If by some weird quirk we are giving request D
      // here, which has ancestors C, B and A (where A is the root), we will build array [C, B, A]
      // during this phase.
      const ancestors = [];
      let ancestorRequest = request.initiatorRequest();
      let node = criticalRequestChains;
      while (ancestorRequest) {
        const ancestorIsCritical = this.isCritical(ancestorRequest);

        // If the parent request isn't a high priority request it won't be in the
        // requestIdToRequests map, and so we can break the chain here. We should also
        // break it if we've seen this request before because this is some kind of circular
        // reference, and that's bad.
        if (!ancestorIsCritical || includes(ancestors, ancestorRequest.requestId)) {
          // Set the ancestors to an empty array and unset node so that we don't add
          // the request in to the tree.
          ancestors.length = 0;
          node = undefined;
          break;
        }
        ancestors.push(ancestorRequest.requestId);
        ancestorRequest = ancestorRequest.initiatorRequest();
      }

      // With the above array we can work from back to front, i.e. A, B, C, and during this process
      // we can build out the tree for any nodes that have yet to be created.
      let ancestor = ancestors.pop();
      while (ancestor) {
        const parentRequest = requestIdToRequests.get(ancestor);
        const parentRequestId = parentRequest.requestId;
        if (!node[parentRequestId]) {
          node[parentRequestId] = {
            request: flattenRequest(parentRequest),
            children: {}
          };
        }

        // Step to the next iteration.
        ancestor = ancestors.pop();
        node = node[parentRequestId].children;
      }

      if (!node) {
        continue;
      }

      // If the node already exists, bail.
      if (node[request.requestId]) {
        continue;
      }

      // node should now point to the immediate parent for this request.
      node[request.requestId] = {
        request: flattenRequest(request),
        children: {}
      };
    }

    return criticalRequestChains;
  }
}

module.exports = CriticalRequestChains;

},{"../../lib/web-inspector":26,"./computed-artifact":"./computed/computed-artifact"}],"./computed/pushed-requests":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const ComputedArtifact = require('./computed-artifact');

class PushedRequests extends ComputedArtifact {

  get name() {
    return 'PushedRequests';
  }

  /**
   * Return list of network requests that were pushed.
   * @param {!Array<!WebInspector.NetworkRequest>} records
   * @return {!Array<!WebInspector.NetworkRequest>}
   */
  compute_(records) {
    const pushedRecords = records.filter(r => r._timing && !!r._timing.pushStart);
    return pushedRecords;
  }
}

module.exports = PushedRequests;

},{"./computed-artifact":"./computed/computed-artifact"}],"./computed/screenshots":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const ComputedArtifact = require('./computed-artifact');
const DevtoolsTimelineModel = require('../../lib/traces/devtools-timeline-model');

class ScreenshotFilmstrip extends ComputedArtifact {

  get name() {
    return 'Screenshots';
  }

  fetchScreenshot(frame) {
    return frame
      .imageDataPromise()
      .then(data => 'data:image/jpg;base64,' + data);
  }

  /**
   * @param {{traceEvents: !Array}} trace
   * @return {!Promise}
  */
  compute_(trace) {
    const model = new DevtoolsTimelineModel(trace.traceEvents);
    const filmStripFrames = model.filmStripModel().frames();

    const frameFetches = filmStripFrames.map(frame => this.fetchScreenshot(frame));
    return Promise.all(frameFetches).then(images => {
      const result = filmStripFrames.map((frame, i) => ({
        timestamp: frame.timestamp,
        datauri: images[i]
      }));
      return result;
    });
  }
}

module.exports = ScreenshotFilmstrip;

},{"../../lib/traces/devtools-timeline-model":24,"./computed-artifact":"./computed/computed-artifact"}],"./computed/speedline":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const ComputedArtifact = require('./computed-artifact');
const speedline = require('speedline');

class Speedline extends ComputedArtifact {

  get name() {
    return 'Speedline';
  }

  /**
   * @return {!Promise}
   */
  compute_(trace) {
    // speedline() may throw without a promise, so we resolve immediately
    // to get in a promise chain.
    return Promise.resolve().then(_ => {
      return speedline(trace.traceEvents);
    }).then(speedlineResults => {
      return speedlineResults;
    });
  }
}

module.exports = Speedline;

},{"./computed-artifact":"./computed/computed-artifact","speedline":254}],"./gatherers/accessibility":[function(require,module,exports){
(function (Buffer){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/* global document */

const Gatherer = require('./gatherer');

const axe = Buffer("LyohIGFYZSB2MS4xLjEKICogQ29weXJpZ2h0IChjKSAyMDE1IERlcXVlIFN5c3RlbXMsIEluYy4KICoKICogWW91ciB1c2Ugb2YgdGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpYwogKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzCiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uCiAqCiAqIFRoaXMgZW50aXJlIGNvcHlyaWdodCBub3RpY2UgbXVzdCBhcHBlYXIgaW4gZXZlcnkgY29weSBvZiB0aGlzIGZpbGUgeW91CiAqIGRpc3RyaWJ1dGUgb3IgaW4gYW55IGZpbGUgdGhhdCBjb250YWlucyBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGlzIHNvdXJjZQogKiBjb2RlLgogKi8KIWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXsidXNlIHN0cmljdCI7dmFyIGIsZCxlPWE7aWYobnVsbCE9PWEmJiJvYmplY3QiPT10eXBlb2YgYSlpZihBcnJheS5pc0FycmF5KGEpKWZvcihlPVtdLGI9MCxkPWEubGVuZ3RoO2Q+YjtiKyspZVtiXT1jKGFbYl0pO2Vsc2V7ZT17fTtmb3IoYiBpbiBhKWVbYl09YyhhW2JdKX1yZXR1cm4gZX1mdW5jdGlvbiBkKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYj1hfHx7fTtyZXR1cm4gYi5ydWxlcz1iLnJ1bGVzfHxbXSxiLnRvb2xzPWIudG9vbHN8fFtdLGIuY2hlY2tzPWIuY2hlY2tzfHxbXSxiLmRhdGE9Yi5kYXRhfHx7Y2hlY2tzOnt9LHJ1bGVzOnt9fSxifWZ1bmN0aW9uIGUoYSxiLGMpeyJ1c2Ugc3RyaWN0Ijt2YXIgZCxlO2ZvcihkPTAsZT1hLmxlbmd0aDtlPmQ7ZCsrKWJbY10oYVtkXSl9ZnVuY3Rpb24gZihhKXsidXNlIHN0cmljdCI7YT1kKGEpLFMuY29tbW9ucz1SPWEuY29tbW9ucyx0aGlzLnJlcG9ydGVyPWEucmVwb3J0ZXIsdGhpcy5ydWxlcz1bXSx0aGlzLnRvb2xzPXt9LHRoaXMuY2hlY2tzPXt9LGUoYS5ydWxlcyx0aGlzLCJhZGRSdWxlIiksZShhLnRvb2xzLHRoaXMsImFkZFRvb2wiKSxlKGEuY2hlY2tzLHRoaXMsImFkZENoZWNrIiksdGhpcy5kYXRhPWEuZGF0YXx8e2NoZWNrczp7fSxydWxlczp7fX0sSChhLnN0eWxlKX1mdW5jdGlvbiBnKGEpeyJ1c2Ugc3RyaWN0Ijt0aGlzLmlkPWEuaWQsdGhpcy5kYXRhPW51bGwsdGhpcy5yZWxhdGVkTm9kZXM9W10sdGhpcy5yZXN1bHQ9bnVsbH1mdW5jdGlvbiBoKGEpeyJ1c2Ugc3RyaWN0Ijt0aGlzLmlkPWEuaWQsdGhpcy5vcHRpb25zPWEub3B0aW9ucyx0aGlzLnNlbGVjdG9yPWEuc2VsZWN0b3IsdGhpcy5ldmFsdWF0ZT1hLmV2YWx1YXRlLGEuYWZ0ZXImJih0aGlzLmFmdGVyPWEuYWZ0ZXIpLGEubWF0Y2hlcyYmKHRoaXMubWF0Y2hlcz1hLm1hdGNoZXMpLHRoaXMuZW5hYmxlZD1hLmhhc093blByb3BlcnR5KCJlbmFibGVkIik/YS5lbmFibGVkOiEwfWZ1bmN0aW9uIGkoYSxiKXsidXNlIHN0cmljdCI7aWYoIVQuaXNIaWRkZW4oYikpe3ZhciBjPVQuZmluZEJ5KGEsIm5vZGUiLGIpO2N8fGEucHVzaCh7bm9kZTpiLGluY2x1ZGU6W10sZXhjbHVkZTpbXX0pfX1mdW5jdGlvbiBqKGEsYyxkKXsidXNlIHN0cmljdCI7YS5mcmFtZXM9YS5mcmFtZXN8fFtdO3ZhciBlLGYsZz1iLnF1ZXJ5U2VsZWN0b3JBbGwoZC5zaGlmdCgpKTthOmZvcih2YXIgaD0wLGk9Zy5sZW5ndGg7aT5oO2grKyl7Zj1nW2hdO2Zvcih2YXIgaj0wLGs9YS5mcmFtZXMubGVuZ3RoO2s+ajtqKyspaWYoYS5mcmFtZXNbal0ubm9kZT09PWYpe2EuZnJhbWVzW2pdW2NdLnB1c2goZCk7YnJlYWsgYX1lPXtub2RlOmYsaW5jbHVkZTpbXSxleGNsdWRlOltdfSxkJiZlW2NdLnB1c2goZCksYS5mcmFtZXMucHVzaChlKX19ZnVuY3Rpb24gayhhKXsidXNlIHN0cmljdCI7aWYoYSYmIm9iamVjdCI9PXR5cGVvZiBhfHxhIGluc3RhbmNlb2YgTm9kZUxpc3Qpe2lmKGEgaW5zdGFuY2VvZiBOb2RlKXJldHVybntpbmNsdWRlOlthXSxleGNsdWRlOltdfTtpZihhLmhhc093blByb3BlcnR5KCJpbmNsdWRlIil8fGEuaGFzT3duUHJvcGVydHkoImV4Y2x1ZGUiKSlyZXR1cm57aW5jbHVkZTphLmluY2x1ZGV8fFtiXSxleGNsdWRlOmEuZXhjbHVkZXx8W119O2lmKGEubGVuZ3RoPT09K2EubGVuZ3RoKXJldHVybntpbmNsdWRlOmEsZXhjbHVkZTpbXX19cmV0dXJuInN0cmluZyI9PXR5cGVvZiBhP3tpbmNsdWRlOlthXSxleGNsdWRlOltdfTp7aW5jbHVkZTpbYl0sZXhjbHVkZTpbXX19ZnVuY3Rpb24gbChhLGMpeyJ1c2Ugc3RyaWN0Ijtmb3IodmFyIGQsZT1bXSxmPTAsZz1hW2NdLmxlbmd0aDtnPmY7ZisrKXtpZihkPWFbY11bZl0sInN0cmluZyI9PXR5cGVvZiBkKXtlPWUuY29uY2F0KFQudG9BcnJheShiLnF1ZXJ5U2VsZWN0b3JBbGwoZCkpKTticmVha31kJiZkLmxlbmd0aD9kLmxlbmd0aD4xP2ooYSxjLGQpOmU9ZS5jb25jYXQoVC50b0FycmF5KGIucXVlcnlTZWxlY3RvckFsbChkWzBdKSkpOmUucHVzaChkKX1yZXR1cm4gZS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGF9KX1mdW5jdGlvbiBtKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYz10aGlzO3RoaXMuZnJhbWVzPVtdLHRoaXMuaW5pdGlhdG9yPWEmJiJib29sZWFuIj09dHlwZW9mIGEuaW5pdGlhdG9yP2EuaW5pdGlhdG9yOiEwLHRoaXMucGFnZT0hMSxhPWsoYSksdGhpcy5leGNsdWRlPWEuZXhjbHVkZSx0aGlzLmluY2x1ZGU9YS5pbmNsdWRlLHRoaXMuaW5jbHVkZT1sKHRoaXMsImluY2x1ZGUiKSx0aGlzLmV4Y2x1ZGU9bCh0aGlzLCJleGNsdWRlIiksVC5zZWxlY3QoImZyYW1lLCBpZnJhbWUiLHRoaXMpLmZvckVhY2goZnVuY3Rpb24oYSl7TShhLGMpJiZpKGMuZnJhbWVzLGEpfSksMT09PXRoaXMuaW5jbHVkZS5sZW5ndGgmJnRoaXMuaW5jbHVkZVswXT09PWImJih0aGlzLnBhZ2U9ITApfWZ1bmN0aW9uIG4oYSl7InVzZSBzdHJpY3QiO3RoaXMuaWQ9YS5pZCx0aGlzLnJlc3VsdD1TLmNvbnN0YW50cy5yZXN1bHQuTkEsdGhpcy5wYWdlTGV2ZWw9YS5wYWdlTGV2ZWwsdGhpcy5pbXBhY3Q9bnVsbCx0aGlzLm5vZGVzPVtdfWZ1bmN0aW9uIG8oYSxiKXsidXNlIHN0cmljdCI7dGhpcy5fYXVkaXQ9Yix0aGlzLmlkPWEuaWQsdGhpcy5zZWxlY3Rvcj1hLnNlbGVjdG9yfHwiKiIsdGhpcy5leGNsdWRlSGlkZGVuPSJib29sZWFuIj09dHlwZW9mIGEuZXhjbHVkZUhpZGRlbj9hLmV4Y2x1ZGVIaWRkZW46ITAsdGhpcy5lbmFibGVkPSJib29sZWFuIj09dHlwZW9mIGEuZW5hYmxlZD9hLmVuYWJsZWQ6ITAsdGhpcy5wYWdlTGV2ZWw9ImJvb2xlYW4iPT10eXBlb2YgYS5wYWdlTGV2ZWw/YS5wYWdlTGV2ZWw6ITEsdGhpcy5hbnk9YS5hbnl8fFtdLHRoaXMuYWxsPWEuYWxsfHxbXSx0aGlzLm5vbmU9YS5ub25lfHxbXSx0aGlzLnRhZ3M9YS50YWdzfHxbXSxhLm1hdGNoZXMmJih0aGlzLm1hdGNoZXM9YS5tYXRjaGVzKX1mdW5jdGlvbiBwKGEpeyJ1c2Ugc3RyaWN0IjtyZXR1cm4gVC5nZXRBbGxDaGVja3MoYSkubWFwKGZ1bmN0aW9uKGIpe3ZhciBjPWEuX2F1ZGl0LmNoZWNrc1tiLmlkfHxiXTtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgYy5hZnRlcj9jOm51bGx9KS5maWx0ZXIoQm9vbGVhbil9ZnVuY3Rpb24gcShhLGIpeyJ1c2Ugc3RyaWN0Ijt2YXIgYz1bXTtyZXR1cm4gYS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBkPVQuZ2V0QWxsQ2hlY2tzKGEpO2QuZm9yRWFjaChmdW5jdGlvbihhKXthLmlkPT09YiYmYy5wdXNoKGEpfSl9KSxjfWZ1bmN0aW9uIHIoYSl7InVzZSBzdHJpY3QiO3JldHVybiBhLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYS5maWx0ZXJlZCE9PSEwfSl9ZnVuY3Rpb24gcyhhKXsidXNlIHN0cmljdCI7dmFyIGI9WyJhbnkiLCJhbGwiLCJub25lIl0sYz1hLm5vZGVzLmZpbHRlcihmdW5jdGlvbihhKXt2YXIgYz0wO3JldHVybiBiLmZvckVhY2goZnVuY3Rpb24oYil7YVtiXT1yKGFbYl0pLGMrPWFbYl0ubGVuZ3RofSksYz4wfSk7cmV0dXJuIGEucGFnZUxldmVsJiZjLmxlbmd0aCYmKGM9W2MucmVkdWNlKGZ1bmN0aW9uKGEsYyl7cmV0dXJuIGE/KGIuZm9yRWFjaChmdW5jdGlvbihiKXthW2JdLnB1c2guYXBwbHkoYVtiXSxjW2JdKX0pLGEpOnZvaWQgMH0pXSksY31mdW5jdGlvbiB0KGEpeyJ1c2Ugc3RyaWN0IjthLnNvdXJjZT1hLnNvdXJjZXx8e30sdGhpcy5pZD1hLmlkLHRoaXMub3B0aW9ucz1hLm9wdGlvbnMsdGhpcy5fcnVuPWEuc291cmNlLnJ1bix0aGlzLl9jbGVhbnVwPWEuc291cmNlLmNsZWFudXAsdGhpcy5hY3RpdmU9ITF9ZnVuY3Rpb24gdShhKXsidXNlIHN0cmljdCI7aWYoIVMuX2F1ZGl0KXRocm93IG5ldyBFcnJvcigiTm8gYXVkaXQgY29uZmlndXJlZCIpO3ZhciBjPVQucXVldWUoKTtPYmplY3Qua2V5cyhTLl9hdWRpdC50b29scykuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1TLl9hdWRpdC50b29sc1thXTtiLmFjdGl2ZSYmYy5kZWZlcihmdW5jdGlvbihhKXtiLmNsZWFudXAoYSl9KX0pLFQudG9BcnJheShiLnF1ZXJ5U2VsZWN0b3JBbGwoImZyYW1lLCBpZnJhbWUiKSkuZm9yRWFjaChmdW5jdGlvbihhKXtjLmRlZmVyKGZ1bmN0aW9uKGIpe3JldHVybiBULnNlbmRDb21tYW5kVG9GcmFtZShhLHtjb21tYW5kOiJjbGVhbnVwLXRvb2wifSxiKX0pfSksYy50aGVuKGEpfWZ1bmN0aW9uIHYoYSxjKXsidXNlIHN0cmljdCI7dmFyIGQ9YSYmYS5jb250ZXh0fHx7fTtkLmluY2x1ZGUmJiFkLmluY2x1ZGUubGVuZ3RoJiYoZC5pbmNsdWRlPVtiXSk7dmFyIGU9YSYmYS5vcHRpb25zfHx7fTtzd2l0Y2goYS5jb21tYW5kKXtjYXNlInJ1bGVzIjpyZXR1cm4geChkLGUsYyk7Y2FzZSJydW4tdG9vbCI6cmV0dXJuIHkoYS5wYXJhbWV0ZXIsYS5zZWxlY3RvckFycmF5LGUsYyk7Y2FzZSJjbGVhbnVwLXRvb2wiOnJldHVybiB1KGMpfX1mdW5jdGlvbiB3KGEpeyJ1c2Ugc3RyaWN0IjtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIGEmJldbYV0/V1thXToiZnVuY3Rpb24iPT10eXBlb2YgYT9hOlZ9ZnVuY3Rpb24geChhLGIsYyl7InVzZSBzdHJpY3QiO2E9bmV3IG0oYSk7dmFyIGQ9VC5xdWV1ZSgpLGU9Uy5fYXVkaXQ7YS5mcmFtZXMubGVuZ3RoJiZkLmRlZmVyKGZ1bmN0aW9uKGMpe1QuY29sbGVjdFJlc3VsdHNGcm9tRnJhbWVzKGEsYiwicnVsZXMiLG51bGwsYyl9KSxkLmRlZmVyKGZ1bmN0aW9uKGMpe2UucnVuKGEsYixjKX0pLGQudGhlbihmdW5jdGlvbihkKXt2YXIgZj1ULm1lcmdlUmVzdWx0cyhkLm1hcChmdW5jdGlvbihhKXtyZXR1cm57cmVzdWx0czphfX0pKTthLmluaXRpYXRvciYmKGY9ZS5hZnRlcihmLGIpLGY9Zi5tYXAoVC5maW5hbGl6ZVJ1bGVSZXN1bHQpKSxjKGYpfSl9ZnVuY3Rpb24geShhLGMsZCxlKXsidXNlIHN0cmljdCI7aWYoIVMuX2F1ZGl0KXRocm93IG5ldyBFcnJvcigiTm8gYXVkaXQgY29uZmlndXJlZCIpO2lmKGMubGVuZ3RoPjEpe3ZhciBmPWIucXVlcnlTZWxlY3RvcihjLnNoaWZ0KCkpO3JldHVybiBULnNlbmRDb21tYW5kVG9GcmFtZShmLHtvcHRpb25zOmQsY29tbWFuZDoicnVuLXRvb2wiLHBhcmFtZXRlcjphLHNlbGVjdG9yQXJyYXk6Y30sZSl9dmFyIGc9Yi5xdWVyeVNlbGVjdG9yKGMuc2hpZnQoKSk7Uy5fYXVkaXQudG9vbHNbYV0ucnVuKGcsZCxlKX1mdW5jdGlvbiB6KGEsYil7InVzZSBzdHJpY3QiO2lmKGI9Ynx8MzAwLGEubGVuZ3RoPmIpe3ZhciBjPWEuaW5kZXhPZigiPiIpO2E9YS5zdWJzdHJpbmcoMCxjKzEpfXJldHVybiBhfWZ1bmN0aW9uIEEoYSl7InVzZSBzdHJpY3QiO3ZhciBiPWEub3V0ZXJIVE1MO3JldHVybiBifHwiZnVuY3Rpb24iIT10eXBlb2YgWE1MU2VyaWFsaXplcnx8KGI9KG5ldyBYTUxTZXJpYWxpemVyKS5zZXJpYWxpemVUb1N0cmluZyhhKSkseihifHwiIil9ZnVuY3Rpb24gQihhLGIpeyJ1c2Ugc3RyaWN0IjtiPWJ8fHt9LHRoaXMuc2VsZWN0b3I9Yi5zZWxlY3Rvcnx8W1QuZ2V0U2VsZWN0b3IoYSldLHRoaXMuc291cmNlPXZvaWQgMCE9PWIuc291cmNlP2Iuc291cmNlOkEoYSksdGhpcy5lbGVtZW50PWF9ZnVuY3Rpb24gQyhhLGIpeyJ1c2Ugc3RyaWN0IjtPYmplY3Qua2V5cyhTLmNvbnN0YW50cy5yYWlzZWRNZXRhZGF0YSkuZm9yRWFjaChmdW5jdGlvbihjKXt2YXIgZD1TLmNvbnN0YW50cy5yYWlzZWRNZXRhZGF0YVtjXSxlPWIucmVkdWNlKGZ1bmN0aW9uKGEsYil7dmFyIGU9ZC5pbmRleE9mKGJbY10pO3JldHVybiBlPmE/ZTphfSwtMSk7ZFtlXSYmKGFbY109ZFtlXSl9KX1mdW5jdGlvbiBEKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYj1hLmFueS5sZW5ndGh8fGEuYWxsLmxlbmd0aHx8YS5ub25lLmxlbmd0aDtyZXR1cm4gYj9TLmNvbnN0YW50cy5yZXN1bHQuRkFJTDpTLmNvbnN0YW50cy5yZXN1bHQuUEFTU31mdW5jdGlvbiBFKGEpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiBiKGEpe3JldHVybiBULmV4dGVuZEJsYWNrbGlzdCh7fSxhLFsicmVzdWx0Il0pfXZhciBjPVQuZXh0ZW5kQmxhY2tsaXN0KHt2aW9sYXRpb25zOltdLHBhc3NlczpbXX0sYSxbIm5vZGVzIl0pO3JldHVybiBhLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGQ9VC5nZXRGYWlsaW5nQ2hlY2tzKGEpLGU9RChkKTtyZXR1cm4gZT09PVMuY29uc3RhbnRzLnJlc3VsdC5GQUlMPyhDKGEsVC5nZXRBbGxDaGVja3MoZCkpLGEuYW55PWQuYW55Lm1hcChiKSxhLmFsbD1kLmFsbC5tYXAoYiksYS5ub25lPWQubm9uZS5tYXAoYiksdm9pZCBjLnZpb2xhdGlvbnMucHVzaChhKSk6KGEuYW55PWEuYW55LmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXN1bHR9KS5tYXAoYiksYS5hbGw9YS5hbGwubWFwKGIpLGEubm9uZT1hLm5vbmUubWFwKGIpLHZvaWQgYy5wYXNzZXMucHVzaChhKSl9KSxDKGMsYy52aW9sYXRpb25zKSxjLnJlc3VsdD1jLnZpb2xhdGlvbnMubGVuZ3RoP1MuY29uc3RhbnRzLnJlc3VsdC5GQUlMOmMucGFzc2VzLmxlbmd0aD9TLmNvbnN0YW50cy5yZXN1bHQuUEFTUzpjLnJlc3VsdCxjfWZ1bmN0aW9uIEYoYSl7InVzZSBzdHJpY3QiO2Zvcih2YXIgYj0xLGM9YS5ub2RlTmFtZTthPWEucHJldmlvdXNFbGVtZW50U2libGluZzspYS5ub2RlTmFtZT09PWMmJmIrKztyZXR1cm4gYn1mdW5jdGlvbiBHKGEsYil7InVzZSBzdHJpY3QiO3ZhciBjLGQsZT1hLnBhcmVudE5vZGUuY2hpbGRyZW47aWYoIWUpcmV0dXJuITE7dmFyIGY9ZS5sZW5ndGg7Zm9yKGM9MDtmPmM7YysrKWlmKGQ9ZVtjXSxkIT09YSYmVC5tYXRjaGVzU2VsZWN0b3IoZCxiKSlyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBIKGEpeyJ1c2Ugc3RyaWN0IjtpZihYJiZYLnBhcmVudE5vZGUmJihYLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoWCksWD1udWxsKSxhKXt2YXIgYz1iLmhlYWR8fGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoImhlYWQiKVswXTtyZXR1cm4gWD1iLmNyZWF0ZUVsZW1lbnQoInN0eWxlIiksWC50eXBlPSJ0ZXh0L2NzcyIsdm9pZCAwPT09WC5zdHlsZVNoZWV0P1guYXBwZW5kQ2hpbGQoYi5jcmVhdGVUZXh0Tm9kZShhKSk6WC5zdHlsZVNoZWV0LmNzc1RleHQ9YSxjLmFwcGVuZENoaWxkKFgpLFh9fWZ1bmN0aW9uIEkoYSxiLGMpeyJ1c2Ugc3RyaWN0IjthLmZvckVhY2goZnVuY3Rpb24oYSl7YS5ub2RlLnNlbGVjdG9yLnVuc2hpZnQoYyksYS5ub2RlPW5ldyBULkRxRWxlbWVudChiLGEubm9kZSk7dmFyIGQ9VC5nZXRBbGxDaGVja3MoYSk7ZC5sZW5ndGgmJmQuZm9yRWFjaChmdW5jdGlvbihhKXthLnJlbGF0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2Euc2VsZWN0b3IudW5zaGlmdChjKSxhPW5ldyBULkRxRWxlbWVudChiLGEpfSl9KX0pfWZ1bmN0aW9uIEooYSxiKXsidXNlIHN0cmljdCI7Zm9yKHZhciBjLGQsZT1iWzBdLm5vZGUsZj0wLGc9YS5sZW5ndGg7Zz5mO2YrKylpZihkPWFbZl0ubm9kZSxjPVQubm9kZVNvcnRlcihkLmVsZW1lbnQsZS5lbGVtZW50KSxjPjB8fDA9PT1jJiZlLnNlbGVjdG9yLmxlbmd0aDxkLnNlbGVjdG9yLmxlbmd0aClyZXR1cm4gdm9pZCBhLnNwbGljZS5hcHBseShhLFtmLDBdLmNvbmNhdChiKSk7YS5wdXNoLmFwcGx5KGEsYil9ZnVuY3Rpb24gSyhhKXsidXNlIHN0cmljdCI7cmV0dXJuIGEmJmEucmVzdWx0cz9BcnJheS5pc0FycmF5KGEucmVzdWx0cyk/YS5yZXN1bHRzLmxlbmd0aD9hLnJlc3VsdHM6bnVsbDpbYS5yZXN1bHRzXTpudWxsfWZ1bmN0aW9uIEwoYSl7InVzZSBzdHJpY3QiO3JldHVybiBhLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gVC5jb250YWlucyhhLGIpPzE6LTF9KVswXX1mdW5jdGlvbiBNKGEsYil7InVzZSBzdHJpY3QiO3ZhciBjPWIuaW5jbHVkZSYmTChiLmluY2x1ZGUuZmlsdGVyKGZ1bmN0aW9uKGIpe3JldHVybiBULmNvbnRhaW5zKGIsYSl9KSksZD1iLmV4Y2x1ZGUmJkwoYi5leGNsdWRlLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4gVC5jb250YWlucyhiLGEpfSkpO3JldHVybiFkJiZjfHxkJiZULmNvbnRhaW5zKGQsYyk/ITA6ITF9ZnVuY3Rpb24gTihhLGIsYyl7InVzZSBzdHJpY3QiO2Zvcih2YXIgZD0wLGU9Yi5sZW5ndGg7ZT5kO2QrKyktMT09PWEuaW5kZXhPZihiW2RdKSYmTShiW2RdLGMpJiZhLnB1c2goYltkXSl9dmFyIE8sUD1mdW5jdGlvbigpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiBhKGEpe3ZhciBiLGMsZD1hLkVsZW1lbnQucHJvdG90eXBlLGU9WyJtYXRjaGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiXSxmPWUubGVuZ3RoO2ZvcihiPTA7Zj5iO2IrKylpZihjPWVbYl0sZFtjXSlyZXR1cm4gY312YXIgYjtyZXR1cm4gZnVuY3Rpb24oYyxkKXtyZXR1cm4gYiYmY1tiXXx8KGI9YShjLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpKSxjW2JdKGQpfX0oKSxRPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijtmb3IodmFyIGIsYz1TdHJpbmcoYSksZD1jLmxlbmd0aCxlPS0xLGY9IiIsZz1jLmNoYXJDb2RlQXQoMCk7KytlPGQ7KXtpZihiPWMuY2hhckNvZGVBdChlKSwwPT1iKXRocm93IG5ldyBFcnJvcigiSU5WQUxJRF9DSEFSQUNURVJfRVJSIik7Zis9Yj49MSYmMzE+PWJ8fGI+PTEyNyYmMTU5Pj1ifHwwPT1lJiZiPj00OCYmNTc+PWJ8fDE9PWUmJmI+PTQ4JiY1Nz49YiYmNDU9PWc/IlxcIitiLnRvU3RyaW5nKDE2KSsiICI6KDEhPWV8fDQ1IT1ifHw0NSE9ZykmJihiPj0xMjh8fDQ1PT1ifHw5NT09Ynx8Yj49NDgmJjU3Pj1ifHxiPj02NSYmOTA+PWJ8fGI+PTk3JiYxMjI+PWIpP2MuY2hhckF0KGUpOiJcXCIrYy5jaGFyQXQoZSl9cmV0dXJuIGZ9OyFmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsYixjKXt2YXIgZD1iJiZjfHwwLGU9MDtmb3IoYj1ifHxbXSxhLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWzAtOWEtZl17Mn0vZyxmdW5jdGlvbihhKXsxNj5lJiYoYltkK2UrK109bFthXSl9KTsxNj5lOyliW2QrZSsrXT0wO3JldHVybiBifWZ1bmN0aW9uIGMoYSxiKXt2YXIgYz1ifHwwLGQ9aztyZXR1cm4gZFthW2MrK11dK2RbYVtjKytdXStkW2FbYysrXV0rZFthW2MrK11dKyItIitkW2FbYysrXV0rZFthW2MrK11dKyItIitkW2FbYysrXV0rZFthW2MrK11dKyItIitkW2FbYysrXV0rZFthW2MrK11dKyItIitkW2FbYysrXV0rZFthW2MrK11dK2RbYVtjKytdXStkW2FbYysrXV0rZFthW2MrK11dK2RbYVtjKytdXX1mdW5jdGlvbiBkKGEsYixkKXt2YXIgZT1iJiZkfHwwLGY9Ynx8W107YT1hfHx7fTt2YXIgZz1udWxsIT1hLmNsb2Nrc2VxP2EuY2xvY2tzZXE6cCxoPW51bGwhPWEubXNlY3M/YS5tc2VjczoobmV3IERhdGUpLmdldFRpbWUoKSxpPW51bGwhPWEubnNlY3M/YS5uc2VjczpyKzEsaj1oLXErKGktcikvMWU0O2lmKDA+aiYmbnVsbD09YS5jbG9ja3NlcSYmKGc9ZysxJjE2MzgzKSwoMD5qfHxoPnEpJiZudWxsPT1hLm5zZWNzJiYoaT0wKSxpPj0xZTQpdGhyb3cgbmV3IEVycm9yKCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYyIpO3E9aCxyPWkscD1nLGgrPTEyMjE5MjkyOGU1O3ZhciBrPSgxZTQqKDI2ODQzNTQ1NSZoKStpKSU0Mjk0OTY3Mjk2O2ZbZSsrXT1rPj4+MjQmMjU1LGZbZSsrXT1rPj4+MTYmMjU1LGZbZSsrXT1rPj4+OCYyNTUsZltlKytdPTI1NSZrO3ZhciBsPWgvNDI5NDk2NzI5NioxZTQmMjY4NDM1NDU1O2ZbZSsrXT1sPj4+OCYyNTUsZltlKytdPTI1NSZsLGZbZSsrXT1sPj4+MjQmMTV8MTYsZltlKytdPWw+Pj4xNiYyNTUsZltlKytdPWc+Pj44fDEyOCxmW2UrK109MjU1Jmc7Zm9yKHZhciBtPWEubm9kZXx8byxuPTA7Nj5uO24rKylmW2Urbl09bVtuXTtyZXR1cm4gYj9iOmMoZil9ZnVuY3Rpb24gZShhLGIsZCl7dmFyIGU9YiYmZHx8MDsic3RyaW5nIj09dHlwZW9mIGEmJihiPSJiaW5hcnkiPT1hP25ldyBqKDE2KTpudWxsLGE9bnVsbCksYT1hfHx7fTt2YXIgZz1hLnJhbmRvbXx8KGEucm5nfHxmKSgpO2lmKGdbNl09MTUmZ1s2XXw2NCxnWzhdPTYzJmdbOF18MTI4LGIpZm9yKHZhciBoPTA7MTY+aDtoKyspYltlK2hdPWdbaF07cmV0dXJuIGJ8fGMoZyl9dmFyIGYsZz1hLmNyeXB0b3x8YS5tc0NyeXB0bztpZighZiYmZyYmZy5nZXRSYW5kb21WYWx1ZXMpe3ZhciBoPW5ldyBVaW50OEFycmF5KDE2KTtmPWZ1bmN0aW9uKCl7cmV0dXJuIGcuZ2V0UmFuZG9tVmFsdWVzKGgpLGh9fWlmKCFmKXt2YXIgaT1uZXcgQXJyYXkoMTYpO2Y9ZnVuY3Rpb24oKXtmb3IodmFyIGEsYj0wOzE2PmI7YisrKTA9PT0oMyZiKSYmKGE9NDI5NDk2NzI5NipNYXRoLnJhbmRvbSgpKSxpW2JdPWE+Pj4oKDMmYik8PDMpJjI1NTtyZXR1cm4gaX19Zm9yKHZhciBqPSJmdW5jdGlvbiI9PXR5cGVvZiBhLkJ1ZmZlcj9hLkJ1ZmZlcjpBcnJheSxrPVtdLGw9e30sbT0wOzI1Nj5tO20rKylrW21dPShtKzI1NikudG9TdHJpbmcoMTYpLnN1YnN0cigxKSxsW2tbbV1dPW07dmFyIG49ZigpLG89WzF8blswXSxuWzFdLG5bMl0sblszXSxuWzRdLG5bNV1dLHA9MTYzODMmKG5bNl08PDh8bls3XSkscT0wLHI9MDtPPWUsTy52MT1kLE8udjQ9ZSxPLnBhcnNlPWIsTy51bnBhcnNlPWMsTy5CdWZmZXJDbGFzcz1qfShhKTt2YXIgUixTPXt9LFQ9Uy51dGlscz17fTtULm1hdGNoZXNTZWxlY3Rvcj1QLFQuZXNjYXBlU2VsZWN0b3I9USxULmNsb25lPWM7dmFyIFU9e307Zi5wcm90b3R5cGUuYWRkUnVsZT1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7YS5tZXRhZGF0YSYmKHRoaXMuZGF0YS5ydWxlc1thLmlkXT1hLm1ldGFkYXRhKTtmb3IodmFyIGIsYz0wLGQ9dGhpcy5ydWxlcy5sZW5ndGg7ZD5jO2MrKylpZihiPXRoaXMucnVsZXNbY10sYi5pZD09PWEuaWQpcmV0dXJuIHZvaWQodGhpcy5ydWxlc1tjXT1uZXcgbyhhLHRoaXMpKTt0aGlzLnJ1bGVzLnB1c2gobmV3IG8oYSx0aGlzKSl9LGYucHJvdG90eXBlLmFkZFRvb2w9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3RoaXMudG9vbHNbYS5pZF09bmV3IHQoYSl9LGYucHJvdG90eXBlLmFkZENoZWNrPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0IjthLm1ldGFkYXRhJiYodGhpcy5kYXRhLmNoZWNrc1thLmlkXT1hLm1ldGFkYXRhKSx0aGlzLmNoZWNrc1thLmlkXT1uZXcgaChhKX0sZi5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKGEsYixjKXsidXNlIHN0cmljdCI7dmFyIGQ9VC5xdWV1ZSgpO3RoaXMucnVsZXMuZm9yRWFjaChmdW5jdGlvbihjKXtULnJ1bGVTaG91bGRSdW4oYyxhLGIpJiZkLmRlZmVyKGZ1bmN0aW9uKGQpe2MucnVuKGEsYixkKX0pfSksZC50aGVuKGMpfSxmLnByb3RvdHlwZS5hZnRlcj1mdW5jdGlvbihhLGIpeyJ1c2Ugc3RyaWN0Ijt2YXIgYz10aGlzLnJ1bGVzO3JldHVybiBhLm1hcChmdW5jdGlvbihhKXt2YXIgZD1ULmZpbmRCeShjLCJpZCIsYS5pZCk7cmV0dXJuIGQuYWZ0ZXIoYSxiKX0pfSxoLnByb3RvdHlwZS5tYXRjaGVzPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0IjtyZXR1cm4hdGhpcy5zZWxlY3Rvcnx8VC5tYXRjaGVzU2VsZWN0b3IoYSx0aGlzLnNlbGVjdG9yKT8hMDohMX0saC5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKGEsYixjKXsidXNlIHN0cmljdCI7Yj1ifHx7fTt2YXIgZD1iLmhhc093blByb3BlcnR5KCJlbmFibGVkIik/Yi5lbmFibGVkOnRoaXMuZW5hYmxlZCxlPWIub3B0aW9uc3x8dGhpcy5vcHRpb25zO2lmKGQmJnRoaXMubWF0Y2hlcyhhKSl7dmFyIGYsaD1uZXcgZyh0aGlzKSxpPVQuY2hlY2tIZWxwZXIoaCxjKTt0cnl7Zj10aGlzLmV2YWx1YXRlLmNhbGwoaSxhLGUpfWNhdGNoKGope3JldHVybiBTLmxvZyhqLm1lc3NhZ2Usai5zdGFjayksdm9pZCBjKG51bGwpfWkuaXNBc3luY3x8KGgucmVzdWx0PWYsc2V0VGltZW91dChmdW5jdGlvbigpe2MoaCl9LDApKX1lbHNlIGMobnVsbCl9LG8ucHJvdG90eXBlLm1hdGNoZXM9ZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7cmV0dXJuITB9LG8ucHJvdG90eXBlLmdhdGhlcj1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7dmFyIGI9VC5zZWxlY3QodGhpcy5zZWxlY3RvcixhKTtyZXR1cm4gdGhpcy5leGNsdWRlSGlkZGVuP2IuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiFULmlzSGlkZGVuKGEpfSk6Yn0sby5wcm90b3R5cGUucnVuQ2hlY2tzPWZ1bmN0aW9uKGEsYixjLGQpeyJ1c2Ugc3RyaWN0Ijt2YXIgZT10aGlzLGY9VC5xdWV1ZSgpO3RoaXNbYV0uZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgZD1lLl9hdWRpdC5jaGVja3NbYS5pZHx8YV0sZz1ULmdldENoZWNrT3B0aW9uKGQsZS5pZCxjKTtmLmRlZmVyKGZ1bmN0aW9uKGEpe2QucnVuKGIsZyxhKX0pfSksZi50aGVuKGZ1bmN0aW9uKGIpe2I9Yi5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGF9KSxkKHt0eXBlOmEscmVzdWx0czpifSl9KX0sby5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKGEsYixjKXsidXNlIHN0cmljdCI7dmFyIGQsZT10aGlzLmdhdGhlcihhKSxmPVQucXVldWUoKSxnPXRoaXM7ZD1uZXcgbih0aGlzKSxlLmZvckVhY2goZnVuY3Rpb24oYSl7Zy5tYXRjaGVzKGEpJiZmLmRlZmVyKGZ1bmN0aW9uKGMpe3ZhciBlPVQucXVldWUoKTtlLmRlZmVyKGZ1bmN0aW9uKGMpe2cucnVuQ2hlY2tzKCJhbnkiLGEsYixjKX0pLGUuZGVmZXIoZnVuY3Rpb24oYyl7Zy5ydW5DaGVja3MoImFsbCIsYSxiLGMpfSksZS5kZWZlcihmdW5jdGlvbihjKXtnLnJ1bkNoZWNrcygibm9uZSIsYSxiLGMpfSksZS50aGVuKGZ1bmN0aW9uKGIpe2lmKGIubGVuZ3RoKXt2YXIgZT0hMSxmPXtub2RlOm5ldyBULkRxRWxlbWVudChhKX07Yi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVzdWx0cy5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGF9KTtmW2EudHlwZV09YixiLmxlbmd0aCYmKGU9ITApfSksZSYmZC5ub2Rlcy5wdXNoKGYpfWMoKX0pfSl9KSxmLnRoZW4oZnVuY3Rpb24oKXtjKGQpfSl9LG8ucHJvdG90eXBlLmFmdGVyPWZ1bmN0aW9uKGEsYil7InVzZSBzdHJpY3QiO3ZhciBjPXAodGhpcyksZD10aGlzLmlkO3JldHVybiBjLmZvckVhY2goZnVuY3Rpb24oYyl7dmFyIGU9cShhLm5vZGVzLGMuaWQpLGY9VC5nZXRDaGVja09wdGlvbihjLGQsYiksZz1jLmFmdGVyKGUsZik7ZS5mb3JFYWNoKGZ1bmN0aW9uKGEpey0xPT09Zy5pbmRleE9mKGEpJiYoYS5maWx0ZXJlZD0hMCl9KX0pLGEubm9kZXM9cyhhKSxhfSx0LnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oYSxiLGMpeyJ1c2Ugc3RyaWN0IjtiPSJ1bmRlZmluZWQiPT10eXBlb2YgYj90aGlzLm9wdGlvbnM6Yix0aGlzLmFjdGl2ZT0hMCx0aGlzLl9ydW4oYSxiLGMpfSx0LnByb3RvdHlwZS5jbGVhbnVwPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijt0aGlzLmFjdGl2ZT0hMSx0aGlzLl9jbGVhbnVwKGEpfSxTLmNvbnN0YW50cz17fSxTLmNvbnN0YW50cy5yZXN1bHQ9e1BBU1M6IlBBU1MiLEZBSUw6IkZBSUwiLE5BOiJOQSJ9LFMuY29uc3RhbnRzLnJhaXNlZE1ldGFkYXRhPXtpbXBhY3Q6WyJtaW5vciIsIm1vZGVyYXRlIiwic2VyaW91cyIsImNyaXRpY2FsIl19LFMudmVyc2lvbj0iZGV2IixhLmF4ZT1TLFMubG9nPWZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiOyJvYmplY3QiPT10eXBlb2YgY29uc29sZSYmY29uc29sZS5sb2cmJkZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLGNvbnNvbGUsYXJndW1lbnRzKX0sUy5jbGVhbnVwPXUsUy5jb25maWd1cmU9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3ZhciBiPVMuX2F1ZGl0O2lmKCFiKXRocm93IG5ldyBFcnJvcigiTm8gYXVkaXQgY29uZmlndXJlZCIpO2EucmVwb3J0ZXImJigiZnVuY3Rpb24iPT10eXBlb2YgYS5yZXBvcnRlcnx8V1thLnJlcG9ydGVyXSkmJihiLnJlcG9ydGVyPWEucmVwb3J0ZXIpLGEuY2hlY2tzJiZhLmNoZWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2IuYWRkQ2hlY2soYSl9KSxhLnJ1bGVzJiZhLnJ1bGVzLmZvckVhY2goZnVuY3Rpb24oYSl7Yi5hZGRSdWxlKGEpfSksYS50b29scyYmYS50b29scy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2IuYWRkVG9vbChhKX0pfSxTLmdldFJ1bGVzPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0IjthPWF8fFtdO3ZhciBiPWEubGVuZ3RoP1MuX2F1ZGl0LnJ1bGVzLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4hIWEuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybi0xIT09Yi50YWdzLmluZGV4T2YoYSl9KS5sZW5ndGh9KTpTLl9hdWRpdC5ydWxlcyxjPVMuX2F1ZGl0LmRhdGEucnVsZXN8fHt9O3JldHVybiBiLm1hcChmdW5jdGlvbihhKXt2YXIgYj1jW2EuaWRdfHx7fTtyZXR1cm57cnVsZUlkOmEuaWQsZGVzY3JpcHRpb246Yi5kZXNjcmlwdGlvbixoZWxwOmIuaGVscCxoZWxwVXJsOmIuaGVscFVybCx0YWdzOmEudGFnc319KX0sUy5fbG9hZD1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7VC5yZXNwb25kYWJsZS5zdWJzY3JpYmUoImF4ZS5waW5nIixmdW5jdGlvbihhLGIpe2Ioe2F4ZTohMH0pfSksVC5yZXNwb25kYWJsZS5zdWJzY3JpYmUoImF4ZS5zdGFydCIsdiksUy5fYXVkaXQ9bmV3IGYoYSl9O3ZhciBWLFc9e307Uy5yZXBvcnRlcj1mdW5jdGlvbihhLGIsYyl7InVzZSBzdHJpY3QiO1dbYV09YixjJiYoVj1iKX0sUy5hMTF5Q2hlY2s9ZnVuY3Rpb24oYSxiLGMpeyJ1c2Ugc3RyaWN0IjsiZnVuY3Rpb24iPT10eXBlb2YgYiYmKGM9YixiPXt9KSxiJiYib2JqZWN0Ij09dHlwZW9mIGJ8fChiPXt9KTt2YXIgZD1TLl9hdWRpdDtpZighZCl0aHJvdyBuZXcgRXJyb3IoIk5vIGF1ZGl0IGNvbmZpZ3VyZWQiKTt2YXIgZT13KGIucmVwb3J0ZXJ8fGQucmVwb3J0ZXIpO3goYSxiLGZ1bmN0aW9uKGEpe2UoYSxjKX0pfSxTLnRvb2w9eSxVLmZhaWx1cmVTdW1tYXJ5PWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYj17fTtyZXR1cm4gYi5ub25lPWEubm9uZS5jb25jYXQoYS5hbGwpLGIuYW55PWEuYW55LE9iamVjdC5rZXlzKGIpLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYlthXS5sZW5ndGg/Uy5fYXVkaXQuZGF0YS5mYWlsdXJlU3VtbWFyaWVzW2FdLmZhaWx1cmVNZXNzYWdlKGJbYV0ubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhLm1lc3NhZ2V8fCIifSkpOnZvaWQgMH0pLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwIT09YX0pLmpvaW4oIlxuXG4iKX0sVS5mb3JtYXRDaGVjaz1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7cmV0dXJue2lkOmEuaWQsaW1wYWN0OmEuaW1wYWN0LG1lc3NhZ2U6YS5tZXNzYWdlLGRhdGE6YS5kYXRhLHJlbGF0ZWROb2RlczphLnJlbGF0ZWROb2Rlcy5tYXAoVS5mb3JtYXROb2RlKX19LFUuZm9ybWF0Q2hlY2tzPWZ1bmN0aW9uKGEsYil7InVzZSBzdHJpY3QiO3JldHVybiBhLmFueT1iLmFueS5tYXAoVS5mb3JtYXRDaGVjayksYS5hbGw9Yi5hbGwubWFwKFUuZm9ybWF0Q2hlY2spLGEubm9uZT1iLm5vbmUubWFwKFUuZm9ybWF0Q2hlY2spLGF9LFUuZm9ybWF0Tm9kZT1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7cmV0dXJue3RhcmdldDphP2Euc2VsZWN0b3I6bnVsbCxodG1sOmE/YS5zb3VyY2U6bnVsbH19LFUuZm9ybWF0UnVsZVJlc3VsdD1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7cmV0dXJue2lkOmEuaWQsZGVzY3JpcHRpb246YS5kZXNjcmlwdGlvbixoZWxwOmEuaGVscCxoZWxwVXJsOmEuaGVscFVybHx8bnVsbCxpbXBhY3Q6bnVsbCx0YWdzOmEudGFncyxub2RlczpbXX19LFUuc3BsaXRSZXN1bHRzV2l0aENoZWNrcz1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7cmV0dXJuIFUuc3BsaXRSZXN1bHRzKGEsVS5mb3JtYXRDaGVja3MpfSxVLnNwbGl0UmVzdWx0cz1mdW5jdGlvbihiLGMpeyJ1c2Ugc3RyaWN0Ijt2YXIgZD1bXSxlPVtdO3JldHVybiBiLmZvckVhY2goZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXt2YXIgZD1iLnJlc3VsdHx8YS5yZXN1bHQsZT1VLmZvcm1hdE5vZGUoYi5ub2RlKTtyZXR1cm4gZS5pbXBhY3Q9Yi5pbXBhY3R8fG51bGwsYyhlLGIsZCl9dmFyIGYsZz1VLmZvcm1hdFJ1bGVSZXN1bHQoYSk7Zj1ULmNsb25lKGcpLGYuaW1wYWN0PWEuaW1wYWN0fHxudWxsLGYubm9kZXM9YS52aW9sYXRpb25zLm1hcChiKSxnLm5vZGVzPWEucGFzc2VzLm1hcChiKSxmLm5vZGVzLmxlbmd0aCYmZC5wdXNoKGYpLGcubm9kZXMubGVuZ3RoJiZlLnB1c2goZyl9KSx7dmlvbGF0aW9uczpkLHBhc3NlczplLHVybDphLmxvY2F0aW9uLmhyZWYsdGltZXN0YW1wOm5ldyBEYXRlfX0sUy5yZXBvcnRlcigibmEiLGZ1bmN0aW9uKGEsYil7InVzZSBzdHJpY3QiO3ZhciBjPWEuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiAwPT09YS52aW9sYXRpb25zLmxlbmd0aCYmMD09PWEucGFzc2VzLmxlbmd0aH0pLm1hcChVLmZvcm1hdFJ1bGVSZXN1bHQpLGQ9VS5zcGxpdFJlc3VsdHNXaXRoQ2hlY2tzKGEpO2Ioe3Zpb2xhdGlvbnM6ZC52aW9sYXRpb25zLHBhc3NlczpkLnBhc3Nlcyxub3RBcHBsaWNhYmxlOmMsdGltZXN0YW1wOmQudGltZXN0YW1wLHVybDpkLnVybH0pfSksUy5yZXBvcnRlcigibm8tcGFzc2VzIixmdW5jdGlvbihhLGIpeyJ1c2Ugc3RyaWN0Ijt2YXIgYz1VLnNwbGl0UmVzdWx0c1dpdGhDaGVja3MoYSk7Yih7dmlvbGF0aW9uczpjLnZpb2xhdGlvbnMsdGltZXN0YW1wOmMudGltZXN0YW1wLHVybDpjLnVybH0pfSksUy5yZXBvcnRlcigicmF3IixmdW5jdGlvbihhLGIpeyJ1c2Ugc3RyaWN0IjtiKGEpfSksUy5yZXBvcnRlcigidjEiLGZ1bmN0aW9uKGEsYil7InVzZSBzdHJpY3QiO3ZhciBjPVUuc3BsaXRSZXN1bHRzKGEsZnVuY3Rpb24oYSxiLGMpe3JldHVybiBjPT09Uy5jb25zdGFudHMucmVzdWx0LkZBSUwmJihhLmZhaWx1cmVTdW1tYXJ5PVUuZmFpbHVyZVN1bW1hcnkoYikpLGF9KTtiKHt2aW9sYXRpb25zOmMudmlvbGF0aW9ucyxwYXNzZXM6Yy5wYXNzZXMsdGltZXN0YW1wOmMudGltZXN0YW1wLHVybDpjLnVybH0pfSksUy5yZXBvcnRlcigidjIiLGZ1bmN0aW9uKGEsYil7InVzZSBzdHJpY3QiO3ZhciBjPVUuc3BsaXRSZXN1bHRzV2l0aENoZWNrcyhhKTtiKHt2aW9sYXRpb25zOmMudmlvbGF0aW9ucyxwYXNzZXM6Yy5wYXNzZXMsdGltZXN0YW1wOmMudGltZXN0YW1wLHVybDpjLnVybH0pfSwhMCksVC5jaGVja0hlbHBlcj1mdW5jdGlvbihhLGIpeyJ1c2Ugc3RyaWN0IjtyZXR1cm57aXNBc3luYzohMSxhc3luYzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQXN5bmM9ITAsZnVuY3Rpb24oYyl7YS52YWx1ZT1jLGIoYSl9fSxkYXRhOmZ1bmN0aW9uKGIpe2EuZGF0YT1ifSxyZWxhdGVkTm9kZXM6ZnVuY3Rpb24oYil7Yj1iIGluc3RhbmNlb2YgTm9kZT9bYl06VC50b0FycmF5KGIpLGEucmVsYXRlZE5vZGVzPWIubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgVC5EcUVsZW1lbnQoYSl9KX19fSxULnNlbmRDb21tYW5kVG9GcmFtZT1mdW5jdGlvbihhLGIsYyl7InVzZSBzdHJpY3QiO3ZhciBkPWEuY29udGVudFdpbmRvdztpZighZClyZXR1cm4gUy5sb2coIkZyYW1lIGRvZXMgbm90IGhhdmUgYSBjb250ZW50IHdpbmRvdyIsYSksYyh7fSk7dmFyIGU9c2V0VGltZW91dChmdW5jdGlvbigpe2U9c2V0VGltZW91dChmdW5jdGlvbigpe1MubG9nKCJObyByZXNwb25zZSBmcm9tIGZyYW1lOiAiLGEpLGMobnVsbCl9LDApfSw1MDApO1QucmVzcG9uZGFibGUoZCwiYXhlLnBpbmciLG51bGwsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZSksZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Uy5sb2coIkVycm9yIHJldHVybmluZyByZXN1bHRzIGZyb20gZnJhbWU6ICIsYSksYyh7fSksYz1udWxsfSwzZTQpLFQucmVzcG9uZGFibGUoZCwiYXhlLnN0YXJ0IixiLGZ1bmN0aW9uKGEpe2MmJihjbGVhclRpbWVvdXQoZSksYyhhKSl9KX0pfSxULmNvbGxlY3RSZXN1bHRzRnJvbUZyYW1lcz1mdW5jdGlvbihhLGIsYyxkLGUpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiBmKGUpe3ZhciBmPXtvcHRpb25zOmIsY29tbWFuZDpjLHBhcmFtZXRlcjpkLGNvbnRleHQ6e2luaXRpYXRvcjohMSxwYWdlOmEucGFnZSxpbmNsdWRlOmUuaW5jbHVkZXx8W10sZXhjbHVkZTplLmV4Y2x1ZGV8fFtdfX07Zy5kZWZlcihmdW5jdGlvbihhKXt2YXIgYj1lLm5vZGU7VC5zZW5kQ29tbWFuZFRvRnJhbWUoYixmLGZ1bmN0aW9uKGMpe3JldHVybiBjP2Eoe3Jlc3VsdHM6YyxmcmFtZUVsZW1lbnQ6YixmcmFtZTpULmdldFNlbGVjdG9yKGIpfSk6dm9pZCBhKG51bGwpfSl9KX1mb3IodmFyIGc9VC5xdWV1ZSgpLGg9YS5mcmFtZXMsaT0wLGo9aC5sZW5ndGg7aj5pO2krKylmKGhbaV0pO2cudGhlbihmdW5jdGlvbihhKXtlKFQubWVyZ2VSZXN1bHRzKGEpKX0pfSxULmNvbnRhaW5zPWZ1bmN0aW9uKGEsYil7InVzZSBzdHJpY3QiO3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiBhLmNvbnRhaW5zP2EuY29udGFpbnMoYik6ISEoMTYmYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSl9LEIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpeyJ1c2Ugc3RyaWN0IjtyZXR1cm57c2VsZWN0b3I6dGhpcy5zZWxlY3Rvcixzb3VyY2U6dGhpcy5zb3VyY2V9fSxULkRxRWxlbWVudD1CLFQuZXh0ZW5kQmxhY2tsaXN0PWZ1bmN0aW9uKGEsYixjKXsidXNlIHN0cmljdCI7Yz1jfHxbXTtmb3IodmFyIGQgaW4gYiliLmhhc093blByb3BlcnR5KGQpJiYtMT09PWMuaW5kZXhPZihkKSYmKGFbZF09YltkXSk7cmV0dXJuIGF9LFQuZXh0ZW5kTWV0YURhdGE9ZnVuY3Rpb24oYSxiKXsidXNlIHN0cmljdCI7Zm9yKHZhciBjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSlpZigiZnVuY3Rpb24iPT10eXBlb2YgYltjXSl0cnl7YVtjXT1iW2NdKGEpfWNhdGNoKGQpe2FbY109bnVsbH1lbHNlIGFbY109YltjXX0sVC5nZXRGYWlsaW5nQ2hlY2tzPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYj1hLmFueS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIWEucmVzdWx0fSk7cmV0dXJue2FsbDphLmFsbC5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIWEucmVzdWx0fSksYW55OmIubGVuZ3RoPT09YS5hbnkubGVuZ3RoP2I6W10sbm9uZTphLm5vbmUuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiEhYS5yZXN1bHR9KX19LFQuZmluYWxpemVSdWxlUmVzdWx0PWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0IjtyZXR1cm4gVC5wdWJsaXNoTWV0YURhdGEoYSksRShhKX0sVC5maW5kQnk9ZnVuY3Rpb24oYSxiLGMpeyJ1c2Ugc3RyaWN0IjthPWF8fFtdO3ZhciBkLGU7Zm9yKGQ9MCxlPWEubGVuZ3RoO2U+ZDtkKyspaWYoYVtkXVtiXT09PWMpcmV0dXJuIGFbZF19LFQuZ2V0QWxsQ2hlY2tzPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYj1bXTtyZXR1cm4gYi5jb25jYXQoYS5hbnl8fFtdKS5jb25jYXQoYS5hbGx8fFtdKS5jb25jYXQoYS5ub25lfHxbXSl9LFQuZ2V0Q2hlY2tPcHRpb249ZnVuY3Rpb24oYSxiLGMpeyJ1c2Ugc3RyaWN0Ijt2YXIgZD0oKGMucnVsZXMmJmMucnVsZXNbYl18fHt9KS5jaGVja3N8fHt9KVthLmlkXSxlPShjLmNoZWNrc3x8e30pW2EuaWRdLGY9YS5lbmFibGVkLGc9YS5vcHRpb25zO3JldHVybiBlJiYoZS5oYXNPd25Qcm9wZXJ0eSgiZW5hYmxlZCIpJiYoZj1lLmVuYWJsZWQpLGUuaGFzT3duUHJvcGVydHkoIm9wdGlvbnMiKSYmKGc9ZS5vcHRpb25zKSksZCYmKGQuaGFzT3duUHJvcGVydHkoImVuYWJsZWQiKSYmKGY9ZC5lbmFibGVkKSxkLmhhc093blByb3BlcnR5KCJvcHRpb25zIikmJihnPWQub3B0aW9ucykpLHtlbmFibGVkOmYsb3B0aW9uczpnfX0sVC5nZXRTZWxlY3Rvcj1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gVC5lc2NhcGVTZWxlY3RvcihhKX1mb3IodmFyIGQsZT1bXTthLnBhcmVudE5vZGU7KXtpZihkPSIiLGEuaWQmJjE9PT1iLnF1ZXJ5U2VsZWN0b3JBbGwoIiMiK1QuZXNjYXBlU2VsZWN0b3IoYS5pZCkpLmxlbmd0aCl7ZS51bnNoaWZ0KCIjIitULmVzY2FwZVNlbGVjdG9yKGEuaWQpKTticmVha31pZihhLmNsYXNzTmFtZSYmInN0cmluZyI9PXR5cGVvZiBhLmNsYXNzTmFtZSYmKGQ9Ii4iK2EuY2xhc3NOYW1lLnRyaW0oKS5zcGxpdCgvXHMrLykubWFwKGMpLmpvaW4oIi4iKSwoIi4iPT09ZHx8RyhhLGQpKSYmKGQ9IiIpKSwhZCl7aWYoZD1ULmVzY2FwZVNlbGVjdG9yKGEubm9kZU5hbWUpLnRvTG93ZXJDYXNlKCksImh0bWwiPT09ZHx8ImJvZHkiPT09ZCl7ZS51bnNoaWZ0KGQpO2JyZWFrfUcoYSxkKSYmKGQrPSI6bnRoLW9mLXR5cGUoIitGKGEpKyIpIil9ZS51bnNoaWZ0KGQpLGE9YS5wYXJlbnROb2RlfXJldHVybiBlLmpvaW4oIiA+ICIpfTt2YXIgWDtULmlzSGlkZGVuPWZ1bmN0aW9uKGIsYyl7InVzZSBzdHJpY3QiO2lmKDk9PT1iLm5vZGVUeXBlKXJldHVybiExO3ZhciBkPWEuZ2V0Q29tcHV0ZWRTdHlsZShiLG51bGwpO3JldHVybiBkJiZiLnBhcmVudE5vZGUmJiJub25lIiE9PWQuZ2V0UHJvcGVydHlWYWx1ZSgiZGlzcGxheSIpJiYoY3x8ImhpZGRlbiIhPT1kLmdldFByb3BlcnR5VmFsdWUoInZpc2liaWxpdHkiKSkmJiJ0cnVlIiE9PWIuZ2V0QXR0cmlidXRlKCJhcmlhLWhpZGRlbiIpP1QuaXNIaWRkZW4oYi5wYXJlbnROb2RlLCEwKTohMH0sVC5tZXJnZVJlc3VsdHM9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3ZhciBiPVtdO3JldHVybiBhLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGM9SyhhKTtjJiZjLmxlbmd0aCYmYy5mb3JFYWNoKGZ1bmN0aW9uKGMpe2Mubm9kZXMmJmEuZnJhbWUmJkkoYy5ub2RlcyxhLmZyYW1lRWxlbWVudCxhLmZyYW1lKTt2YXIgZD1ULmZpbmRCeShiLCJpZCIsYy5pZCk7ZD9jLm5vZGVzLmxlbmd0aCYmSihkLm5vZGVzLGMubm9kZXMpOmIucHVzaChjKX0pfSksYn0sVC5ub2RlU29ydGVyPWZ1bmN0aW9uKGEsYil7InVzZSBzdHJpY3QiO3JldHVybiBhPT09Yj8wOjQmYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKT8tMToxfSxULnB1Ymxpc2hNZXRhRGF0YT1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gYihhKXtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGQ9Y1tiLmlkXXx8e30sZT1kLm1lc3NhZ2VzfHx7fSxmPVQuZXh0ZW5kQmxhY2tsaXN0KHt9LGQsWyJtZXNzYWdlcyJdKTtmLm1lc3NhZ2U9Yi5yZXN1bHQ9PT1hP2UucGFzczplLmZhaWwsVC5leHRlbmRNZXRhRGF0YShiLGYpfX12YXIgYz1TLl9hdWRpdC5kYXRhLmNoZWNrc3x8e30sZD1TLl9hdWRpdC5kYXRhLnJ1bGVzfHx7fSxlPVQuZmluZEJ5KFMuX2F1ZGl0LnJ1bGVzLCJpZCIsYS5pZCl8fHt9O2EudGFncz1ULmNsb25lKGUudGFnc3x8W10pO3ZhciBmPWIoITApLGc9YighMSk7YS5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuYW55LmZvckVhY2goZiksYS5hbGwuZm9yRWFjaChmKSxhLm5vbmUuZm9yRWFjaChnKX0pLFQuZXh0ZW5kTWV0YURhdGEoYSxULmNsb25lKGRbYS5pZF18fHt9KSl9LGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gYigpe2Z1bmN0aW9uIGIoKXtmb3IodmFyIGE9ZS5sZW5ndGg7YT5mO2YrKyl7dmFyIGI9ZVtmXSxkPWIuc2hpZnQoKTtiLnB1c2goYyhmKSksZC5hcHBseShudWxsLGIpfX1mdW5jdGlvbiBjKGEpe3JldHVybiBmdW5jdGlvbihiKXtlW2FdPWIsLS1nfHxkKCl9fWZ1bmN0aW9uIGQoKXtoKGUpfXZhciBlPVtdLGY9MCxnPTAsaD1hO3JldHVybntkZWZlcjpmdW5jdGlvbihhKXtlLnB1c2goW2FdKSwrK2csYigpfSx0aGVuOmZ1bmN0aW9uKGEpe2g9YSxnfHxkKCl9LGFib3J0OmZ1bmN0aW9uKGIpe2g9YSxiKGUpfX19VC5xdWV1ZT1ifSgpLGZ1bmN0aW9uKGIpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiBjKGEpe3JldHVybiJvYmplY3QiPT10eXBlb2YgYSYmInN0cmluZyI9PXR5cGVvZiBhLnV1aWQmJmEuX3Jlc3BvbmRhYmxlPT09ITB9ZnVuY3Rpb24gZChhLGIsYyxkLGUpe3ZhciBmPXt1dWlkOmQsdG9waWM6YixtZXNzYWdlOmMsX3Jlc3BvbmRhYmxlOiEwfTtoW2RdPWUsYS5wb3N0TWVzc2FnZShKU09OLnN0cmluZ2lmeShmKSwiKiIpfWZ1bmN0aW9uIGUoYSxiLGMsZSl7dmFyIGY9Ty52MSgpO2QoYSxiLGMsZixlKX1mdW5jdGlvbiBmKGEsYil7dmFyIGM9Yi50b3BpYyxkPWIubWVzc2FnZSxlPWlbY107ZSYmZShkLGcoYS5zb3VyY2UsbnVsbCxiLnV1aWQpKX1mdW5jdGlvbiBnKGEsYixjKXtyZXR1cm4gZnVuY3Rpb24oZSxmKXtkKGEsYixlLGMsZil9fXZhciBoPXt9LGk9e307ZS5zdWJzY3JpYmU9ZnVuY3Rpb24oYSxiKXtpW2FdPWJ9LGEuYWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsZnVuY3Rpb24oYSl7aWYoInN0cmluZyI9PXR5cGVvZiBhLmRhdGEpe3ZhciBiO3RyeXtiPUpTT04ucGFyc2UoYS5kYXRhKX1jYXRjaChkKXt9aWYoYyhiKSl7dmFyIGU9Yi51dWlkO2hbZV0mJihoW2VdKGIubWVzc2FnZSxnKGEuc291cmNlLGIudG9waWMsZSkpLGhbZV09bnVsbCksZihhLGIpfX19LCExKSxiLnJlc3BvbmRhYmxlPWV9KFQpLFQucnVsZVNob3VsZFJ1bj1mdW5jdGlvbihhLGIsYyl7InVzZSBzdHJpY3QiO2lmKGEucGFnZUxldmVsJiYhYi5wYWdlKXJldHVybiExO3ZhciBkPWMucnVuT25seSxlPShjLnJ1bGVzfHx7fSlbYS5pZF07cmV0dXJuIGQ/InJ1bGUiPT09ZC50eXBlPy0xIT09ZC52YWx1ZXMuaW5kZXhPZihhLmlkKTohIShkLnZhbHVlc3x8W10pLmZpbHRlcihmdW5jdGlvbihiKXtyZXR1cm4tMSE9PWEudGFncy5pbmRleE9mKGIpfSkubGVuZ3RoOihlJiZlLmhhc093blByb3BlcnR5KCJlbmFibGVkIik/ZS5lbmFibGVkOmEuZW5hYmxlZCk/ITA6ITF9LFQuc2VsZWN0PWZ1bmN0aW9uKGEsYil7InVzZSBzdHJpY3QiO2Zvcih2YXIgYyxkPVtdLGU9MCxmPWIuaW5jbHVkZS5sZW5ndGg7Zj5lO2UrKyljPWIuaW5jbHVkZVtlXSxjLm5vZGVUeXBlPT09Yy5FTEVNRU5UX05PREUmJlQubWF0Y2hlc1NlbGVjdG9yKGMsYSkmJk4oZCxbY10sYiksTihkLGMucXVlcnlTZWxlY3RvckFsbChhKSxiKTtyZXR1cm4gZC5zb3J0KFQubm9kZVNvcnRlcil9LFQudG9BcnJheT1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpfSxTLl9sb2FkKHtkYXRhOntydWxlczp7YWNjZXNza2V5czp7ZGVzY3JpcHRpb246IkVuc3VyZXMgZXZlcnkgYWNjZXNza2V5IGF0dHJpYnV0ZSB2YWx1ZSBpcyB1bmlxdWUiLGhlbHA6ImFjY2Vzc2tleSBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBiZSB1bmlxdWUiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2FjY2Vzc2tleXMifSwiYXJlYS1hbHQiOntkZXNjcmlwdGlvbjoiRW5zdXJlcyA8YXJlYT4gZWxlbWVudHMgb2YgaW1hZ2UgbWFwcyBoYXZlIGFsdGVybmF0ZSB0ZXh0IixoZWxwOiJBY3RpdmUgPGFyZWE+IGVsZW1lbnRzIG11c3QgaGF2ZSBhbHRlcm5hdGUgdGV4dCIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvYXJlYS1hbHQifSwiYXJpYS1hbGxvd2VkLWF0dHIiOntkZXNjcmlwdGlvbjoiRW5zdXJlcyBBUklBIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWQgZm9yIGFuIGVsZW1lbnQncyByb2xlIixoZWxwOiJFbGVtZW50cyBtdXN0IG9ubHkgdXNlIGFsbG93ZWQgQVJJQSBhdHRyaWJ1dGVzIixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9hcmlhLWFsbG93ZWQtYXR0ciJ9LCJhcmlhLXJlcXVpcmVkLWF0dHIiOntkZXNjcmlwdGlvbjoiRW5zdXJlcyBlbGVtZW50cyB3aXRoIEFSSUEgcm9sZXMgaGF2ZSBhbGwgcmVxdWlyZWQgQVJJQSBhdHRyaWJ1dGVzIixoZWxwOiJSZXF1aXJlZCBBUklBIGF0dHJpYnV0ZXMgbXVzdCBiZSBwcm92aWRlZCIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvYXJpYS1yZXF1aXJlZC1hdHRyIn0sImFyaWEtcmVxdWlyZWQtY2hpbGRyZW4iOntkZXNjcmlwdGlvbjoiRW5zdXJlcyBlbGVtZW50cyB3aXRoIGFuIEFSSUEgcm9sZSB0aGF0IHJlcXVpcmUgY2hpbGQgcm9sZXMgY29udGFpbiB0aGVtIixoZWxwOiJDZXJ0YWluIEFSSUEgcm9sZXMgbXVzdCBjb250YWluIHBhcnRpY3VsYXIgY2hpbGRyZW4iLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2FyaWEtcmVxdWlyZWQtY2hpbGRyZW4ifSwiYXJpYS1yZXF1aXJlZC1wYXJlbnQiOntkZXNjcmlwdGlvbjoiRW5zdXJlcyBlbGVtZW50cyB3aXRoIGFuIEFSSUEgcm9sZSB0aGF0IHJlcXVpcmUgcGFyZW50IHJvbGVzIGFyZSBjb250YWluZWQgYnkgdGhlbSIsaGVscDoiQ2VydGFpbiBBUklBIHJvbGVzIG11c3QgYmUgY29udGFpbmVkIGJ5IHBhcnRpY3VsYXIgcGFyZW50cyIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvYXJpYS1yZXF1aXJlZC1wYXJlbnQifSwiYXJpYS1yb2xlcyI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIGFsbCBlbGVtZW50cyB3aXRoIGEgcm9sZSBhdHRyaWJ1dGUgdXNlIGEgdmFsaWQgdmFsdWUiLGhlbHA6IkFSSUEgcm9sZXMgdXNlZCBtdXN0IGNvbmZvcm0gdG8gdmFsaWQgdmFsdWVzIixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9hcmlhLXJvbGVzIn0sImFyaWEtdmFsaWQtYXR0ci12YWx1ZSI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIGFsbCBBUklBIGF0dHJpYnV0ZXMgaGF2ZSB2YWxpZCB2YWx1ZXMiLGhlbHA6IkFSSUEgYXR0cmlidXRlcyBtdXN0IGNvbmZvcm0gdG8gdmFsaWQgdmFsdWVzIixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9hcmlhLXZhbGlkLWF0dHItdmFsdWUifSwiYXJpYS12YWxpZC1hdHRyIjp7ZGVzY3JpcHRpb246IkVuc3VyZXMgYXR0cmlidXRlcyB0aGF0IGJlZ2luIHdpdGggYXJpYS0gYXJlIHZhbGlkIEFSSUEgYXR0cmlidXRlcyIsaGVscDoiQVJJQSBhdHRyaWJ1dGVzIG11c3QgY29uZm9ybSB0byB2YWxpZCBuYW1lcyIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvYXJpYS12YWxpZC1hdHRyIn0sImF1ZGlvLWNhcHRpb24iOntkZXNjcmlwdGlvbjoiRW5zdXJlcyA8YXVkaW8+IGVsZW1lbnRzIGhhdmUgY2FwdGlvbnMiLGhlbHA6IjxhdWRpbz4gZWxlbWVudHMgbXVzdCBoYXZlIGEgY2FwdGlvbnMgdHJhY2siLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2F1ZGlvLWNhcHRpb24ifSxibGluazp7ZGVzY3JpcHRpb246IkVuc3VyZXMgPGJsaW5rPiBlbGVtZW50cyBhcmUgbm90IHVzZWQiLGhlbHA6IjxibGluaz4gZWxlbWVudHMgYXJlIGRlcHJlY2F0ZWQgYW5kIG11c3Qgbm90IGJlIHVzZWQiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2JsaW5rIn0sImJ1dHRvbi1uYW1lIjp7ZGVzY3JpcHRpb246IkVuc3VyZXMgYnV0dG9ucyBoYXZlIGRpc2Nlcm5pYmxlIHRleHQiLGhlbHA6IkJ1dHRvbnMgbXVzdCBoYXZlIGRpc2Nlcm5pYmxlIHRleHQiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2J1dHRvbi1uYW1lIn0sYnlwYXNzOntkZXNjcmlwdGlvbjoiRW5zdXJlcyBlYWNoIHBhZ2UgaGFzIGF0IGxlYXN0IG9uZSBtZWNoYW5pc20gZm9yIGEgdXNlciB0byBieXBhc3MgbmF2aWdhdGlvbiBhbmQganVtcCBzdHJhaWdodCB0byB0aGUgY29udGVudCIsaGVscDoiUGFnZSBtdXN0IGhhdmUgbWVhbnMgdG8gYnlwYXNzIHJlcGVhdGVkIGJsb2NrcyIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvYnlwYXNzIn0sY2hlY2tib3hncm91cDp7ZGVzY3JpcHRpb246J0Vuc3VyZXMgcmVsYXRlZCA8aW5wdXQgdHlwZT0iY2hlY2tib3giPiBlbGVtZW50cyBoYXZlIGEgZ3JvdXAgYW5kIHRoYXQgdGhhdCBncm91cCBkZXNpZ25hdGlvbiBpcyBjb25zaXN0ZW50JyxoZWxwOiJDaGVja2JveCBpbnB1dHMgd2l0aCB0aGUgc2FtZSBuYW1lIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGJlIHBhcnQgb2YgYSBncm91cCIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvY2hlY2tib3hncm91cCJ9LCJjb2xvci1jb250cmFzdCI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIHRoZSBjb250cmFzdCBiZXR3ZWVuIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3JzIG1lZXRzIFdDQUcgMiBBQSBjb250cmFzdCByYXRpbyB0aHJlc2hvbGRzIixoZWxwOiJFbGVtZW50cyBtdXN0IGhhdmUgc3VmZmljaWVudCBjb2xvciBjb250cmFzdCIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvY29sb3ItY29udHJhc3QifSwiZGF0YS10YWJsZSI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIGRhdGEgdGFibGVzIGFyZSBtYXJrZWQgdXAgc2VtYW50aWNhbGx5IGFuZCBoYXZlIHRoZSBjb3JyZWN0IGhlYWRlciBzdHJ1Y3R1cmUiLGhlbHA6IkRhdGEgdGFibGVzIHNob3VsZCBiZSBtYXJrZWQgdXAgcHJvcGVybHkiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2RhdGEtdGFibGUifSwiZGVmaW5pdGlvbi1saXN0Ijp7ZGVzY3JpcHRpb246IkVuc3VyZXMgPGRsPiBlbGVtZW50cyBhcmUgc3RydWN0dXJlZCBjb3JyZWN0bHkiLGhlbHA6IjxkbD4gZWxlbWVudHMgbXVzdCBvbmx5IGRpcmVjdGx5IGNvbnRhaW4gcHJvcGVybHktb3JkZXJlZCA8ZHQ+IGFuZCA8ZGQ+IGdyb3VwcywgPHNjcmlwdD4gb3IgPHRlbXBsYXRlPiBlbGVtZW50cyIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvZGVmaW5pdGlvbi1saXN0In0sZGxpdGVtOntkZXNjcmlwdGlvbjoiRW5zdXJlcyA8ZHQ+IGFuZCA8ZGQ+IGVsZW1lbnRzIGFyZSBjb250YWluZWQgYnkgYSA8ZGw+IixoZWxwOiI8ZHQ+IGFuZCA8ZGQ+IGVsZW1lbnRzIG11c3QgYmUgY29udGFpbmVkIGJ5IGEgPGRsPiIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvZGxpdGVtIn0sImRvY3VtZW50LXRpdGxlIjp7ZGVzY3JpcHRpb246IkVuc3VyZXMgZWFjaCBIVE1MIGRvY3VtZW50IGNvbnRhaW5zIGEgbm9uLWVtcHR5IDx0aXRsZT4gZWxlbWVudCIsaGVscDoiRG9jdW1lbnRzIG11c3QgaGF2ZSA8dGl0bGU+IGVsZW1lbnQgdG8gYWlkIGluIG5hdmlnYXRpb24iLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2RvY3VtZW50LXRpdGxlIn0sImR1cGxpY2F0ZS1pZCI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIGV2ZXJ5IGlkIGF0dHJpYnV0ZSB2YWx1ZSBpcyB1bmlxdWUiLGhlbHA6ImlkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGJlIHVuaXF1ZSIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvZHVwbGljYXRlLWlkIn0sImVtcHR5LWhlYWRpbmciOntkZXNjcmlwdGlvbjoiRW5zdXJlcyBoZWFkaW5ncyBoYXZlIGRpc2Nlcm5pYmxlIHRleHQiLGhlbHA6IkhlYWRpbmdzIG11c3Qgbm90IGJlIGVtcHR5IixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9lbXB0eS1oZWFkaW5nIn0sImZyYW1lLXRpdGxlIjp7ZGVzY3JpcHRpb246IkVuc3VyZXMgPGlmcmFtZT4gYW5kIDxmcmFtZT4gZWxlbWVudHMgY29udGFpbiBhIHVuaXF1ZSBhbmQgbm9uLWVtcHR5IHRpdGxlIGF0dHJpYnV0ZSIsaGVscDoiRnJhbWVzIG11c3QgaGF2ZSB1bmlxdWUgdGl0bGUgYXR0cmlidXRlIixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9mcmFtZS10aXRsZSJ9LCJoZWFkaW5nLW9yZGVyIjp7ZGVzY3JpcHRpb246IkVuc3VyZXMgdGhlIG9yZGVyIG9mIGhlYWRpbmdzIGlzIHNlbWFudGljYWxseSBjb3JyZWN0IixoZWxwOiJIZWFkaW5nIGxldmVscyBzaG91bGQgb25seSBpbmNyZWFzZSBieSBvbmUiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2hlYWRpbmctb3JkZXIifSwiaHRtbC1sYW5nIjp7ZGVzY3JpcHRpb246IkVuc3VyZXMgZXZlcnkgSFRNTCBkb2N1bWVudCBoYXMgYSBsYW5nIGF0dHJpYnV0ZSBhbmQgaXRzIHZhbHVlIGlzIHZhbGlkIixoZWxwOiI8aHRtbD4gZWxlbWVudCBtdXN0IGhhdmUgYSB2YWxpZCBsYW5nIGF0dHJpYnV0ZSIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvaHRtbC1sYW5nIn0sImltYWdlLWFsdCI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIDxpbWc+IGVsZW1lbnRzIGhhdmUgYWx0ZXJuYXRlIHRleHQgb3IgYSByb2xlIG9mIG5vbmUgb3IgcHJlc2VudGF0aW9uIixoZWxwOiJJbWFnZXMgbXVzdCBoYXZlIGFsdGVybmF0ZSB0ZXh0IixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9pbWFnZS1hbHQifSwiaW5wdXQtaW1hZ2UtYWx0Ijp7ZGVzY3JpcHRpb246J0Vuc3VyZXMgPGlucHV0IHR5cGU9ImltYWdlIj4gZWxlbWVudHMgaGF2ZSBhbHRlcm5hdGUgdGV4dCcsaGVscDoiSW1hZ2UgYnV0dG9ucyBtdXN0IGhhdmUgYWx0ZXJuYXRlIHRleHQiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2lucHV0LWltYWdlLWFsdCJ9LCJsYWJlbC10aXRsZS1vbmx5Ijp7ZGVzY3JpcHRpb246IkVuc3VyZXMgdGhhdCBldmVyeSBmb3JtIGVsZW1lbnQgaXMgbm90IHNvbGVseSBsYWJlbGVkIHVzaW5nIHRoZSB0aXRsZSBvciBhcmlhLWRlc2NyaWJlZGJ5IGF0dHJpYnV0ZXMiLGhlbHA6IkZvcm0gZWxlbWVudHMgc2hvdWxkIGhhdmUgYSB2aXNpYmxlIGxhYmVsIixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9sYWJlbC10aXRsZS1vbmx5In0sbGFiZWw6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIGV2ZXJ5IGZvcm0gZWxlbWVudCBoYXMgYSBsYWJlbCIsaGVscDoiRm9ybSBlbGVtZW50cyBtdXN0IGhhdmUgbGFiZWxzIixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9sYWJlbCJ9LCJsYXlvdXQtdGFibGUiOntkZXNjcmlwdGlvbjoiRW5zdXJlcyBwcmVzZW50YXRpb25hbCA8dGFibGU+IGVsZW1lbnRzIGRvIG5vdCB1c2UgPHRoPiwgPGNhcHRpb24+IGVsZW1lbnRzIG9yIHRoZSBzdW1tYXJ5IGF0dHJpYnV0ZSIsaGVscDoiTGF5b3V0IHRhYmxlcyBtdXN0IG5vdCB1c2UgZGF0YSB0YWJsZSBlbGVtZW50cyIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvbGF5b3V0LXRhYmxlIn0sImxpbmstbmFtZSI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIGxpbmtzIGhhdmUgZGlzY2VybmlibGUgdGV4dCIsaGVscDoiTGlua3MgbXVzdCBoYXZlIGRpc2Nlcm5pYmxlIHRleHQiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2xpbmstbmFtZSJ9LGxpc3Q6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIHRoYXQgbGlzdHMgYXJlIHN0cnVjdHVyZWQgY29ycmVjdGx5IixoZWxwOiI8dWw+IGFuZCA8b2w+IG11c3Qgb25seSBkaXJlY3RseSBjb250YWluIDxsaT4sIDxzY3JpcHQ+IG9yIDx0ZW1wbGF0ZT4gZWxlbWVudHMiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2xpc3QifSxsaXN0aXRlbTp7ZGVzY3JpcHRpb246IkVuc3VyZXMgPGxpPiBlbGVtZW50cyBhcmUgdXNlZCBzZW1hbnRpY2FsbHkiLGhlbHA6IjxsaT4gZWxlbWVudHMgbXVzdCBiZSBjb250YWluZWQgaW4gYSA8dWw+IG9yIDxvbD4iLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL2xpc3RpdGVtIn0sbWFycXVlZTp7ZGVzY3JpcHRpb246IkVuc3VyZXMgPG1hcnF1ZWU+IGVsZW1lbnRzIGFyZSBub3QgdXNlZCIsaGVscDoiPG1hcnF1ZWU+IGVsZW1lbnRzIGFyZSBkZXByZWNhdGVkIGFuZCBtdXN0IG5vdCBiZSB1c2VkIixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9tYXJxdWVlIn0sIm1ldGEtcmVmcmVzaCI6e2Rlc2NyaXB0aW9uOidFbnN1cmVzIDxtZXRhIGh0dHAtZXF1aXY9InJlZnJlc2giPiBpcyBub3QgdXNlZCcsaGVscDoiVGltZWQgcmVmcmVzaCBtdXN0IG5vdCBleGlzdCIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvbWV0YS1yZWZyZXNoIn0sIm1ldGEtdmlld3BvcnQiOntkZXNjcmlwdGlvbjonRW5zdXJlcyA8bWV0YSBuYW1lPSJ2aWV3cG9ydCI+IGRvZXMgbm90IGRpc2FibGUgdGV4dCBzY2FsaW5nIGFuZCB6b29taW5nJyxoZWxwOiJab29taW5nIGFuZCBzY2FsaW5nIG11c3Qgbm90IGJlIGRpc2FibGVkIixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9tZXRhLXZpZXdwb3J0In0sIm9iamVjdC1hbHQiOntkZXNjcmlwdGlvbjoiRW5zdXJlcyA8b2JqZWN0PiBlbGVtZW50cyBoYXZlIGFsdGVybmF0ZSB0ZXh0IixoZWxwOiI8b2JqZWN0PiBlbGVtZW50cyBtdXN0IGhhdmUgYWx0ZXJuYXRlIHRleHQiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL29iamVjdC1hbHQifSxyYWRpb2dyb3VwOntkZXNjcmlwdGlvbjonRW5zdXJlcyByZWxhdGVkIDxpbnB1dCB0eXBlPSJyYWRpbyI+IGVsZW1lbnRzIGhhdmUgYSBncm91cCBhbmQgdGhhdCB0aGUgZ3JvdXAgZGVzaWduYXRpb24gaXMgY29uc2lzdGVudCcsaGVscDoiUmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgbmFtZSBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBiZSBwYXJ0IG9mIGEgZ3JvdXAiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL3JhZGlvZ3JvdXAifSxyZWdpb246e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIGFsbCBjb250ZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBsYW5kbWFyayByZWdpb24iLGhlbHA6IkNvbnRlbnQgc2hvdWxkIGJlIGNvbnRhaW5lZCBpbiBhIGxhbmRtYXJrIHJlZ2lvbiIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvcmVnaW9uIn0sc2NvcGU6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIHRoZSBzY29wZSBhdHRyaWJ1dGUgaXMgdXNlZCBjb3JyZWN0bHkgb24gdGFibGVzIixoZWxwOiJzY29wZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIHVzZWQgY29ycmVjdGx5IixoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS9zY29wZSJ9LCJzZXJ2ZXItc2lkZS1pbWFnZS1tYXAiOntkZXNjcmlwdGlvbjoiRW5zdXJlcyB0aGF0IHNlcnZlci1zaWRlIGltYWdlIG1hcHMgYXJlIG5vdCB1c2VkIixoZWxwOiJTZXJ2ZXItc2lkZSBpbWFnZSBtYXBzIG11c3Qgbm90IGJlIHVzZWQiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL3NlcnZlci1zaWRlLWltYWdlLW1hcCJ9LCJza2lwLWxpbmsiOntkZXNjcmlwdGlvbjoiRW5zdXJlcyB0aGUgZmlyc3QgbGluayBvbiB0aGUgcGFnZSBpcyBhIHNraXAgbGluayIsaGVscDoiVGhlIHBhZ2Ugc2hvdWxkIGhhdmUgYSBza2lwIGxpbmsgYXMgaXRzIGZpcnN0IGxpbmsiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL3NraXAtbGluayJ9LHRhYmluZGV4OntkZXNjcmlwdGlvbjoiRW5zdXJlcyB0YWJpbmRleCBhdHRyaWJ1dGUgdmFsdWVzIGFyZSBub3QgZ3JlYXRlciB0aGFuIDAiLGhlbHA6IkVsZW1lbnRzIHNob3VsZCBub3QgaGF2ZSB0YWJpbmRleCBncmVhdGVyIHRoYW4gemVybyIsaGVscFVybDoiaHR0cHM6Ly9kZXF1ZXVuaXZlcnNpdHkuY29tL3J1bGVzL2F4ZS8xLjEvdGFiaW5kZXgifSwidmFsaWQtbGFuZyI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIGxhbmcgYXR0cmlidXRlcyBoYXZlIHZhbGlkIHZhbHVlcyIsaGVscDoibGFuZyBhdHRyaWJ1dGUgbXVzdCBoYXZlIGEgdmFsaWQgdmFsdWUiLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL3ZhbGlkLWxhbmcifSwidmlkZW8tY2FwdGlvbiI6e2Rlc2NyaXB0aW9uOiJFbnN1cmVzIDx2aWRlbz4gZWxlbWVudHMgaGF2ZSBjYXB0aW9ucyIsaGVscDoiPHZpZGVvPiBlbGVtZW50cyBtdXN0IGhhdmUgY2FwdGlvbnMiLApoZWxwVXJsOiJodHRwczovL2RlcXVldW5pdmVyc2l0eS5jb20vcnVsZXMvYXhlLzEuMS92aWRlby1jYXB0aW9uIn0sInZpZGVvLWRlc2NyaXB0aW9uIjp7ZGVzY3JpcHRpb246IkVuc3VyZXMgPHZpZGVvPiBlbGVtZW50cyBoYXZlIGF1ZGlvIGRlc2NyaXB0aW9ucyIsaGVscDoiPHZpZGVvPiBlbGVtZW50cyBtdXN0IGhhdmUgYW4gYXVkaW8gZGVzY3JpcHRpb24gdHJhY2siLGhlbHBVcmw6Imh0dHBzOi8vZGVxdWV1bml2ZXJzaXR5LmNvbS9ydWxlcy9heGUvMS4xL3ZpZGVvLWRlc2NyaXB0aW9uIn19LGNoZWNrczp7YWNjZXNza2V5czp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkFjY2Vzc2tleSBhdHRyaWJ1dGUgdmFsdWUgaXMgdW5pcXVlIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRG9jdW1lbnQgaGFzIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgYWNjZXNza2V5IjtyZXR1cm4gYn19fSwibm9uLWVtcHR5LWFsdCI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGhhcyBhIG5vbi1lbXB0eSBhbHQgYXR0cmlidXRlIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCBoYXMgbm8gYWx0IGF0dHJpYnV0ZSBvciB0aGUgYWx0IGF0dHJpYnV0ZSBpcyBlbXB0eSI7cmV0dXJuIGJ9fX0sImFyaWEtbGFiZWwiOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iYXJpYS1sYWJlbCBhdHRyaWJ1dGUgZXhpc3RzIGFuZCBpcyBub3QgZW1wdHkiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJhcmlhLWxhYmVsIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdCBvciBpcyBlbXB0eSI7cmV0dXJuIGJ9fX0sImFyaWEtbGFiZWxsZWRieSI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJhcmlhLWxhYmVsbGVkYnkgYXR0cmlidXRlIGV4aXN0cyBhbmQgcmVmZXJlbmNlcyBlbGVtZW50cyB0aGF0IGFyZSB2aXNpYmxlIHRvIHNjcmVlbiByZWFkZXJzIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iYXJpYS1sYWJlbGxlZGJ5IGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdCwgcmVmZXJlbmNlcyBlbGVtZW50cyB0aGF0IGRvIG5vdCBleGlzdCBvciByZWZlcmVuY2VzIGVsZW1lbnRzIHRoYXQgYXJlIGVtcHR5IG9yIG5vdCB2aXNpYmxlIjtyZXR1cm4gYn19fSwiYXJpYS1hbGxvd2VkLWF0dHIiOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iQVJJQSBhdHRyaWJ1dGVzIGFyZSB1c2VkIGNvcnJlY3RseSBmb3IgdGhlIGRlZmluZWQgcm9sZSI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IkFSSUEgYXR0cmlidXRlIisoYS5kYXRhJiZhLmRhdGEubGVuZ3RoPjE/InMgYXJlIjoiIGlzIikrIiBub3QgYWxsb3dlZDoiLGM9YS5kYXRhO2lmKGMpZm9yKHZhciBkLGU9LTEsZj1jLmxlbmd0aC0xO2Y+ZTspZD1jW2UrPTFdLGIrPSIgIitkO3JldHVybiBifX19LCJhcmlhLXJlcXVpcmVkLWF0dHIiOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iQWxsIHJlcXVpcmVkIEFSSUEgYXR0cmlidXRlcyBhcmUgcHJlc2VudCI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IlJlcXVpcmVkIEFSSUEgYXR0cmlidXRlIisoYS5kYXRhJiZhLmRhdGEubGVuZ3RoPjE/InMiOiIiKSsiIG5vdCBwcmVzZW50OiIsYz1hLmRhdGE7aWYoYylmb3IodmFyIGQsZT0tMSxmPWMubGVuZ3RoLTE7Zj5lOylkPWNbZSs9MV0sYis9IiAiK2Q7cmV0dXJuIGJ9fX0sImFyaWEtcmVxdWlyZWQtY2hpbGRyZW4iOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iUmVxdWlyZWQgQVJJQSBjaGlsZHJlbiBhcmUgcHJlc2VudCI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IlJlcXVpcmVkIEFSSUEgIisoYS5kYXRhJiZhLmRhdGEubGVuZ3RoPjE/ImNoaWxkcmVuIjoiY2hpbGQiKSsiIHJvbGUgbm90IHByZXNlbnQ6IixjPWEuZGF0YTtpZihjKWZvcih2YXIgZCxlPS0xLGY9Yy5sZW5ndGgtMTtmPmU7KWQ9Y1tlKz0xXSxiKz0iICIrZDtyZXR1cm4gYn19fSwiYXJpYS1yZXF1aXJlZC1wYXJlbnQiOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iUmVxdWlyZWQgQVJJQSBwYXJlbnQgcm9sZSBwcmVzZW50IjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iUmVxdWlyZWQgQVJJQSBwYXJlbnQiKyhhLmRhdGEmJmEuZGF0YS5sZW5ndGg+MT8icyI6IiIpKyIgcm9sZSBub3QgcHJlc2VudDoiLGM9YS5kYXRhO2lmKGMpZm9yKHZhciBkLGU9LTEsZj1jLmxlbmd0aC0xO2Y+ZTspZD1jW2UrPTFdLGIrPSIgIitkO3JldHVybiBifX19LGludmFsaWRyb2xlOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iQVJJQSByb2xlIGlzIHZhbGlkIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iUm9sZSBtdXN0IGJlIG9uZSBvZiB0aGUgdmFsaWQgQVJJQSByb2xlcyI7cmV0dXJuIGJ9fX0sYWJzdHJhY3Ryb2xlOntpbXBhY3Q6InNlcmlvdXMiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJBYnN0cmFjdCByb2xlcyBhcmUgbm90IHVzZWQiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJBYnN0cmFjdCByb2xlcyBjYW5ub3QgYmUgZGlyZWN0bHkgdXNlZCI7cmV0dXJuIGJ9fX0sImFyaWEtdmFsaWQtYXR0ci12YWx1ZSI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJBUklBIGF0dHJpYnV0ZSB2YWx1ZXMgYXJlIHZhbGlkIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iSW52YWxpZCBBUklBIGF0dHJpYnV0ZSB2YWx1ZSIrKGEuZGF0YSYmYS5kYXRhLmxlbmd0aD4xPyJzIjoiIikrIjoiLGM9YS5kYXRhO2lmKGMpZm9yKHZhciBkLGU9LTEsZj1jLmxlbmd0aC0xO2Y+ZTspZD1jW2UrPTFdLGIrPSIgIitkO3JldHVybiBifX19LCJhcmlhLXZhbGlkLWF0dHIiOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iQVJJQSBhdHRyaWJ1dGUgbmFtZSIrKGEuZGF0YSYmYS5kYXRhLmxlbmd0aD4xPyJzIjoiIikrIiBhcmUgdmFsaWQiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJJbnZhbGlkIEFSSUEgYXR0cmlidXRlIG5hbWUiKyhhLmRhdGEmJmEuZGF0YS5sZW5ndGg+MT8icyI6IiIpKyI6IixjPWEuZGF0YTtpZihjKWZvcih2YXIgZCxlPS0xLGY9Yy5sZW5ndGgtMTtmPmU7KWQ9Y1tlKz0xXSxiKz0iICIrZDtyZXR1cm4gYn19fSxjYXB0aW9uOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iVGhlIG11bHRpbWVkaWEgZWxlbWVudCBoYXMgYSBjYXB0aW9ucyB0cmFjayI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IlRoZSBtdWx0aW1lZGlhIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhIGNhcHRpb25zIHRyYWNrIjtyZXR1cm4gYn19fSxleGlzdHM6e2ltcGFjdDoibWlub3IiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGRvZXMgbm90IGV4aXN0IjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCBleGlzdHMiO3JldHVybiBifX19LCJub24tZW1wdHktaWYtcHJlc2VudCI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50ICI7cmV0dXJuIGIrPWEuZGF0YT8iaGFzIGEgbm9uLWVtcHR5IHZhbHVlIGF0dHJpYnV0ZSI6ImRvZXMgbm90IGhhdmUgYSB2YWx1ZSBhdHRyaWJ1dGUifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGhhcyBhIHZhbHVlIGF0dHJpYnV0ZSBhbmQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBlbXB0eSI7cmV0dXJuIGJ9fX0sIm5vbi1lbXB0eS12YWx1ZSI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGhhcyBhIG5vbi1lbXB0eSB2YWx1ZSBhdHRyaWJ1dGUiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGhhcyBubyB2YWx1ZSBhdHRyaWJ1dGUgb3IgdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyBlbXB0eSI7cmV0dXJuIGJ9fX0sImJ1dHRvbi1oYXMtdmlzaWJsZS10ZXh0Ijp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkVsZW1lbnQgaGFzIGlubmVyIHRleHQgdGhhdCBpcyB2aXNpYmxlIHRvIHNjcmVlbiByZWFkZXJzIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCBkb2VzIG5vdCBoYXZlIGlubmVyIHRleHQgdGhhdCBpcyB2aXNpYmxlIHRvIHNjcmVlbiByZWFkZXJzIjtyZXR1cm4gYn19fSwicm9sZS1wcmVzZW50YXRpb24iOntpbXBhY3Q6Im1vZGVyYXRlIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0nRWxlbWVudFwncyBkZWZhdWx0IHNlbWFudGljcyB3ZXJlIG92ZXJyaWRlbiB3aXRoIHJvbGU9InByZXNlbnRhdGlvbiInO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSdFbGVtZW50XCdzIGRlZmF1bHQgc2VtYW50aWNzIHdlcmUgbm90IG92ZXJyaWRkZW4gd2l0aCByb2xlPSJwcmVzZW50YXRpb24iJztyZXR1cm4gYn19fSwicm9sZS1ub25lIjp7aW1wYWN0OiJtb2RlcmF0ZSIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9J0VsZW1lbnRcJ3MgZGVmYXVsdCBzZW1hbnRpY3Mgd2VyZSBvdmVycmlkZW4gd2l0aCByb2xlPSJub25lIic7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9J0VsZW1lbnRcJ3MgZGVmYXVsdCBzZW1hbnRpY3Mgd2VyZSBub3Qgb3ZlcnJpZGRlbiB3aXRoIHJvbGU9Im5vbmUiJztyZXR1cm4gYn19fSwiZHVwbGljYXRlLWltZy1sYWJlbCI6e2ltcGFjdDoibWlub3IiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGRvZXMgbm90IGR1cGxpY2F0ZSBleGlzdGluZyB0ZXh0IGluIDxpbWc+IGFsdCB0ZXh0IjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCBjb250YWlucyA8aW1nPiBlbGVtZW50IHdpdGggYWx0IHRleHQgdGhhdCBkdXBsaWNhdGVzIGV4aXN0aW5nIHRleHQiO3JldHVybiBifX19LCJmb2N1c2FibGUtbm8tbmFtZSI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkVsZW1lbnQgaXMgbm90IGluIHRhYiBvcmRlciBvciBoYXMgYWNjZXNzaWJsZSB0ZXh0IjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCBpcyBpbiB0YWIgb3JkZXIgYW5kIGRvZXMgbm90IGhhdmUgYWNjZXNzaWJsZSB0ZXh0IjtyZXR1cm4gYn19fSwiaW50ZXJuYWwtbGluay1wcmVzZW50Ijp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlZhbGlkIHNraXAgbGluayBmb3VuZCI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9Ik5vIHZhbGlkIHNraXAgbGluayBmb3VuZCI7cmV0dXJuIGJ9fX0sImhlYWRlci1wcmVzZW50Ijp7aW1wYWN0OiJtb2RlcmF0ZSIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlBhZ2UgaGFzIGEgaGVhZGVyIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iUGFnZSBkb2VzIG5vdCBoYXZlIGEgaGVhZGVyIjtyZXR1cm4gYn19fSxsYW5kbWFyazp7aW1wYWN0OiJzZXJpb3VzIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iUGFnZSBoYXMgYSBsYW5kbWFyayByZWdpb24iO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJQYWdlIGRvZXMgbm90IGhhdmUgYSBsYW5kbWFyayByZWdpb24iO3JldHVybiBifX19LCJncm91cC1sYWJlbGxlZGJ5Ijp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9J0FsbCBlbGVtZW50cyB3aXRoIHRoZSBuYW1lICInK2EuZGF0YS5uYW1lKyciIHJlZmVyZW5jZSB0aGUgc2FtZSBlbGVtZW50IHdpdGggYXJpYS1sYWJlbGxlZGJ5JztyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0nQWxsIGVsZW1lbnRzIHdpdGggdGhlIG5hbWUgIicrYS5kYXRhLm5hbWUrJyIgZG8gbm90IHJlZmVyZW5jZSB0aGUgc2FtZSBlbGVtZW50IHdpdGggYXJpYS1sYWJlbGxlZGJ5JztyZXR1cm4gYn19fSxmaWVsZHNldDp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkVsZW1lbnQgaXMgY29udGFpbmVkIGluIGEgZmllbGRzZXQiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSIiLGM9YS5kYXRhJiZhLmRhdGEuZmFpbHVyZUNvZGU7cmV0dXJuIGIrPSJuby1sZWdlbmQiPT09Yz8iRmllbGRzZXQgZG9lcyBub3QgaGF2ZSBhIGxlZ2VuZCBhcyBpdHMgZmlyc3QgY2hpbGQiOiJlbXB0eS1sZWdlbmQiPT09Yz8iTGVnZW5kIGRvZXMgbm90IGhhdmUgdGV4dCB0aGF0IGlzIHZpc2libGUgdG8gc2NyZWVuIHJlYWRlcnMiOiJtaXhlZC1pbnB1dHMiPT09Yz8iRmllbGRzZXQgY29udGFpbnMgdW5yZWxhdGVkIGlucHV0cyI6Im5vLWdyb3VwLWxhYmVsIj09PWM/IkFSSUEgZ3JvdXAgZG9lcyBub3QgaGF2ZSBhcmlhLWxhYmVsIG9yIGFyaWEtbGFiZWxsZWRieSI6Imdyb3VwLW1peGVkLWlucHV0cyI9PT1jPyJBUklBIGdyb3VwIGNvbnRhaW5zIHVucmVsYXRlZCBpbnB1dHMiOiJFbGVtZW50IGRvZXMgbm90IGhhdmUgYSBjb250YWluaW5nIGZpZWxkc2V0IG9yIEFSSUEgZ3JvdXAifX19LCJjb2xvci1jb250cmFzdCI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSIiO3JldHVybiBiKz1hLmRhdGEmJmEuZGF0YS5jb250cmFzdFJhdGlvPyJFbGVtZW50IGhhcyBzdWZmaWNpZW50IGNvbG9yIGNvbnRyYXN0IG9mICIrYS5kYXRhLmNvbnRyYXN0UmF0aW86IlVuYWJsZSB0byBkZXRlcm1pbmUgY29udHJhc3QgcmF0aW8ifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGhhcyBpbnN1ZmZpY2llbnQgY29sb3IgY29udHJhc3Qgb2YgIithLmRhdGEuY29udHJhc3RSYXRpbysiIChmb3JlZ3JvdW5kIGNvbG9yOiAiK2EuZGF0YS5mZ0NvbG9yKyIsIGJhY2tncm91bmQgY29sb3I6ICIrYS5kYXRhLmJnQ29sb3IrIiwgZm9udCBzaXplOiAiK2EuZGF0YS5mb250U2l6ZSsiLCBmb250IHdlaWdodDogIithLmRhdGEuZm9udFdlaWdodCsiKSI7cmV0dXJuIGJ9fX0sImNvbnNpc3RlbnQtY29sdW1ucyI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJUYWJsZSBoYXMgY29uc2lzdGVudCBjb2x1bW4gd2lkdGhzIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iVGFibGUgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgY29sdW1ucyBpbiBldmVyeSByb3ciO3JldHVybiBifX19LCJjZWxsLW5vLWhlYWRlciI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJBbGwgZGF0YSBjZWxscyBoYXZlIHRhYmxlIGhlYWRlcnMiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJTb21lIGRhdGEgY2VsbHMgZG8gbm90IGhhdmUgdGFibGUgaGVhZGVycyI7cmV0dXJuIGJ9fX0sImhlYWRlcnMtdmlzaWJsZS10ZXh0Ijp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkhlYWRlciBjZWxsIGhhcyB2aXNpYmxlIHRleHQiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJIZWFkZXIgY2VsbCBkb2VzIG5vdCBoYXZlIHZpc2libGUgdGV4dCI7cmV0dXJuIGJ9fX0sImhlYWRlcnMtYXR0ci1yZWZlcmVuY2UiOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iaGVhZGVycyBhdHRyaWJ1dGUgcmVmZXJlbmNlcyBlbGVtZW50cyB0aGF0IGFyZSB2aXNpYmxlIHRvIHNjcmVlbiByZWFkZXJzIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iaGVhZGVycyBhdHRyaWJ1dGUgcmVmZXJlbmNlcyBlbGVtZW50IHRoYXQgaXMgbm90IHZpc2libGUgdG8gc2NyZWVuIHJlYWRlcnMiO3JldHVybiBifX19LCJ0aC1zY29wZSI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9Ijx0aD4gZWxlbWVudHMgdXNlIHNjb3BlIGF0dHJpYnV0ZSI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9Ijx0aD4gZWxlbWVudHMgbXVzdCB1c2Ugc2NvcGUgYXR0cmlidXRlIjtyZXR1cm4gYn19fSwibm8tY2FwdGlvbiI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlRhYmxlIGhhcyBhIDxjYXB0aW9uPiI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IlRhYmxlIGRvZXMgbm90IGhhdmUgYSA8Y2FwdGlvbj4iO3JldHVybiBifX19LCJ0aC1oZWFkZXJzLWF0dHIiOntpbXBhY3Q6InNlcmlvdXMiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSI8dGg+IGVsZW1lbnRzIGRvIG5vdCB1c2UgaGVhZGVycyBhdHRyaWJ1dGUiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSI8dGg+IGVsZW1lbnRzIHNob3VsZCBub3QgdXNlIGhlYWRlcnMgYXR0cmlidXRlIjtyZXR1cm4gYn19fSwidGgtc2luZ2xlLXJvdy1jb2x1bW4iOntpbXBhY3Q6InNlcmlvdXMiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSI8dGg+IGVsZW1lbnRzIGFyZSB1c2VkIHdoZW4gdGhlcmUgaXMgb25seSBhIHNpbmdsZSByb3cgYW5kIHNpbmdsZSBjb2x1bW4gb2YgaGVhZGVycyI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9Ijx0aD4gZWxlbWVudHMgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHRoZXJlIGlzIGEgc2luZ2xlIHJvdyBhbmQgc2luZ2xlIGNvbHVtbiBvZiBoZWFkZXJzIjtyZXR1cm4gYn19fSwic2FtZS1jYXB0aW9uLXN1bW1hcnkiOntpbXBhY3Q6Im1vZGVyYXRlIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iQ29udGVudCBvZiBzdW1tYXJ5IGF0dHJpYnV0ZSBhbmQgPGNhcHRpb24+IGFyZSBub3QgZHVwbGljYXRlZCI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IkNvbnRlbnQgb2Ygc3VtbWFyeSBhdHRyaWJ1dGUgYW5kIDxjYXB0aW9uPiBlbGVtZW50IGFyZSBpbmRlbnRpY2FsIjtyZXR1cm4gYn19fSxyb3dzcGFuOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iVGFibGUgZG9lcyBub3QgaGF2ZSBjZWxscyB3aXRoIHJvd3NwYW4gYXR0cmlidXRlIGdyZWF0ZXIgdGhhbiAxIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iVGFibGUgaGFzIGNlbGxzIHdob3NlIHJvd3NwYW4gYXR0cmlidXRlIGlzIG5vdCBlcXVhbCB0byAxIjtyZXR1cm4gYn19fSwic3RydWN0dXJlZC1kbGl0ZW1zIjp7aW1wYWN0OiJzZXJpb3VzIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iV2hlbiBub3QgZW1wdHksIGVsZW1lbnQgaGFzIGJvdGggPGR0PiBhbmQgPGRkPiBlbGVtZW50cyI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IldoZW4gbm90IGVtcHR5LCBlbGVtZW50IGRvZXMgbm90IGhhdmUgYXQgbGVhc3Qgb25lIDxkdD4gZWxlbWVudCBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgPGRkPiBlbGVtZW50IjtyZXR1cm4gYn19fSwib25seS1kbGl0ZW1zIjp7aW1wYWN0OiJzZXJpb3VzIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCBvbmx5IGhhcyBjaGlsZHJlbiB0aGF0IGFyZSA8ZHQ+IG9yIDxkZD4gZWxlbWVudHMiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGhhcyBjaGlsZHJlbiB0aGF0IGFyZSBub3QgPGR0PiBvciA8ZGQ+IGVsZW1lbnRzIjtyZXR1cm4gYn19fSxkbGl0ZW06e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkRlc2NyaXB0aW9uIGxpc3QgaXRlbSBoYXMgYSA8ZGw+IHBhcmVudCBlbGVtZW50IjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRGVzY3JpcHRpb24gbGlzdCBpdGVtIGRvZXMgbm90IGhhdmUgYSA8ZGw+IHBhcmVudCBlbGVtZW50IjtyZXR1cm4gYn19fSwiZG9jLWhhcy10aXRsZSI6e2ltcGFjdDoibW9kZXJhdGUiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJEb2N1bWVudCBoYXMgYSBub24tZW1wdHkgPHRpdGxlPiBlbGVtZW50IjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRG9jdW1lbnQgZG9lcyBub3QgaGF2ZSBhIG5vbi1lbXB0eSA8dGl0bGU+IGVsZW1lbnQiO3JldHVybiBifX19LCJkdXBsaWNhdGUtaWQiOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iRG9jdW1lbnQgaGFzIG5vIGVsZW1lbnRzIHRoYXQgc2hhcmUgdGhlIHNhbWUgaWQgYXR0cmlidXRlIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRG9jdW1lbnQgaGFzIG11bHRpcGxlIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgaWQgYXR0cmlidXRlOiAiK2EuZGF0YTtyZXR1cm4gYn19fSwiaGFzLXZpc2libGUtdGV4dCI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGhhcyB0ZXh0IHRoYXQgaXMgdmlzaWJsZSB0byBzY3JlZW4gcmVhZGVycyI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IkVsZW1lbnQgZG9lcyBub3QgaGF2ZSB0ZXh0IHRoYXQgaXMgdmlzaWJsZSB0byBzY3JlZW4gcmVhZGVycyI7cmV0dXJuIGJ9fX0sIm5vbi1lbXB0eS10aXRsZSI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50IGhhcyBhIHRpdGxlIGF0dHJpYnV0ZSI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IkVsZW1lbnQgaGFzIG5vIHRpdGxlIGF0dHJpYnV0ZSBvciB0aGUgdGl0bGUgYXR0cmlidXRlIGlzIGVtcHR5IjtyZXR1cm4gYn19fSwidW5pcXVlLWZyYW1lLXRpdGxlIjp7aW1wYWN0OiJzZXJpb3VzIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCdzIHRpdGxlIGF0dHJpYnV0ZSBpcyB1bmlxdWUiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJFbGVtZW50J3MgdGl0bGUgYXR0cmlidXRlIGlzIG5vdCB1bmlxdWUiO3JldHVybiBifX19LCJoZWFkaW5nLW9yZGVyIjp7aW1wYWN0OiJtaW5vciIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkhlYWRpbmcgb3JkZXIgdmFsaWQiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJIZWFkaW5nIG9yZGVyIGludmFsaWQiO3JldHVybiBifX19LCJoYXMtbGFuZyI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlRoZSA8aHRtbD4gZWxlbWVudCBoYXMgYSBsYW5nIGF0dHJpYnV0ZSI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IlRoZSA8aHRtbD4gZWxlbWVudCBkb2VzIG5vdCBoYXZlIGEgbGFuZyBhdHRyaWJ1dGUiO3JldHVybiBifX19LCJ2YWxpZC1sYW5nIjp7aW1wYWN0OiJzZXJpb3VzIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iVmFsdWUgb2YgbGFuZyBhdHRyaWJ1dGUgaXMgaW5jbHVkZWQgaW4gdGhlIGxpc3Qgb2YgdmFsaWQgbGFuZ3VhZ2VzIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iVmFsdWUgb2YgbGFuZyBhdHRyaWJ1dGUgbm90IGluY2x1ZGVkIGluIHRoZSBsaXN0IG9mIHZhbGlkIGxhbmd1YWdlcyI7cmV0dXJuIGJ9fX0sImhhcy1hbHQiOntpbXBhY3Q6ImNyaXRpY2FsIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCBoYXMgYW4gYWx0IGF0dHJpYnV0ZSI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IkVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBhbHQgYXR0cmlidXRlIjtyZXR1cm4gYn19fSwidGl0bGUtb25seSI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkZvcm0gZWxlbWVudCBkb2VzIG5vdCBzb2xlbHkgdXNlIHRpdGxlIGF0dHJpYnV0ZSBmb3IgaXRzIGxhYmVsIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iT25seSB0aXRsZSB1c2VkIHRvIGdlbmVyYXRlIGxhYmVsIGZvciBmb3JtIGVsZW1lbnQiO3JldHVybiBifX19LCJpbXBsaWNpdC1sYWJlbCI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJGb3JtIGVsZW1lbnQgaGFzIGFuIGltcGxpY2l0ICh3cmFwcGVkKSA8bGFiZWw+IjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRm9ybSBlbGVtZW50IGRvZXMgbm90IGhhdmUgYW4gaW1wbGljaXQgKHdyYXBwZWQpIDxsYWJlbD4iO3JldHVybiBifX19LCJleHBsaWNpdC1sYWJlbCI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJGb3JtIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IDxsYWJlbD4iO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJGb3JtIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBleHBsaWNpdCA8bGFiZWw+IjtyZXR1cm4gYn19fSwiaGVscC1zYW1lLWFzLWxhYmVsIjp7aW1wYWN0OiJtaW5vciIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkhlbHAgdGV4dCAodGl0bGUgb3IgYXJpYS1kZXNjcmliZWRieSkgZG9lcyBub3QgZHVwbGljYXRlIGxhYmVsIHRleHQiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJIZWxwIHRleHQgKHRpdGxlIG9yIGFyaWEtZGVzY3JpYmVkYnkpIHRleHQgaXMgdGhlIHNhbWUgYXMgdGhlIGxhYmVsIHRleHQiO3JldHVybiBifX19LCJtdWx0aXBsZS1sYWJlbCI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkZvcm0gZWxlbWVudCBkb2VzIG5vdCBoYXZlIG11bHRpcGxlIDxsYWJlbD4gZWxlbWVudHMiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJGb3JtIGVsZW1lbnQgaGFzIG11bHRpcGxlIDxsYWJlbD4gZWxlbWVudHMiO3JldHVybiBifX19LCJoYXMtdGgiOntpbXBhY3Q6InNlcmlvdXMiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJMYXlvdXQgdGFibGUgZG9lcyBub3QgdXNlIDx0aD4gZWxlbWVudHMiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJMYXlvdXQgdGFibGUgdXNlcyA8dGg+IGVsZW1lbnRzIjtyZXR1cm4gYn19fSwiaGFzLWNhcHRpb24iOntpbXBhY3Q6InNlcmlvdXMiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJMYXlvdXQgdGFibGUgZG9lcyBub3QgdXNlIDxjYXB0aW9uPiBlbGVtZW50IjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iTGF5b3V0IHRhYmxlIHVzZXMgPGNhcHRpb24+IGVsZW1lbnQiO3JldHVybiBifX19LCJoYXMtc3VtbWFyeSI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkxheW91dCB0YWJsZSBkb2VzIG5vdCB1c2Ugc3VtbWFyeSBhdHRyaWJ1dGUiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJMYXlvdXQgdGFibGUgdXNlcyBzdW1tYXJ5IGF0dHJpYnV0ZSI7cmV0dXJuIGJ9fX0sIm9ubHktbGlzdGl0ZW1zIjp7aW1wYWN0OiJzZXJpb3VzIixtZXNzYWdlczp7cGFzczpmdW5jdGlvbihhKXt2YXIgYj0iTGlzdCBlbGVtZW50IG9ubHkgaGFzIGNoaWxkcmVuIHRoYXQgYXJlIDxsaT4sIDxzY3JpcHQ+IG9yIDx0ZW1wbGF0ZT4gZWxlbWVudHMiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJMaXN0IGVsZW1lbnQgaGFzIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCA8bGk+LCA8c2NyaXB0PiBvciA8dGVtcGxhdGU+IGVsZW1lbnRzIjtyZXR1cm4gYn19fSxsaXN0aXRlbTp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9Ikxpc3QgaXRlbSBoYXMgYSA8dWw+IG9yIDxvbD4gcGFyZW50IGVsZW1lbnQiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJMaXN0IGl0ZW0gZG9lcyBub3QgaGF2ZSBhIDx1bD4gb3IgPG9sPiBwYXJlbnQgZWxlbWVudCI7cmV0dXJuIGJ9fX0sIm1ldGEtcmVmcmVzaCI6e2ltcGFjdDoiY3JpdGljYWwiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSI8bWV0YT4gdGFnIGRvZXMgbm90IGltbWVkaWF0ZWx5IHJlZnJlc2ggdGhlIHBhZ2UiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSI8bWV0YT4gdGFnIGZvcmNlcyB0aW1lZCByZWZyZXNoIG9mIHBhZ2UiO3JldHVybiBifX19LCJtZXRhLXZpZXdwb3J0Ijp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IjxtZXRhPiB0YWcgZG9lcyBub3QgZGlzYWJsZSB6b29taW5nIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iPG1ldGE+IHRhZyBkaXNhYmxlcyB6b29taW5nIjtyZXR1cm4gYn19fSxyZWdpb246e2ltcGFjdDoibW9kZXJhdGUiLG1lc3NhZ2VzOntwYXNzOmZ1bmN0aW9uKGEpe3ZhciBiPSJDb250ZW50IGNvbnRhaW5lZCBieSBBUklBIGxhbmRtYXJrIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iQ29udGVudCBub3QgY29udGFpbmVkIGJ5IGFuIEFSSUEgbGFuZG1hcmsiO3JldHVybiBifX19LCJodG1sNS1zY29wZSI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlNjb3BlIGF0dHJpYnV0ZSBpcyBvbmx5IHVzZWQgb24gdGFibGUgaGVhZGVyIGVsZW1lbnRzICg8dGg+KSI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IkluIEhUTUwgNSwgc2NvcGUgYXR0cmlidXRlcyBtYXkgb25seSBiZSB1c2VkIG9uIHRhYmxlIGhlYWRlciBlbGVtZW50cyAoPHRoPikiO3JldHVybiBifX19LCJodG1sNC1zY29wZSI6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlNjb3BlIGF0dHJpYnV0ZSBpcyBvbmx5IHVzZWQgb24gdGFibGUgY2VsbCBlbGVtZW50cyAoPHRoPiBhbmQgPHRkPikiO3JldHVybiBifSxmYWlsOmZ1bmN0aW9uKGEpe3ZhciBiPSJJbiBIVE1MIDQsIHRoZSBzY29wZSBhdHRyaWJ1dGUgbWF5IG9ubHkgYmUgdXNlZCBvbiB0YWJsZSBjZWxsIGVsZW1lbnRzICg8dGg+IGFuZCA8dGQ+KSI7cmV0dXJuIGJ9fX0sInNjb3BlLXZhbHVlIjp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlNjb3BlIGF0dHJpYnV0ZSBpcyB1c2VkIGNvcnJlY3RseSI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9IlRoZSB2YWx1ZSBvZiB0aGUgc2NvcGUgYXR0cmlidXRlIG1heSBvbmx5IGJlICdyb3cnIG9yICdjb2wnIjtyZXR1cm4gYn19fSwic2tpcC1saW5rIjp7aW1wYWN0OiJjcml0aWNhbCIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlZhbGlkIHNraXAgbGluayBmb3VuZCI7cmV0dXJuIGJ9LGZhaWw6ZnVuY3Rpb24oYSl7dmFyIGI9Ik5vIHZhbGlkIHNraXAgbGluayBmb3VuZCI7cmV0dXJuIGJ9fX0sdGFiaW5kZXg6e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IkVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhIHRhYmluZGV4IGdyZWF0ZXIgdGhhbiAwIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iRWxlbWVudCBoYXMgYSB0YWJpbmRleCBncmVhdGVyIHRoYW4gMCI7cmV0dXJuIGJ9fX0sZGVzY3JpcHRpb246e2ltcGFjdDoic2VyaW91cyIsbWVzc2FnZXM6e3Bhc3M6ZnVuY3Rpb24oYSl7dmFyIGI9IlRoZSBtdWx0aW1lZGlhIGVsZW1lbnQgaGFzIGFuIGF1ZGlvIGRlc2NyaXB0aW9uIHRyYWNrIjtyZXR1cm4gYn0sZmFpbDpmdW5jdGlvbihhKXt2YXIgYj0iVGhlIG11bHRpbWVkaWEgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFuIGF1ZGlvIGRlc2NyaXB0aW9uIHRyYWNrIjtyZXR1cm4gYn19fX0sZmFpbHVyZVN1bW1hcmllczp7YW55OntmYWlsdXJlTWVzc2FnZTpmdW5jdGlvbihhKXt2YXIgYj0iRml4IGFueSBvZiB0aGUgZm9sbG93aW5nOiIsYz1hO2lmKGMpZm9yKHZhciBkLGU9LTEsZj1jLmxlbmd0aC0xO2Y+ZTspZD1jW2UrPTFdLGIrPSJcbiAgIitkLnNwbGl0KCJcbiIpLmpvaW4oIlxuICAiKTtyZXR1cm4gYn19LG5vbmU6e2ZhaWx1cmVNZXNzYWdlOmZ1bmN0aW9uKGEpe3ZhciBiPSJGaXggYWxsIG9mIHRoZSBmb2xsb3dpbmc6IixjPWE7aWYoYylmb3IodmFyIGQsZT0tMSxmPWMubGVuZ3RoLTE7Zj5lOylkPWNbZSs9MV0sYis9IlxuICAiK2Quc3BsaXQoIlxuIikuam9pbigiXG4gICIpO3JldHVybiBifX19fSxydWxlczpbe2lkOiJhY2Nlc3NrZXlzIixzZWxlY3RvcjoiW2FjY2Vzc2tleV0iLHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnMjExIl0sYWxsOltdLGFueTpbXSxub25lOlsiYWNjZXNza2V5cyJdfSx7aWQ6ImFyZWEtYWx0IixzZWxlY3RvcjoibWFwIGFyZWFbaHJlZl0iLGV4Y2x1ZGVIaWRkZW46ITEsdGFnczpbIndjYWcyYSIsIndjYWcxMTEiLCJzZWN0aW9uNTA4Iiwic2VjdGlvbjUwOGEiXSxhbGw6W10sYW55Olsibm9uLWVtcHR5LWFsdCIsImFyaWEtbGFiZWwiLCJhcmlhLWxhYmVsbGVkYnkiXSxub25lOltdfSx7aWQ6ImFyaWEtYWxsb3dlZC1hdHRyIix0YWdzOlsid2NhZzJhIiwid2NhZzQxMSJdLGFsbDpbXSxhbnk6WyJhcmlhLWFsbG93ZWQtYXR0ciJdLG5vbmU6W119LHtpZDoiYXJpYS1yZXF1aXJlZC1hdHRyIixzZWxlY3RvcjoiW3JvbGVdIix0YWdzOlsid2NhZzJhIiwid2NhZzQxMSJdLGFsbDpbXSxhbnk6WyJhcmlhLXJlcXVpcmVkLWF0dHIiXSxub25lOltdfSx7aWQ6ImFyaWEtcmVxdWlyZWQtY2hpbGRyZW4iLHNlbGVjdG9yOiJbcm9sZV0iLHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnNDExIl0sYWxsOltdLGFueTpbImFyaWEtcmVxdWlyZWQtY2hpbGRyZW4iXSxub25lOltdfSx7aWQ6ImFyaWEtcmVxdWlyZWQtcGFyZW50IixzZWxlY3RvcjoiW3JvbGVdIix0YWdzOlsid2NhZzJhIiwid2NhZzQxMSJdLGFsbDpbXSxhbnk6WyJhcmlhLXJlcXVpcmVkLXBhcmVudCJdLG5vbmU6W119LHtpZDoiYXJpYS1yb2xlcyIsc2VsZWN0b3I6Iltyb2xlXSIsdGFnczpbIndjYWcyYSIsIndjYWc0MTEiXSxhbGw6W10sYW55OltdLG5vbmU6WyJpbnZhbGlkcm9sZSIsImFic3RyYWN0cm9sZSJdfSx7aWQ6ImFyaWEtdmFsaWQtYXR0ci12YWx1ZSIsdGFnczpbIndjYWcyYSIsIndjYWc0MTEiXSxhbGw6W10sYW55Olt7b3B0aW9uczpbXSxpZDoiYXJpYS12YWxpZC1hdHRyLXZhbHVlIn1dLG5vbmU6W119LHtpZDoiYXJpYS12YWxpZC1hdHRyIix0YWdzOlsid2NhZzJhIiwid2NhZzQxMSJdLGFsbDpbXSxhbnk6W3tvcHRpb25zOltdLGlkOiJhcmlhLXZhbGlkLWF0dHIifV0sbm9uZTpbXX0se2lkOiJhdWRpby1jYXB0aW9uIixzZWxlY3RvcjoiYXVkaW8iLGV4Y2x1ZGVIaWRkZW46ITEsdGFnczpbIndjYWcyYSIsIndjYWcxMjIiLCJzZWN0aW9uNTA4Iiwic2VjdGlvbjUwOGEiXSxhbGw6W10sYW55OltdLG5vbmU6WyJjYXB0aW9uIl19LHtpZDoiYmxpbmsiLHNlbGVjdG9yOiJibGluayIsdGFnczpbIndjYWcyYSIsIndjYWcyMjIiXSxhbGw6W10sYW55OltdLG5vbmU6WyJleGlzdHMiXX0se2lkOiJidXR0b24tbmFtZSIsc2VsZWN0b3I6J2J1dHRvbiwgW3JvbGU9ImJ1dHRvbiJdLCBpbnB1dFt0eXBlPSJidXR0b24iXSwgaW5wdXRbdHlwZT0ic3VibWl0Il0sIGlucHV0W3R5cGU9InJlc2V0Il0nLHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnNDEyIiwic2VjdGlvbjUwOCIsInNlY3Rpb241MDhhIl0sYWxsOltdLGFueTpbIm5vbi1lbXB0eS1pZi1wcmVzZW50Iiwibm9uLWVtcHR5LXZhbHVlIiwiYnV0dG9uLWhhcy12aXNpYmxlLXRleHQiLCJhcmlhLWxhYmVsIiwiYXJpYS1sYWJlbGxlZGJ5Iiwicm9sZS1wcmVzZW50YXRpb24iLCJyb2xlLW5vbmUiXSxub25lOlsiZHVwbGljYXRlLWltZy1sYWJlbCIsImZvY3VzYWJsZS1uby1uYW1lIl19LHtpZDoiYnlwYXNzIixzZWxlY3RvcjoiaHRtbCIscGFnZUxldmVsOiEwLG1hdGNoZXM6ZnVuY3Rpb24oYSl7cmV0dXJuISFhLnF1ZXJ5U2VsZWN0b3IoImFbaHJlZl0iKX0sdGFnczpbIndjYWcyYSIsIndjYWcyNDEiLCJzZWN0aW9uNTA4Iiwic2VjdGlvbjUwOG8iXSxhbGw6W10sYW55OlsiaW50ZXJuYWwtbGluay1wcmVzZW50IiwiaGVhZGVyLXByZXNlbnQiLCJsYW5kbWFyayJdLG5vbmU6W119LHtpZDoiY2hlY2tib3hncm91cCIsc2VsZWN0b3I6ImlucHV0W3R5cGU9Y2hlY2tib3hdW25hbWVdIix0YWdzOlsid2NhZzJhIiwid2NhZzEzMSJdLGFsbDpbXSxhbnk6WyJncm91cC1sYWJlbGxlZGJ5IiwiZmllbGRzZXQiXSxub25lOltdfSx7aWQ6ImNvbG9yLWNvbnRyYXN0IixzZWxlY3RvcjoiKiIsdGFnczpbIndjYWcyYWEiLCJ3Y2FnMTQzIl0sYWxsOltdLGFueTpbImNvbG9yLWNvbnRyYXN0Il0sbm9uZTpbXX0se2lkOiJkYXRhLXRhYmxlIixzZWxlY3RvcjoidGFibGUiLG1hdGNoZXM6ZnVuY3Rpb24oYSl7cmV0dXJuIFIudGFibGUuaXNEYXRhVGFibGUoYSl9LHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnMTMxIl0sYWxsOltdLGFueTpbImNvbnNpc3RlbnQtY29sdW1ucyJdLG5vbmU6WyJjZWxsLW5vLWhlYWRlciIsImhlYWRlcnMtdmlzaWJsZS10ZXh0IiwiaGVhZGVycy1hdHRyLXJlZmVyZW5jZSIsInRoLXNjb3BlIiwibm8tY2FwdGlvbiIsInRoLWhlYWRlcnMtYXR0ciIsInRoLXNpbmdsZS1yb3ctY29sdW1uIiwic2FtZS1jYXB0aW9uLXN1bW1hcnkiLCJyb3dzcGFuIl19LHtpZDoiZGVmaW5pdGlvbi1saXN0IixzZWxlY3RvcjoiZGwiLHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnMTMxIl0sYWxsOltdLGFueTpbXSxub25lOlsic3RydWN0dXJlZC1kbGl0ZW1zIiwib25seS1kbGl0ZW1zIl19LHtpZDoiZGxpdGVtIixzZWxlY3RvcjoiZGQsIGR0Iix0YWdzOlsid2NhZzJhIiwid2NhZzEzMSJdLGFsbDpbXSxhbnk6WyJkbGl0ZW0iXSxub25lOltdfSx7aWQ6ImRvY3VtZW50LXRpdGxlIixzZWxlY3RvcjoiaHRtbCIsdGFnczpbIndjYWcyYSIsIndjYWcyNDIiXSxhbGw6W10sYW55OlsiZG9jLWhhcy10aXRsZSJdLG5vbmU6W119LHtpZDoiZHVwbGljYXRlLWlkIixzZWxlY3RvcjoiW2lkXSIsdGFnczpbIndjYWcyYSIsIndjYWc0MTEiXSxhbGw6W10sYW55OlsiZHVwbGljYXRlLWlkIl0sbm9uZTpbXX0se2lkOiJlbXB0eS1oZWFkaW5nIixzZWxlY3RvcjonaDEsIGgyLCBoMywgaDQsIGg1LCBoNiwgW3JvbGU9ImhlYWRpbmciXScsdGFnczpbIndjYWcyYSIsIndjYWcxMzEiXSxhbGw6W10sYW55OlsiaGFzLXZpc2libGUtdGV4dCIsInJvbGUtcHJlc2VudGF0aW9uIiwicm9sZS1ub25lIl0sbm9uZTpbXX0se2lkOiJmcmFtZS10aXRsZSIsc2VsZWN0b3I6ImZyYW1lLCBpZnJhbWUiLHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnMjQxIl0sYWxsOltdLGFueTpbIm5vbi1lbXB0eS10aXRsZSJdLG5vbmU6WyJ1bmlxdWUtZnJhbWUtdGl0bGUiXX0se2lkOiJoZWFkaW5nLW9yZGVyIixzZWxlY3RvcjoiaDEsaDIsaDMsaDQsaDUsaDYsW3JvbGU9aGVhZGluZ10iLGVuYWJsZWQ6ITEsdGFnczpbImJlc3QtcHJhY3RpY2UiXSxhbGw6W10sYW55OlsiaGVhZGluZy1vcmRlciJdLG5vbmU6W119LHtpZDoiaHRtbC1sYW5nIixzZWxlY3RvcjoiaHRtbCIsdGFnczpbIndjYWcyYSIsIndjYWczMTEiXSxhbGw6W10sYW55OlsiaGFzLWxhbmciXSxub25lOlt7b3B0aW9uczpbImFhIiwiYWIiLCJhZSIsImFmIiwiYWsiLCJhbSIsImFuIiwiYXIiLCJhcyIsImF2IiwiYXkiLCJheiIsImJhIiwiYmUiLCJiZyIsImJoIiwiYmkiLCJibSIsImJuIiwiYm8iLCJiciIsImJzIiwiY2EiLCJjZSIsImNoIiwiY28iLCJjciIsImNzIiwiY3UiLCJjdiIsImN5IiwiZGEiLCJkZSIsImR2IiwiZHoiLCJlZSIsImVsIiwiZW4iLCJlbyIsImVzIiwiZXQiLCJldSIsImZhIiwiZmYiLCJmaSIsImZqIiwiZm8iLCJmciIsImZ5IiwiZ2EiLCJnZCIsImdsIiwiZ24iLCJndSIsImd2IiwiaGEiLCJoZSIsImhpIiwiaG8iLCJociIsImh0IiwiaHUiLCJoeSIsImh6IiwiaWEiLCJpZCIsImllIiwiaWciLCJpaSIsImlrIiwiaW4iLCJpbyIsImlzIiwiaXQiLCJpdSIsIml3IiwiamEiLCJqaSIsImp2IiwianciLCJrYSIsImtnIiwia2kiLCJraiIsImtrIiwia2wiLCJrbSIsImtuIiwia28iLCJrciIsImtzIiwia3UiLCJrdiIsImt3Iiwia3kiLCJsYSIsImxiIiwibGciLCJsaSIsImxuIiwibG8iLCJsdCIsImx1IiwibHYiLCJtZyIsIm1oIiwibWkiLCJtayIsIm1sIiwibW4iLCJtbyIsIm1yIiwibXMiLCJtdCIsIm15IiwibmEiLCJuYiIsIm5kIiwibmUiLCJuZyIsIm5sIiwibm4iLCJubyIsIm5yIiwibnYiLCJueSIsIm9jIiwib2oiLCJvbSIsIm9yIiwib3MiLCJwYSIsInBpIiwicGwiLCJwcyIsInB0IiwicXUiLCJybSIsInJuIiwicm8iLCJydSIsInJ3Iiwic2EiLCJzYyIsInNkIiwic2UiLCJzZyIsInNoIiwic2kiLCJzayIsInNsIiwic20iLCJzbiIsInNvIiwic3EiLCJzciIsInNzIiwic3QiLCJzdSIsInN2Iiwic3ciLCJ0YSIsInRlIiwidGciLCJ0aCIsInRpIiwidGsiLCJ0bCIsInRuIiwidG8iLCJ0ciIsInRzIiwidHQiLCJ0dyIsInR5IiwidWciLCJ1ayIsInVyIiwidXoiLCJ2ZSIsInZpIiwidm8iLCJ3YSIsIndvIiwieGgiLCJ5aSIsInlvIiwiemEiLCJ6aCIsInp1Il0saWQ6InZhbGlkLWxhbmcifV19LHtpZDoiaW1hZ2UtYWx0IixzZWxlY3RvcjoiaW1nIix0YWdzOlsid2NhZzJhIiwid2NhZzExMSIsInNlY3Rpb241MDgiLCJzZWN0aW9uNTA4YSJdLGFsbDpbXSxhbnk6WyJoYXMtYWx0IiwiYXJpYS1sYWJlbCIsImFyaWEtbGFiZWxsZWRieSIsIm5vbi1lbXB0eS10aXRsZSIsInJvbGUtcHJlc2VudGF0aW9uIiwicm9sZS1ub25lIl0sbm9uZTpbXX0se2lkOiJpbnB1dC1pbWFnZS1hbHQiLHNlbGVjdG9yOidpbnB1dFt0eXBlPSJpbWFnZSJdJyx0YWdzOlsid2NhZzJhIiwid2NhZzExMSIsInNlY3Rpb241MDgiLCJzZWN0aW9uNTA4YSJdLGFsbDpbXSxhbnk6WyJub24tZW1wdHktYWx0IiwiYXJpYS1sYWJlbCIsImFyaWEtbGFiZWxsZWRieSJdLG5vbmU6W119LHtpZDoibGFiZWwtdGl0bGUtb25seSIsc2VsZWN0b3I6ImlucHV0Om5vdChbdHlwZT0naGlkZGVuJ10pOm5vdChbdHlwZT0naW1hZ2UnXSk6bm90KFt0eXBlPSdidXR0b24nXSk6bm90KFt0eXBlPSdzdWJtaXQnXSk6bm90KFt0eXBlPSdyZXNldCddKSwgc2VsZWN0LCB0ZXh0YXJlYSIsZW5hYmxlZDohMSx0YWdzOlsiYmVzdC1wcmFjdGljZSJdLGFsbDpbXSxhbnk6W10sbm9uZTpbInRpdGxlLW9ubHkiXX0se2lkOiJsYWJlbCIsc2VsZWN0b3I6ImlucHV0Om5vdChbdHlwZT0naGlkZGVuJ10pOm5vdChbdHlwZT0naW1hZ2UnXSk6bm90KFt0eXBlPSdidXR0b24nXSk6bm90KFt0eXBlPSdzdWJtaXQnXSk6bm90KFt0eXBlPSdyZXNldCddKSwgc2VsZWN0LCB0ZXh0YXJlYSIsdGFnczpbIndjYWcyYSIsIndjYWczMzIiLCJ3Y2FnMTMxIiwic2VjdGlvbjUwOCIsInNlY3Rpb241MDhuIl0sYWxsOltdLGFueTpbImFyaWEtbGFiZWwiLCJhcmlhLWxhYmVsbGVkYnkiLCJpbXBsaWNpdC1sYWJlbCIsImV4cGxpY2l0LWxhYmVsIiwibm9uLWVtcHR5LXRpdGxlIl0sbm9uZTpbImhlbHAtc2FtZS1hcy1sYWJlbCIsIm11bHRpcGxlLWxhYmVsIl19LHtpZDoibGF5b3V0LXRhYmxlIixzZWxlY3RvcjoidGFibGUiLG1hdGNoZXM6ZnVuY3Rpb24oYSl7cmV0dXJuIVIudGFibGUuaXNEYXRhVGFibGUoYSl9LHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnMTMxIl0sYWxsOltdLGFueTpbXSxub25lOlsiaGFzLXRoIiwiaGFzLWNhcHRpb24iLCJoYXMtc3VtbWFyeSJdfSx7aWQ6ImxpbmstbmFtZSIsc2VsZWN0b3I6J2FbaHJlZl06bm90KFtyb2xlPSJidXR0b24iXSksIFtyb2xlPWxpbmtdW2hyZWZdJyx0YWdzOlsid2NhZzJhIiwid2NhZzExMSIsIndjYWc0MTIiLCJzZWN0aW9uNTA4Iiwic2VjdGlvbjUwOGEiXSxhbGw6W10sYW55OlsiaGFzLXZpc2libGUtdGV4dCIsImFyaWEtbGFiZWwiLCJhcmlhLWxhYmVsbGVkYnkiLCJyb2xlLXByZXNlbnRhdGlvbiIsInJvbGUtbm9uZSJdLG5vbmU6WyJkdXBsaWNhdGUtaW1nLWxhYmVsIiwiZm9jdXNhYmxlLW5vLW5hbWUiXX0se2lkOiJsaXN0IixzZWxlY3RvcjoidWwsIG9sIix0YWdzOlsid2NhZzJhIiwid2NhZzEzMSJdLGFsbDpbXSxhbnk6W10sbm9uZTpbIm9ubHktbGlzdGl0ZW1zIl19LHtpZDoibGlzdGl0ZW0iLHNlbGVjdG9yOiJsaSIsdGFnczpbIndjYWcyYSIsIndjYWcxMzEiXSxhbGw6W10sYW55OlsibGlzdGl0ZW0iXSxub25lOltdfSx7aWQ6Im1hcnF1ZWUiLHNlbGVjdG9yOiJtYXJxdWVlIix0YWdzOlsid2NhZzJhIiwid2NhZzIyMiIsInNlY3Rpb241MDgiLCJzZWN0aW9uNTA4aiJdLGFsbDpbXSxhbnk6W10sbm9uZTpbImV4aXN0cyJdfSx7aWQ6Im1ldGEtcmVmcmVzaCIsc2VsZWN0b3I6J21ldGFbaHR0cC1lcXVpdj0icmVmcmVzaCJdJyxleGNsdWRlSGlkZGVuOiExLHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnMmFhYSIsIndjYWcyMjEiLCJ3Y2FnMjI0Iiwid2NhZzMyNSJdLGFsbDpbXSxhbnk6WyJtZXRhLXJlZnJlc2giXSxub25lOltdfSx7aWQ6Im1ldGEtdmlld3BvcnQiLHNlbGVjdG9yOidtZXRhW25hbWU9InZpZXdwb3J0Il0nLGV4Y2x1ZGVIaWRkZW46ITEsdGFnczpbIndjYWcyYWEiLCJ3Y2FnMTQ0Il0sYWxsOltdLGFueTpbIm1ldGEtdmlld3BvcnQiXSxub25lOltdfSx7aWQ6Im9iamVjdC1hbHQiLHNlbGVjdG9yOiJvYmplY3QiLHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnMTExIl0sYWxsOltdLGFueTpbImhhcy12aXNpYmxlLXRleHQiXSxub25lOltdfSx7aWQ6InJhZGlvZ3JvdXAiLHNlbGVjdG9yOiJpbnB1dFt0eXBlPXJhZGlvXVtuYW1lXSIsdGFnczpbIndjYWcyYSIsIndjYWcxMzEiXSxhbGw6W10sYW55OlsiZ3JvdXAtbGFiZWxsZWRieSIsImZpZWxkc2V0Il0sbm9uZTpbXX0se2lkOiJyZWdpb24iLHNlbGVjdG9yOiJodG1sIixwYWdlTGV2ZWw6ITAsZW5hYmxlZDohMSx0YWdzOlsiYmVzdC1wcmFjdGljZSJdLGFsbDpbXSxhbnk6WyJyZWdpb24iXSxub25lOltdfSx7aWQ6InNjb3BlIixzZWxlY3RvcjoiW3Njb3BlXSIsZW5hYmxlZDohMSx0YWdzOlsiYmVzdC1wcmFjdGljZSJdLGFsbDpbXSxhbnk6WyJodG1sNS1zY29wZSIsImh0bWw0LXNjb3BlIl0sbm9uZTpbInNjb3BlLXZhbHVlIl19LHtpZDoic2VydmVyLXNpZGUtaW1hZ2UtbWFwIixzZWxlY3RvcjoiaW1nW2lzbWFwXSIsdGFnczpbIndjYWcyYSIsIndjYWcyMTEiLCJzZWN0aW9uNTA4Iiwic2VjdGlvbjUwOGYiXSxhbGw6W10sYW55OltdLG5vbmU6WyJleGlzdHMiXX0se2lkOiJza2lwLWxpbmsiLHNlbGVjdG9yOiJhW2hyZWZdIixwYWdlTGV2ZWw6ITAsZW5hYmxlZDohMSx0YWdzOlsiYmVzdC1wcmFjdGljZSJdLGFsbDpbXSxhbnk6WyJza2lwLWxpbmsiXSxub25lOltdfSx7aWQ6InRhYmluZGV4IixzZWxlY3RvcjoiW3RhYmluZGV4XSIsdGFnczpbImJlc3QtcHJhY3RpY2UiXSxhbGw6W10sYW55OlsidGFiaW5kZXgiXSxub25lOltdfSx7aWQ6InZhbGlkLWxhbmciLHNlbGVjdG9yOiJbbGFuZ106bm90KGh0bWwpLCBbeG1sXFw6bGFuZ106bm90KGh0bWwpIix0YWdzOlsid2NhZzJhYSIsIndjYWczMTIiXSxhbGw6W10sYW55OltdLG5vbmU6W3tvcHRpb25zOlsiYWEiLCJhYiIsImFlIiwiYWYiLCJhayIsImFtIiwiYW4iLCJhciIsImFzIiwiYXYiLCJheSIsImF6IiwiYmEiLCJiZSIsImJnIiwiYmgiLCJiaSIsImJtIiwiYm4iLCJibyIsImJyIiwiYnMiLCJjYSIsImNlIiwiY2giLCJjbyIsImNyIiwiY3MiLCJjdSIsImN2IiwiY3kiLCJkYSIsImRlIiwiZHYiLCJkeiIsImVlIiwiZWwiLCJlbiIsImVvIiwiZXMiLCJldCIsImV1IiwiZmEiLCJmZiIsImZpIiwiZmoiLCJmbyIsImZyIiwiZnkiLCJnYSIsImdkIiwiZ2wiLCJnbiIsImd1IiwiZ3YiLCJoYSIsImhlIiwiaGkiLCJobyIsImhyIiwiaHQiLCJodSIsImh5IiwiaHoiLCJpYSIsImlkIiwiaWUiLCJpZyIsImlpIiwiaWsiLCJpbiIsImlvIiwiaXMiLCJpdCIsIml1IiwiaXciLCJqYSIsImppIiwianYiLCJqdyIsImthIiwia2ciLCJraSIsImtqIiwia2siLCJrbCIsImttIiwia24iLCJrbyIsImtyIiwia3MiLCJrdSIsImt2Iiwia3ciLCJreSIsImxhIiwibGIiLCJsZyIsImxpIiwibG4iLCJsbyIsImx0IiwibHUiLCJsdiIsIm1nIiwibWgiLCJtaSIsIm1rIiwibWwiLCJtbiIsIm1vIiwibXIiLCJtcyIsIm10IiwibXkiLCJuYSIsIm5iIiwibmQiLCJuZSIsIm5nIiwibmwiLCJubiIsIm5vIiwibnIiLCJudiIsIm55Iiwib2MiLCJvaiIsIm9tIiwib3IiLCJvcyIsInBhIiwicGkiLCJwbCIsInBzIiwicHQiLCJxdSIsInJtIiwicm4iLCJybyIsInJ1IiwicnciLCJzYSIsInNjIiwic2QiLCJzZSIsInNnIiwic2giLCJzaSIsInNrIiwic2wiLCJzbSIsInNuIiwic28iLCJzcSIsInNyIiwic3MiLCJzdCIsInN1Iiwic3YiLCJzdyIsInRhIiwidGUiLCJ0ZyIsInRoIiwidGkiLCJ0ayIsInRsIiwidG4iLCJ0byIsInRyIiwidHMiLCJ0dCIsInR3IiwidHkiLCJ1ZyIsInVrIiwidXIiLCJ1eiIsInZlIiwidmkiLCJ2byIsIndhIiwid28iLCJ4aCIsInlpIiwieW8iLCJ6YSIsInpoIiwienUiXSxpZDoidmFsaWQtbGFuZyJ9XX0se2lkOiJ2aWRlby1jYXB0aW9uIixzZWxlY3RvcjoidmlkZW8iLHRhZ3M6WyJ3Y2FnMmEiLCJ3Y2FnMTIyIiwid2NhZzEyMyIsInNlY3Rpb241MDgiLCJzZWN0aW9uNTA4YSJdLGFsbDpbXSxhbnk6W10sbm9uZTpbImNhcHRpb24iXX0se2lkOiJ2aWRlby1kZXNjcmlwdGlvbiIsc2VsZWN0b3I6InZpZGVvIix0YWdzOlsid2NhZzJhYSIsIndjYWcxMjUiLCJzZWN0aW9uNTA4Iiwic2VjdGlvbjUwOGEiXSxhbGw6W10sYW55OltdLG5vbmU6WyJkZXNjcmlwdGlvbiJdfV0sY2hlY2tzOlt7aWQ6ImFic3RyYWN0cm9sZSIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4iYWJzdHJhY3QiPT09Ui5hcmlhLmdldFJvbGVUeXBlKGEuZ2V0QXR0cmlidXRlKCJyb2xlIikpfX0se2lkOiJhcmlhLWFsbG93ZWQtYXR0ciIsbWF0Y2hlczpmdW5jdGlvbihhKXt2YXIgYj1hLmdldEF0dHJpYnV0ZSgicm9sZSIpO2J8fChiPVIuYXJpYS5pbXBsaWNpdFJvbGUoYSkpO3ZhciBjPVIuYXJpYS5hbGxvd2VkQXR0cihiKTtpZihiJiZjKXt2YXIgZD0vXmFyaWEtLztpZihhLmhhc0F0dHJpYnV0ZXMoKSlmb3IodmFyIGU9YS5hdHRyaWJ1dGVzLGY9MCxnPWUubGVuZ3RoO2c+ZjtmKyspaWYoZC50ZXN0KGVbZl0ubm9kZU5hbWUpKXJldHVybiEwfXJldHVybiExfSxldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPVtdLGc9YS5nZXRBdHRyaWJ1dGUoInJvbGUiKSxoPWEuYXR0cmlidXRlcztpZihnfHwoZz1SLmFyaWEuaW1wbGljaXRSb2xlKGEpKSxlPVIuYXJpYS5hbGxvd2VkQXR0cihnKSxnJiZlKWZvcih2YXIgaT0wLGo9aC5sZW5ndGg7aj5pO2krKyljPWhbaV0sZD1jLm5vZGVOYW1lLFIuYXJpYS52YWxpZGF0ZUF0dHIoZCkmJi0xPT09ZS5pbmRleE9mKGQpJiZmLnB1c2goZCsnPSInK2Mubm9kZVZhbHVlKyciJyk7cmV0dXJuIGYubGVuZ3RoPyh0aGlzLmRhdGEoZiksITEpOiEwfX0se2lkOiJpbnZhbGlkcm9sZSIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4hUi5hcmlhLmlzVmFsaWRSb2xlKGEuZ2V0QXR0cmlidXRlKCJyb2xlIikpfX0se2lkOiJhcmlhLXJlcXVpcmVkLWF0dHIiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9W107aWYoYS5oYXNBdHRyaWJ1dGVzKCkpe3ZhciBkLGU9YS5nZXRBdHRyaWJ1dGUoInJvbGUiKSxmPVIuYXJpYS5yZXF1aXJlZEF0dHIoZSk7aWYoZSYmZilmb3IodmFyIGc9MCxoPWYubGVuZ3RoO2g+ZztnKyspZD1mW2ddLGEuZ2V0QXR0cmlidXRlKGQpfHxjLnB1c2goZCl9cmV0dXJuIGMubGVuZ3RoPyh0aGlzLmRhdGEoYyksITEpOiEwfX0se2lkOiJhcmlhLXJlcXVpcmVkLWNoaWxkcmVuIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGMpe2lmKG51bGw9PT1hKXJldHVybiExO3ZhciBkPWcoYiksZT1bJ1tyb2xlPSInK2IrJyJdJ107cmV0dXJuIGQmJihlPWUuY29uY2F0KGQpKSxlPWUuam9pbigiLCIpLGM/aChhLGUpfHwhIWEucXVlcnlTZWxlY3RvcihlKTohIWEucXVlcnlTZWxlY3RvcihlKX1mdW5jdGlvbiBkKGEsYil7dmFyIGQsZTtmb3IoZD0wLGU9YS5sZW5ndGg7ZT5kO2QrKylpZihudWxsIT09YVtkXSYmYyhhW2RdLGIsITApKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIGUoYSxiLGUpe3ZhciBmLGc9Yi5sZW5ndGgsaD1bXSxqPWkoYSwiYXJpYS1vd25zIik7Zm9yKGY9MDtnPmY7ZisrKXt2YXIgaz1iW2ZdO2lmKGMoYSxrKXx8ZChqLGspKXtpZighZSlyZXR1cm4gbnVsbH1lbHNlIGUmJmgucHVzaChrKX1yZXR1cm4gaC5sZW5ndGg/aDohZSYmYi5sZW5ndGg/YjpudWxsfXZhciBmPVIuYXJpYS5yZXF1aXJlZE93bmVkLGc9Ui5hcmlhLmltcGxpY2l0Tm9kZXMsaD1SLnV0aWxzLm1hdGNoZXNTZWxlY3RvcixpPVIuZG9tLmlkcmVmcyxqPWEuZ2V0QXR0cmlidXRlKCJyb2xlIiksaz1mKGopO2lmKCFrKXJldHVybiEwO3ZhciBsPSExLG09ay5vbmU7aWYoIW0pe3ZhciBsPSEwO209ay5hbGx9dmFyIG49ZShhLG0sbCk7cmV0dXJuIG4/KHRoaXMuZGF0YShuKSwhMSk6ITB9fSx7aWQ6ImFyaWEtcmVxdWlyZWQtcGFyZW50IixldmFsdWF0ZTpmdW5jdGlvbihhLGMpe2Z1bmN0aW9uIGQoYSl7dmFyIGI9Ui5hcmlhLmltcGxpY2l0Tm9kZXMoYSl8fFtdO3JldHVybiBiLmNvbmNhdCgnW3JvbGU9IicrYSsnIl0nKS5qb2luKCIsIil9ZnVuY3Rpb24gZShhLGIsYyl7dmFyIGUsZixnPWEuZ2V0QXR0cmlidXRlKCJyb2xlIiksaD1bXTtpZihifHwoYj1SLmFyaWEucmVxdWlyZWRDb250ZXh0KGcpKSwhYilyZXR1cm4gbnVsbDtmb3IoZT0wLGY9Yi5sZW5ndGg7Zj5lO2UrKyl7aWYoYyYmUi51dGlscy5tYXRjaGVzU2VsZWN0b3IoYSxkKGJbZV0pKSlyZXR1cm4gbnVsbDtpZihSLmRvbS5maW5kVXAoYSxkKGJbZV0pKSlyZXR1cm4gbnVsbDtoLnB1c2goYltlXSl9cmV0dXJuIGh9ZnVuY3Rpb24gZihhKXtmb3IodmFyIGM9W10sZD1udWxsO2E7KWEuaWQmJihkPWIucXVlcnlTZWxlY3RvcigiW2FyaWEtb3duc349IitSLnV0aWxzLmVzY2FwZVNlbGVjdG9yKGEuaWQpKyJdIiksZCYmYy5wdXNoKGQpKSxhPWEucGFyZW50Tm9kZTtyZXR1cm4gYy5sZW5ndGg/YzpudWxsfXZhciBnPWUoYSk7aWYoIWcpcmV0dXJuITA7dmFyIGg9ZihhKTtpZihoKWZvcih2YXIgaT0wLGo9aC5sZW5ndGg7aj5pO2krKylpZihnPWUoaFtpXSxnLCEwKSwhZylyZXR1cm4hMDtyZXR1cm4gdGhpcy5kYXRhKGcpLCExfX0se2lkOiJhcmlhLXZhbGlkLWF0dHItdmFsdWUiLG1hdGNoZXM6ZnVuY3Rpb24oYSl7dmFyIGI9L15hcmlhLS87aWYoYS5oYXNBdHRyaWJ1dGVzKCkpZm9yKHZhciBjPWEuYXR0cmlidXRlcyxkPTAsZT1jLmxlbmd0aDtlPmQ7ZCsrKWlmKGIudGVzdChjW2RdLm5vZGVOYW1lKSlyZXR1cm4hMDtyZXR1cm4hMX0sZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtiPUFycmF5LmlzQXJyYXkoYik/YjpbXTtmb3IodmFyIGMsZCxlPVtdLGY9L15hcmlhLS8sZz1hLmF0dHJpYnV0ZXMsaD0wLGk9Zy5sZW5ndGg7aT5oO2grKyljPWdbaF0sZD1jLm5vZGVOYW1lLC0xPT09Yi5pbmRleE9mKGQpJiZmLnRlc3QoZCkmJiFSLmFyaWEudmFsaWRhdGVBdHRyVmFsdWUoYSxkKSYmZS5wdXNoKGQrJz0iJytjLm5vZGVWYWx1ZSsnIicpO3JldHVybiBlLmxlbmd0aD8odGhpcy5kYXRhKGUpLCExKTohMH0sb3B0aW9uczpbXX0se2lkOiJhcmlhLXZhbGlkLWF0dHIiLG1hdGNoZXM6ZnVuY3Rpb24oYSl7dmFyIGI9L15hcmlhLS87aWYoYS5oYXNBdHRyaWJ1dGVzKCkpZm9yKHZhciBjPWEuYXR0cmlidXRlcyxkPTAsZT1jLmxlbmd0aDtlPmQ7ZCsrKWlmKGIudGVzdChjW2RdLm5vZGVOYW1lKSlyZXR1cm4hMDtyZXR1cm4hMX0sZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtiPUFycmF5LmlzQXJyYXkoYik/YjpbXTtmb3IodmFyIGMsZD1bXSxlPS9eYXJpYS0vLGY9YS5hdHRyaWJ1dGVzLGc9MCxoPWYubGVuZ3RoO2g+ZztnKyspYz1mW2ddLm5vZGVOYW1lLC0xPT09Yi5pbmRleE9mKGMpJiZlLnRlc3QoYykmJiFSLmFyaWEudmFsaWRhdGVBdHRyKGMpJiZkLnB1c2goYyk7cmV0dXJuIGQubGVuZ3RoPyh0aGlzLmRhdGEoZCksITEpOiEwfSxvcHRpb25zOltdfSx7aWQ6ImNvbG9yLWNvbnRyYXN0IixtYXRjaGVzOmZ1bmN0aW9uKGEpe3ZhciBjPWEubm9kZU5hbWUsZD1hLnR5cGUsZT1iO2lmKCJJTlBVVCI9PT1jKXJldHVybi0xPT09WyJoaWRkZW4iLCJyYW5nZSIsImNvbG9yIiwiY2hlY2tib3giLCJyYWRpbyIsImltYWdlIl0uaW5kZXhPZihkKSYmIWEuZGlzYWJsZWQ7aWYoIlNFTEVDVCI9PT1jKXJldHVybiEhYS5vcHRpb25zLmxlbmd0aCYmIWEuZGlzYWJsZWQ7aWYoIlRFWFRBUkVBIj09PWMpcmV0dXJuIWEuZGlzYWJsZWQ7aWYoIk9QVElPTiI9PT1jKXJldHVybiExO2lmKCJCVVRUT04iPT09YyYmYS5kaXNhYmxlZClyZXR1cm4hMTtpZigiTEFCRUwiPT09Yyl7dmFyIGY9YS5odG1sRm9yJiZlLmdldEVsZW1lbnRCeUlkKGEuaHRtbEZvcik7aWYoZiYmZi5kaXNhYmxlZClyZXR1cm4hMTt2YXIgZj1hLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Om5vdChbdHlwZT0iaGlkZGVuIl0pOm5vdChbdHlwZT0iaW1hZ2UiXSk6bm90KFt0eXBlPSJidXR0b24iXSk6bm90KFt0eXBlPSJzdWJtaXQiXSk6bm90KFt0eXBlPSJyZXNldCJdKSwgc2VsZWN0LCB0ZXh0YXJlYScpO2lmKGYmJmYuZGlzYWJsZWQpcmV0dXJuITF9aWYoYS5pZCl7dmFyIGY9ZS5xdWVyeVNlbGVjdG9yKCJbYXJpYS1sYWJlbGxlZGJ5fj0iK1IudXRpbHMuZXNjYXBlU2VsZWN0b3IoYS5pZCkrIl0iKTtpZihmJiZmLmRpc2FibGVkKXJldHVybiExfWlmKCIiPT09Ui50ZXh0LnZpc2libGUoYSwhMSwhMCkpcmV0dXJuITE7dmFyIGcsaCxpPWIuY3JlYXRlUmFuZ2UoKSxqPWEuY2hpbGROb2RlcyxrPWoubGVuZ3RoO2ZvcihoPTA7az5oO2grKylnPWpbaF0sMz09PWcubm9kZVR5cGUmJiIiIT09Ui50ZXh0LnNhbml0aXplKGcubm9kZVZhbHVlKSYmaS5zZWxlY3ROb2RlQ29udGVudHMoZyk7dmFyIGw9aS5nZXRDbGllbnRSZWN0cygpO2ZvcihrPWwubGVuZ3RoLGg9MDtrPmg7aCsrKWlmKFIuZG9tLnZpc3VhbGx5T3ZlcmxhcHMobFtoXSxhKSlyZXR1cm4hMDtyZXR1cm4hMX0sZXZhbHVhdGU6ZnVuY3Rpb24oYixjKXt2YXIgZD1bXSxlPVIuY29sb3IuZ2V0QmFja2dyb3VuZENvbG9yKGIsZCksZj1SLmNvbG9yLmdldEZvcmVncm91bmRDb2xvcihiKTtpZihudWxsPT09Znx8bnVsbD09PWUpcmV0dXJuITA7dmFyIGc9YS5nZXRDb21wdXRlZFN0eWxlKGIpLGg9cGFyc2VGbG9hdChnLmdldFByb3BlcnR5VmFsdWUoImZvbnQtc2l6ZSIpKSxpPWcuZ2V0UHJvcGVydHlWYWx1ZSgiZm9udC13ZWlnaHQiKSxqPS0xIT09WyJib2xkIiwiYm9sZGVyIiwiNjAwIiwiNzAwIiwiODAwIiwiOTAwIl0uaW5kZXhPZihpKSxrPVIuY29sb3IuaGFzVmFsaWRDb250cmFzdFJhdGlvKGUsZixoLGopO3JldHVybiB0aGlzLmRhdGEoe2ZnQ29sb3I6Zi50b0hleFN0cmluZygpLGJnQ29sb3I6ZS50b0hleFN0cmluZygpLGNvbnRyYXN0UmF0aW86ay5jb250cmFzdFJhdGlvLnRvRml4ZWQoMiksZm9udFNpemU6KDcyKmgvOTYpLnRvRml4ZWQoMSkrInB0Iixmb250V2VpZ2h0Omo/ImJvbGQiOiJub3JtYWwifSksay5pc1ZhbGlkfHx0aGlzLnJlbGF0ZWROb2RlcyhkKSxrLmlzVmFsaWR9fSx7aWQ6ImZpZWxkc2V0IixldmFsdWF0ZTpmdW5jdGlvbihhLGMpe2Z1bmN0aW9uIGQoYSxiKXtyZXR1cm4gUi51dGlscy50b0FycmF5KGEucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0LHRleHRhcmVhLGJ1dHRvbixpbnB1dDpub3QoW25hbWU9IicrYisnIl0pOm5vdChbdHlwZT0iaGlkZGVuIl0pJykpfWZ1bmN0aW9uIGUoYSxiKXt2YXIgYz1hLmZpcnN0RWxlbWVudENoaWxkO2lmKCFjfHwiTEVHRU5EIiE9PWMubm9kZU5hbWUpcmV0dXJuIGoucmVsYXRlZE5vZGVzKFthXSksaT0ibm8tbGVnZW5kIiwhMTtpZighUi50ZXh0LmFjY2Vzc2libGVUZXh0KGMpKXJldHVybiBqLnJlbGF0ZWROb2RlcyhbY10pLGk9ImVtcHR5LWxlZ2VuZCIsITE7dmFyIGU9ZChhLGIpO3JldHVybiBlLmxlbmd0aD8oai5yZWxhdGVkTm9kZXMoZSksaT0ibWl4ZWQtaW5wdXRzIiwhMSk6ITB9ZnVuY3Rpb24gZihhLGIpe3ZhciBjPVIuZG9tLmlkcmVmcyhhLCJhcmlhLWxhYmVsbGVkYnkiKS5zb21lKGZ1bmN0aW9uKGEpe3JldHVybiBhJiZSLnRleHQuYWNjZXNzaWJsZVRleHQoYSl9KSxlPWEuZ2V0QXR0cmlidXRlKCJhcmlhLWxhYmVsIik7aWYoIShjfHxlJiZSLnRleHQuc2FuaXRpemUoZSkpKXJldHVybiBqLnJlbGF0ZWROb2RlcyhhKSxpPSJuby1ncm91cC1sYWJlbCIsITE7dmFyIGY9ZChhLGIpO3JldHVybiBmLmxlbmd0aD8oai5yZWxhdGVkTm9kZXMoZiksaT0iZ3JvdXAtbWl4ZWQtaW5wdXRzIiwhMSk6ITB9ZnVuY3Rpb24gZyhhLGIpe3JldHVybiBSLnV0aWxzLnRvQXJyYXkoYSkuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBhIT09Yn0pfWZ1bmN0aW9uIGgoYyl7dmFyIGQ9Ui51dGlscy5lc2NhcGVTZWxlY3RvcihhLm5hbWUpLGg9Yi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPSInK1IudXRpbHMuZXNjYXBlU2VsZWN0b3IoYS50eXBlKSsnIl1bbmFtZT0iJytkKyciXScpO2lmKGgubGVuZ3RoPDIpcmV0dXJuITA7dmFyIGs9Ui5kb20uZmluZFVwKGMsImZpZWxkc2V0IiksbD1SLmRvbS5maW5kVXAoYywnW3JvbGU9Imdyb3VwIl0nKygicmFkaW8iPT09YS50eXBlPycsW3JvbGU9InJhZGlvZ3JvdXAiXSc6IiIpKTtyZXR1cm4gbHx8az9rP2UoayxkKTpmKGwsZCk6KGk9Im5vLWdyb3VwIixqLnJlbGF0ZWROb2RlcyhnKGgsYykpLCExKX12YXIgaSxqPXRoaXMsaz17bmFtZTphLmdldEF0dHJpYnV0ZSgibmFtZSIpLHR5cGU6YS5nZXRBdHRyaWJ1dGUoInR5cGUiKX0sbD1oKGEpO3JldHVybiBsfHwoay5mYWlsdXJlQ29kZT1pKSx0aGlzLmRhdGEoayksbH0sYWZ0ZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz17fTtyZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24oYSl7aWYoYS5yZXN1bHQpcmV0dXJuITA7dmFyIGI9YS5kYXRhO2lmKGIpe2lmKGNbYi50eXBlXT1jW2IudHlwZV18fHt9LCFjW2IudHlwZV1bYi5uYW1lXSlyZXR1cm4gY1tiLnR5cGVdW2IubmFtZV09W2JdLCEwO3ZhciBkPWNbYi50eXBlXVtiLm5hbWVdLnNvbWUoZnVuY3Rpb24oYSl7cmV0dXJuIGEuZmFpbHVyZUNvZGU9PT1iLmZhaWx1cmVDb2RlfSk7cmV0dXJuIGR8fGNbYi50eXBlXVtiLm5hbWVdLnB1c2goYiksIWR9cmV0dXJuITF9KX19LHtpZDoiZ3JvdXAtbGFiZWxsZWRieSIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxjKXt0aGlzLmRhdGEoe25hbWU6YS5nZXRBdHRyaWJ1dGUoIm5hbWUiKSx0eXBlOmEuZ2V0QXR0cmlidXRlKCJ0eXBlIil9KTt2YXIgZD1iLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9IicrUi51dGlscy5lc2NhcGVTZWxlY3RvcihhLnR5cGUpKyciXVtuYW1lPSInK1IudXRpbHMuZXNjYXBlU2VsZWN0b3IoYS5uYW1lKSsnIl0nKTtyZXR1cm4gZC5sZW5ndGg8PTE/ITA6MCE9PVtdLm1hcC5jYWxsKGQsZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRBdHRyaWJ1dGUoImFyaWEtbGFiZWxsZWRieSIpO3JldHVybiBiP2Iuc3BsaXQoL1xzKy8pOltdfSkucmVkdWNlKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybi0xIT09Yi5pbmRleE9mKGEpfSl9KS5maWx0ZXIoZnVuY3Rpb24oYSl7CnZhciBjPWIuZ2V0RWxlbWVudEJ5SWQoYSk7cmV0dXJuIGMmJlIudGV4dC5hY2Nlc3NpYmxlVGV4dChjKX0pLmxlbmd0aH0sYWZ0ZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz17fTtyZXR1cm4gYS5maWx0ZXIoZnVuY3Rpb24oYSl7dmFyIGI9YS5kYXRhO3JldHVybiBiJiYoY1tiLnR5cGVdPWNbYi50eXBlXXx8e30sIWNbYi50eXBlXVtiLm5hbWVdKT8oY1tiLnR5cGVdW2IubmFtZV09ITAsITApOiExfSl9fSx7aWQ6ImFjY2Vzc2tleXMiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZGF0YShhLmdldEF0dHJpYnV0ZSgiYWNjZXNza2V5IikpLHRoaXMucmVsYXRlZE5vZGVzKFthXSksITB9LGFmdGVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9e307cmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBjW2EuZGF0YV0/KGNbYS5kYXRhXS5yZWxhdGVkTm9kZXMucHVzaChhLnJlbGF0ZWROb2Rlc1swXSksITEpOihjW2EuZGF0YV09YSxhLnJlbGF0ZWROb2Rlcz1bXSwhMCl9KS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVzdWx0PSEhYS5yZWxhdGVkTm9kZXMubGVuZ3RoLGF9KX19LHtpZDoiZm9jdXNhYmxlLW5vLW5hbWUiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5nZXRBdHRyaWJ1dGUoInRhYmluZGV4IiksZD1SLmRvbS5pc0ZvY3VzYWJsZShhKSYmYz4tMTtyZXR1cm4gZD8hUi50ZXh0LmFjY2Vzc2libGVUZXh0KGEpOiExfX0se2lkOiJ0YWJpbmRleCIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS50YWJJbmRleDw9MH19LHtpZDoiZHVwbGljYXRlLWltZy1sYWJlbCIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9YS5xdWVyeVNlbGVjdG9yQWxsKCJpbWciKSxkPVIudGV4dC52aXNpYmxlKGEsITApLGU9MCxmPWMubGVuZ3RoO2Y+ZTtlKyspe3ZhciBnPVIudGV4dC5hY2Nlc3NpYmxlVGV4dChjW2VdKTtpZihnPT09ZCYmIiIhPT1kKXJldHVybiEwfXJldHVybiExfSxlbmFibGVkOiExfSx7aWQ6ImV4cGxpY2l0LWxhYmVsIixldmFsdWF0ZTpmdW5jdGlvbihhLGMpe3ZhciBkPWIucXVlcnlTZWxlY3RvcignbGFiZWxbZm9yPSInK1IudXRpbHMuZXNjYXBlU2VsZWN0b3IoYS5pZCkrJyJdJyk7cmV0dXJuIGQ/ISFSLnRleHQuYWNjZXNzaWJsZVRleHQoZCk6ITF9LHNlbGVjdG9yOiJbaWRdIn0se2lkOiJoZWxwLXNhbWUtYXMtbGFiZWwiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9Ui50ZXh0LmxhYmVsKGEpLGQ9YS5nZXRBdHRyaWJ1dGUoInRpdGxlIik7aWYoIWMpcmV0dXJuITE7aWYoIWQmJihkPSIiLGEuZ2V0QXR0cmlidXRlKCJhcmlhLWRlc2NyaWJlZGJ5IikpKXt2YXIgZT1SLmRvbS5pZHJlZnMoYSwiYXJpYS1kZXNjcmliZWRieSIpO2Q9ZS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGE/Ui50ZXh0LmFjY2Vzc2libGVUZXh0KGEpOiIifSkuam9pbigiIil9cmV0dXJuIFIudGV4dC5zYW5pdGl6ZShkKT09PVIudGV4dC5zYW5pdGl6ZShjKX0sZW5hYmxlZDohMX0se2lkOiJpbXBsaWNpdC1sYWJlbCIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1SLmRvbS5maW5kVXAoYSwibGFiZWwiKTtyZXR1cm4gYz8hIVIudGV4dC5hY2Nlc3NpYmxlVGV4dChjKTohMX19LHtpZDoibXVsdGlwbGUtbGFiZWwiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBkPVtdLnNsaWNlLmNhbGwoYi5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbFtmb3I9IicrUi51dGlscy5lc2NhcGVTZWxlY3RvcihhLmlkKSsnIl0nKSksZT1hLnBhcmVudE5vZGU7ZTspIkxBQkVMIj09PWUudGFnTmFtZSYmLTE9PT1kLmluZGV4T2YoZSkmJmQucHVzaChlKSxlPWUucGFyZW50Tm9kZTtyZXR1cm4gdGhpcy5yZWxhdGVkTm9kZXMoZCksZC5sZW5ndGg+MX19LHtpZDoidGl0bGUtb25seSIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1SLnRleHQubGFiZWwoYSk7cmV0dXJuIShjfHwhYS5nZXRBdHRyaWJ1dGUoInRpdGxlIikmJiFhLmdldEF0dHJpYnV0ZSgiYXJpYS1kZXNjcmliZWRieSIpKX19LHtpZDoiaGFzLWxhbmciLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuaGFzQXR0cmlidXRlKCJsYW5nIil8fGEuaGFzQXR0cmlidXRlKCJ4bWw6bGFuZyIpfX0se2lkOiJ2YWxpZC1sYW5nIixvcHRpb25zOlsiYWEiLCJhYiIsImFlIiwiYWYiLCJhayIsImFtIiwiYW4iLCJhciIsImFzIiwiYXYiLCJheSIsImF6IiwiYmEiLCJiZSIsImJnIiwiYmgiLCJiaSIsImJtIiwiYm4iLCJibyIsImJyIiwiYnMiLCJjYSIsImNlIiwiY2giLCJjbyIsImNyIiwiY3MiLCJjdSIsImN2IiwiY3kiLCJkYSIsImRlIiwiZHYiLCJkeiIsImVlIiwiZWwiLCJlbiIsImVvIiwiZXMiLCJldCIsImV1IiwiZmEiLCJmZiIsImZpIiwiZmoiLCJmbyIsImZyIiwiZnkiLCJnYSIsImdkIiwiZ2wiLCJnbiIsImd1IiwiZ3YiLCJoYSIsImhlIiwiaGkiLCJobyIsImhyIiwiaHQiLCJodSIsImh5IiwiaHoiLCJpYSIsImlkIiwiaWUiLCJpZyIsImlpIiwiaWsiLCJpbiIsImlvIiwiaXMiLCJpdCIsIml1IiwiaXciLCJqYSIsImppIiwianYiLCJqdyIsImthIiwia2ciLCJraSIsImtqIiwia2siLCJrbCIsImttIiwia24iLCJrbyIsImtyIiwia3MiLCJrdSIsImt2Iiwia3ciLCJreSIsImxhIiwibGIiLCJsZyIsImxpIiwibG4iLCJsbyIsImx0IiwibHUiLCJsdiIsIm1nIiwibWgiLCJtaSIsIm1rIiwibWwiLCJtbiIsIm1vIiwibXIiLCJtcyIsIm10IiwibXkiLCJuYSIsIm5iIiwibmQiLCJuZSIsIm5nIiwibmwiLCJubiIsIm5vIiwibnIiLCJudiIsIm55Iiwib2MiLCJvaiIsIm9tIiwib3IiLCJvcyIsInBhIiwicGkiLCJwbCIsInBzIiwicHQiLCJxdSIsInJtIiwicm4iLCJybyIsInJ1IiwicnciLCJzYSIsInNjIiwic2QiLCJzZSIsInNnIiwic2giLCJzaSIsInNrIiwic2wiLCJzbSIsInNuIiwic28iLCJzcSIsInNyIiwic3MiLCJzdCIsInN1Iiwic3YiLCJzdyIsInRhIiwidGUiLCJ0ZyIsInRoIiwidGkiLCJ0ayIsInRsIiwidG4iLCJ0byIsInRyIiwidHMiLCJ0dCIsInR3IiwidHkiLCJ1ZyIsInVrIiwidXIiLCJ1eiIsInZlIiwidmkiLCJ2byIsIndhIiwid28iLCJ4aCIsInlpIiwieW8iLCJ6YSIsInpoIiwienUiXSxldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPShhLmdldEF0dHJpYnV0ZSgibGFuZyIpfHwiIikudHJpbSgpLnRvTG93ZXJDYXNlKCksZD0oYS5nZXRBdHRyaWJ1dGUoInhtbDpsYW5nIil8fCIiKS50cmltKCkudG9Mb3dlckNhc2UoKSxlPVtdO3JldHVybihifHxbXSkuZm9yRWFjaChmdW5jdGlvbihhKXthPWEudG9Mb3dlckNhc2UoKSwhY3x8YyE9PWEmJjAhPT1jLmluZGV4T2YoYS50b0xvd2VyQ2FzZSgpKyItIil8fChjPW51bGwpLCFkfHxkIT09YSYmMCE9PWQuaW5kZXhPZihhLnRvTG93ZXJDYXNlKCkrIi0iKXx8KGQ9bnVsbCl9KSxkJiZlLnB1c2goJ3htbDpsYW5nPSInK2QrJyInKSxjJiZlLnB1c2goJ2xhbmc9IicrYysnIicpLGUubGVuZ3RoPyh0aGlzLmRhdGEoZSksITApOiExfX0se2lkOiJkbGl0ZW0iLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIkRMIj09PWEucGFyZW50Tm9kZS50YWdOYW1lfX0se2lkOiJoYXMtbGlzdGl0ZW0iLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5jaGlsZHJlbjtpZigwPT09Yy5sZW5ndGgpcmV0dXJuITA7Zm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspaWYoIkxJIj09PWNbZF0ubm9kZU5hbWUpcmV0dXJuITE7cmV0dXJuITB9fSx7aWQ6Imxpc3RpdGVtIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3JldHVybi0xIT09WyJVTCIsIk9MIl0uaW5kZXhPZihhLnBhcmVudE5vZGUudGFnTmFtZSl9fSx7aWQ6Im9ubHktZGxpdGVtcyIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZD1bXSxlPWEuY2hpbGROb2RlcyxmPSExLGc9MDtnPGUubGVuZ3RoO2crKyljPWVbZ10sMT09PWMubm9kZVR5cGUmJiJEVCIhPT1jLm5vZGVOYW1lJiYiREQiIT09Yy5ub2RlTmFtZSYmIlNDUklQVCIhPT1jLm5vZGVOYW1lJiYiVEVNUExBVEUiIT09Yy5ub2RlTmFtZT9kLnB1c2goYyk6Mz09PWMubm9kZVR5cGUmJiIiIT09Yy5ub2RlVmFsdWUudHJpbSgpJiYoZj0hMCk7ZC5sZW5ndGgmJnRoaXMucmVsYXRlZE5vZGVzKGQpO3ZhciBoPSEhZC5sZW5ndGh8fGY7cmV0dXJuIGh9fSx7aWQ6Im9ubHktbGlzdGl0ZW1zIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyxkPVtdLGU9YS5jaGlsZE5vZGVzLGY9ITEsZz0wO2c8ZS5sZW5ndGg7ZysrKWM9ZVtnXSwxPT09Yy5ub2RlVHlwZSYmIkxJIiE9PWMubm9kZU5hbWUmJiJTQ1JJUFQiIT09Yy5ub2RlTmFtZSYmIlRFTVBMQVRFIiE9PWMubm9kZU5hbWU/ZC5wdXNoKGMpOjM9PT1jLm5vZGVUeXBlJiYiIiE9PWMubm9kZVZhbHVlLnRyaW0oKSYmKGY9ITApO3JldHVybiBkLmxlbmd0aCYmdGhpcy5yZWxhdGVkTm9kZXMoZCksISFkLmxlbmd0aHx8Zn19LHtpZDoic3RydWN0dXJlZC1kbGl0ZW1zIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEuY2hpbGRyZW47aWYoIWN8fCFjLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGQ9ITEsZT0hMSxmPTA7ZjxjLmxlbmd0aDtmKyspe2lmKCJEVCI9PT1jW2ZdLm5vZGVOYW1lJiYoZD0hMCksZCYmIkREIj09PWNbZl0ubm9kZU5hbWUpcmV0dXJuITE7IkREIj09PWNbZl0ubm9kZU5hbWUmJihlPSEwKX1yZXR1cm4gZHx8ZX19LHtpZDoiY2FwdGlvbiIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4hYS5xdWVyeVNlbGVjdG9yKCJ0cmFja1traW5kPWNhcHRpb25zXSIpfX0se2lkOiJkZXNjcmlwdGlvbiIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4hYS5xdWVyeVNlbGVjdG9yKCJ0cmFja1traW5kPWRlc2NyaXB0aW9uc10iKX19LHtpZDoibWV0YS12aWV3cG9ydCIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZD1hLmdldEF0dHJpYnV0ZSgiY29udGVudCIpfHwiIixlPWQuc3BsaXQoL1s7LF0vKSxmPXt9LGc9MCxoPWUubGVuZ3RoO2g+ZztnKyspe2M9ZVtnXS5zcGxpdCgiPSIpO3ZhciBpPWMuc2hpZnQoKTtpJiZjLmxlbmd0aCYmKGZbaS50cmltKCldPWMuam9pbigiPSIpLnRyaW0oKSl9cmV0dXJuIGZbIm1heGltdW0tc2NhbGUiXSYmcGFyc2VGbG9hdChmWyJtYXhpbXVtLXNjYWxlIl0pPDU/ITE6Im5vIj09PWZbInVzZXItc2NhbGFibGUiXT8hMTohMH19LHtpZDoiaGVhZGVyLXByZXNlbnQiLHNlbGVjdG9yOiJodG1sIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3JldHVybiEhYS5xdWVyeVNlbGVjdG9yKCdoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBbcm9sZT0iaGVhZGluZyJdJyl9fSx7aWQ6ImhlYWRpbmctb3JkZXIiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5nZXRBdHRyaWJ1dGUoImFyaWEtbGV2ZWwiKTtpZihudWxsIT09YylyZXR1cm4gdGhpcy5kYXRhKHBhcnNlSW50KGMsMTApKSwhMDt2YXIgZD1hLnRhZ05hbWUubWF0Y2goL0goXGQpLyk7cmV0dXJuIGQ/KHRoaXMuZGF0YShwYXJzZUludChkWzFdLDEwKSksITApOiEwfSxhZnRlcjpmdW5jdGlvbihhLGIpe2lmKGEubGVuZ3RoPDIpcmV0dXJuIGE7Zm9yKHZhciBjPWFbMF0uZGF0YSxkPTE7ZDxhLmxlbmd0aDtkKyspYVtkXS5yZXN1bHQmJmFbZF0uZGF0YT5jKzEmJihhW2RdLnJlc3VsdD0hMSksYz1hW2RdLmRhdGE7cmV0dXJuIGF9fSx7aWQ6ImludGVybmFsLWxpbmstcHJlc2VudCIsc2VsZWN0b3I6Imh0bWwiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuISFhLnF1ZXJ5U2VsZWN0b3IoJ2FbaHJlZl49IiMiXScpfX0se2lkOiJsYW5kbWFyayIsc2VsZWN0b3I6Imh0bWwiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuISFhLnF1ZXJ5U2VsZWN0b3IoJ1tyb2xlPSJtYWluIl0nKX19LHtpZDoibWV0YS1yZWZyZXNoIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEuZ2V0QXR0cmlidXRlKCJjb250ZW50Iil8fCIiLGQ9Yy5zcGxpdCgvWzssXS8pO3JldHVybiIiPT09Y3x8IjAiPT09ZFswXX19LHtpZDoicmVnaW9uIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGgmJlIuZG9tLmlzRm9jdXNhYmxlKFIuZG9tLmdldEVsZW1lbnRCeVJlZmVyZW5jZShoLCJocmVmIikpJiZoPT09YX1mdW5jdGlvbiBkKGEpe3ZhciBiPWEuZ2V0QXR0cmlidXRlKCJyb2xlIik7cmV0dXJuIGImJi0xIT09Zy5pbmRleE9mKGIpfWZ1bmN0aW9uIGUoYSl7cmV0dXJuIGQoYSk/bnVsbDpjKGEpP2YoYSk6Ui5kb20uaXNWaXNpYmxlKGEsITApJiYoUi50ZXh0LnZpc2libGUoYSwhMCwhMCl8fFIuZG9tLmlzVmlzdWFsQ29udGVudChhKSk/YTpmKGEpfWZ1bmN0aW9uIGYoYSl7dmFyIGI9Ui51dGlscy50b0FycmF5KGEuY2hpbGRyZW4pO3JldHVybiAwPT09Yi5sZW5ndGg/W106Yi5tYXAoZSkuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09YX0pLnJlZHVjZShmdW5jdGlvbihhLGIpe3JldHVybiBhLmNvbmNhdChiKX0sW10pfXZhciBnPVIuYXJpYS5nZXRSb2xlc0J5VHlwZSgibGFuZG1hcmsiKSxoPWEucXVlcnlTZWxlY3RvcigiYVtocmVmXSIpLGk9ZihhKTtyZXR1cm4gdGhpcy5yZWxhdGVkTm9kZXMoaSksIWkubGVuZ3RofSxhZnRlcjpmdW5jdGlvbihhLGIpe3JldHVyblthWzBdXX19LHtpZDoic2tpcC1saW5rIixzZWxlY3RvcjoiYVtocmVmXSIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUi5kb20uaXNGb2N1c2FibGUoUi5kb20uZ2V0RWxlbWVudEJ5UmVmZXJlbmNlKGEsImhyZWYiKSl9LGFmdGVyOmZ1bmN0aW9uKGEsYil7cmV0dXJuW2FbMF1dfX0se2lkOiJ1bmlxdWUtZnJhbWUtdGl0bGUiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZGF0YShhLnRpdGxlKSwhMH0sYWZ0ZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz17fTtyZXR1cm4gYS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2NbYS5kYXRhXT12b2lkIDAhPT1jW2EuZGF0YV0/KytjW2EuZGF0YV06MH0pLGEuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiEhY1thLmRhdGFdfSl9fSx7aWQ6ImFyaWEtbGFiZWwiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5nZXRBdHRyaWJ1dGUoImFyaWEtbGFiZWwiKTtyZXR1cm4hIShjP1IudGV4dC5zYW5pdGl6ZShjKS50cmltKCk6IiIpfX0se2lkOiJhcmlhLWxhYmVsbGVkYnkiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPVIuZG9tLmlkcmVmcyhhLCJhcmlhLWxhYmVsbGVkYnkiKSxmPWUubGVuZ3RoO2ZvcihkPTA7Zj5kO2QrKylpZihjPWVbZF0sYyYmUi50ZXh0LmFjY2Vzc2libGVUZXh0KGMpLnRyaW0oKSlyZXR1cm4hMDtyZXR1cm4hMX19LHtpZDoiYnV0dG9uLWhhcy12aXNpYmxlLXRleHQiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFIudGV4dC5hY2Nlc3NpYmxlVGV4dChhKS5sZW5ndGg+MH0sc2VsZWN0b3I6J2J1dHRvbiwgW3JvbGU9ImJ1dHRvbiJdOm5vdChpbnB1dCknfSx7aWQ6ImRvYy1oYXMtdGl0bGUiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYyl7dmFyIGQ9Yi50aXRsZTtyZXR1cm4hIShkP1IudGV4dC5zYW5pdGl6ZShkKS50cmltKCk6IiIpfX0se2lkOiJkdXBsaWNhdGUtaWQiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYyl7Zm9yKHZhciBkPWIucXVlcnlTZWxlY3RvckFsbCgnW2lkPSInK1IudXRpbHMuZXNjYXBlU2VsZWN0b3IoYS5pZCkrJyJdJyksZT1bXSxmPTA7ZjxkLmxlbmd0aDtmKyspZFtmXSE9PWEmJmUucHVzaChkW2ZdKTtyZXR1cm4gZS5sZW5ndGgmJnRoaXMucmVsYXRlZE5vZGVzKGUpLHRoaXMuZGF0YShhLmdldEF0dHJpYnV0ZSgiaWQiKSksZC5sZW5ndGg8PTF9LGFmdGVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9W107cmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybi0xPT09Yy5pbmRleE9mKGEuZGF0YSk/KGMucHVzaChhLmRhdGEpLCEwKTohMX0pfX0se2lkOiJleGlzdHMiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuITB9fSx7aWQ6Imhhcy1hbHQiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuaGFzQXR0cmlidXRlKCJhbHQiKX19LHtpZDoiaGFzLXZpc2libGUtdGV4dCIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUi50ZXh0LmFjY2Vzc2libGVUZXh0KGEpLmxlbmd0aD4wfX0se2lkOiJub24tZW1wdHktYWx0IixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEuZ2V0QXR0cmlidXRlKCJhbHQiKTtyZXR1cm4hIShjP1IudGV4dC5zYW5pdGl6ZShjKS50cmltKCk6IiIpfX0se2lkOiJub24tZW1wdHktaWYtcHJlc2VudCIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmdldEF0dHJpYnV0ZSgidmFsdWUiKTtyZXR1cm4gdGhpcy5kYXRhKGMpLG51bGw9PT1jfHwiIiE9PVIudGV4dC5zYW5pdGl6ZShjKS50cmltKCl9LHNlbGVjdG9yOidbdHlwZT0ic3VibWl0Il0sIFt0eXBlPSJyZXNldCJdJ30se2lkOiJub24tZW1wdHktdGl0bGUiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5nZXRBdHRyaWJ1dGUoInRpdGxlIik7cmV0dXJuISEoYz9SLnRleHQuc2FuaXRpemUoYykudHJpbSgpOiIiKX19LHtpZDoibm9uLWVtcHR5LXZhbHVlIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEuZ2V0QXR0cmlidXRlKCJ2YWx1ZSIpO3JldHVybiEhKGM/Ui50ZXh0LnNhbml0aXplKGMpLnRyaW0oKToiIil9LHNlbGVjdG9yOidbdHlwZT0iYnV0dG9uIl0nfSx7aWQ6InJvbGUtbm9uZSIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4ibm9uZSI9PT1hLmdldEF0dHJpYnV0ZSgicm9sZSIpfX0se2lkOiJyb2xlLXByZXNlbnRhdGlvbiIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4icHJlc2VudGF0aW9uIj09PWEuZ2V0QXR0cmlidXRlKCJyb2xlIil9fSx7aWQ6ImNlbGwtbm8taGVhZGVyIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyxkLGU9W10sZj0wLGc9YS5yb3dzLmxlbmd0aDtnPmY7ZisrKXtjPWEucm93c1tmXTtmb3IodmFyIGg9MCxpPWMuY2VsbHMubGVuZ3RoO2k+aDtoKyspZD1jLmNlbGxzW2hdLCFSLnRhYmxlLmlzRGF0YUNlbGwoZCl8fFIuYXJpYS5sYWJlbChkKXx8Ui50YWJsZS5nZXRIZWFkZXJzKGQpLmxlbmd0aHx8ZS5wdXNoKGQpfXJldHVybiBlLmxlbmd0aD8odGhpcy5yZWxhdGVkTm9kZXMoZSksITApOiExfX0se2lkOiJjb25zaXN0ZW50LWNvbHVtbnMiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjLGQ9Ui50YWJsZS50b0FycmF5KGEpLGU9W10sZj0wLGc9ZC5sZW5ndGg7Zz5mO2YrKykwPT09Zj9jPWRbZl0ubGVuZ3RoOmMhPT1kW2ZdLmxlbmd0aCYmZS5wdXNoKGEucm93c1tmXSk7cmV0dXJuIWUubGVuZ3RofX0se2lkOiJoYXMtY2FwdGlvbiIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4hIWEuY2FwdGlvbn19LHtpZDoiaGFzLXN1bW1hcnkiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuISFhLnN1bW1hcnl9fSx7aWQ6Imhhcy10aCIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZCxlPVtdLGY9MCxnPWEucm93cy5sZW5ndGg7Zz5mO2YrKyl7Yz1hLnJvd3NbZl07Zm9yKHZhciBoPTAsaT1jLmNlbGxzLmxlbmd0aDtpPmg7aCsrKWQ9Yy5jZWxsc1toXSwiVEgiPT09ZC5ub2RlTmFtZSYmZS5wdXNoKGQpfXJldHVybiBlLmxlbmd0aD8odGhpcy5yZWxhdGVkTm9kZXMoZSksITApOiExfX0se2lkOiJoZWFkZXJzLWF0dHItcmVmZXJlbmNlIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7YSYmUi50ZXh0LmFjY2Vzc2libGVUZXh0KGEpfHxnLnB1c2goZSl9Zm9yKHZhciBkLGUsZixnPVtdLGg9MCxpPWEucm93cy5sZW5ndGg7aT5oO2grKyl7ZD1hLnJvd3NbaF07Zm9yKHZhciBqPTAsaz1kLmNlbGxzLmxlbmd0aDtrPmo7aisrKWU9ZC5jZWxsc1tqXSxmPVIuZG9tLmlkcmVmcyhlLCJoZWFkZXJzIiksZi5sZW5ndGgmJmYuZm9yRWFjaChjKX1yZXR1cm4gZy5sZW5ndGg/KHRoaXMucmVsYXRlZE5vZGVzKGcpLCEwKTohMX19LHtpZDoiaGVhZGVycy12aXNpYmxlLXRleHQiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjLGQsZT1bXSxmPTAsZz1hLnJvd3MubGVuZ3RoO2c+ZjtmKyspe2M9YS5yb3dzW2ZdO2Zvcih2YXIgaD0wLGk9Yy5jZWxscy5sZW5ndGg7aT5oO2grKylkPWMuY2VsbHNbaF0sUi50YWJsZS5pc0hlYWRlcihkKSYmIVIudGV4dC5hY2Nlc3NpYmxlVGV4dChkKSYmZS5wdXNoKGQpfXJldHVybiBlLmxlbmd0aD8odGhpcy5yZWxhdGVkTm9kZXMoZSksITApOiExfX0se2lkOiJodG1sNC1zY29wZSIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxjKXtyZXR1cm4gUi5kb20uaXNIVE1MNShiKT8hMToiVEgiPT09YS5ub2RlTmFtZXx8IlREIj09PWEubm9kZU5hbWV9fSx7aWQ6Imh0bWw1LXNjb3BlIixldmFsdWF0ZTpmdW5jdGlvbihhLGMpe3JldHVybiBSLmRvbS5pc0hUTUw1KGIpPyJUSCI9PT1hLm5vZGVOYW1lOiExfX0se2lkOiJuby1jYXB0aW9uIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3JldHVybiEoYS5jYXB0aW9ufHx7fSkudGV4dENvbnRlbnR9LGVuYWJsZWQ6ITF9LHtpZDoicm93c3BhbiIsZXZhbHVhdGU6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGMsZCxlPVtdLGY9MCxnPWEucm93cy5sZW5ndGg7Zz5mO2YrKyl7Yz1hLnJvd3NbZl07Zm9yKHZhciBoPTAsaT1jLmNlbGxzLmxlbmd0aDtpPmg7aCsrKWQ9Yy5jZWxsc1toXSwxIT09ZC5yb3dTcGFuJiZlLnB1c2goZCl9cmV0dXJuIGUubGVuZ3RoPyh0aGlzLnJlbGF0ZWROb2RlcyhlKSwhMCk6ITF9fSx7aWQ6InNhbWUtY2FwdGlvbi1zdW1tYXJ5IixzZWxlY3RvcjoidGFibGUiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7cmV0dXJuISghYS5zdW1tYXJ5fHwhYS5jYXB0aW9uKSYmYS5zdW1tYXJ5PT09Ui50ZXh0LmFjY2Vzc2libGVUZXh0KGEuY2FwdGlvbil9fSx7aWQ6InNjb3BlLXZhbHVlIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEuZ2V0QXR0cmlidXRlKCJzY29wZSIpO3JldHVybiJyb3ciIT09YyYmImNvbCIhPT1jfX0se2lkOiJ0aC1oZWFkZXJzLWF0dHIiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjLGQsZT1bXSxmPTAsZz1hLnJvd3MubGVuZ3RoO2c+ZjtmKyspe2M9YS5yb3dzW2ZdO2Zvcih2YXIgaD0wLGk9Yy5jZWxscy5sZW5ndGg7aT5oO2grKylkPWMuY2VsbHNbaF0sIlRIIj09PWQubm9kZU5hbWUmJmQuZ2V0QXR0cmlidXRlKCJoZWFkZXJzIikmJmUucHVzaChkKX1yZXR1cm4gZS5sZW5ndGg/KHRoaXMucmVsYXRlZE5vZGVzKGUpLCEwKTohMX19LHtpZDoidGgtc2NvcGUiLGV2YWx1YXRlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjLGQsZT1bXSxmPTAsZz1hLnJvd3MubGVuZ3RoO2c+ZjtmKyspe2M9YS5yb3dzW2ZdO2Zvcih2YXIgaD0wLGk9Yy5jZWxscy5sZW5ndGg7aT5oO2grKylkPWMuY2VsbHNbaF0sIlRIIiE9PWQubm9kZU5hbWV8fGQuZ2V0QXR0cmlidXRlKCJzY29wZSIpfHxlLnB1c2goZCl9cmV0dXJuIGUubGVuZ3RoPyh0aGlzLnJlbGF0ZWROb2RlcyhlKSwhMCk6ITF9fSx7aWQ6InRoLXNpbmdsZS1yb3ctY29sdW1uIixldmFsdWF0ZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyxkLGUsZj1bXSxnPVtdLGg9MCxpPWEucm93cy5sZW5ndGg7aT5oO2grKyl7Yz1hLnJvd3NbaF07Zm9yKHZhciBqPTAsaz1jLmNlbGxzLmxlbmd0aDtrPmo7aisrKWQ9Yy5jZWxsc1tqXSxkLm5vZGVOYW1lJiYoUi50YWJsZS5pc0NvbHVtbkhlYWRlcihkKSYmLTE9PT1nLmluZGV4T2YoaCk/Zy5wdXNoKGgpOlIudGFibGUuaXNSb3dIZWFkZXIoZCkmJihlPVIudGFibGUuZ2V0Q2VsbFBvc2l0aW9uKGQpLC0xPT09Zi5pbmRleE9mKGUueCkmJmYucHVzaChlLngpKSl9cmV0dXJuIGcubGVuZ3RoPjF8fGYubGVuZ3RoPjE/ITA6ITF9fV0sY29tbW9uczpmdW5jdGlvbigpe2Z1bmN0aW9uIGMoYil7dmFyIGMsZD1hLmdldENvbXB1dGVkU3R5bGUoYik7aWYoIm5vbmUiIT09ZC5nZXRQcm9wZXJ0eVZhbHVlKCJiYWNrZ3JvdW5kLWltYWdlIikpcmV0dXJuIG51bGw7dmFyIGU9ZC5nZXRQcm9wZXJ0eVZhbHVlKCJiYWNrZ3JvdW5kLWNvbG9yIik7InRyYW5zcGFyZW50Ij09PWU/Yz1uZXcgci5Db2xvcigwLDAsMCwwKTooYz1uZXcgci5Db2xvcixjLnBhcnNlUmdiU3RyaW5nKGUpKTt2YXIgZj1kLmdldFByb3BlcnR5VmFsdWUoIm9wYWNpdHkiKTtyZXR1cm4gYy5hbHBoYT1jLmFscGhhKmYsY31mdW5jdGlvbiBkKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYj1hLm1hdGNoKC9yZWN0XHMqXCgoWzAtOV0rKXB4LD9ccyooWzAtOV0rKXB4LD9ccyooWzAtOV0rKXB4LD9ccyooWzAtOV0rKXB4XHMqXCkvKTtyZXR1cm4gYiYmNT09PWIubGVuZ3RoP2JbM10tYlsxXTw9MCYmYlsyXS1iWzRdPD0wOiExfWZ1bmN0aW9uIGUoYSl7dmFyIGM9bnVsbDtyZXR1cm4gYS5pZCYmKGM9Yi5xdWVyeVNlbGVjdG9yKCdsYWJlbFtmb3I9Iicrdi5lc2NhcGVTZWxlY3RvcihhLmlkKSsnIl0nKSk/YzpjPXMuZmluZFVwKGEsImxhYmVsIil9ZnVuY3Rpb24gZihhKXtyZXR1cm4tMSE9PVsiYnV0dG9uIiwicmVzZXQiLCJzdWJtaXQiXS5pbmRleE9mKGEudHlwZSl9ZnVuY3Rpb24gZyhhKXtyZXR1cm4iVEVYVEFSRUEiPT09YS5ub2RlTmFtZXx8IlNFTEVDVCI9PT1hLm5vZGVOYW1lfHwiSU5QVVQiPT09YS5ub2RlTmFtZSYmImhpZGRlbiIhPT1hLnR5cGV9ZnVuY3Rpb24gaChhKXtyZXR1cm4tMSE9PVsiQlVUVE9OIiwiU1VNTUFSWSIsIkEiXS5pbmRleE9mKGEubm9kZU5hbWUpfWZ1bmN0aW9uIGkoYSl7cmV0dXJuLTEhPT1bIlRBQkxFIiwiRklHVVJFIl0uaW5kZXhPZihhLm5vZGVOYW1lKX1mdW5jdGlvbiBqKGEpe2lmKCJJTlBVVCI9PT1hLm5vZGVOYW1lKXJldHVybiFhLmhhc0F0dHJpYnV0ZSgidHlwZSIpfHwtMSE9PXkuaW5kZXhPZihhLmdldEF0dHJpYnV0ZSgidHlwZSIpKSYmYS52YWx1ZT9hLnZhbHVlOiIiO2lmKCJTRUxFQ1QiPT09YS5ub2RlTmFtZSl7dmFyIGI9YS5vcHRpb25zO2lmKGImJmIubGVuZ3RoKXtmb3IodmFyIGM9IiIsZD0wO2Q8Yi5sZW5ndGg7ZCsrKWJbZF0uc2VsZWN0ZWQmJihjKz0iICIrYltkXS50ZXh0KTtyZXR1cm4gdS5zYW5pdGl6ZShjKX1yZXR1cm4iIn1yZXR1cm4iVEVYVEFSRUEiPT09YS5ub2RlTmFtZSYmYS52YWx1ZT9hLnZhbHVlOiIifWZ1bmN0aW9uIGsoYSxiKXt2YXIgYz1hLnF1ZXJ5U2VsZWN0b3IoYik7cmV0dXJuIGM/dS5hY2Nlc3NpYmxlVGV4dChjKToiIn1mdW5jdGlvbiBsKGEpe2lmKCFhKXJldHVybiExO3N3aXRjaChhLm5vZGVOYW1lKXtjYXNlIlNFTEVDVCI6Y2FzZSJURVhUQVJFQSI6cmV0dXJuITA7Y2FzZSJJTlBVVCI6cmV0dXJuIWEuaGFzQXR0cmlidXRlKCJ0eXBlIil8fC0xIT09eS5pbmRleE9mKGEuZ2V0QXR0cmlidXRlKCJ0eXBlIikpO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIG0oYSl7cmV0dXJuIklOUFVUIj09PWEubm9kZU5hbWUmJiJpbWFnZSI9PT1hLnR5cGV8fC0xIT09WyJJTUciLCJBUFBMRVQiLCJBUkVBIl0uaW5kZXhPZihhLm5vZGVOYW1lKX1mdW5jdGlvbiBuKGEpe3JldHVybiEhdS5zYW5pdGl6ZShhKX12YXIgbz17fSxwPW8uYXJpYT17fSxxPXAuX2x1dD17fTtxLmF0dHJpYnV0ZXM9eyJhcmlhLWFjdGl2ZWRlc2NlbmRhbnQiOnt0eXBlOiJpZHJlZiJ9LCJhcmlhLWF0b21pYyI6e3R5cGU6ImJvb2xlYW4iLHZhbHVlczpbInRydWUiLCJmYWxzZSJdfSwiYXJpYS1hdXRvY29tcGxldGUiOnt0eXBlOiJubXRva2VuIix2YWx1ZXM6WyJpbmxpbmUiLCJsaXN0IiwiYm90aCIsIm5vbmUiXX0sImFyaWEtYnVzeSI6e3R5cGU6ImJvb2xlYW4iLHZhbHVlczpbInRydWUiLCJmYWxzZSJdfSwiYXJpYS1jaGVja2VkIjp7dHlwZToibm10b2tlbiIsdmFsdWVzOlsidHJ1ZSIsImZhbHNlIiwibWl4ZWQiLCJ1bmRlZmluZWQiXX0sImFyaWEtY29sY291bnQiOnt0eXBlOiJpbnQifSwiYXJpYS1jb2xpbmRleCI6e3R5cGU6ImludCJ9LCJhcmlhLWNvbHNwYW4iOnt0eXBlOiJpbnQifSwiYXJpYS1jb250cm9scyI6e3R5cGU6ImlkcmVmcyJ9LCJhcmlhLWRlc2NyaWJlZGJ5Ijp7dHlwZToiaWRyZWZzIn0sImFyaWEtZGlzYWJsZWQiOnt0eXBlOiJib29sZWFuIix2YWx1ZXM6WyJ0cnVlIiwiZmFsc2UiXX0sImFyaWEtZHJvcGVmZmVjdCI6e3R5cGU6Im5tdG9rZW5zIix2YWx1ZXM6WyJjb3B5IiwibW92ZSIsInJlZmVyZW5jZSIsImV4ZWN1dGUiLCJwb3B1cCIsIm5vbmUiXX0sImFyaWEtZXhwYW5kZWQiOnt0eXBlOiJubXRva2VuIix2YWx1ZXM6WyJ0cnVlIiwiZmFsc2UiLCJ1bmRlZmluZWQiXX0sImFyaWEtZmxvd3RvIjp7dHlwZToiaWRyZWZzIn0sImFyaWEtZ3JhYmJlZCI6e3R5cGU6Im5tdG9rZW4iLHZhbHVlczpbInRydWUiLCJmYWxzZSIsInVuZGVmaW5lZCJdfSwiYXJpYS1oYXNwb3B1cCI6e3R5cGU6ImJvb2xlYW4iLHZhbHVlczpbInRydWUiLCJmYWxzZSJdfSwiYXJpYS1oaWRkZW4iOnt0eXBlOiJib29sZWFuIix2YWx1ZXM6WyJ0cnVlIiwiZmFsc2UiXX0sImFyaWEtaW52YWxpZCI6e3R5cGU6Im5tdG9rZW4iLHZhbHVlczpbInRydWUiLCJmYWxzZSIsInNwZWxsaW5nIiwiZ3JhbW1hciJdfSwiYXJpYS1sYWJlbCI6e3R5cGU6InN0cmluZyJ9LCJhcmlhLWxhYmVsbGVkYnkiOnt0eXBlOiJpZHJlZnMifSwiYXJpYS1sZXZlbCI6e3R5cGU6ImludCJ9LCJhcmlhLWxpdmUiOnt0eXBlOiJubXRva2VuIix2YWx1ZXM6WyJvZmYiLCJwb2xpdGUiLCJhc3NlcnRpdmUiXX0sImFyaWEtbXVsdGlsaW5lIjp7dHlwZToiYm9vbGVhbiIsdmFsdWVzOlsidHJ1ZSIsImZhbHNlIl19LCJhcmlhLW11bHRpc2VsZWN0YWJsZSI6e3R5cGU6ImJvb2xlYW4iLHZhbHVlczpbInRydWUiLCJmYWxzZSJdfSwiYXJpYS1vcmllbnRhdGlvbiI6e3R5cGU6Im5tdG9rZW4iLHZhbHVlczpbImhvcml6b250YWwiLCJ2ZXJ0aWNhbCJdfSwiYXJpYS1vd25zIjp7dHlwZToiaWRyZWZzIn0sImFyaWEtcG9zaW5zZXQiOnt0eXBlOiJpbnQifSwiYXJpYS1wcmVzc2VkIjp7dHlwZToibm10b2tlbiIsdmFsdWVzOlsidHJ1ZSIsImZhbHNlIiwibWl4ZWQiLCJ1bmRlZmluZWQiXX0sImFyaWEtcmVhZG9ubHkiOnt0eXBlOiJib29sZWFuIix2YWx1ZXM6WyJ0cnVlIiwiZmFsc2UiXX0sImFyaWEtcmVsZXZhbnQiOnt0eXBlOiJubXRva2VucyIsdmFsdWVzOlsiYWRkaXRpb25zIiwicmVtb3ZhbHMiLCJ0ZXh0IiwiYWxsIl19LCJhcmlhLXJlcXVpcmVkIjp7dHlwZToiYm9vbGVhbiIsdmFsdWVzOlsidHJ1ZSIsImZhbHNlIl19LCJhcmlhLXJvd2NvdW50Ijp7dHlwZToiaW50In0sImFyaWEtcm93aW5kZXgiOnt0eXBlOiJpbnQifSwiYXJpYS1yb3dzcGFuIjp7dHlwZToiaW50In0sImFyaWEtc2VsZWN0ZWQiOnt0eXBlOiJubXRva2VuIix2YWx1ZXM6WyJ0cnVlIiwiZmFsc2UiLCJ1bmRlZmluZWQiXX0sImFyaWEtc2V0c2l6ZSI6e3R5cGU6ImludCJ9LCJhcmlhLXNvcnQiOnt0eXBlOiJubXRva2VuIix2YWx1ZXM6WyJhc2NlbmRpbmciLCJkZXNjZW5kaW5nIiwib3RoZXIiLCJub25lIl19LCJhcmlhLXZhbHVlbWF4Ijp7dHlwZToiZGVjaW1hbCJ9LCJhcmlhLXZhbHVlbWluIjp7dHlwZToiZGVjaW1hbCJ9LCJhcmlhLXZhbHVlbm93Ijp7dHlwZToiZGVjaW1hbCJ9LCJhcmlhLXZhbHVldGV4dCI6e3R5cGU6InN0cmluZyJ9fSxxLmdsb2JhbEF0dHJpYnV0ZXM9WyJhcmlhLWF0b21pYyIsImFyaWEtYnVzeSIsImFyaWEtY29udHJvbHMiLCJhcmlhLWRlc2NyaWJlZGJ5IiwiYXJpYS1kaXNhYmxlZCIsImFyaWEtZHJvcGVmZmVjdCIsImFyaWEtZmxvd3RvIiwiYXJpYS1ncmFiYmVkIiwiYXJpYS1oYXNwb3B1cCIsImFyaWEtaGlkZGVuIiwiYXJpYS1pbnZhbGlkIiwiYXJpYS1sYWJlbCIsImFyaWEtbGFiZWxsZWRieSIsImFyaWEtbGl2ZSIsImFyaWEtb3ducyIsImFyaWEtcmVsZXZhbnQiXSxxLnJvbGU9e2FsZXJ0Ont0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LGFsZXJ0ZGlhbG9nOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LGFwcGxpY2F0aW9uOnt0eXBlOiJsYW5kbWFyayIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbH0sYXJ0aWNsZTp7dHlwZToic3RydWN0dXJlIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsLGltcGxpY2l0OlsiYXJ0aWNsZSJdfSxiYW5uZXI6e3R5cGU6ImxhbmRtYXJrIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxidXR0b246e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiLCJhcmlhLXByZXNzZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpudWxsLGltcGxpY2l0OlsiYnV0dG9uIiwnaW5wdXRbdHlwZT0iYnV0dG9uIl0nLCdpbnB1dFt0eXBlPSJpbWFnZSJdJ119LGNlbGw6e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtY29saW5kZXgiLCJhcmlhLWNvbHNwYW4iLCJhcmlhLXJvd2luZGV4IiwiYXJpYS1yb3dzcGFuIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiLCJjb250ZW50cyJdLGNvbnRleHQ6WyJyb3ciXX0sY2hlY2tib3g6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7cmVxdWlyZWQ6WyJhcmlhLWNoZWNrZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpudWxsLGltcGxpY2l0OlsnaW5wdXRbdHlwZT0iY2hlY2tib3giXSddfSxjb2x1bW5oZWFkZXI6e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiLCJhcmlhLXNvcnQiLCJhcmlhLXJlYWRvbmx5IiwiYXJpYS1zZWxlY3RlZCIsImFyaWEtcmVxdWlyZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpbInJvdyJdfSxjb21ib2JveDp7dHlwZToiY29tcG9zaXRlIixhdHRyaWJ1dGVzOntyZXF1aXJlZDpbImFyaWEtZXhwYW5kZWQiXSxhbGxvd2VkOlsiYXJpYS1hdXRvY29tcGxldGUiLCJhcmlhLXJlcXVpcmVkIiwiYXJpYS1hY3RpdmVkZXNjZW5kYW50Il19LG93bmVkOnthbGw6WyJsaXN0Ym94IiwidGV4dGJveCJdfSxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbH0sY29tbWFuZDp7bmFtZUZyb206WyJhdXRob3IiXSx0eXBlOiJhYnN0cmFjdCJ9LGNvbXBsZW1lbnRhcnk6e3R5cGU6ImxhbmRtYXJrIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsLGltcGxpY2l0OlsiYXNpZGUiXX0sY29tcG9zaXRlOntuYW1lRnJvbTpbImF1dGhvciJdLHR5cGU6ImFic3RyYWN0In0sY29udGVudGluZm86e3R5cGU6ImxhbmRtYXJrIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxkZWZpbml0aW9uOnt0eXBlOiJzdHJ1Y3R1cmUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LGRpYWxvZzp7dHlwZToid2lkZ2V0IixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsLGltcGxpY2l0OlsiZGlhbG9nIl19LGRpcmVjdG9yeTp7dHlwZToic3RydWN0dXJlIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIiwiY29udGVudHMiXSxjb250ZXh0Om51bGx9LGRvY3VtZW50Ont0eXBlOiJzdHJ1Y3R1cmUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGwsaW1wbGljaXQ6WyJib2R5Il19LGZvcm06e3R5cGU6ImxhbmRtYXJrIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxncmlkOnt0eXBlOiJjb21wb3NpdGUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWxldmVsIiwiYXJpYS1tdWx0aXNlbGVjdGFibGUiLCJhcmlhLXJlYWRvbmx5IiwiYXJpYS1hY3RpdmVkZXNjZW5kYW50IiwiYXJpYS1leHBhbmRlZCJdfSxvd25lZDp7b25lOlsicm93Z3JvdXAiLCJyb3ciXX0sbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LGdyaWRjZWxsOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLXNlbGVjdGVkIiwiYXJpYS1yZWFkb25seSIsImFyaWEtZXhwYW5kZWQiLCJhcmlhLXJlcXVpcmVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiLCJjb250ZW50cyJdLGNvbnRleHQ6WyJyb3ciXX0sZ3JvdXA6e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtYWN0aXZlZGVzY2VuZGFudCIsImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbCxpbXBsaWNpdDpbImRldGFpbHMiXX0saGVhZGluZzp7dHlwZToic3RydWN0dXJlIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1sZXZlbCIsImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpudWxsLGltcGxpY2l0OlsiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2Il19LGltZzp7dHlwZToic3RydWN0dXJlIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsLGltcGxpY2l0OlsiaW1nIl19LGlucHV0OntuYW1lRnJvbTpbImF1dGhvciJdLHR5cGU6ImFic3RyYWN0In0sbGFuZG1hcms6e25hbWVGcm9tOlsiYXV0aG9yIl0sdHlwZToiYWJzdHJhY3QifSxsaW5rOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiLCJjb250ZW50cyJdLGNvbnRleHQ6bnVsbCxpbXBsaWNpdDpbImFbaHJlZl0iXX0sbGlzdDp7dHlwZToic3RydWN0dXJlIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDp7YWxsOlsibGlzdGl0ZW0iXX0sbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGwsaW1wbGljaXQ6WyJvbCIsInVsIl19LGxpc3Rib3g6e3R5cGU6ImNvbXBvc2l0ZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtYWN0aXZlZGVzY2VuZGFudCIsImFyaWEtbXVsdGlzZWxlY3RhYmxlIiwiYXJpYS1yZXF1aXJlZCIsImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6e2FsbDpbIm9wdGlvbiJdfSxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbCxpbXBsaWNpdDpbInNlbGVjdCJdfSxsaXN0aXRlbTp7dHlwZToic3RydWN0dXJlIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1sZXZlbCIsImFyaWEtcG9zaW5zZXQiLCJhcmlhLXNldHNpemUiLCJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiLCJjb250ZW50cyJdLGNvbnRleHQ6WyJsaXN0Il0saW1wbGljaXQ6WyJsaSJdfSxsb2c6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbH0sbWFpbjp7dHlwZToibGFuZG1hcmsiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LG1hcnF1ZWU6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbH0sbWF0aDp7dHlwZToic3RydWN0dXJlIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxtZW51Ont0eXBlOiJjb21wb3NpdGUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWFjdGl2ZWRlc2NlbmRhbnQiLCJhcmlhLWV4cGFuZGVkIl19LG93bmVkOntvbmU6WyJtZW51aXRlbSIsIm1lbnVpdGVtcmFkaW8iLCJtZW51aXRlbWNoZWNrYm94Il19LG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxtZW51YmFyOnt0eXBlOiJjb21wb3NpdGUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWFjdGl2ZWRlc2NlbmRhbnQiLCJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LG1lbnVpdGVtOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6bnVsbCxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIiwiY29udGVudHMiXSxjb250ZXh0OlsibWVudSIsIm1lbnViYXIiXX0sbWVudWl0ZW1jaGVja2JveDp7dHlwZToid2lkZ2V0IixhdHRyaWJ1dGVzOntyZXF1aXJlZDpbImFyaWEtY2hlY2tlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIiwiY29udGVudHMiXSxjb250ZXh0OlsibWVudSIsIm1lbnViYXIiXX0sbWVudWl0ZW1yYWRpbzp7dHlwZToid2lkZ2V0IixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1zZWxlY3RlZCIsImFyaWEtcG9zaW5zZXQiLCJhcmlhLXNldHNpemUiXSxyZXF1aXJlZDpbImFyaWEtY2hlY2tlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIiwiY29udGVudHMiXSxjb250ZXh0OlsibWVudSIsIm1lbnViYXIiXX0sbmF2aWdhdGlvbjp7dHlwZToibGFuZG1hcmsiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LG5vbmU6e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczpudWxsLG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LG5vdGU6e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbH0sb3B0aW9uOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLXNlbGVjdGVkIiwiYXJpYS1wb3NpbnNldCIsImFyaWEtc2V0c2l6ZSIsImFyaWEtY2hlY2tlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIiwiY29udGVudHMiXSxjb250ZXh0OlsibGlzdGJveCJdfSxwcmVzZW50YXRpb246e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczpudWxsLG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LHByb2dyZXNzYmFyOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLXZhbHVldGV4dCIsImFyaWEtdmFsdWVub3ciLCJhcmlhLXZhbHVlbWF4IiwiYXJpYS12YWx1ZW1pbiJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxyYWRpbzp7dHlwZToid2lkZ2V0IixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1zZWxlY3RlZCIsImFyaWEtcG9zaW5zZXQiLCJhcmlhLXNldHNpemUiXSxyZXF1aXJlZDpbImFyaWEtY2hlY2tlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIiwiY29udGVudHMiXSxjb250ZXh0Om51bGwsaW1wbGljaXQ6WydpbnB1dFt0eXBlPSJyYWRpbyJdJ119LHJhZGlvZ3JvdXA6e3R5cGU6ImNvbXBvc2l0ZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtYWN0aXZlZGVzY2VuZGFudCIsImFyaWEtcmVxdWlyZWQiLCJhcmlhLWV4cGFuZGVkIl19LG93bmVkOnthbGw6WyJyYWRpbyJdfSxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbH0scmFuZ2U6e25hbWVGcm9tOlsiYXV0aG9yIl0sdHlwZToiYWJzdHJhY3QifSxyZWdpb246e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbCxpbXBsaWNpdDpbInNlY3Rpb24iXX0scm9sZXR5cGU6e3R5cGU6ImFic3RyYWN0In0scm93Ont0eXBlOiJzdHJ1Y3R1cmUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWxldmVsIiwiYXJpYS1zZWxlY3RlZCIsImFyaWEtYWN0aXZlZGVzY2VuZGFudCIsImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6e29uZTpbImNlbGwiLCJjb2x1bW5oZWFkZXIiLCJyb3doZWFkZXIiLCJncmlkY2VsbCJdfSxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpbInJvd2dyb3VwIiwiZ3JpZCIsInRyZWVncmlkIiwidGFibGUiXX0scm93Z3JvdXA6e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtYWN0aXZlZGVzY2VuZGFudCIsImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6e2FsbDpbInJvdyJdfSxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpbImdyaWQiLCJ0YWJsZSJdfSxyb3doZWFkZXI6e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtc29ydCIsImFyaWEtcmVxdWlyZWQiLCJhcmlhLXJlYWRvbmx5IiwiYXJpYS1leHBhbmRlZCIsImFyaWEtc2VsZWN0ZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpbInJvdyJdfSxzY3JvbGxiYXI6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7cmVxdWlyZWQ6WyJhcmlhLWNvbnRyb2xzIiwiYXJpYS1vcmllbnRhdGlvbiIsImFyaWEtdmFsdWVub3ciLCJhcmlhLXZhbHVlbWF4IiwiYXJpYS12YWx1ZW1pbiJdLGFsbG93ZWQ6WyJhcmlhLXZhbHVldGV4dCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxzZWFyY2g6e3R5cGU6ImxhbmRtYXJrIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxzZWFyY2hib3g6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtYWN0aXZlZGVzY2VuZGFudCIsImFyaWEtYXV0b2NvbXBsZXRlIiwiYXJpYS1tdWx0aWxpbmUiLCJhcmlhLXJlYWRvbmx5IiwiYXJpYS1yZXF1aXJlZCJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsLGltcGxpY2l0OlsnaW5wdXRbdHlwZT0ic2VhcmNoIl0nXX0sc2VjdGlvbjp7bmFtZUZyb206WyJhdXRob3IiLCJjb250ZW50cyJdLHR5cGU6ImFic3RyYWN0In0sc2VjdGlvbmhlYWQ6e25hbWVGcm9tOlsiYXV0aG9yIiwiY29udGVudHMiXSx0eXBlOiJhYnN0cmFjdCJ9LHNlbGVjdDp7bmFtZUZyb206WyJhdXRob3IiXSx0eXBlOiJhYnN0cmFjdCJ9LHNlcGFyYXRvcjp7dHlwZToic3RydWN0dXJlIixhdHRyaWJ1dGVzOnthbGxvd2VkOlsiYXJpYS1leHBhbmRlZCIsImFyaWEtb3JpZW50YXRpb24iXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbH0sc2xpZGVyOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLXZhbHVldGV4dCIsImFyaWEtb3JpZW50YXRpb24iXSxyZXF1aXJlZDpbImFyaWEtdmFsdWVub3ciLCJhcmlhLXZhbHVlbWF4IiwiYXJpYS12YWx1ZW1pbiJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxzcGluYnV0dG9uOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLXZhbHVldGV4dCIsImFyaWEtcmVxdWlyZWQiXSxyZXF1aXJlZDpbImFyaWEtdmFsdWVub3ciLCJhcmlhLXZhbHVlbWF4IiwiYXJpYS12YWx1ZW1pbiJdfSxvd25lZDpudWxsLG5hbWVGcm9tOlsiYXV0aG9yIl0sY29udGV4dDpudWxsfSxzdGF0dXM6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbCxpbXBsaWNpdDpbIm91dHB1dCJdfSxzdHJ1Y3R1cmU6e3R5cGU6ImFic3RyYWN0In0sInN3aXRjaCI6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7cmVxdWlyZWQ6WyJhcmlhLWNoZWNrZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpudWxsfSx0YWI6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtc2VsZWN0ZWQiLCJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiLCJjb250ZW50cyJdLGNvbnRleHQ6WyJ0YWJsaXN0Il19LHRhYmxlOnt0eXBlOiJzdHJ1Y3R1cmUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWNvbGNvdW50IiwiYXJpYS1yb3djb3VudCJdfSxvd25lZDp7b25lOlsicm93Z3JvdXAiLCJyb3ciXX0sbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGwsaW1wbGljaXQ6WyJ0YWJsZSJdfSx0YWJsaXN0Ont0eXBlOiJjb21wb3NpdGUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWFjdGl2ZWRlc2NlbmRhbnQiLCJhcmlhLWV4cGFuZGVkIiwiYXJpYS1sZXZlbCIsImFyaWEtbXVsdGlzZWxlY3RhYmxlIl19LG93bmVkOnthbGw6WyJ0YWIiXX0sbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LHRhYnBhbmVsOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LHRleHQ6e3R5cGU6InN0cnVjdHVyZSIsb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpudWxsfSx0ZXh0Ym94Ont0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWFjdGl2ZWRlc2NlbmRhbnQiLCJhcmlhLWF1dG9jb21wbGV0ZSIsImFyaWEtbXVsdGlsaW5lIiwiYXJpYS1yZWFkb25seSIsImFyaWEtcmVxdWlyZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbCxpbXBsaWNpdDpbJ2lucHV0W3R5cGU9InRleHQiXScsImlucHV0Om5vdChbdHlwZV0pIl19LHRpbWVyOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWV4cGFuZGVkIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LHRvb2xiYXI6e3R5cGU6InN0cnVjdHVyZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtYWN0aXZlZGVzY2VuZGFudCIsImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbCxpbXBsaWNpdDpbJ21lbnVbdHlwZT0idG9vbGJhciJdJ119LHRvb2x0aXA6e3R5cGU6IndpZGdldCIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtZXhwYW5kZWQiXX0sb3duZWQ6bnVsbCxuYW1lRnJvbTpbImF1dGhvciIsImNvbnRlbnRzIl0sY29udGV4dDpudWxsfSx0cmVlOnt0eXBlOiJjb21wb3NpdGUiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWFjdGl2ZWRlc2NlbmRhbnQiLCJhcmlhLW11bHRpc2VsZWN0YWJsZSIsImFyaWEtcmVxdWlyZWQiLCJhcmlhLWV4cGFuZGVkIl19LG93bmVkOnthbGw6WyJ0cmVlaXRlbSJdfSxuYW1lRnJvbTpbImF1dGhvciJdLGNvbnRleHQ6bnVsbH0sdHJlZWdyaWQ6e3R5cGU6ImNvbXBvc2l0ZSIsYXR0cmlidXRlczp7YWxsb3dlZDpbImFyaWEtYWN0aXZlZGVzY2VuZGFudCIsImFyaWEtZXhwYW5kZWQiLCJhcmlhLWxldmVsIiwiYXJpYS1tdWx0aXNlbGVjdGFibGUiLCJhcmlhLXJlYWRvbmx5IiwiYXJpYS1yZXF1aXJlZCJdfSxvd25lZDp7YWxsOlsidHJlZWl0ZW0iXX0sbmFtZUZyb206WyJhdXRob3IiXSxjb250ZXh0Om51bGx9LHRyZWVpdGVtOnt0eXBlOiJ3aWRnZXQiLGF0dHJpYnV0ZXM6e2FsbG93ZWQ6WyJhcmlhLWNoZWNrZWQiLCJhcmlhLXNlbGVjdGVkIiwiYXJpYS1leHBhbmRlZCIsImFyaWEtbGV2ZWwiLCJhcmlhLXBvc2luc2V0IiwiYXJpYS1zZXRzaXplIl19LG93bmVkOm51bGwsbmFtZUZyb206WyJhdXRob3IiLCJjb250ZW50cyJdLGNvbnRleHQ6WyJ0cmVlZ3JpZCIsInRyZWUiXX0sd2lkZ2V0Ont0eXBlOiJhYnN0cmFjdCJ9LHdpbmRvdzp7bmFtZUZyb206WyJhdXRob3IiXSx0eXBlOiJhYnN0cmFjdCJ9fTt2YXIgcj17fTtvLmNvbG9yPXI7dmFyIHM9by5kb209e30sdD1vLnRhYmxlPXt9LHU9by50ZXh0PXt9LHY9by51dGlscz17fTt2LmVzY2FwZVNlbGVjdG9yPVMudXRpbHMuZXNjYXBlU2VsZWN0b3Isdi5tYXRjaGVzU2VsZWN0b3I9Uy51dGlscy5tYXRjaGVzU2VsZWN0b3Isdi5jbG9uZT1TLnV0aWxzLmNsb25lLHAucmVxdWlyZWRBdHRyPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYj1xLnJvbGVbYV0sYz1iJiZiLmF0dHJpYnV0ZXMmJmIuYXR0cmlidXRlcy5yZXF1aXJlZDtyZXR1cm4gY3x8W119LHAuYWxsb3dlZEF0dHI9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3ZhciBiPXEucm9sZVthXSxjPWImJmIuYXR0cmlidXRlcyYmYi5hdHRyaWJ1dGVzLmFsbG93ZWR8fFtdLGQ9YiYmYi5hdHRyaWJ1dGVzJiZiLmF0dHJpYnV0ZXMucmVxdWlyZWR8fFtdO3JldHVybiBjLmNvbmNhdChxLmdsb2JhbEF0dHJpYnV0ZXMpLmNvbmNhdChkKX0scC52YWxpZGF0ZUF0dHI9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3JldHVybiEhcS5hdHRyaWJ1dGVzW2FdfSxwLnZhbGlkYXRlQXR0clZhbHVlPWZ1bmN0aW9uKGEsYyl7InVzZSBzdHJpY3QiO3ZhciBkLGUsZixnLGg9YixpPWEuZ2V0QXR0cmlidXRlKGMpLGo9cS5hdHRyaWJ1dGVzW2NdO2lmKCFqKXJldHVybiEwO2lmKGoudmFsdWVzKXJldHVybiJzdHJpbmciPT10eXBlb2YgaSYmLTEhPT1qLnZhbHVlcy5pbmRleE9mKGkudG9Mb3dlckNhc2UoKSk/ITA6ITE7c3dpdGNoKGoudHlwZSl7Y2FzZSJpZHJlZiI6cmV0dXJuISghaXx8IWguZ2V0RWxlbWVudEJ5SWQoaSkpO2Nhc2UiaWRyZWZzIjpmb3IoZD12LnRva2VuTGlzdChpKSxlPTAsZj1kLmxlbmd0aDtmPmU7ZSsrKWlmKGRbZV0mJiFoLmdldEVsZW1lbnRCeUlkKGRbZV0pKXJldHVybiExO3JldHVybiEhZC5sZW5ndGg7Y2FzZSJzdHJpbmciOnJldHVybiEwO2Nhc2UiZGVjaW1hbCI6cmV0dXJuIGc9aS5tYXRjaCgvXlstK10/KFswLTldKilcLj8oWzAtOV0qKSQvKSwhKCFnfHwhZ1sxXSYmIWdbMl0pO2Nhc2UiaW50IjpyZXR1cm4vXlstK10/WzAtOV0rJC8udGVzdChpKX19LHAubGFiZWw9ZnVuY3Rpb24oYSl7dmFyIGIsYztyZXR1cm4gYS5nZXRBdHRyaWJ1dGUoImFyaWEtbGFiZWxsZWRieSIpJiYoYj1zLmlkcmVmcyhhLCJhcmlhLWxhYmVsbGVkYnkiKSxjPWIubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhP3UudmlzaWJsZShhLCEwKToiIn0pLmpvaW4oIiAiKS50cmltKCkpP2M6KGM9YS5nZXRBdHRyaWJ1dGUoImFyaWEtbGFiZWwiKSxjJiYoYz11LnNhbml0aXplKGMpLnRyaW0oKSk/YzpudWxsKX0scC5pc1ZhbGlkUm9sZT1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7cmV0dXJuIHEucm9sZVthXT8hMDohMX0scC5nZXRSb2xlc1dpdGhOYW1lRnJvbUNvbnRlbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHEucm9sZSkuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBxLnJvbGVbYV0ubmFtZUZyb20mJi0xIT09cS5yb2xlW2FdLm5hbWVGcm9tLmluZGV4T2YoImNvbnRlbnRzIil9KX0scC5nZXRSb2xlc0J5VHlwZT1mdW5jdGlvbihhKXtyZXR1cm4gT2JqZWN0LmtleXMocS5yb2xlKS5maWx0ZXIoZnVuY3Rpb24oYil7cmV0dXJuIHEucm9sZVtiXS50eXBlPT09YX0pfSxwLmdldFJvbGVUeXBlPWZ1bmN0aW9uKGEpe3ZhciBiPXEucm9sZVthXTtyZXR1cm4gYiYmYi50eXBlfHxudWxsfSxwLnJlcXVpcmVkT3duZWQ9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3ZhciBiPW51bGwsYz1xLnJvbGVbYV07cmV0dXJuIGMmJihiPXYuY2xvbmUoYy5vd25lZCkpLGJ9LHAucmVxdWlyZWRDb250ZXh0PWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYj1udWxsLGM9cS5yb2xlW2FdO3JldHVybiBjJiYoYj12LmNsb25lKGMuY29udGV4dCkpLGJ9LHAuaW1wbGljaXROb2Rlcz1mdW5jdGlvbihhKXsidXNlIHN0cmljdCI7dmFyIGI9bnVsbCxjPXEucm9sZVthXTtyZXR1cm4gYyYmYy5pbXBsaWNpdCYmKGI9di5jbG9uZShjLmltcGxpY2l0KSksYn0scC5pbXBsaWNpdFJvbGU9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3ZhciBiLGMsZCxlPXEucm9sZTtmb3IoYiBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkoYikmJihjPWVbYl0sYy5pbXBsaWNpdCkpZm9yKHZhciBmPTAsZz1jLmltcGxpY2l0Lmxlbmd0aDtnPmY7ZisrKWlmKGQ9Yy5pbXBsaWNpdFtmXSx2Lm1hdGNoZXNTZWxlY3RvcihhLGQpKXJldHVybiBiO3JldHVybiBudWxsfSxyLkNvbG9yPWZ1bmN0aW9uKGEsYixjLGQpe3RoaXMucmVkPWEsdGhpcy5ncmVlbj1iLHRoaXMuYmx1ZT1jLHRoaXMuYWxwaGE9ZCx0aGlzLnRvSGV4U3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9TWF0aC5yb3VuZCh0aGlzLnJlZCkudG9TdHJpbmcoMTYpLGI9TWF0aC5yb3VuZCh0aGlzLmdyZWVuKS50b1N0cmluZygxNiksYz1NYXRoLnJvdW5kKHRoaXMuYmx1ZSkudG9TdHJpbmcoMTYpO3JldHVybiIjIisodGhpcy5yZWQ+MTUuNT9hOiIwIithKSsodGhpcy5ncmVlbj4xNS41P2I6IjAiK2IpKyh0aGlzLmJsdWU+MTUuNT9jOiIwIitjKX07dmFyIGU9L15yZ2JcKChcZCspLCAoXGQrKSwgKFxkKylcKSQvLGY9L15yZ2JhXCgoXGQrKSwgKFxkKyksIChcZCspLCAoXGQqKFwuXGQrKT8pXCkvO3RoaXMucGFyc2VSZ2JTdHJpbmc9ZnVuY3Rpb24oYSl7dmFyIGI9YS5tYXRjaChlKTtyZXR1cm4gYj8odGhpcy5yZWQ9cGFyc2VJbnQoYlsxXSwxMCksdGhpcy5ncmVlbj1wYXJzZUludChiWzJdLDEwKSx0aGlzLmJsdWU9cGFyc2VJbnQoYlszXSwxMCksdm9pZCh0aGlzLmFscGhhPTEpKTooYj1hLm1hdGNoKGYpLGI/KHRoaXMucmVkPXBhcnNlSW50KGJbMV0sMTApLHRoaXMuZ3JlZW49cGFyc2VJbnQoYlsyXSwxMCksdGhpcy5ibHVlPXBhcnNlSW50KGJbM10sMTApLHZvaWQodGhpcy5hbHBoYT1wYXJzZUZsb2F0KGJbNF0pKSk6dm9pZCAwKX0sdGhpcy5nZXRSZWxhdGl2ZUx1bWluYW5jZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMucmVkLzI1NSxiPXRoaXMuZ3JlZW4vMjU1LGM9dGhpcy5ibHVlLzI1NSxkPS4wMzkyOD49YT9hLzEyLjkyOk1hdGgucG93KChhKy4wNTUpLzEuMDU1LDIuNCksZT0uMDM5Mjg+PWI/Yi8xMi45MjpNYXRoLnBvdygoYisuMDU1KS8xLjA1NSwyLjQpLGY9LjAzOTI4Pj1jP2MvMTIuOTI6TWF0aC5wb3coKGMrLjA1NSkvMS4wNTUsMi40KTtyZXR1cm4uMjEyNipkKy43MTUyKmUrLjA3MjIqZn19LHIuZmxhdHRlbkNvbG9ycz1mdW5jdGlvbihhLGIpe3ZhciBjPWEuYWxwaGEsZD0oMS1jKSpiLnJlZCtjKmEucmVkLGU9KDEtYykqYi5ncmVlbitjKmEuZ3JlZW4sZj0oMS1jKSpiLmJsdWUrYyphLmJsdWUsZz1hLmFscGhhK2IuYWxwaGEqKDEtYS5hbHBoYSk7cmV0dXJuIG5ldyByLkNvbG9yKGQsZSxmLGcpfSxyLmdldENvbnRyYXN0PWZ1bmN0aW9uKGEsYil7aWYoIWJ8fCFhKXJldHVybiBudWxsO2IuYWxwaGE8MSYmKGI9ci5mbGF0dGVuQ29sb3JzKGIsYSkpO3ZhciBjPWEuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKSxkPWIuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtyZXR1cm4oTWF0aC5tYXgoZCxjKSsuMDUpLyhNYXRoLm1pbihkLGMpKy4wNSl9LHIuaGFzVmFsaWRDb250cmFzdFJhdGlvPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXIuZ2V0Q29udHJhc3QoYSxiKSxmPWQmJk1hdGguY2VpbCg3MipjKS85NjwxNHx8IWQmJk1hdGguY2VpbCg3MipjKS85NjwxODtyZXR1cm57aXNWYWxpZDpmJiZlPj00LjV8fCFmJiZlPj0zLGNvbnRyYXN0UmF0aW86ZX19LHMuaXNPcGFxdWU9ZnVuY3Rpb24oYSl7dmFyIGI9YyhhKTtyZXR1cm4gbnVsbD09PWJ8fDE9PT1iLmFscGhhPyEwOiExfTt2YXIgdz1mdW5jdGlvbihjLGQpe2Zvcih2YXIgZSxmLGcsaCxpLGosayxsPVtdLG09ITEsbj1jLG89YS5nZXRDb21wdXRlZFN0eWxlKG4pO251bGwhPT1uJiYoIXMuaXNPcGFxdWUobil8fDA9PT1wYXJzZUludChvLmdldFByb3BlcnR5VmFsdWUoImhlaWdodCIpLDEwKSk7KWc9by5nZXRQcm9wZXJ0eVZhbHVlKCJwb3NpdGlvbiIpLGg9by5nZXRQcm9wZXJ0eVZhbHVlKCJ0b3AiKSxpPW8uZ2V0UHJvcGVydHlWYWx1ZSgiYm90dG9tIiksaj1vLmdldFByb3BlcnR5VmFsdWUoImxlZnQiKSxrPW8uZ2V0UHJvcGVydHlWYWx1ZSgicmlnaHQiKSwoInN0YXRpYyIhPT1nJiYicmVsYXRpdmUiIT09Z3x8InJlbGF0aXZlIj09PWcmJigiYXV0byIhPT1qfHwiYXV0byIhPT1rfHwiYXV0byIhPT1ofHwiYXV0byIhPT1pKSkmJihtPSEwKSxuPW4ucGFyZW50RWxlbWVudCxudWxsIT09biYmKG89YS5nZXRDb21wdXRlZFN0eWxlKG4pLDAhPT1wYXJzZUludChvLmdldFByb3BlcnR5VmFsdWUoImhlaWdodCIpLDEwKSYmbC5wdXNoKG4pKTtpZihtJiZzLnN1cHBvcnRzRWxlbWVudHNGcm9tUG9pbnQoYikpe2lmKGU9cy5lbGVtZW50c0Zyb21Qb2ludChiLE1hdGguY2VpbChkLmxlZnQrMSksTWF0aC5jZWlsKGQudG9wKzEpKSxmPWUuaW5kZXhPZihjKSwtMT09PWYpcmV0dXJuIG51bGw7ZSYmZjxlLmxlbmd0aC0xJiYobD1lLnNsaWNlKGYrMSkpfXJldHVybiBsfTtyLmdldEJhY2tncm91bmRDb2xvcj1mdW5jdGlvbihhLGIpe3ZhciBkLGUsZj1jKGEpO2lmKCFifHxudWxsIT09ZiYmMD09PWYuYWxwaGF8fGIucHVzaChhKSxudWxsPT09Znx8MT09PWYuYWxwaGEpcmV0dXJuIGY7YS5zY3JvbGxJbnRvVmlldygpO3ZhciBnPWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksaD1hLGk9W3tjb2xvcjpmLG5vZGU6YX1dLGo9dyhoLGcpO2lmKCFqKXJldHVybiBudWxsO2Zvcig7MSE9PWYuYWxwaGE7KXtpZihkPWouc2hpZnQoKSwhZCYmIkhUTUwiIT09aC50YWdOYW1lKXJldHVybiBudWxsO2lmKGR8fCJIVE1MIiE9PWgudGFnTmFtZSl7aWYoIXMudmlzdWFsbHlDb250YWlucyhhLGQpKXJldHVybiBudWxsO2lmKGU9YyhkKSwhYnx8bnVsbCE9PWUmJjA9PT1lLmFscGhhfHxiLnB1c2goZCksbnVsbD09PWUpcmV0dXJuIG51bGx9ZWxzZSBlPW5ldyByLkNvbG9yKDI1NSwyNTUsMjU1LDEpO2g9ZCxmPWUsaS5wdXNoKHtjb2xvcjpmLG5vZGU6aH0pfWZvcih2YXIgaz1pLnBvcCgpLGw9ay5jb2xvcjt2b2lkIDAhPT0oaz1pLnBvcCgpKTspbD1yLmZsYXR0ZW5Db2xvcnMoay5jb2xvcixsKTtyZXR1cm4gbH0sci5nZXRGb3JlZ3JvdW5kQ29sb3I9ZnVuY3Rpb24oYil7dmFyIGM9YS5nZXRDb21wdXRlZFN0eWxlKGIpLGQ9bmV3IHIuQ29sb3I7ZC5wYXJzZVJnYlN0cmluZyhjLmdldFByb3BlcnR5VmFsdWUoImNvbG9yIikpO3ZhciBlPWMuZ2V0UHJvcGVydHlWYWx1ZSgib3BhY2l0eSIpO2lmKGQuYWxwaGE9ZC5hbHBoYSplLDE9PT1kLmFscGhhKXJldHVybiBkO3ZhciBmPXIuZ2V0QmFja2dyb3VuZENvbG9yKGIpO3JldHVybiBudWxsPT09Zj9udWxsOnIuZmxhdHRlbkNvbG9ycyhkLGYpfSxzLnN1cHBvcnRzRWxlbWVudHNGcm9tUG9pbnQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5jcmVhdGVFbGVtZW50KCJ4Iik7cmV0dXJuIGIuc3R5bGUuY3NzVGV4dD0icG9pbnRlci1ldmVudHM6YXV0byIsImF1dG8iPT09Yi5zdHlsZS5wb2ludGVyRXZlbnRzfHwhIWEubXNFbGVtZW50c0Zyb21Qb2ludH0scy5lbGVtZW50c0Zyb21Qb2ludD1mdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGc9W10saD1bXTtpZihhLm1zRWxlbWVudHNGcm9tUG9pbnQpe3ZhciBpPWEubXNFbGVtZW50c0Zyb21Qb2ludChiLGMpO3JldHVybiBpP0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGkpOm51bGw7Cn1mb3IoOyhkPWEuZWxlbWVudEZyb21Qb2ludChiLGMpKSYmLTE9PT1nLmluZGV4T2YoZCkmJm51bGwhPT1kJiYoZy5wdXNoKGQpLGgucHVzaCh7dmFsdWU6ZC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCJwb2ludGVyLWV2ZW50cyIpLHByaW9yaXR5OmQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgicG9pbnRlci1ldmVudHMiKX0pLGQuc3R5bGUuc2V0UHJvcGVydHkoInBvaW50ZXItZXZlbnRzIiwibm9uZSIsImltcG9ydGFudCIpLCFzLmlzT3BhcXVlKGQpKTspO2ZvcihlPWgubGVuZ3RoO2Y9aFstLWVdOylnW2VdLnN0eWxlLnNldFByb3BlcnR5KCJwb2ludGVyLWV2ZW50cyIsZi52YWx1ZT9mLnZhbHVlOiIiLGYucHJpb3JpdHkpO3JldHVybiBnfSxzLmZpbmRVcD1mdW5jdGlvbihhLGMpeyJ1c2Ugc3RyaWN0Ijt2YXIgZCxlPWIucXVlcnlTZWxlY3RvckFsbChjKSxmPWUubGVuZ3RoO2lmKCFmKXJldHVybiBudWxsO2ZvcihlPXYudG9BcnJheShlKSxkPWEucGFyZW50Tm9kZTtkJiYtMT09PWUuaW5kZXhPZihkKTspZD1kLnBhcmVudE5vZGU7cmV0dXJuIGR9LHMuZ2V0RWxlbWVudEJ5UmVmZXJlbmNlPWZ1bmN0aW9uKGEsYyl7InVzZSBzdHJpY3QiO3ZhciBkLGU9YS5nZXRBdHRyaWJ1dGUoYyksZj1iO2lmKGUmJiIjIj09PWUuY2hhckF0KDApKXtpZihlPWUuc3Vic3RyaW5nKDEpLGQ9Zi5nZXRFbGVtZW50QnlJZChlKSlyZXR1cm4gZDtpZihkPWYuZ2V0RWxlbWVudHNCeU5hbWUoZSksZC5sZW5ndGgpcmV0dXJuIGRbMF19cmV0dXJuIG51bGx9LHMuZ2V0RWxlbWVudENvb3JkaW5hdGVzPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYz1zLmdldFNjcm9sbE9mZnNldChiKSxkPWMubGVmdCxlPWMudG9wLGY9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtyZXR1cm57dG9wOmYudG9wK2UscmlnaHQ6Zi5yaWdodCtkLGJvdHRvbTpmLmJvdHRvbStlLGxlZnQ6Zi5sZWZ0K2Qsd2lkdGg6Zi5yaWdodC1mLmxlZnQsaGVpZ2h0OmYuYm90dG9tLWYudG9wfX0scy5nZXRTY3JvbGxPZmZzZXQ9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO2lmKCFhLm5vZGVUeXBlJiZhLmRvY3VtZW50JiYoYT1hLmRvY3VtZW50KSw5PT09YS5ub2RlVHlwZSl7dmFyIGI9YS5kb2N1bWVudEVsZW1lbnQsYz1hLmJvZHk7cmV0dXJue2xlZnQ6YiYmYi5zY3JvbGxMZWZ0fHxjJiZjLnNjcm9sbExlZnR8fDAsdG9wOmImJmIuc2Nyb2xsVG9wfHxjJiZjLnNjcm9sbFRvcHx8MH19cmV0dXJue2xlZnQ6YS5zY3JvbGxMZWZ0LHRvcDphLnNjcm9sbFRvcH19LHMuZ2V0Vmlld3BvcnRTaXplPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijt2YXIgYixjPWEuZG9jdW1lbnQsZD1jLmRvY3VtZW50RWxlbWVudDtyZXR1cm4gYS5pbm5lcldpZHRoP3t3aWR0aDphLmlubmVyV2lkdGgsaGVpZ2h0OmEuaW5uZXJIZWlnaHR9OmQ/e3dpZHRoOmQuY2xpZW50V2lkdGgsaGVpZ2h0OmQuY2xpZW50SGVpZ2h0fTooYj1jLmJvZHkse3dpZHRoOmIuY2xpZW50V2lkdGgsaGVpZ2h0OmIuY2xpZW50SGVpZ2h0fSl9LHMuaWRyZWZzPWZ1bmN0aW9uKGEsYyl7InVzZSBzdHJpY3QiO3ZhciBkLGUsZj1iLGc9W10saD1hLmdldEF0dHJpYnV0ZShjKTtpZihoKWZvcihoPXYudG9rZW5MaXN0KGgpLGQ9MCxlPWgubGVuZ3RoO2U+ZDtkKyspZy5wdXNoKGYuZ2V0RWxlbWVudEJ5SWQoaFtkXSkpO3JldHVybiBnfSxzLmlzRm9jdXNhYmxlPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0IjtpZighYXx8YS5kaXNhYmxlZHx8IXMuaXNWaXNpYmxlKGEpJiYiQVJFQSIhPT1hLm5vZGVOYW1lKXJldHVybiExO3N3aXRjaChhLm5vZGVOYW1lKXtjYXNlIkEiOmNhc2UiQVJFQSI6aWYoYS5ocmVmKXJldHVybiEwO2JyZWFrO2Nhc2UiSU5QVVQiOnJldHVybiJoaWRkZW4iIT09YS50eXBlO2Nhc2UiVEVYVEFSRUEiOmNhc2UiU0VMRUNUIjpjYXNlIkRFVEFJTFMiOmNhc2UiQlVUVE9OIjpyZXR1cm4hMH12YXIgYj1hLmdldEF0dHJpYnV0ZSgidGFiaW5kZXgiKTtyZXR1cm4gYiYmIWlzTmFOKHBhcnNlSW50KGIsMTApKT8hMDohMX0scy5pc0hUTUw1PWZ1bmN0aW9uKGEpe3ZhciBiPWEuZG9jdHlwZTtyZXR1cm4gbnVsbD09PWI/ITE6Imh0bWwiPT09Yi5uYW1lJiYhYi5wdWJsaWNJZCYmIWIuc3lzdGVtSWR9LHMuaXNOb2RlPWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0IjtyZXR1cm4gYSBpbnN0YW5jZW9mIE5vZGV9LHMuaXNPZmZzY3JlZW49ZnVuY3Rpb24oYyl7InVzZSBzdHJpY3QiO3ZhciBkLGU9Yi5kb2N1bWVudEVsZW1lbnQsZj1hLmdldENvbXB1dGVkU3R5bGUoYi5ib2R5fHxlKS5nZXRQcm9wZXJ0eVZhbHVlKCJkaXJlY3Rpb24iKSxnPXMuZ2V0RWxlbWVudENvb3JkaW5hdGVzKGMpO2lmKGcuYm90dG9tPDApcmV0dXJuITA7aWYoImx0ciI9PT1mKXtpZihnLnJpZ2h0PDApcmV0dXJuITB9ZWxzZSBpZihkPU1hdGgubWF4KGUuc2Nyb2xsV2lkdGgscy5nZXRWaWV3cG9ydFNpemUoYSkud2lkdGgpLGcubGVmdD5kKXJldHVybiEwO3JldHVybiExfSxzLmlzVmlzaWJsZT1mdW5jdGlvbihiLGMsZSl7InVzZSBzdHJpY3QiO3ZhciBmLGc9Yi5ub2RlTmFtZSxoPWIucGFyZW50Tm9kZTtyZXR1cm4gOT09PWIubm9kZVR5cGU/ITA6KGY9YS5nZXRDb21wdXRlZFN0eWxlKGIsbnVsbCksbnVsbD09PWY/ITE6Im5vbmUiPT09Zi5nZXRQcm9wZXJ0eVZhbHVlKCJkaXNwbGF5Iil8fCJTVFlMRSI9PT1nfHwiU0NSSVBUIj09PWd8fCFjJiZkKGYuZ2V0UHJvcGVydHlWYWx1ZSgiY2xpcCIpKXx8IWUmJigiaGlkZGVuIj09PWYuZ2V0UHJvcGVydHlWYWx1ZSgidmlzaWJpbGl0eSIpfHwhYyYmcy5pc09mZnNjcmVlbihiKSl8fGMmJiJ0cnVlIj09PWIuZ2V0QXR0cmlidXRlKCJhcmlhLWhpZGRlbiIpPyExOmg/cy5pc1Zpc2libGUoaCxjLCEwKTohMSl9LHMuaXNWaXN1YWxDb250ZW50PWZ1bmN0aW9uKGEpeyJ1c2Ugc3RyaWN0Ijtzd2l0Y2goYS50YWdOYW1lLnRvVXBwZXJDYXNlKCkpe2Nhc2UiSU1HIjpjYXNlIklGUkFNRSI6Y2FzZSJPQkpFQ1QiOmNhc2UiVklERU8iOmNhc2UiQVVESU8iOmNhc2UiQ0FOVkFTIjpjYXNlIlNWRyI6Y2FzZSJNQVRIIjpjYXNlIkJVVFRPTiI6Y2FzZSJTRUxFQ1QiOmNhc2UiVEVYVEFSRUEiOmNhc2UiS0VZR0VOIjpjYXNlIlBST0dSRVNTIjpjYXNlIk1FVEVSIjpyZXR1cm4hMDtjYXNlIklOUFVUIjpyZXR1cm4iaGlkZGVuIiE9PWEudHlwZTtkZWZhdWx0OnJldHVybiExfX0scy52aXN1YWxseUNvbnRhaW5zPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9Yi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxlPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZj1lLnRvcCxnPWUubGVmdCxoPXt0b3A6Zi1jLnNjcm9sbFRvcCxib3R0b206Zi1jLnNjcm9sbFRvcCtjLnNjcm9sbEhlaWdodCxsZWZ0OmctYy5zY3JvbGxMZWZ0LHJpZ2h0OmctYy5zY3JvbGxMZWZ0K2Muc2Nyb2xsV2lkdGh9O2lmKGQubGVmdDxoLmxlZnQmJmQubGVmdDxlLmxlZnR8fGQudG9wPGgudG9wJiZkLnRvcDxlLnRvcHx8ZC5yaWdodD5oLnJpZ2h0JiZkLnJpZ2h0PmUucmlnaHR8fGQuYm90dG9tPmguYm90dG9tJiZkLmJvdHRvbT5lLmJvdHRvbSlyZXR1cm4hMTt2YXIgaT1hLmdldENvbXB1dGVkU3R5bGUoYyk7cmV0dXJuIGQucmlnaHQ+ZS5yaWdodHx8ZC5ib3R0b20+ZS5ib3R0b20/InNjcm9sbCI9PT1pLm92ZXJmbG93fHwiYXV0byI9PT1pLm92ZXJmbG93fHwiaGlkZGVuIj09PWkub3ZlcmZsb3d8fGMgaW5zdGFuY2VvZiBIVE1MQm9keUVsZW1lbnR8fGMgaW5zdGFuY2VvZiBIVE1MSHRtbEVsZW1lbnQ6ITB9LHMudmlzdWFsbHlPdmVybGFwcz1mdW5jdGlvbihiLGMpe3ZhciBkPWMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksZT1kLnRvcCxmPWQubGVmdCxnPXt0b3A6ZS1jLnNjcm9sbFRvcCxib3R0b206ZS1jLnNjcm9sbFRvcCtjLnNjcm9sbEhlaWdodCxsZWZ0OmYtYy5zY3JvbGxMZWZ0LHJpZ2h0OmYtYy5zY3JvbGxMZWZ0K2Muc2Nyb2xsV2lkdGh9O2lmKGIubGVmdD5nLnJpZ2h0JiZiLmxlZnQ+ZC5yaWdodHx8Yi50b3A+Zy5ib3R0b20mJmIudG9wPmQuYm90dG9tfHxiLnJpZ2h0PGcubGVmdCYmYi5yaWdodDxkLmxlZnR8fGIuYm90dG9tPGcudG9wJiZiLmJvdHRvbTxkLnRvcClyZXR1cm4hMTt2YXIgaD1hLmdldENvbXB1dGVkU3R5bGUoYyk7cmV0dXJuIGIubGVmdD5kLnJpZ2h0fHxiLnRvcD5kLmJvdHRvbT8ic2Nyb2xsIj09PWgub3ZlcmZsb3d8fCJhdXRvIj09PWgub3ZlcmZsb3d8fGMgaW5zdGFuY2VvZiBIVE1MQm9keUVsZW1lbnR8fGMgaW5zdGFuY2VvZiBIVE1MSHRtbEVsZW1lbnQ6ITB9LHQuZ2V0Q2VsbFBvc2l0aW9uPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjPXQudG9BcnJheShzLmZpbmRVcChhLCJ0YWJsZSIpKSxkPTA7ZDxjLmxlbmd0aDtkKyspaWYoY1tkXSYmKGI9Y1tkXS5pbmRleE9mKGEpLC0xIT09YikpcmV0dXJue3g6Yix5OmR9fSx0LmdldEhlYWRlcnM9ZnVuY3Rpb24oYSl7aWYoYS5nZXRBdHRyaWJ1dGUoImhlYWRlcnMiKSlyZXR1cm4gby5kb20uaWRyZWZzKGEsImhlYWRlcnMiKTtmb3IodmFyIGIsYz1bXSxkPW8udGFibGUudG9BcnJheShvLmRvbS5maW5kVXAoYSwidGFibGUiKSksZT1vLnRhYmxlLmdldENlbGxQb3NpdGlvbihhKSxmPWUueC0xO2Y+PTA7Zi0tKWI9ZFtlLnldW2ZdLG8udGFibGUuaXNSb3dIZWFkZXIoYikmJmMudW5zaGlmdChiKTtmb3IodmFyIGc9ZS55LTE7Zz49MDtnLS0pYj1kW2ddW2UueF0sYiYmby50YWJsZS5pc0NvbHVtbkhlYWRlcihiKSYmYy51bnNoaWZ0KGIpO3JldHVybiBjfSx0LmlzQ29sdW1uSGVhZGVyPWZ1bmN0aW9uKGEpe3ZhciBiPWEuZ2V0QXR0cmlidXRlKCJzY29wZSIpO2lmKCJjb2wiPT09YilyZXR1cm4hMDtpZihifHwiVEgiIT09YS5ub2RlTmFtZSlyZXR1cm4hMTtmb3IodmFyIGMsZD10LmdldENlbGxQb3NpdGlvbihhKSxlPXQudG9BcnJheShzLmZpbmRVcChhLCJ0YWJsZSIpKSxmPWVbZC55XSxnPTAsaD1mLmxlbmd0aDtoPmc7ZysrKWlmKGM9ZltnXSxjIT09YSYmdC5pc0RhdGFDZWxsKGMpKXJldHVybiExO3JldHVybiEwfSx0LmlzRGF0YUNlbGw9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuY2hpbGRyZW4ubGVuZ3RofHxhLnRleHRDb250ZW50LnRyaW0oKT8iVEQiPT09YS5ub2RlTmFtZTohMX0sdC5pc0RhdGFUYWJsZT1mdW5jdGlvbihiKXt2YXIgYz1iLmdldEF0dHJpYnV0ZSgicm9sZSIpO2lmKCgicHJlc2VudGF0aW9uIj09PWN8fCJub25lIj09PWMpJiYhcy5pc0ZvY3VzYWJsZShiKSlyZXR1cm4hMTtpZigidHJ1ZSI9PT1iLmdldEF0dHJpYnV0ZSgiY29udGVudGVkaXRhYmxlIil8fHMuZmluZFVwKGIsJ1tjb250ZW50ZWRpdGFibGU9InRydWUiXScpKXJldHVybiEwO2lmKCJncmlkIj09PWN8fCJ0cmVlZ3JpZCI9PT1jfHwidGFibGUiPT09YylyZXR1cm4hMDtpZigibGFuZG1hcmsiPT09by5hcmlhLmdldFJvbGVUeXBlKGMpKXJldHVybiEwO2lmKCIwIj09PWIuZ2V0QXR0cmlidXRlKCJkYXRhdGFibGUiKSlyZXR1cm4hMTtpZihiLmdldEF0dHJpYnV0ZSgic3VtbWFyeSIpKXJldHVybiEwO2lmKGIudEhlYWR8fGIudEZvb3R8fGIuY2FwdGlvbilyZXR1cm4hMDtmb3IodmFyIGQ9MCxlPWIuY2hpbGRyZW4ubGVuZ3RoO2U+ZDtkKyspaWYoIkNPTEdST1VQIj09PWIuY2hpbGRyZW5bZF0ubm9kZU5hbWUpcmV0dXJuITA7Zm9yKHZhciBmLGcsaD0wLGk9Yi5yb3dzLmxlbmd0aCxqPSExLGs9MDtpPms7aysrKXtmPWIucm93c1trXTtmb3IodmFyIGw9MCxtPWYuY2VsbHMubGVuZ3RoO20+bDtsKyspe2lmKGc9Zi5jZWxsc1tsXSxqfHxnLm9mZnNldFdpZHRoPT09Zy5jbGllbnRXaWR0aCYmZy5vZmZzZXRIZWlnaHQ9PT1nLmNsaWVudEhlaWdodHx8KGo9ITApLGcuZ2V0QXR0cmlidXRlKCJzY29wZSIpfHxnLmdldEF0dHJpYnV0ZSgiaGVhZGVycyIpfHxnLmdldEF0dHJpYnV0ZSgiYWJiciIpKXJldHVybiEwO2lmKCJUSCI9PT1nLm5vZGVOYW1lKXJldHVybiEwO2lmKDE9PT1nLmNoaWxkcmVuLmxlbmd0aCYmIkFCQlIiPT09Zy5jaGlsZHJlblswXS5ub2RlTmFtZSlyZXR1cm4hMDtoKyt9fWlmKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoInRhYmxlIikubGVuZ3RoKXJldHVybiExO2lmKDI+aSlyZXR1cm4hMTt2YXIgbj1iLnJvd3NbTWF0aC5jZWlsKGkvMildO2lmKDE9PT1uLmNlbGxzLmxlbmd0aCYmMT09PW4uY2VsbHNbMF0uY29sU3BhbilyZXR1cm4hMTtpZihuLmNlbGxzLmxlbmd0aD49NSlyZXR1cm4hMDtpZihqKXJldHVybiEwO3ZhciBwLHE7Zm9yKGs9MDtpPms7aysrKXtpZihmPWIucm93c1trXSxwJiZwIT09YS5nZXRDb21wdXRlZFN0eWxlKGYpLmdldFByb3BlcnR5VmFsdWUoImJhY2tncm91bmQtY29sb3IiKSlyZXR1cm4hMDtpZihwPWEuZ2V0Q29tcHV0ZWRTdHlsZShmKS5nZXRQcm9wZXJ0eVZhbHVlKCJiYWNrZ3JvdW5kLWNvbG9yIikscSYmcSE9PWEuZ2V0Q29tcHV0ZWRTdHlsZShmKS5nZXRQcm9wZXJ0eVZhbHVlKCJiYWNrZ3JvdW5kLWltYWdlIikpcmV0dXJuITA7cT1hLmdldENvbXB1dGVkU3R5bGUoZikuZ2V0UHJvcGVydHlWYWx1ZSgiYmFja2dyb3VuZC1pbWFnZSIpfXJldHVybiBpPj0yMD8hMDpzLmdldEVsZW1lbnRDb29yZGluYXRlcyhiKS53aWR0aD4uOTUqcy5nZXRWaWV3cG9ydFNpemUoYSkud2lkdGg/ITE6MTA+aD8hMTpiLnF1ZXJ5U2VsZWN0b3IoIm9iamVjdCwgZW1iZWQsIGlmcmFtZSwgYXBwbGV0Iik/ITE6ITB9LHQuaXNIZWFkZXI9ZnVuY3Rpb24oYSl7cmV0dXJuIHQuaXNDb2x1bW5IZWFkZXIoYSl8fHQuaXNSb3dIZWFkZXIoYSk/ITA6YS5pZD8hIWIucXVlcnlTZWxlY3RvcignW2hlYWRlcnN+PSInK3YuZXNjYXBlU2VsZWN0b3IoYS5pZCkrJyJdJyk6ITF9LHQuaXNSb3dIZWFkZXI9ZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRBdHRyaWJ1dGUoInNjb3BlIik7aWYoInJvdyI9PT1iKXJldHVybiEwO2lmKGJ8fCJUSCIhPT1hLm5vZGVOYW1lKXJldHVybiExO2lmKHQuaXNDb2x1bW5IZWFkZXIoYSkpcmV0dXJuITE7Zm9yKHZhciBjLGQ9dC5nZXRDZWxsUG9zaXRpb24oYSksZT10LnRvQXJyYXkocy5maW5kVXAoYSwidGFibGUiKSksZj0wLGc9ZS5sZW5ndGg7Zz5mO2YrKylpZihjPWVbZl1bZC54XSxjIT09YSYmdC5pc0RhdGFDZWxsKGMpKXJldHVybiExO3JldHVybiEwfSx0LnRvQXJyYXk9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9YS5yb3dzLGQ9MCxlPWMubGVuZ3RoO2U+ZDtkKyspe3ZhciBmPWNbZF0uY2VsbHM7YltkXT1iW2RdfHxbXTtmb3IodmFyIGc9MCxoPTAsaT1mLmxlbmd0aDtpPmg7aCsrKWZvcih2YXIgaj0wO2o8ZltoXS5jb2xTcGFuO2orKyl7Zm9yKHZhciBrPTA7azxmW2hdLnJvd1NwYW47aysrKXtmb3IoYltkK2tdPWJbZCtrXXx8W107YltkK2tdW2ddOylnKys7YltkK2tdW2ddPWZbaF19ZysrfX1yZXR1cm4gYn07dmFyIHg9e3N1Ym1pdDoiU3VibWl0IixyZXNldDoiUmVzZXQifSx5PVsidGV4dCIsInNlYXJjaCIsInRlbCIsInVybCIsImVtYWlsIiwiZGF0ZSIsInRpbWUiLCJudW1iZXIiLCJyYW5nZSIsImNvbG9yIl0sej1bImEiLCJlbSIsInN0cm9uZyIsInNtYWxsIiwibWFyayIsImFiYnIiLCJkZm4iLCJpIiwiYiIsInMiLCJ1IiwiY29kZSIsInZhciIsInNhbXAiLCJrYmQiLCJzdXAiLCJzdWIiLCJxIiwiY2l0ZSIsInNwYW4iLCJiZG8iLCJiZGkiLCJiciIsIndiciIsImlucyIsImRlbCIsImltZyIsImVtYmVkIiwib2JqZWN0IiwiaWZyYW1lIiwibWFwIiwiYXJlYSIsInNjcmlwdCIsIm5vc2NyaXB0IiwicnVieSIsInZpZGVvIiwiYXVkaW8iLCJpbnB1dCIsInRleHRhcmVhIiwic2VsZWN0IiwiYnV0dG9uIiwibGFiZWwiLCJvdXRwdXQiLCJkYXRhbGlzdCIsImtleWdlbiIsInByb2dyZXNzIiwiY29tbWFuZCIsImNhbnZhcyIsInRpbWUiLCJtZXRlciJdO3JldHVybiB1LmFjY2Vzc2libGVUZXh0PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxiLGMpe3ZhciBpPSIiO2lmKGgoYSkmJihpPWQoYSwhMSwhMSl8fCIiLG4oaSkpKXJldHVybiBpO2lmKCJGSUdVUkUiPT09YS5ub2RlTmFtZSYmKGk9ayhhLCJmaWdjYXB0aW9uIiksbihpKSkpcmV0dXJuIGk7aWYoIlRBQkxFIj09PWEubm9kZU5hbWUpe2lmKGk9ayhhLCJjYXB0aW9uIiksbihpKSlyZXR1cm4gaTtpZihpPWEuZ2V0QXR0cmlidXRlKCJ0aXRsZSIpfHxhLmdldEF0dHJpYnV0ZSgic3VtbWFyeSIpfHwiIixuKGkpKXJldHVybiBpfWlmKG0oYSkpcmV0dXJuIGEuZ2V0QXR0cmlidXRlKCJhbHQiKXx8IiI7aWYoZyhhKSYmIWMpe2lmKGYoYSkpcmV0dXJuIGEudmFsdWV8fGEudGl0bGV8fHhbYS50eXBlXXx8IiI7dmFyIGo9ZShhKTtpZihqKXJldHVybiBvKGosYiwhMCl9cmV0dXJuIiJ9ZnVuY3Rpb24gYyhhLGIsYyl7cmV0dXJuIWImJmEuaGFzQXR0cmlidXRlKCJhcmlhLWxhYmVsbGVkYnkiKT91LnNhbml0aXplKHMuaWRyZWZzKGEsImFyaWEtbGFiZWxsZWRieSIpLm1hcChmdW5jdGlvbihiKXtyZXR1cm4gYT09PWImJnEucG9wKCksbyhiLCEwLGEhPT1iKX0pLmpvaW4oIiAiKSk6YyYmbChhKXx8IWEuaGFzQXR0cmlidXRlKCJhcmlhLWxhYmVsIik/IiI6dS5zYW5pdGl6ZShhLmdldEF0dHJpYnV0ZSgiYXJpYS1sYWJlbCIpKX1mdW5jdGlvbiBkKGEsYixjKXtmb3IodmFyIGQsZT1hLmNoaWxkTm9kZXMsZj0iIixnPTA7ZzxlLmxlbmd0aDtnKyspZD1lW2ddLDM9PT1kLm5vZGVUeXBlP2YrPWQudGV4dENvbnRlbnQ6MT09PWQubm9kZVR5cGUmJigtMT09PXouaW5kZXhPZihkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpJiYoZis9IiAiKSxmKz1vKGVbZ10sYixjKSk7cmV0dXJuIGZ9ZnVuY3Rpb24gbyhhLGUsZil7InVzZSBzdHJpY3QiO3ZhciBnPSIiO2lmKG51bGw9PT1hfHwhcy5pc1Zpc2libGUoYSwhMCl8fC0xIT09cS5pbmRleE9mKGEpKXJldHVybiIiO3EucHVzaChhKTt2YXIgaD1hLmdldEF0dHJpYnV0ZSgicm9sZSIpO3JldHVybiBnKz1jKGEsZSxmKSxuKGcpP2c6KGc9YihhLGUsZiksbihnKT9nOmYmJihnKz1qKGEpLG4oZykpP2c6aShhKXx8aCYmLTE9PT1wLmdldFJvbGVzV2l0aE5hbWVGcm9tQ29udGVudHMoKS5pbmRleE9mKGgpfHwoZz1kKGEsZSxmKSwhbihnKSk/YS5oYXNBdHRyaWJ1dGUoInRpdGxlIik/YS5nZXRBdHRyaWJ1dGUoInRpdGxlIik6IiI6Zyl9dmFyIHE9W107cmV0dXJuIHUuc2FuaXRpemUobyhhKSl9LHUubGFiZWw9ZnVuY3Rpb24oYSl7dmFyIGMsZDtyZXR1cm4oZD1wLmxhYmVsKGEpKT9kOmEuaWQmJihjPWIucXVlcnlTZWxlY3RvcignbGFiZWxbZm9yPSInK3YuZXNjYXBlU2VsZWN0b3IoYS5pZCkrJyJdJyksZD1jJiZ1LnZpc2libGUoYywhMCkpP2Q6KGM9cy5maW5kVXAoYSwibGFiZWwiKSxkPWMmJnUudmlzaWJsZShjLCEwKSxkP2Q6bnVsbCl9LHUuc2FuaXRpemU9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3JldHVybiBhLnJlcGxhY2UoL1xyXG4vZywiXG4iKS5yZXBsYWNlKC9cdTAwQTAvZywiICIpLnJlcGxhY2UoL1tcc117Mix9L2csIiAiKS50cmltKCl9LHUudmlzaWJsZT1mdW5jdGlvbihhLGIsYyl7InVzZSBzdHJpY3QiO3ZhciBkLGUsZixnPWEuY2hpbGROb2RlcyxoPWcubGVuZ3RoLGk9IiI7Zm9yKGQ9MDtoPmQ7ZCsrKWU9Z1tkXSwzPT09ZS5ub2RlVHlwZT8oZj1lLm5vZGVWYWx1ZSxmJiZzLmlzVmlzaWJsZShhLGIpJiYoaSs9ZS5ub2RlVmFsdWUpKTpjfHwoaSs9dS52aXNpYmxlKGUsYikpO3JldHVybiB1LnNhbml0aXplKGkpfSx2LnRvQXJyYXk9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3JldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKX0sdi50b2tlbkxpc3Q9ZnVuY3Rpb24oYSl7InVzZSBzdHJpY3QiO3JldHVybiBhLnRyaW0oKS5yZXBsYWNlKC9cc3syLH0vZywiICIpLnNwbGl0KCIgIil9LG99KCl9KSxTLnZlcnNpb249IjEuMS4xIn0od2luZG93LHdpbmRvdy5kb2N1bWVudCk7","base64");

// This is run in the page, not Lighthouse itself.
/* istanbul ignore next */
function runA11yChecks() {
  return new Promise((resolve, reject) => {
    axe.a11yCheck(document, resolve);
  });
}

class Accessibility extends Gatherer {
  static _errorAccessibility(errorString) {
    return {
      raw: undefined,
      value: undefined,
      debugString: errorString
    };
  }

  afterPass(options) {
    const driver = options.driver;

    return driver
        .evaluateAsync(`${axe};(${runA11yChecks.toString()}())`)
        .then(returnedValue => {
          if (!returnedValue) {
            this.artifact = Accessibility._errorAccessibility('Unable to parse axe results');
            return;
          }

          if (returnedValue.error) {
            this.artifact = Accessibility._errorAccessibility(returnedValue.error);
          } else {
            this.artifact = returnedValue;
          }
        }, _ => {
          this.artifact = Accessibility._errorAccessibility('Axe results timed out');
        });
  }
}

module.exports = Accessibility;

}).call(this,require("buffer").Buffer)
},{"./gatherer":"./gatherers/gatherer","buffer":194}],"./gatherers/cache-contents":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/* global caches */

const Gatherer = require('./gatherer');

// This is run in the page, not Lighthouse itself.
/* istanbul ignore next */
function getCacheContents() {
  // Get every cache by name.
  return caches.keys()

      // Open each one.
      .then(cacheNames => Promise.all(cacheNames.map(cacheName => caches.open(cacheName))))

      .then(caches => {
        const requests = [];

        // Take each cache and get any requests is contains, and bounce each one down to its URL.
        return Promise.all(caches.map(cache => {
          return cache.keys()
              .then(reqs => {
                requests.push(...reqs.map(r => r.url));
              });
        })).then(_ => {
          return requests;
        });
      });
}

class CacheContents extends Gatherer {
  static _error(errorString) {
    return {
      raw: undefined,
      value: undefined,
      debugString: errorString
    };
  }

  afterPass(options) {
    const driver = options.driver;

    return driver
        .evaluateAsync(`(${getCacheContents.toString()}())`)
        .then(returnedValue => {
          if (!returnedValue) {
            this.artifact = CacheContents._error('Unable to retrieve cache contents');
            return;
          }
          this.artifact = returnedValue;
        }, _ => {
          this.artifact = CacheContents._error('Unable to retrieve cache contents');
        });
  }
}

module.exports = CacheContents;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/content-width":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

/* global window */

/* istanbul ignore next */
function getContentWidth() {
  // window.innerWidth to get the scrollable size of the window (irrespective of zoom)
  // window.outerWidth to get the size of the visible area
  return Promise.resolve({
    scrollWidth: window.innerWidth,
    viewportWidth: window.outerWidth
  });
}

class ContentWidth extends Gatherer {

  afterPass(options) {
    const driver = options.driver;

    return driver.evaluateAsync(`(${getContentWidth.toString()}())`)

    .then(returnedValue => {
      this.artifact = returnedValue;
    }, _ => {
      this.artifact = {
        scrollWidth: -1,
        viewportWidth: -1
      };
      return;
    });
  }
}

module.exports = ContentWidth;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/gatherer":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Base class for all gatherers; defines pass lifecycle methods.
 */
class Gatherer {

  constructor() {
    this.artifact = {};
  }

  /**
   * @return {string}
   */
  get name() {
    return this.constructor.name;
  }

  /* eslint-disable no-unused-vars */

  /**
   * Called before navigation to target url.
   * @param {!Object} options
   */
  beforePass(options) { }

  /**
   * Called after target page is loaded. If a trace is enabled for this pass,
   * the trace is still being recorded.
   * @param {!Object} options
   */
  pass(options) { }

  /**
   * Called after target page is loaded, all gatherer `pass` methods have been
   * executed, and — if generated in this pass — the trace is ended. The trace
   * and record of network activity are provided in `loadData`.
   * @param {!Object} options
   * @param {{networkRecords: !Array, trace: {traceEvents: !Array}} loadData
   */
  afterPass(options, loadData) { }

  /* eslint-enable no-unused-vars */

}

module.exports = Gatherer;

},{}],"./gatherers/geolocation-on-start":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

/**
 * @fileoverview Tests whether the page attempts to request geolocation on page load. This often
 * represents a poor user experience, since it lacks context. As such, if the page requests
 * geolocation the gatherer will intercept the call and mark a boolean flag to true. The audit that
 * corresponds with this gatherer then checks for the flag.
 * @author Paul Lewis
 */

/* global navigator, window */

/* istanbul ignore next */
function overrideGeo() {
  window.__didNotCallGeo = true;
  // Override the geo functions so that if they're called they're intercepted and we know about it.
  navigator.geolocation.getCurrentPosition =
  navigator.geolocation.watchPosition = function() {
    window.__didNotCallGeo = false;
  };
}

function collectGeoState() {
  return Promise.resolve(window.__didNotCallGeo);
}

class GeolocationOnStart extends Gatherer {

  beforePass(options) {
    return options.driver.evaluateScriptOnLoad(`(${overrideGeo.toString()}())`);
  }

  afterPass(options) {
    return options.driver.evaluateAsync(`(${collectGeoState.toString()}())`)
        .then(returnedValue => {
          this.artifact = returnedValue;
        }, _ => {
          this.artifact = -1;
          return;
        });
  }
}

module.exports = GeolocationOnStart;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/html-without-javascript":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/* Note that this returns the innerText of the <body> element, not the HTML. */

const Gatherer = require('./gatherer');

/* global document */

/* istanbul ignore next */
function getBodyText() {
  // note: we use innerText, not textContent, because textContent includes the content of <script> elements!
  const body = document.querySelector('body');
  return Promise.resolve(body ? body.innerText : '');
}

class HTMLWithoutJavaScript extends Gatherer {

  beforePass(options) {
    options.disableJavaScript = true;
  }

  afterPass(options) {
    // Reset the JS disable.
    options.disableJavaScript = false;

    const driver = options.driver;

    this.artifact = {};
    return driver.evaluateAsync(`(${getBodyText.toString()}())`)
      .then(result => {
        this.artifact = result;
      })
      .catch(_ => {
        this.artifact = {
          value: -1,
          debugString: 'Unable to get document body innerText'
        };
      });
  }
}

module.exports = HTMLWithoutJavaScript;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/html":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

class HTML extends Gatherer {

  afterPass(options) {
    const driver = options.driver;

    return driver.sendCommand('DOM.getDocument')
        .then(result => result.root.nodeId)
        .then(nodeId => driver.sendCommand('DOM.getOuterHTML', {
          nodeId: nodeId
        }))
        .then(nodeHTML => {
          this.artifact = nodeHTML.outerHTML;
        }).catch(_ => {
          this.artifact = {
            value: -1,
            debugString: 'Unable to get document HTML'
          };
        });
  }
}

module.exports = HTML;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/http-redirect":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

/**
 * This gatherer changes the options.url so that its pass loads the http page.
 * After load it detects if its on a crypographic scheme.
 * TODO: Instead of abusing a loadPage pass for this test, it could likely just do an XHR instead
 */
class HTTPRedirect extends Gatherer {

  constructor() {
    super();
    this._preRedirectURL = undefined;
  }

  beforePass(options) {
    this._preRedirectURL = options.url;
    options.url = this._preRedirectURL.replace(/^https/, 'http');
  }

  afterPass(options) {
    // Reset the options.
    options.url = this._preRedirectURL;

    // Allow override for faster testing.
    const timeout = options._testTimeout || 10000;

    const securityPromise = options.driver.getSecurityState()
      .then(state => {
        return {
          value: state.schemeIsCryptographic
        };
      }, _ => {
        return {
          value: false,
          debugString: 'Error requesting security state'
        };
      });

    let noSecurityChangesTimeout;
    const timeoutPromise = new Promise((resolve, reject) => {
      // Set up a timeout for ten seconds in case we don't get any
      // security events at all. If that happens, bail.
      noSecurityChangesTimeout = setTimeout(_ => {
        resolve({
          value: false,
          debugString: 'Timed out waiting for HTTP redirection.'
        });
      }, timeout);
    });

    return Promise.race([
      securityPromise,
      timeoutPromise
    ]).then(result => {
      // Clear timeout. No effect if it won, no need to wait if it lost.
      clearTimeout(noSecurityChangesTimeout);
      this.artifact = result;
    });
  }
}

module.exports = HTTPRedirect;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/https":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

/**
 * @fileoverview Determines the security level of the page.
 * @see https://chromedevtools.github.io/debugger-protocol-viewer/tot/Security/#type-SecurityState
 */

class HTTPS extends Gatherer {

  constructor() {
    super();
    this._noSecurityChangesTimeout = undefined;
  }

  afterPass(options) {
    // Allow override for faster testing.
    const timeout = options._testTimeout || 10000;

    const securityPromise = options.driver.getSecurityState()
      .then(state => {
        return {
          value: state.schemeIsCryptographic
        };
      }, _ => {
        return {
          value: false,
          debugString: 'Error requesting page security state.'
        };
      });

    let noSecurityChangesTimeout;
    const timeoutPromise = new Promise((resolve, reject) => {
      // Set up a timeout for ten seconds in case we don't get any
      // security events at all. If that happens, bail.
      noSecurityChangesTimeout = setTimeout(_ => {
        resolve({
          value: false,
          debugString: 'Timed out waiting for page security state.'
        });
      }, timeout);
    });

    return Promise.race([
      securityPromise,
      timeoutPromise
    ]).then(result => {
      // Clear timeout. No effect if it won, no need to wait if it lost.
      clearTimeout(noSecurityChangesTimeout);
      this.artifact = result;
    });
  }
}

module.exports = HTTPS;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/manifest":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');
const manifestParser = require('../../lib/manifest-parser');

class Manifest extends Gatherer {

  static _errorManifest(errorString) {
    return {
      raw: undefined,
      value: undefined,
      debugString: errorString
    };
  }

  afterPass(options) {
    const driver = options.driver;
    /**
     * This re-fetches the manifest separately, which could
     * potentially lead to a different asset. Using the original manifest
     * resource is tracked in issue #83
     */
    return driver.sendCommand('Page.getAppManifest')
      .then(response => {
        if (response.errors.length) {
          let errorString;
          if (response.url) {
            errorString = `Unable to retrieve manifest at ${response.url}: `;
          }
          this.artifact = Manifest._errorManifest(errorString + response.errors.join(', '));
          return;
        }

        // The driver will return an empty string for url and the data if the
        // page has no manifest.
        if (!response.data.length && !response.data.url) {
          this.artifact = Manifest._errorManifest('No manifest found.');
          return;
        }

        this.artifact = manifestParser(response.data, response.url, options.url);
      }, _ => {
        this.artifact = Manifest._errorManifest('Unable to retrieve manifest');
        return;
      });
  }
}

module.exports = Manifest;

},{"../../lib/manifest-parser":22,"./gatherer":"./gatherers/gatherer"}],"./gatherers/offline":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

class Offline extends Gatherer {
  beforePass(options) {
    return options.driver.goOffline();
  }

  afterPass(options, tracingData) {
    const navigationRecord = tracingData.networkRecords.filter(record => {
      return record._url === options.url && record._fetchedViaServiceWorker;
    }).pop(); // Take the last record that matches.

    this.artifact = navigationRecord ? navigationRecord.statusCode : -1;

    return options.driver.goOnline(options);
  }
}

module.exports = Offline;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/service-worker":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

class ServiceWorker extends Gatherer {
  beforePass(options) {
    const driver = options.driver;
    return driver
      .getServiceWorkerVersions()
      .then(data => {
        return {
          versions: data.versions
        };
      })
      .catch(err => {
        return {
          debugString: `Error in querying Service Worker status: ${err.message}`
        };
      }).then(artifact => {
        this.artifact = artifact;
      });
  }
}

module.exports = ServiceWorker;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/styles":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Gathers the active style and stylesheets used on a page.
 * "Active" means that if the stylesheet is removed at a later time
 * (before endStylesCollect is called), this gatherer will not include it.
 */

'use strict';

const WebInspector = require('../../lib/web-inspector');
const Gatherer = require('./gatherer');

/**
 * @param {!gonzales.AST} parseTree
 * @return {!Array}
 */
function getCSSPropsInStyleSheet(parseTree) {
  const results = [];

  parseTree.traverseByType('declaration', function(node, index, parent) {
    const keyVal = node.toString().split(':').map(item => item.trim());
    results.push({
      property: {name: keyVal[0], val: keyVal[1]},
      declarationRange: node.declarationRange,
      selector: parent.selectors.toString()
    });
  });

  return results;
}

class Styles extends Gatherer {

  constructor() {
    super();
    this._activeStyleSheetIds = [];
    this._activeStyleHeaders = {};
    this._onStyleSheetAdded = this.onStyleSheetAdded.bind(this);
    this._onStyleSheetRemoved = this.onStyleSheetRemoved.bind(this);
  }

  onStyleSheetAdded(styleHeader) {
    // Exclude stylesheets "injected" by extensions or ones that were added by
    // users using the "inspector".
    if (styleHeader.header.origin !== 'regular') {
      return;
    }

    this._activeStyleHeaders[styleHeader.header.styleSheetId] = styleHeader;
    this._activeStyleSheetIds.push(styleHeader.header.styleSheetId);
  }

  onStyleSheetRemoved(styleHeader) {
    delete this._activeStyleHeaders[styleHeader.styleSheetId];

    const idx = this._activeStyleSheetIds.indexOf(styleHeader.styleSheetId);
    if (idx !== -1) {
      this._activeStyleSheetIds.splice(idx, 1);
    }
  }

  beginStylesCollect(driver) {
    driver.on('CSS.styleSheetAdded', this._onStyleSheetAdded);
    driver.on('CSS.styleSheetRemoved', this._onStyleSheetRemoved);
    return driver.sendCommand('DOM.enable')
      .then(_ => driver.sendCommand('CSS.enable'));
  }

  endStylesCollect(driver) {
    return new Promise((resolve, reject) => {
      if (!this._activeStyleSheetIds.length) {
        reject('No active stylesheets were collected.');
        return;
      }

      const parser = new WebInspector.SCSSParser();

      // Get text content of each style.
      const contentPromises = this._activeStyleSheetIds.map(sheetId => {
        return driver.sendCommand('CSS.getStyleSheetText', {
          styleSheetId: sheetId
        }).then(content => {
          const styleHeader = this._activeStyleHeaders[sheetId];
          styleHeader.content = content.text;
          styleHeader.parsedContent = getCSSPropsInStyleSheet(
              parser.parse(styleHeader.content));
          return styleHeader;
        });
      });

      Promise.all(contentPromises).then(styleHeaders => {
        driver.off('CSS.styleSheetAdded', this._onStyleSheetAdded);
        driver.off('CSS.styleSheetRemoved', this._onStyleSheetRemoved);
        return driver.sendCommand('CSS.disable')
          .then(_ => driver.sendCommand('DOM.disable'))
          .then(_ => resolve(styleHeaders));
      }).catch(err => reject(err));
    });
  }

  beforePass(options) {
    return this.beginStylesCollect(options.driver);
  }

  afterPass(options) {
    return this.endStylesCollect(options.driver)
      .then(stylesheets => {
        // Want unique stylesheets. Remove those with the same text content.
        // An example where stylesheets are the same is if the user includes a
        // stylesheet more than once (these have unique stylesheet ids according to
        // the DevTools protocol). Another example is many instances of a shadow
        // root that share the same <style> tag.
        const map = new Map(stylesheets.map(s => [s.content, s]));
        this.artifact = Array.from(map.values());
      }, err => {
        this.artifact = {
          rawValue: -1,
          debugString: err
        };
      });
  }
}

module.exports = Styles;

},{"../../lib/web-inspector":26,"./gatherer":"./gatherers/gatherer"}],"./gatherers/theme-color":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

class ThemeColor extends Gatherer {

  afterPass(options) {
    const driver = options.driver;

    return driver.querySelector('head meta[name="theme-color"]')
      .then(node => node && node.getAttribute('content'))
      .then(themeColorMeta => {
        this.artifact = themeColorMeta;
      })
      .catch(_ => {
        // The audit should read this as a fail since -1 is not a valid color.
        this.artifact = -1;
      });
  }
}

module.exports = ThemeColor;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/url":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

class URL extends Gatherer {

  afterPass(options) {
    // Used currently by cache-start-url audit, which wants to know if the start_url
    // in the manifest is stored in the cache.
    // Instead of the originally inputted URL (options.initialUrl), we want the resolved
    // post-redirect URL (which is here at options.url)
    this.artifact = {
      initialUrl: options.initialUrl,
      finalUrl: options.url
    };
  }
}

module.exports = URL;

},{"./gatherer":"./gatherers/gatherer"}],"./gatherers/viewport":[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Gatherer = require('./gatherer');

class Viewport extends Gatherer {

  /**
   * @param {!{driver: !Object}} options Run options
   * @return {!Promise<?string>} The value of the viewport meta's content attribute, or null
   */
  afterPass(options) {
    const driver = options.driver;

    return driver.querySelector('head meta[name="viewport"]')
      .then(node => node && node.getAttribute('content'))
      .then(viewport => {
        this.artifact = viewport;
      })
      .catch(_ => {
        this.artifact = -1;
      });
  }
}

module.exports = Viewport;

},{"./gatherer":"./gatherers/gatherer"}],1:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

class Aggregate {

  /**
   * @private
   * @param {!Array<!AuditResult>} results
   * @param {!AggregationCriteria} expected
   * @return {!Array<!AuditResult>}
   */
  static _filterResultsByAuditNames(results, expected) {
    const expectedNames = Object.keys(expected);
    return results.filter(r => expectedNames.indexOf(/** @type {string} */ (r.name)) !== -1);
  }

  /**
   * @private
   * @param {!AggregationCriteria} expected
   * @return {number}
   */
  static _getTotalWeight(expected) {
    const expectedNames = Object.keys(expected);
    const totalWeight = expectedNames.reduce((last, e) => last + (expected[e].weight || 0), 0);
    return totalWeight;
  }

  /**
   * @private
   * @param {!Array<!AuditResult>} results
   * @return {!Object<!AuditResult>}
   */
  static _remapResultsByName(results) {
    const remapped = {};
    results.forEach(r => {
      if (remapped[r.name]) {
        throw new Error(`Cannot remap: ${r.name} already exists`);
      }

      remapped[r.name] = r;
    });
    return remapped;
  }

  /**
   * Converts each raw audit output to a weighted value for the aggregation.
   * @private
   * @param {!AuditResult} result The audit's output value.
   * @param {!AggregationCriterion} expected The aggregation's expected value and weighting for this result.
   * @param {!string} name The name of the audit.
   * @return {number} The weighted result.
   */
  static _convertToWeight(result, expected, name) {
    let weight = 0;

    if (typeof expected === 'undefined' ||
        typeof expected.expectedValue === 'undefined' ||
        typeof expected.weight === 'undefined') {
      const msg =
          `aggregations: ${name} audit does not contain expectedValue or weight properties`;
      throw new Error(msg);
    }

    if (typeof result === 'undefined' ||
        typeof result.score === 'undefined') {
      let msg =
          `${name} audit result is undefined or does not contain score property`;
      if (result && result.debugString) {
        msg += ': ' + result.debugString;
      }
      throw new Error(msg);
    }

    if (typeof result.score !== typeof expected.expectedValue) {
      const expectedType = typeof expected.expectedValue;
      const resultType = typeof result.rawValue;
      let msg = `Expected expectedValue of type ${expectedType}, got ${resultType}`;
      if (result.debugString) {
        msg += ': ' + result.debugString;
      }
      throw new Error(msg);
    }

    switch (typeof expected.expectedValue) {
      case 'boolean':
        weight = this._convertBooleanToWeight(result.score,
            expected.expectedValue, expected.weight);
        break;

      case 'number':
        weight = this._convertNumberToWeight(result.score, expected.expectedValue, expected.weight);
        break;

      default:
        weight = 0;
        break;
    }

    return weight;
  }

  /**
   * Converts a numeric result to a weight.
   * @param {number} resultValue The result.
   * @param {number} expectedValue The expected value.
   * @param {number} weight The weight to assign.
   * @return {number} The final weight.
   */
  static _convertNumberToWeight(resultValue, expectedValue, weight) {
    return (resultValue / expectedValue) * weight;
  }

  /**
   * Converts a boolean result to a weight.
   * @param {boolean} resultValue The result.
   * @param {boolean} expectedValue The expected value.
   * @param {number} weight The weight to assign.
   * @return {number} The final weight.
   */
  static _convertBooleanToWeight(resultValue, expectedValue, weight) {
    return (resultValue === expectedValue) ? weight : 0;
  }

  /**
   * Compares the set of audit results to the expected values.
   * @param {!Array<!AuditResult>} results The audit results.
   * @param {!Array<!AggregationItem>} items The aggregation's expected values and weighting.
   * @param {!boolean} aggregationIsScored Whether or not the aggregation is scored.
   * @return {!Array<!AggregationResultItem>} The aggregation score.
   */
  static compare(results, items, aggregationIsScored) {
    return items.map(item => {
      const expectedNames = Object.keys(item.audits);

      // Filter down and remap the results to something more comparable to
      // the expected set of results.
      const filteredAndRemappedResults =
          Aggregate._remapResultsByName(
            Aggregate._filterResultsByAuditNames(results, item.audits)
          );

      const subItems = [];
      let overallScore = 0;
      let maxScore = 1;

      // Step through each item in the expected results, and add them
      // to the overall score and add each to the subItems list.
      expectedNames.forEach(e => {
        /* istanbul ignore if */
        // TODO(paullewis): Remove once coming soon audits have landed.
        if (item.audits[e].comingSoon) {
          subItems.push({
            score: '¯\\_(ツ)_/¯', // TODO(samthor): Patch going to Closure, String.raw is badly typed
            name: 'coming-soon',
            category: item.audits[e].category,
            description: item.audits[e].description,
            comingSoon: true
          });

          return;
        }

        if (!filteredAndRemappedResults[e]) {
          return;
        }

        subItems.push(filteredAndRemappedResults[e].name);

        // Only add to the score if this aggregation contributes to the
        // overall score.
        if (!aggregationIsScored) {
          return;
        }

        overallScore += Aggregate._convertToWeight(
            filteredAndRemappedResults[e],
            item.audits[e],
            e);
      });

      if (aggregationIsScored) {
        maxScore = Aggregate._getTotalWeight(item.audits);
      }

      return {
        overall: (overallScore / maxScore),
        name: item.name,
        description: item.description,
        subItems: subItems
      };
    });
  }

  /**
   * Aggregates all the results.
   * @param {!Aggregation} aggregation
   * @param {!Array<!AuditResult>} results
   * @return {!AggregationResult}
   */
  static aggregate(aggregation, auditResults) {
    return {
      name: aggregation.name,
      description: aggregation.description,
      scored: aggregation.scored,
      categorizable: aggregation.categorizable,
      score: Aggregate.compare(auditResults, aggregation.items, aggregation.scored)
    };
  }
}

module.exports = Aggregate;

},{}],2:[function(require,module,exports){
(function (__dirname){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const defaultConfigPath = './default.json';
const defaultConfig = require('./default.json');
const recordsFromLogs = require('../lib/network-recorder').recordsFromLogs;

const GatherRunner = require('../gather/gather-runner');
const log = require('../lib/log');
const path = require('path');
const Audit = require('../audits/audit');

// cleanTrace is run to remove duplicate TracingStartedInPage events,
// and to change TracingStartedInBrowser events into TracingStartedInPage.
// This is done by searching for most occuring threads and basing new events
// off of those.
function cleanTrace(trace) {
  const traceEvents = trace.traceEvents;
  // Keep track of most occuring threads
  const threads = [];
  const countsByThread = {};
  const traceStartEvents = [];
  const makeMockEvent = (evt, ts) => {
    return {
      pid: evt.pid,
      tid: evt.tid,
      ts: ts || 0,  // default to 0 for now
      ph: 'I',
      cat: 'disabled-by-default-devtools.timeline',
      name: 'TracingStartedInPage',
      args: {
        data: {
          page: evt.frame
        }
      },
      s: 't'
    };
  };

  let frame;
  let data;
  let name;
  let counter;

  traceEvents.forEach((evt, idx) => {
    if (evt.name.startsWith('TracingStartedIn')) {
      traceStartEvents.push(idx);
    }

    // find the event's frame
    data = evt.args && (evt.args.data || evt.args.beginData || evt.args.counters);
    frame = (evt.args && evt.args.frame) || data && (data.frame || data.page);

    if (!frame) {
      return;
    }

    // Increase occurences count of the frame
    name = `pid${evt.pid}-tid${evt.tid}-frame${frame}`;
    counter = countsByThread[name];
    if (!counter) {
      counter = {
        pid: evt.pid,
        tid: evt.tid,
        frame: frame,
        count: 0
      };
      countsByThread[name] = counter;
      threads.push(counter);
    }
    counter.count++;
  });

  // find most active thread (and frame)
  threads.sort((a, b) => b.count - a.count);
  const mostActiveFrame = threads[0];

  // Remove all current TracingStartedIn* events, storing
  // the first events ts.
  const ts = traceEvents[traceStartEvents[0]] && traceEvents[traceStartEvents[0]].ts;

  // account for offset after removing items
  let i = 0;
  for (const dup of traceStartEvents) {
    traceEvents.splice(dup - i, 1);
    i++;
  }

  // Add a new TracingStartedInPage event based on most active thread
  // and using TS of first found TracingStartedIn* event
  traceEvents.unshift(makeMockEvent(mostActiveFrame, ts));

  return trace;
}

function validatePasses(passes, audits, rootPath) {
  if (!Array.isArray(passes)) {
    return;
  }
  const requiredGatherers = getGatherersNeededByAudits(audits);

  // Log if we are running gathers that are not needed by the audits listed in the config
  passes.forEach(pass => {
    pass.gatherers.forEach(gatherer => {
      const GathererClass = GatherRunner.getGathererClass(gatherer, rootPath);
      const isGatherRequiredByAudits = requiredGatherers.has(GathererClass.name);
      if (isGatherRequiredByAudits === false) {
        const msg = `${GathererClass.name} gatherer requested, however no audit requires it.`;
        log.warn('config', msg);
      }
    });
  });

  // Log if multiple passes require trace or network recording and could overwrite one another.
  const usedNames = new Set();
  passes.forEach((pass, index) => {
    if (!pass.recordNetwork && !pass.recordTrace) {
      return;
    }

    const passName = pass.passName || Audit.DEFAULT_PASS;
    if (usedNames.has(passName)) {
      log.warn('config', `passes[${index}] may overwrite trace or network ` +
          `data of earlier pass without a unique passName (repeated name: ${passName}.`);
    }
    usedNames.add(passName);
  });
}

function getGatherersNeededByAudits(audits) {
  // It's possible we didn't get given any audits (but existing audit results), in which case
  // there is no need to do any work here.
  if (!audits) {
    return new Set();
  }

  return audits.reduce((list, audit) => {
    audit.meta.requiredArtifacts.forEach(artifact => list.add(artifact));
    return list;
  }, new Set());
}

function requireAudits(audits, configPath) {
  if (!audits) {
    return null;
  }
  const Runner = require('../runner');
  const coreList = Runner.getAuditList();

  return audits.map(nameOrAuditClass => {
    let AuditClass;
    if (typeof nameOrAuditClass === 'string') {
      const name = nameOrAuditClass;
      // See if the audit is a Lighthouse core audit.
      const coreAudit = coreList.find(a => a === `${name}.js`);
      let requirePath = `../audits/${name}`;
      if (!coreAudit) {
        // Otherwise, attempt to find it elsewhere. This throws if not found.
        requirePath = Runner.resolvePlugin(name, configPath, 'audit');
      }
      AuditClass = require(requirePath);
      assertValidAudit(AuditClass, name);
    } else {
      AuditClass = nameOrAuditClass;
      assertValidAudit(AuditClass);
    }

    return AuditClass;
  });
}

function assertValidAudit(auditDefinition, auditName) {
  auditName = auditName || (auditDefinition.meta && auditDefinition.meta.name) || 'audit';
  if (typeof auditDefinition.audit !== 'function') {
    throw new Error(`${auditName} has no audit() method.`);
  }

  if (typeof auditDefinition.meta.name !== 'string') {
    throw new Error(`${auditName} has no meta.name property, or the property is not a string.`);
  }

  if (typeof auditDefinition.meta.category !== 'string') {
    throw new Error(`${auditName} has no meta.category property, or the property is not a string.`);
  }

  if (typeof auditDefinition.meta.description !== 'string') {
    throw new Error(
      `${auditName} has no meta.description property, or the property is not a string.`
    );
  }

  if (!Array.isArray(auditDefinition.meta.requiredArtifacts)) {
    throw new Error(
      `${auditName} has no meta.requiredArtifacts property, or the property is not an array.`
    );
  }

  if (typeof auditDefinition.generateAuditResult !== 'function') {
    throw new Error(
      `${auditName} has no generateAuditResult() method. ` +
        'Did you inherit from the proper base class?'
    );
  }
}

function expandArtifacts(artifacts) {
  if (!artifacts) {
    return null;
  }
  // currently only trace logs and performance logs should be imported
  if (artifacts.traces) {
    Object.keys(artifacts.traces).forEach(key => {
      log.log('info', 'Normalizng trace contents into expected state...');
      let trace = require(artifacts.traces[key]);
      // Before Chrome 54.0.2816 (codereview.chromium.org/2161583004), trace was
      // an array of trace events. After this point, trace is an object with a
      // traceEvents property. Normalize to new format.
      if (Array.isArray(trace)) {
        trace = {
          traceEvents: trace
        };
      }
      trace = cleanTrace(trace);

      artifacts.traces[key] = trace;
    });
  }

  if (artifacts.performanceLog) {
    if (typeof artifacts.performanceLog === 'string') {
      // Support older format of a single performance log.
      const log = require(artifacts.performanceLog);
      artifacts.networkRecords = {
        [Audit.DEFAULT_PASS]: recordsFromLogs(log)
      };
    } else {
      artifacts.networkRecords = {};
      Object.keys(artifacts.performanceLog).forEach(key => {
        const log = require(artifacts.performanceLog[key]);
        artifacts.networkRecords[key] = recordsFromLogs(log);
      });
    }
  }

  return artifacts;
}

class Config {
  /**
   * @constructor
   * @param {!LighthouseConfig} configJSON
   * @param {string=} configPath The absolute path to the config file, if there is one.
   */
  constructor(configJSON, configPath) {
    if (!configJSON) {
      configJSON = defaultConfig;
      configPath = path.resolve(__dirname, defaultConfigPath);
    }

    if (configPath && !path.isAbsolute(configPath)) {
      throw new Error('configPath must be an absolute path.');
    }

    // We don't want to mutate the original config object
    const inputConfig = configJSON;
    configJSON = JSON.parse(JSON.stringify(inputConfig));
    // Copy arrays that could contain plugins to allow for programmatic
    // injection of plugins.
    if (Array.isArray(inputConfig.passes)) {
      configJSON.passes.forEach((pass, i) => {
        pass.gatherers = Array.from(inputConfig.passes[i].gatherers);
      });
    }
    if (Array.isArray(inputConfig.audits)) {
      configJSON.audits = Array.from(inputConfig.audits);
    }
    // Store the directory of the config path, if one was provided.
    this._configDir = configPath ? path.dirname(configPath) : undefined;

    this._passes = configJSON.passes || null;
    this._auditResults = configJSON.auditResults || null;
    if (this._auditResults && !Array.isArray(this._auditResults)) {
      throw new Error('config.auditResults must be an array');
    }

    this._aggregations = configJSON.aggregations || null;

    this._audits = requireAudits(configJSON.audits, this._configDir);
    this._artifacts = expandArtifacts(configJSON.artifacts);

    // validatePasses must follow after audits are required
    validatePasses(configJSON.passes, this._audits, this._configDir);
  }

  /** @type {string} */
  get configDir() {
    return this._configDir;
  }

  /** @type {Array<!Pass>} */
  get passes() {
    return this._passes;
  }

  /** @type {Array<!Audit>} */
  get audits() {
    return this._audits;
  }

  /** @type {Array<!AuditResult>} */
  get auditResults() {
    return this._auditResults;
  }

  /** @type {Array<!Artifacts>} */
  get artifacts() {
    return this._artifacts;
  }

  /** @type {Array<!Aggregation>} */
  get aggregations() {
    return this._aggregations;
  }
}

module.exports = Config;

}).call(this,"/../lighthouse-core/config")
},{"../audits/audit":"../audits/audit","../gather/gather-runner":16,"../lib/log":21,"../lib/network-recorder":23,"../runner":27,"./default.json":3,"path":198}],3:[function(require,module,exports){
module.exports={
  "passes": [{
    "recordNetwork": true,
    "recordTrace": true,
    "gatherers": [
      "url",
      "https",
      "viewport",
      "theme-color",
      "manifest",
      "accessibility",
      "content-width",
      "cache-contents",
      "geolocation-on-start"
    ]
  },
  {
    "passName": "offlinePass",
    "recordNetwork": true,
    "gatherers": [
      "service-worker",
      "offline"
    ]
  },
  {
    "gatherers": [
      "http-redirect",
      "html-without-javascript"
    ]
  }],

  "audits": [
    "is-on-https",
    "redirects-http",
    "service-worker",
    "works-offline",
    "viewport",
    "manifest-display",
    "without-javascript",
    "first-meaningful-paint",
    "speed-index-metric",
    "estimated-input-latency",
    "time-to-interactive",
    "user-timings",
    "screenshots",
    "critical-request-chains",
    "manifest-exists",
    "manifest-background-color",
    "manifest-theme-color",
    "manifest-icons-min-192",
    "manifest-icons-min-144",
    "manifest-name",
    "manifest-short-name",
    "manifest-short-name-length",
    "manifest-start-url",
    "meta-theme-color",
    "aria-valid-attr",
    "aria-allowed-attr",
    "color-contrast",
    "image-alt",
    "label",
    "tabindex",
    "content-width",
    "geolocation-on-start"
  ],

  "aggregations": [{
    "name": "Progressive Web App",
    "description": "These audits validate the aspects of a Progressive Web App.",
    "scored": true,
    "categorizable": true,
    "items": [{
      "name": "App can load on offline/flaky connections",
      "description": "Ensuring your web app can respond when the network connection is unavailable or flaky is critical to providing your users a good experience. This is achieved through use of a <a href=\"https://developers.google.com/web/fundamentals/primers/service-worker/\">Service Worker</a>.",
      "audits": {
        "service-worker": {
          "expectedValue": true,
          "weight": 1
        },
        "works-offline": {
          "expectedValue": true,
          "weight": 1
        },
        "cache-start-url": {
          "expectedValue": true,
          "weight": 1
        }
      }
    },{
      "name": "Page load performance is fast",
      "description": "Users notice if sites and apps don't perform well. These top-level metrics capture the most important perceived performance concerns.",
      "audits": {
        "first-meaningful-paint": {
          "expectedValue": 100,
          "weight": 1
        },
        "speed-index-metric": {
          "expectedValue": 100,
          "weight": 1
        },
        "estimated-input-latency": {
          "expectedValue": 100,
          "weight": 1
        },
        "time-to-interactive": {
          "expectedValue": 100,
          "weight": 1
        },
        "scrolling-60fps": {
          "expectedValue": true,
          "weight": 0,
          "comingSoon": true,
          "description": "Content scrolls at 60fps",
          "category": "UX"
        },
        "touch-150ms": {
          "expectedValue": true,
          "weight": 0,
          "comingSoon": true,
          "description": "Touch input gets a response in < 150ms",
          "category": "UX"
        },
        "fmp-no-jank": {
          "expectedValue": true,
          "weight": 0,
          "comingSoon": true,
          "description": "App is interactive without jank after the first meaningful paint",
          "category": "UX"
        }
      }
    }, {
      "name": "Site is progressively enhanced",
      "description": "Progressive enhancement means that everyone can access the basic content and functionality of a page in any browser, and those without certain browser features may receive a reduced but still functional experience.",
      "audits": {
        "without-javascript": {
          "expectedValue": true,
          "weight": 1
        }
      }
    }, {
      "name": "Network connection is secure",
      "description": "Security is an important part of the web for both developers and users. Moving forward, Transport Layer Security (TLS) support will be required for many APIs.",
      "audits": {
        "is-on-https": {
          "expectedValue": true,
          "weight": 1
        },
        "redirects-http": {
          "expectedValue": true,
          "weight": 1
        }
      }
    }, {
      "name": "User can be prompted to Add to Homescreen",
      "description": "While users can manually add your site to their homescreen in the browser menu, the <a href=\"https://developers.google.com/web/updates/2015/03/increasing-engagement-with-app-install-banners-in-chrome-for-android?hl=en\">prompt (aka app install banner)</a> will proactively prompt the user to install the app if the below requirements are met and the user has visited your site at least twice (with at least five minutes between visits).",
      "see": "https://github.com/GoogleChrome/lighthouse/issues/23",
      "audits": {
        "service-worker": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-exists": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-start-url": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-icons-min-144": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-short-name": {
          "expectedValue": true,
          "weight": 1
        }
      }
    }, {
      "name": "Installed web app will launch with custom splash screen",
      "description": "A default splash screen will be constructed, but meeting these requirements guarantee a high-quality and customizable <a href=\"https://developers.google.com/web/updates/2015/10/splashscreen?hl=en\">splash screen</a> the user sees between tapping the home screen icon and your app’s first paint.",
      "see": "https://github.com/GoogleChrome/lighthouse/issues/24",
      "audits": {
        "manifest-exists": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-name": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-background-color": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-theme-color": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-icons-min-192": {
          "expectedValue": true,
          "weight": 1
        }
      }
    }, {
      "name": "Address bar matches brand colors",
      "description": "The browser address bar can be themed to match your site. A theme-color <a href=\"https://developers.google.com/web/updates/2014/11/Support-for-theme-color-in-Chrome-39-for-Android\">meta tag</a> will upgrade the address bar when a user browses the site, and the <a href=\"https://developers.google.com/web/updates/2015/08/using-manifest-to-set-sitewide-theme-color\">manifest theme-color</a> will apply the same theme site-wide once it's been added to homescreen.",
      "audits": {
        "manifest-exists": {
          "expectedValue": true,
          "weight": 1
        },
        "theme-color-meta": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-theme-color": {
          "expectedValue": true,
          "weight": 1
        }
      }
    }, {
      "name": "Design is mobile-friendly",
      "description": "Users increasingly experience your app on mobile devices, so it's important to ensure that the experience can adapt to smaller screens.",
      "audits": {
        "viewport": {
          "expectedValue": true,
          "weight": 1
        },
        "content-width": {
          "expectedValue": true,
          "weight": 1
        }
      }
    }]
  },{
    "name": "Best Practices",
    "description": "These audits do not affect your score but are worth a look.",
    "scored": false,
    "categorizable": false,
    "items": [{
      "audits": {
        "aria-allowed-attr": {
          "expectedValue": true,
          "weight": 1
        },
        "aria-valid-attr": {
          "expectedValue": true,
          "weight": 1
        },
        "color-contrast": {
          "expectedValue": true,
          "weight": 1
        },
        "image-alt": {
          "expectedValue": true,
          "weight": 1
        },
        "label": {
          "expectedValue": true,
          "weight": 1
        },
        "tabindex": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-short-name-length": {
          "expectedValue": true,
          "weight": 1
        },
        "manifest-display": {
          "expectedValue": true,
          "weight": 1
        },
        "geolocation-on-start": {
          "expectedValue": true,
          "weight": 1
        },
        "serviceworker-push": {
          "expectedValue": true,
          "weight": 0,
          "comingSoon": true,
          "description": "Service worker makes use of push notifications, if appropriate",
          "category": "UX"
        },
        "tap-targets": {
          "expectedValue": true,
          "weight": 0,
          "comingSoon": true,
          "description": "Tap targets are appropriately sized for touch",
          "category": "UX"
        },
        "payments-autocomplete": {
          "expectedValue": true,
          "weight": 0,
          "comingSoon": true,
          "description": "Payment forms marked up with [autocomplete] attributes",
          "category": "UX"
        },
        "login-autocomplete": {
          "expectedValue": true,
          "weight": 0,
          "comingSoon": true,
          "description": "Login forms marked up with [autocomplete] attributes",
          "category": "UX"
        },
        "input-type": {
          "expectedValue": true,
          "weight": 0,
          "comingSoon": true,
          "description": "Input fields use appropriate [type] attributes for custom keyboards",
          "category": "UX"
        }
      }
    }]
  },{
    "name": "Performance Metrics",
    "description": "These encapsulate your app's performance.",
    "scored": false,
    "categorizable": false,
    "items": [{
      "audits": {
        "critical-request-chains": {
          "expectedValue": 0,
          "weight": 1
        },
        "user-timings": {
          "expectedValue": 0,
          "weight": 1
        }
      }
    }]
  }]
}

},{}],4:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const path = require('path');

const Formatter = require('./formatter');
const html = "<style>\n.axe-violation {\n  color: #D0021B;\n}\n\n.axe-violation__help {\n  color: #76B530;\n}\n\n.axe-violation__help-minor,\n.axe-violation__help-moderate {\n  color: #F5A623;\n}\n\n.axe-violation__help-serious,\n.axe-violation__help--critical {\n  color: #D0021B;\n}\n</style>\n<div class=\"axe-violation\">\n  <details>\n    <summary>\n      <a class=\"axe-violation__help--{{ this.impact }}\" href=\"{{ this.helpUrl }}\" target=\"_blank\">{{ this.help }}</a>\n    </summary>\n    <ul>\n    {{#each this.nodes}}\n      <li><code>{{ this.target }}</code></li>\n    {{/each}}\n    </ul>\n  </details>\n</div>\n";

class Accessibilty extends Formatter {
  static getFormatter(type) {
    switch (type) {
      case 'pretty':
        return function(info) {
          if (info === null ||
              typeof info === 'undefined' ||
              typeof info.impact === 'undefined' ||
              typeof info.helpUrl === 'undefined' ||
              typeof info.nodes === 'undefined' ||
              !Array.isArray(info.nodes)) {
            return '';
          }

          const output = `      - Rating: ${info.impact}\n` +
          `      - See: ${info.helpUrl}\n` +
          `      - Nodes: ${info.nodes.length} nodes identified (see HTML output for details)\n`;
          return output;
        };

      case 'html':
        // Returns a handlebars string to be used by the Report.
        return html;

      default:
        throw new Error('Unknown formatter type');
    }
  }
}

module.exports = Accessibilty;

},{"./formatter":7,"path":198}],5:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const url = require('url');
const path = require('path');

const Formatter = require('./formatter');
const html = "<style>\n.tree-marker {\n  width: 12px;\n  height: 26px;\n  display: block;\n  float: left;\n  background-position: top left;\n}\n\n.horiz-down {\n  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMjZweCIgdmlld0JveD0iMCAwIDE2IDI2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzLjcuMiAoMjgyNzYpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPmhvcml6LWRvd248L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iaG9yaXotZG93biIgZmlsbD0iI0Q4RDhEOCI+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMTM4IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3LjAwMDAwMCwgMTMuMDAwMDAwKSByb3RhdGUoLTI3MC4wMDAwMDApIHRyYW5zbGF0ZSgtNy4wMDAwMDAsIC0xMy4wMDAwMDApICIgeD0iNiIgeT0iNCIgd2lkdGg9IjIiIGhlaWdodD0iMTgiPjwvcmVjdD4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xMzkiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDguMDAwMDAwLCAxOS4wMDAwMDApIHJvdGF0ZSgtMjcwLjAwMDAwMCkgdHJhbnNsYXRlKC04LjAwMDAwMCwgLTE5LjAwMDAwMCkgIiB4PSIxIiB5PSIxOCIgd2lkdGg9IjE0IiBoZWlnaHQ9IjIiPjwvcmVjdD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==');\n}\n\n.right {\n  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMjZweCIgdmlld0JveD0iMCAwIDE2IDI2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzLjcuMiAoMjgyNzYpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPnJpZ2h0PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InJpZ2h0IiBmaWxsPSIjRDhEOEQ4Ij4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xMzgiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDguMDAwMDAwLCAxMy4wMDAwMDApIHJvdGF0ZSgtMjcwLjAwMDAwMCkgdHJhbnNsYXRlKC04LjAwMDAwMCwgLTEzLjAwMDAwMCkgIiB4PSI3IiB5PSI1IiB3aWR0aD0iMiIgaGVpZ2h0PSIxNiI+PC9yZWN0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+');\n}\n\n.up-right {\n  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMjZweCIgdmlld0JveD0iMCAwIDE2IDI2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzLjcuMiAoMjgyNzYpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPnVwLXJpZ2h0PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGRlZnM+PC9kZWZzPgogICAgPGcgaWQ9IlBhZ2UtMSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InVwLXJpZ2h0IiBmaWxsPSIjRDhEOEQ4Ij4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS0xMzgiIHg9IjciIHk9IjAiIHdpZHRoPSIyIiBoZWlnaHQ9IjE0Ij48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMTM5IiB4PSI5IiB5PSIxMiIgd2lkdGg9IjciIGhlaWdodD0iMiI+PC9yZWN0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+');\n}\n\n.vert-right {\n  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMjZweCIgdmlld0JveD0iMCAwIDE2IDI2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzLjcuMiAoMjgyNzYpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPnZlcnQtcmlnaHQ8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0idmVydC1yaWdodCIgZmlsbD0iI0Q4RDhEOCI+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMTM4IiB4PSI3IiB5PSIwIiB3aWR0aD0iMiIgaGVpZ2h0PSIyNyI+PC9yZWN0PgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLTEzOSIgeD0iOSIgeT0iMTIiIHdpZHRoPSI3IiBoZWlnaHQ9IjIiPjwvcmVjdD4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ZnPg==');\n}\n\n.vert {\n  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMjZweCIgdmlld0JveD0iMCAwIDE2IDI2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzLjcuMiAoMjgyNzYpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPnZlcnQ8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0idmVydCIgZmlsbD0iI0Q4RDhEOCI+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtMTM4IiB4PSI3IiB5PSIwIiB3aWR0aD0iMiIgaGVpZ2h0PSIyNiI+PC9yZWN0PgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+');\n}\n\n.space {\n  background: url('data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjxzdmcgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDE2IDE2IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPgogICAgPCEtLSBHZW5lcmF0b3I6IFNrZXRjaCAzLjcuMiAoMjgyNzYpIC0gaHR0cDovL3d3dy5ib2hlbWlhbmNvZGluZy5jb20vc2tldGNoIC0tPgogICAgPHRpdGxlPmhvcml6LWRvd248L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZGVmcz48L2RlZnM+CiAgICA8ZyBpZD0iUGFnZS0xIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0iaG9yaXotZG93biI+PC9nPgogICAgPC9nPgo8L3N2Zz4=');\n}\n\n.cnc-tree {\n  font-size: 14px;\n  width: 100%;\n  overflow-x: auto;\n}\n\n.cnc-node {\n  height: 26px;\n  line-height: 26px;\n  white-space: nowrap;\n}\n\n.cnc-node__tree-value {\n  margin-left: 10px;\n}\n\n.cnc-node__chain-duration {\n  font-weight: bold;\n}\n\n.cnc-node__tree-hostname {\n  color: #999;\n}\n\n</style>\n\n{{#*inline \"writeNode\"}}\n  <div class=\"cnc-node\" title=\"{{ @key }}\">\n    <span class=\"cnc-node__tree-marker\">\n    {{#each treeMarkers as |separator| }}\n      {{#separator}}\n      <span class=\"tree-marker vert\"></span>\n      <span class=\"tree-marker space\"></span>\n      {{else}}\n      <span class=\"tree-marker space\"></span>\n      <span class=\"tree-marker space\"></span>\n      {{/separator}}\n    {{/each}}\n    {{#isLastChild}}\n      <span class=\"tree-marker up-right\"></span>\n      <span class=\"tree-marker right\"></span>\n    {{else}}\n      <span class=\"tree-marker vert-right\"></span>\n      <span class=\"tree-marker right\"></span>\n    {{/isLastChild}}\n\n    {{#hasChildren}}\n      <span class=\"tree-marker horiz-down\"></span>\n    {{else}}\n      <span class=\"tree-marker right\"></span>\n    {{/hasChildren}}\n    </span>\n\n    <span class=\"cnc-node__tree-value\">\n      {{#parseURL this.node.request.url }}\n        <span class=\"cnc-node__tree-file\">{{ this.file }}</span>\n        <span class=\"cnc-node__tree-hostname\">({{ this.hostname }})</span>\n      {{/parseURL}}\n      {{#unless hasChildren}}\n        - <span class=\"cnc-node__chain-duration\">{{chainDuration startTime this.node.request.endTime }}ms, {{formatTransferSize this.transferSize}}KB</span>\n      {{/unless}}\n    </span>\n  </div>\n\n  {{#each this.node.children as |child| }}\n    {{#createContextFor ../node.children @key ../treeMarkers ../isLastChild ../startTime ../transferSize }}\n      {{> writeNode this }}\n    {{/createContextFor }}\n  {{/each}}\n{{/inline}}\n\n<div class=\"cnc-tree\">\n  <div>Longest request chain (shorter is better): <strong>{{longestChain this}}</strong></div>\n  <div>Longest chain duration (shorter is better): <strong>{{formatTime (longestDuration this)}}ms</strong></div>\n  <div>Longest chain transfer size (smaller is better): <strong>{{formatTransferSize (longestChainTransferSize this)}}KB</strong></div>\n  <div>\n    <div>Initial navigation</div>\n    {{#createTreeRenderContext this}}\n      {{#each this.tree }}\n        {{#createContextFor ../tree @key undefined undefined ../startTime ../transferSize }}\n          {{> writeNode this }}\n        {{/createContextFor}}\n      {{/each}}\n    {{/createTreeRenderContext}}\n  </div>\n</div>\n";

class CriticalRequestChains extends Formatter {

  /**
   * gets the formatter for the CLI Printer and the HTML report.
   */
  static getFormatter(type) {
    switch (type) {
      case 'pretty':
        return function(info) {
          if (info === null ||
              typeof info === 'undefined') {
            return '';
          }

          const longestChain = CriticalRequestChains._getLongestChainLength(info);
          const longestDuration =
              CriticalRequestChains._getLongestChainDuration(info).toFixed(2);
          const longestTransferSize = CriticalRequestChains.formatTransferSize(
              CriticalRequestChains._getLongestChainTransferSize(info));
          const urlTree = CriticalRequestChains._createURLTreeOutput(info);

          const output = `    - Longest request chain (shorter is better): ${longestChain}\n` +
          `    - Longest chain duration (shorter is better): ${longestDuration}ms\n` +
          `    - Longest chain transfer size (smaller is better): ${longestTransferSize}KB\n` +
          '    - Initial navigation\n' +
              '      ' + urlTree.replace(/\n/g, '\n      ') + '\n';
          return output;
        };

      case 'html':
        // Returns a handlebars string to be used by the Report.
        return html;

      default:
        throw new Error('Unknown formatter type');
    }
  }

  static _traverse(tree, cb) {
    function walk(node, depth, startTime, transferSize) {
      const children = Object.keys(node);
      if (children.length === 0) {
        return;
      }

      if (!transferSize) {
        transferSize = 0;
      }

      children.forEach(id => {
        const child = node[id];
        if (!startTime) {
          startTime = child.request.startTime;
        }

        // Call the callback with the info for this child.
        cb({
          depth,
          id,
          node: child,
          chainDuration: (child.request.endTime - startTime) * 1000,
          chainTransferSize: (transferSize + child.request.transferSize)
        });

        // Carry on walking.
        walk(child.children, depth + 1, startTime);
      }, '');
    }

    walk(tree, 0);
  }

  static _getLongestChainLength(tree) {
    let longestChain = 0;
    this._traverse(tree, opts => {
      const depth = opts.depth;
      if (depth > longestChain) {
        longestChain = depth;
      }
    });

    // Always return the longest chain + 1 because the depth is zero indexed.
    return (longestChain + 1);
  }

  static _getLongestChainDuration(tree) {
    let longestChainDuration = 0;
    this._traverse(tree, opts => {
      const duration = opts.chainDuration;
      if (duration > longestChainDuration) {
        longestChainDuration = duration;
      }
    });
    return longestChainDuration;
  }

  static _getLongestChainTransferSize(tree) {
    let transferSize = 0;
    this._traverse(tree, opts => {
      const chainTransferSize = opts.chainTransferSize;
      if (chainTransferSize > transferSize) {
        transferSize = chainTransferSize;
      }
    });
    return transferSize;
  }

  /**
   * Converts the tree into an ASCII tree.
   */
  static _createURLTreeOutput(tree) {
    function write(opts) {
      const node = opts.node;
      const depth = opts.depth;
      const treeMarkers = opts.treeMarkers;
      let startTime = opts.startTime;
      const transferSize = opts.transferSize;

      return Object.keys(node).reduce((output, id, currentIndex, arr) => {
        // Test if this node has children, and if it's the last child.
        const hasChildren = (Object.keys(node[id].children).length > 0);
        const isLastChild = (currentIndex === arr.length - 1);

        // If the parent is the last child then don't drop the vertical bar.
        const ancestorTreeMarker = treeMarkers.reduce((markers, marker) => {
          return markers + (marker ? '┃ ' : '  ');
        }, '');

        // Copy the tree markers so that we don't change by reference.
        const newTreeMakers = treeMarkers.slice(0);

        // Add on the new entry.
        newTreeMakers.push(!isLastChild);

        // Create the appropriate tree marker based on the depth of this
        // node as well as whether or not it has children and is itself the last child.
        const treeMarker = ancestorTreeMarker +
            (isLastChild ? '┗━' : '┣━') +
            (hasChildren ? '┳' : '━');

        const parsedURL = CriticalRequestChains.parseURL(node[id].request.url);

        if (!startTime) {
          startTime = node[id].request.startTime;
        }

        const duration = ((node[id].request.endTime - startTime) * 1000).toFixed(2);
        const chainTransferSize = transferSize + node[id].request.transferSize;
        const formattedTransferSize = CriticalRequestChains.formatTransferSize(chainTransferSize);

        // Return the previous output plus this new node, and recursively write its children.
        return output + `${treeMarker} ${parsedURL.file} (${parsedURL.hostname})` +
            // If this node has children, write them out. Othewise write the chain time.
            (hasChildren ? '' : ` - ${duration}ms, ${formattedTransferSize}KB`) + '\n' +
            write({
              node: node[id].children,
              depth: depth + 1,
              treeMarkers: newTreeMakers,
              startTime,
              transferSize: chainTransferSize
            });
      }, '');
    }

    return write({
      node: tree,
      depth: 0,
      treeMarkers: [],
      startTime: 0,
      transferSize: 0
    });
  }

  static formatTime(time) {
    return time.toFixed(2);
  }

  static formatTransferSize(size) {
    return (size / 1024).toFixed(2);
  }

  static parseURL(resourceURL, opts) {
    const MAX_FILENAME_LENGTH = 64;
    const parsedResourceURL = url.parse(resourceURL);
    const hostname = parsedResourceURL.hostname;
    // Handle 'about:*' URLs specially since they have no path.
    let file = parsedResourceURL.protocol === 'about:' ? parsedResourceURL.href :
        // Otherwise, remove any query strings from the path.
        parsedResourceURL.path.replace(/\?.*/, '')
        // And grab the last two parts.
        .split('/').slice(-2).join('/');

    if (file.length > MAX_FILENAME_LENGTH) {
      file = file.slice(0, MAX_FILENAME_LENGTH) + '...';
    }

    const parsedURL = {
      file,
      hostname
    };

    // If we get passed the opts parameter, this is Handlebars, so we
    // need to return the object back via the opts.fn so it becomes the context.
    if (opts) {
      return opts.fn(parsedURL);
    }

    return parsedURL;
  }

  static getHelpers() {
    return {
      longestChain(info) {
        return CriticalRequestChains._getLongestChainLength(info);
      },

      longestDuration(info) {
        return CriticalRequestChains._getLongestChainDuration(info);
      },

      longestChainTransferSize(info) {
        return CriticalRequestChains._getLongestChainTransferSize(info);
      },

      chainDuration(startTime, endTime) {
        return ((endTime - startTime) * 1000).toFixed(2);
      },

      formatTransferSize: CriticalRequestChains.formatTransferSize,

      parseURL: CriticalRequestChains.parseURL,

      formatTime: CriticalRequestChains.formatTime,

      /**
       * Helper function for Handlebars that creates the context for each node
       * based on its parent. Calculates if this node is the last child, whether
       * it has any children itself and what the tree looks like all the way back
       * up to the root, so the tree markers can be drawn correctly.
       */
      createContextFor(parent, id, treeMarkers, parentIsLastChild, startTime, transferSize, opts) {
        const node = parent[id];
        const siblings = Object.keys(parent);
        const isLastChild = siblings.indexOf(id) === (siblings.length - 1);
        const hasChildren = Object.keys(node.children).length > 0;

        // Copy the tree markers so that we don't change by reference.
        const newTreeMarkers = Array.isArray(treeMarkers) ? treeMarkers.slice(0) : [];

        // Add on the new entry.
        if (typeof parentIsLastChild !== 'undefined') {
          newTreeMarkers.push(!parentIsLastChild);
        }

        return opts.fn({
          node,
          isLastChild,
          hasChildren,
          startTime,
          transferSize: (transferSize + node.request.transferSize),
          treeMarkers: newTreeMarkers
        });
      },

      createTreeRenderContext(tree, opts) {
        const transferSize = 0;
        let startTime = 0;
        const rootNodes = Object.keys(tree);

        if (rootNodes.length > 0) {
          startTime = tree[rootNodes[0]].request.startTime;
        }

        return opts.fn({
          tree,
          startTime,
          transferSize
        });
      }
    };
  }
}

module.exports = CriticalRequestChains;

},{"./formatter":7,"path":198,"url":204}],6:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Formatter = require('./formatter');
const path = require('path');

const html = "<style>\n  .input-latency-measures {\n    font-size: 14px\n  }\n</style>\n\n<div>\n  <div class=\"input-latency-measures\">\n    <div>90% probability of input latency at <strong>{{ninetiethTime this}}ms</strong> or shorter.<div>\n    <div>\n      ({{#each this}}{{percentile this.percentile}}%: {{fixedTenths this.time}}ms{{#unless @last}}, {{/unless}}{{/each}})\n    </div>\n  </div>\n</div>\n";

class EstimatedInputLatencyFormatter extends Formatter {
  static getFormatter(type) {
    switch (type) {
      case 'pretty':
        return function(percentiles) {
          if (!percentiles || !Array.isArray(percentiles)) {
            return '';
          }

          const ninetieth = percentiles.find(result => result.percentile === 0.9);
          const time = ninetieth.time.toFixed(1);
          const allResults = percentiles.map(result => {
            const percentile = Math.round(result.percentile * 100);
            const time = result.time.toFixed(1);
            return `${percentile}%: ${time}ms`;
          }).join(', ');

          const output = `    - 90% probability of input latency at ${time}ms or shorter.\n` +
              `      (${allResults})\n`;

          return output;
        };

      case 'html':
        // Returns a handlebars string to be used by the Report.
        return html;

      default:
        throw new Error('Unknown formatter type');
    }
  }

  static getHelpers() {
    return {
      ninetiethTime(percentiles) {
        if (!Array.isArray(percentiles)) {
          return;
        }

        const ninetieth = percentiles.find(result => result.percentile === 0.9);
        return ninetieth.time.toFixed(1);
      },
      percentile(value) {
        return Math.round(value * 100);
      },
      fixedTenths(value) {
        return value.toFixed(1);
      }
    };
  }
}

module.exports = EstimatedInputLatencyFormatter;

},{"./formatter":7,"path":198}],7:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

class Formatter {

  static get CAPITAL_LETTERS() {
    return /([A-Z])/g;
  }

  static get SUPPORTED_FORMATS() {
    // Get the available formatters if they don't already exist.
    if (!this._formatters) {
      this._getFormatters();
    }

    // From the formatters we can establish a master list of supported format names.
    if (!this._supportedFormatsNames) {
      this._generateSupportedFormats();
    }

    return this._supportedFormatsNames;
  }

  static _getFormatters() {
    this._formatters = {
      accessibility: require('./accessibility'),
      criticalRequestChains: require('./critical-request-chains'),
      estimatedInputLatency: require('./estimated-input-latency'),
      urllist: require('./url-list'),
      null: require('./null-formatter'),
      speedline: require('./speedline-formatter'),
      userTimings: require('./user-timings')
    };
  }

  static _generateSupportedFormats() {
    const formatNames = Object.keys(this._formatters);
    this._supportedFormatsNames = formatNames.reduce((prev, format) => {
      // Reformulates names like criticalNetworkChains to CRITICAL_NETWORK_CHAINS so they appear
      // like a bunch of constants.
      const formatName = format.replace(Formatter.CAPITAL_LETTERS, '_$1').toUpperCase();
      prev[formatName] = format;
      return prev;
    }, {});
  }

  static getByName(name) {
    if (!this._formatters) {
      this._getFormatters();
    }

    if (!this._formatters[name]) {
      throw new Error(`Unknown formatter: ${name}`);
    }

    return this._formatters[name];
  }

  static getFormatter() {
    throw new Error('Formatter must implement getPrettyFormatter()');
  }

  /**
   * Optional function to get any Handlebars helpers this formatter expects to need.
   */
  static getHelpers() {}
}

module.exports = Formatter;

},{"./accessibility":4,"./critical-request-chains":5,"./estimated-input-latency":6,"./null-formatter":8,"./speedline-formatter":9,"./url-list":10,"./user-timings":11}],8:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Formatter = require('./formatter');

class NullFormatter extends Formatter {
  static getFormatter(type) {
    switch (type) {
      case 'pretty':
        return _ => '';

      case 'html':
        return '';

      default:
        throw new Error('Unknown formatter type');
    }
  }
}

module.exports = NullFormatter;

},{"./formatter":7}],9:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Formatter = require('./formatter');
const path = require('path');

const html = "<style>\n  .speedline-measures {\n    font-size: 14px\n  }\n</style>\n\n<div>\n  <div class=\"speedline-measures\">\n    <div>First Visual Change: <strong>{{this.first}}ms</strong></div>\n    <div>Last Visual Change: <strong>{{this.complete}}ms</strong></div>\n  </div>\n</div>\n";

class SpeedlineFormatter extends Formatter {
  static getFormatter(type) {
    switch (type) {
      case 'pretty':
        return function(info) {
          if (!info || !Array.isArray(info.frames)) {
            return '';
          }

          const output = `    - First Visual Change: ${info.first}ms\n` +
          `    - Last Visual Change: ${info.complete}ms\n`;

          return output;
        };

      case 'html':
        // Returns a handlebars string to be used by the Report.
        return html;

      default:
        throw new Error('Unknown formatter type');
    }
  }
}

module.exports = SpeedlineFormatter;

},{"./formatter":7,"path":198}],10:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Formatter = require('./formatter');
const path = require('path');

const html = "<style>\n  .http-resources {\n    font-size: 14px;\n  }\n  .http-resource__url {\n    margin-right: 8px;\n  }\n  .http-resource__protocol,\n  .http-resource__code {\n    color: #999;\n  }\n</style>\n\n<div>\n  <details class=\"http-resources\">\n    <summary>URLs</summary>\n    {{#each this}}\n      <div class=\"http-resource\">\n        <span class=\"http-resource__url\">{{this.url}}</span>\n        {{#if this.label}}\n          <span class=\"http-resource__protocol\">({{this.label}})</span>\n        {{/if}}\n        {{#if this.code}}\n          <pre class=\"http-resource__code\">{{this.code}}</pre>\n        {{/if}}\n      </div>\n    {{/each}}\n  </details>\n</div>\n";

class UrlList extends Formatter {
  static getFormatter(type) {
    switch (type) {
      case 'pretty':
        return resources => {
          if (!Array.isArray(resources)) {
            return '';
          }

          let output = '';
          resources.forEach(resource => {
            output += `      ${resource.url}`;
            if (resource.label) {
              output += ` (${resource.label})`;
            }
            output += '\n';
          });
          return output;
        };

      case 'html':
        // Returns a handlebars string to be used by the Report.
        return html;

      default:
        throw new Error('Unknown formatter type');
    }
  }
}

module.exports = UrlList;

},{"./formatter":7,"path":198}],11:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const Formatter = require('./formatter');
const path = require('path');

const html = "<style>\n  .ut-measures {\n    font-size: 14px\n  }\n\n  .ut-measure_listing-duration {\n    font-weight: bold\n  }\n</style>\n\n<div>\n  <div class=\"ut-measures\">\n    {{#each this}}\n      <div>\n        {{#if this.isMark}}\n          <span class=\"ut-measure_listing-duration\">Mark: {{ decimal this.startTime }}ms</span> - {{ this.name }}\n        {{else}}\n          <span class=\"ut-measure_listing-duration\">Measure {{ decimal this.duration }}ms</span> - {{ this.name }}\n        {{/if}}\n      </div>\n    {{/each}}\n  </div>\n</div>\n";

class UserTimings extends Formatter {
  static getFormatter(type) {
    switch (type) {
      case 'pretty':
        return events => {
          if (!Array.isArray(events)) {
            return '';
          }

          const measuresStr = events.filter(e => !e.isMark).reduce((prev, event) => {
            let output = prev + `    - measure ${event.name}: \t`;
            output += `duration: ${event.duration.toFixed(1)}ms,\t`;
            output += `start: ${event.startTime.toFixed(1)}ms,\tend: ${event.endTime.toFixed(1)}`;
            return output + '\n';
          }, '');
          const marksStr = events.filter(e => e.isMark).reduce((prev, event) => {
            return prev + `    - mark ${event.name}: \t time: ${event.startTime.toFixed(1)}ms\n`;
          }, '');
          return measuresStr + marksStr;
        };

      case 'html':
        // Returns a handlebars string to be used by the Report.
        return html;

      default:
        throw new Error('Unknown formatter type');
    }
  }
}

module.exports = UserTimings;

},{"./formatter":7,"path":198}],12:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const EventEmitter = require('events').EventEmitter;
const log = require('../../lib/log.js');

class Connection {

  constructor() {
    this._lastCommandId = 0;
    /** @type {!Map<number, {resolve: function(*), reject: function(*), method: string}>}*/
    this._callbacks = new Map();
    this._eventEmitter = new EventEmitter();
  }

  /**
   * @return {!Promise}
   */
  connect() {
    return Promise.reject(new Error('Not implemented'));
  }

  /**
   * @return {!Promise}
   */
  disconnect() {
    return Promise.reject(new Error('Not implemented'));
  }

  /**
   * Call protocol methods
   * @param {!string} method
   * @param {!Object} params
   * @return {!Promise}
   */
  sendCommand(method, params) {
    log.formatProtocol('method => browser', {method, params}, 'verbose');
    const id = ++this._lastCommandId;
    params = params || {};
    const message = JSON.stringify({id, method, params});
    this.sendRawMessage(message);
    return new Promise((resolve, reject) => {
      this._callbacks.set(id, {resolve, reject, method});
    });
  }

  /**
   * Bind listeners for connection events
   * @param {!string} eventName
   * @param {function(...)} cb
   */
  on(eventName, cb) {
    if (eventName !== 'notification') {
      throw new Error('Only supports "notification" events');
    }
    this._eventEmitter.on(eventName, cb);
  }

  /* eslint-disable no-unused-vars */

  /**
   * @param {string} message
   * @protected
   */
  sendRawMessage(message) {
    return Promise.reject(new Error('Not implemented'));
  }

  /* eslint-enable no-unused-vars */

  /**
   * @param {string} message
   * @protected
   */
  handleRawMessage(message) {
    const object = JSON.parse(message);
    // Remote debugging protocol is JSON RPC 2.0 compiant. In terms of that transport,
    // responses to the commands carry "id" property, while notifications do not.
    if (object.id) {
      const callback = this._callbacks.get(object.id);
      this._callbacks.delete(object.id);
      if (object.error) {
        log.formatProtocol('method <= browser ERR',
            {method: callback.method, params: object.result}, 'error');
        callback.reject(object.result);
        return;
      }
      log.formatProtocol('method <= browser OK',
          {method: callback.method, params: object.result}, 'verbose');
      callback.resolve(object.result);
      return;
    }
    log.formatProtocol('method <= browser EVENT',
        {method: object.method, params: object.result}, 'verbose');
    this.emitNotification(object.method, object.params);
  }

  /**
   * @param {!string} command
   * @param {!Object} params
   * @protected
   */
  emitNotification(method, params) {
    this._eventEmitter.emit('notification', {method, params});
  }

  /**
   * @protected
   */
  dispose() {
    this._eventEmitter.removeAllListeners();
    this._eventEmitter = null;
  }
}

module.exports = Connection;

},{"../../lib/log.js":21,"events":195}],13:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const NetworkRecorder = require('../../lib/network-recorder');
const emulation = require('../../lib/emulation');
const Element = require('../../lib/element');
const EventEmitter = require('events').EventEmitter;
const parseURL = require('url').parse;

const log = require('../../lib/log.js');

const MAX_WAIT_FOR_FULLY_LOADED = 25 * 1000;
const PAUSE_AFTER_LOAD = 500;

class Driver {

  /**
   * @param {!Connection} connection
   */
  constructor(connection) {
    this._traceEvents = [];
    this._traceCategories = Driver.traceCategories;
    this._eventEmitter = new EventEmitter();
    this._connection = connection;
    connection.on('notification', event => this._eventEmitter.emit(event.method, event.params));
  }

  static get traceCategories() {
    return [
      '-*', // exclude default
      'toplevel',
      'blink.console',
      'blink.user_timing',
      'benchmark',
      'netlog',
      'devtools.timeline',
      'disabled-by-default-blink.debug.layout',
      'disabled-by-default-devtools.timeline',
      'disabled-by-default-devtools.timeline.frame',
      'disabled-by-default-devtools.timeline.stack',
      // 'disabled-by-default-v8.cpu_profile',  // these would include JS stack samples, but
      // 'disabled-by-default-v8.cpu_profile.hires', // will take the trace from 5MB -> 100MB
      'disabled-by-default-devtools.screenshot'
    ];
  }

  /**
   * @return {!Promise<null>}
   */
  connect() {
    return this._connection.connect();
  }

  disconnect() {
    return this._connection.disconnect();
  }

  /**
   * Bind listeners for protocol events
   * @param {!string} eventName
   * @param {function(...)} cb
   */
  on(eventName, cb) {
    if (this._eventEmitter === null) {
      throw new Error('connect() must be called before attempting to listen to events.');
    }

    // log event listeners being bound
    log.formatProtocol('listen for event =>', {method: eventName}, 'verbose');
    this._eventEmitter.on(eventName, cb);
  }

  /**
   * Bind a one-time listener for protocol events. Listener is removed once it
   * has been called.
   * @param {!string} eventName
   * @param {function(...)} cb
   */
  once(eventName, cb) {
    if (this._eventEmitter === null) {
      throw new Error('connect() must be called before attempting to listen to events.');
    }
    // log event listeners being bound
    log.formatProtocol('listen once for event =>', {method: eventName}, 'verbose');
    this._eventEmitter.once(eventName, cb);
  }

  /**
   * Unbind event listeners
   * @param {!string} eventName
   * @param {function(...)} cb
   */
  off(eventName, cb) {
    if (this._eventEmitter === null) {
      throw new Error('connect() must be called before attempting to remove an event listener.');
    }

    this._eventEmitter.removeListener(eventName, cb);
  }

  /**
   * Call protocol methods
   * @param {!string} method
   * @param {!Object} params
   * @return {!Promise}
   */
  sendCommand(method, params) {
    return this._connection.sendCommand(method, params);
  }

  evaluateScriptOnLoad(scriptSource) {
    return this.sendCommand('Page.addScriptToEvaluateOnLoad', {
      scriptSource
    });
  }

  /**
   * Evaluate an expression in the context of the current page. Expression must
   * evaluate to a Promise. Returns a promise that resolves on asyncExpression's
   * resolved value.
   * @param {string} asyncExpression
   * @return {!Promise<*>}
   */
  evaluateAsync(asyncExpression) {
    return new Promise((resolve, reject) => {
      // If this gets to 60s and it hasn't been resolved, reject the Promise.
      const asyncTimeout = setTimeout(
        (_ => reject(new Error('The asynchronous expression exceeded the allotted time of 60s'))),
        60000
      );
      this.sendCommand('Runtime.evaluate', {
        expression: asyncExpression,
        includeCommandLineAPI: true,
        awaitPromise: true,
        returnByValue: true
      }).then(result => {
        clearTimeout(asyncTimeout);
        resolve(result.result.value);
      }).catch(reject);
    });
  }

  getSecurityState() {
    return new Promise((resolve, reject) => {
      this.once('Security.securityStateChanged', data => {
        this.sendCommand('Security.disable')
          .then(_ => resolve(data), reject);
      });

      this.sendCommand('Security.enable').catch(reject);
    });
  }

  getServiceWorkerVersions() {
    return new Promise((resolve, reject) => {
      this.once('ServiceWorker.workerVersionUpdated', data => {
        this.sendCommand('ServiceWorker.disable')
          .then(_ => resolve(data), reject);
      });

      this.sendCommand('ServiceWorker.enable').catch(reject);
    });
  }

  /**
   * If our main document URL redirects, we will update options.url accordingly
   * As such, options.url will always represent the post-redirected URL.
   * options.initialUrl is the pre-redirect URL that things started with
   */
  enableUrlUpdateIfRedirected(opts) {
    this._networkRecorder.on('requestloaded', redirectRequest => {
      // Quit if this is not a redirected request
      if (!redirectRequest.redirectSource) {
        return;
      }
      const earlierRequest = redirectRequest.redirectSource;
      if (earlierRequest.url === opts.url) {
        opts.url = redirectRequest.url;
      }
    });
  }

  /**
   * Returns a promise that resolves when the network has been idle for
   * `pauseAfterLoadMs` ms and a method to cancel internal network listeners and
   * timeout.
   * @param {string} pauseAfterLoadMs
   * @return {{promise: !Promise, cancel: function()}}
   * @private
   */
  _waitForNetworkIdle(pauseAfterLoadMs) {
    let idleTimeout;
    let cancel;

    const promise = new Promise((resolve, reject) => {
      const onIdle = () => {
        // eslint-disable-next-line no-use-before-define
        this._networkRecorder.once('networkbusy', onBusy);
        idleTimeout = setTimeout(_ => {
          cancel();
          resolve();
        }, pauseAfterLoadMs);
      };

      const onBusy = () => {
        this._networkRecorder.once('networkidle', onIdle);
        clearTimeout(idleTimeout);
      };

      cancel = () => {
        clearTimeout(idleTimeout);
        this._networkRecorder.removeListener('networkbusy', onBusy);
        this._networkRecorder.removeListener('networkidle', onIdle);
      };

      if (this._networkRecorder.isIdle()) {
        onIdle();
      } else {
        onBusy();
      }
    });

    return {
      promise,
      cancel
    };
  }

  /**
   * Return a promise that resolves `pauseAfterLoadMs` after the load event
   * fires and a method to cancel internal listeners and timeout.
   * @param {number} pauseAfterLoadMs
   * @return {{promise: !Promise, cancel: function()}}
   * @private
   */
  _waitForLoadEvent(pauseAfterLoadMs) {
    let loadListener;
    let loadTimeout;

    const promise = new Promise((resolve, reject) => {
      loadListener = function() {
        loadTimeout = setTimeout(resolve, pauseAfterLoadMs);
      };
      this.once('Page.loadEventFired', loadListener);
    });
    const cancel = () => {
      this.off('Page.loadEventFired', loadListener);
      clearTimeout(loadTimeout);
    };

    return {
      promise,
      cancel
    };
  }

  /**
   * Returns a promise that resolves when:
   * - it's been pauseAfterLoadMs milliseconds after both onload and the network
   * has gone idle, or
   * - MAX_WAIT_FOR_FULLY_LOADED milliseconds have passed.
   * See https://github.com/GoogleChrome/lighthouse/issues/627 for more.
   * @param {number} pauseAfterLoadMs
   * @return {!Promise}
   * @private
   */
  _waitForFullyLoaded(pauseAfterLoadMs) {
    let maxTimeoutHandle;

    // Listener for onload. Resolves pauseAfterLoadMs ms after load.
    const waitForLoadEvent = this._waitForLoadEvent(pauseAfterLoadMs);
    // Network listener. Resolves when the network has been idle for pauseAfterLoadMs.
    const waitForNetworkIdle = this._waitForNetworkIdle(pauseAfterLoadMs);

    // Wait for both load promises. Resolves on cleanup function the clears load
    // timeout timer.
    const loadPromise = Promise.all([
      waitForLoadEvent.promise,
      waitForNetworkIdle.promise
    ]).then(_ => {
      return function() {
        log.verbose('Driver', 'loadEventFired and network considered idle');
        clearTimeout(maxTimeoutHandle);
      };
    });

    // Last resort timeout. Resolves MAX_WAIT_FOR_FULLY_LOADED ms from now on
    // cleanup function that removes loadEvent and network idle listeners.
    const maxTimeoutPromise = new Promise((resolve, reject) => {
      maxTimeoutHandle = setTimeout(resolve, MAX_WAIT_FOR_FULLY_LOADED);
    }).then(_ => {
      return function() {
        log.warn('Driver', 'Timed out waiting for page load. Moving on...');
        waitForLoadEvent.cancel();
        waitForNetworkIdle.cancel();
      };
    });

    // Wait for load or timeout and run the cleanup function the winner returns.
    return Promise.race([
      loadPromise,
      maxTimeoutPromise
    ]).then(cleanup => cleanup());
  }

  /**
   * Navigate to the given URL. Use of this method directly isn't advised: if
   * the current page is already at the given URL, navigation will not occur and
   * so the returned promise will only resolve after the MAX_WAIT_FOR_FULLY_LOADED
   * timeout. See https://github.com/GoogleChrome/lighthouse/pull/185 for one
   * possible workaround.
   * @param {string} url
   * @param {!Object} options
   * @return {!Promise}
   */
  gotoURL(url, options) {
    const _options = options || {};
    const waitForLoad = _options.waitForLoad || false;
    const disableJS = _options.disableJavaScript || false;
    const pauseAfterLoadMs = (_options.flags && _options.flags.pauseAfterLoad) || PAUSE_AFTER_LOAD;

    return this.sendCommand('Page.enable')
      .then(_ => this.sendCommand('Emulation.setScriptExecutionDisabled', {value: disableJS}))
      .then(_ => this.sendCommand('Page.navigate', {url}))
      .then(_ => waitForLoad && this._waitForFullyLoaded(pauseAfterLoadMs));
  }

  reloadForCleanStateIfNeeded() {
    return Promise.resolve();
  }

  /**
   * @param {string} selector Selector to find in the DOM
   * @return {!Promise<Element>} The found element, or null, resolved in a promise
   */
  querySelector(selector) {
    return this.sendCommand('DOM.getDocument')
      .then(result => result.root.nodeId)
      .then(nodeId => this.sendCommand('DOM.querySelector', {
        nodeId,
        selector
      }))
      .then(element => {
        if (element.nodeId === 0) {
          return null;
        }
        return new Element(element, this);
      });
  }

  beginTrace() {
    const tracingOpts = {
      categories: this._traceCategories.join(','),
      transferMode: 'ReturnAsStream',
      options: 'sampling-frequency=10000'  // 1000 is default and too slow.
    };

    return this.sendCommand('Page.enable')
      .then(_ => this.sendCommand('Tracing.start', tracingOpts));
  }

  endTrace() {
    return new Promise((resolve, reject) => {
      // When the tracing has ended this will fire with a stream handle.
      this.once('Tracing.tracingComplete', streamHandle => {
        this._readTraceFromStream(streamHandle)
            .then(traceContents => resolve(traceContents), reject);
      });

      // Issue the command to stop tracing.
      this.sendCommand('Tracing.end').catch(reject);
    });
  }

  _readTraceFromStream(streamHandle) {
    return new Promise((resolve, reject) => {
      // COMPAT: We've found `result` not retaining its value in this scenario when it's
      // declared with `let`. Observed in Chrome 50 and 52. While investigating the V8 bug
      // further, we'll use a plain `var` declaration.
      var isEOF = false;
      var result = '';

      const readArguments = {
        handle: streamHandle.stream
      };

      const onChunkRead = response => {
        if (isEOF) {
          return;
        }

        result += response.data;

        if (response.eof) {
          isEOF = true;
          return resolve(JSON.parse(result));
        }

        return this.sendCommand('IO.read', readArguments).then(onChunkRead);
      };

      this.sendCommand('IO.read', readArguments).then(onChunkRead).catch(reject);
    });
  }

  beginNetworkCollect(opts) {
    return new Promise((resolve, reject) => {
      this._networkRecords = [];
      this._networkRecorder = new NetworkRecorder(this._networkRecords);
      this.enableUrlUpdateIfRedirected(opts);

      this.on('Network.requestWillBeSent', this._networkRecorder.onRequestWillBeSent);
      this.on('Network.requestServedFromCache', this._networkRecorder.onRequestServedFromCache);
      this.on('Network.responseReceived', this._networkRecorder.onResponseReceived);
      this.on('Network.dataReceived', this._networkRecorder.onDataReceived);
      this.on('Network.loadingFinished', this._networkRecorder.onLoadingFinished);
      this.on('Network.loadingFailed', this._networkRecorder.onLoadingFailed);
      this.on('Network.resourceChangedPriority', this._networkRecorder.onResourceChangedPriority);

      this.sendCommand('Network.enable').then(resolve, reject);
    });
  }

  endNetworkCollect() {
    return new Promise((resolve, reject) => {
      this.off('Network.requestWillBeSent', this._networkRecorder.onRequestWillBeSent);
      this.off('Network.requestServedFromCache', this._networkRecorder.onRequestServedFromCache);
      this.off('Network.responseReceived', this._networkRecorder.onResponseReceived);
      this.off('Network.dataReceived', this._networkRecorder.onDataReceived);
      this.off('Network.loadingFinished', this._networkRecorder.onLoadingFinished);
      this.off('Network.loadingFailed', this._networkRecorder.onLoadingFailed);
      this.off('Network.resourceChangedPriority', this._networkRecorder.onResourceChangedPriority);

      resolve(this._networkRecords);

      this._networkRecorder = null;
      this._networkRecords = [];
    });
  }

  enableRuntimeEvents() {
    return this.sendCommand('Runtime.enable');
  }

  beginEmulation() {
    return Promise.all([
      emulation.enableNexus5X(this),
      emulation.enableNetworkThrottling(this)
    ]);
  }

  /**
   * Emulate internet disconnection.
   * @return {!Promise}
   */
  goOffline() {
    return this.sendCommand('Network.enable').then(_ => emulation.goOffline(this));
  }

  /**
   * Enable internet connection, using emulated mobile settings if
   * `options.flags.mobile` is true.
   * @param {!Object} options
   * @return {!Promise}
   */
  goOnline(options) {
    return this.sendCommand('Network.enable').then(_ => {
      if (options.flags.mobile) {
        return emulation.enableNetworkThrottling(this);
      }

      return emulation.disableNetworkThrottling(this);
    });
  }

  cleanAndDisableBrowserCaches() {
    return Promise.all([
      this.clearBrowserCache(),
      this.disableBrowserCache()
    ]);
  }

  clearBrowserCache() {
    return this.sendCommand('Network.clearBrowserCache');
  }

  disableBrowserCache() {
    return this.sendCommand('Network.setCacheDisabled', {cacheDisabled: true});
  }

  clearDataForOrigin(url) {
    const parsedURL = parseURL(url);
    const origin = `${parsedURL.protocol}//${parsedURL.hostname}` +
      (parsedURL.port ? `:${parsedURL.port}` : '');

    // Clear all types of storage except cookies, so the user isn't logged out.
    //   https://chromedevtools.github.io/debugger-protocol-viewer/tot/Storage/#type-StorageType
    const typesToClear = [
      'appcache',
      // 'cookies',
      'file_systems',
      'indexeddb',
      'local_storage',
      'shader_cache',
      'websql',
      'service_workers',
      'cache_storage'
    ].join(',');

    return this.sendCommand('Storage.clearDataForOrigin', {
      origin: origin,
      storageTypes: typesToClear
    });
  }

  /**
   * Keeps track of calls to a JS function and returns a list of {url, line, col}
   * of the usage. Should be called before page load (in beforePass).
   * @param {string} funcName The function name to track ('Date.now', 'console.time').
   * @return {function(): !Promise<!Array<{url: string, line: number, col: number}>>}
   *     Call this method when you want results.
   */
  captureFunctionCallSites(funcName) {
    const globalVarToPopulate = `window['__${funcName}StackTraces']`;
    const collectUsage = () => {
      return this.evaluateAsync(
          `__returnResults(Array.from(${globalVarToPopulate}).map(item => JSON.parse(item)))`);
    };

    const funcBody = captureJSCallUsage.toString();

    this.evaluateScriptOnLoad(`
        ${globalVarToPopulate} = new Set();
        (${funcName} = ${funcBody}(${funcName}, ${globalVarToPopulate}))`);

    return collectUsage;
  }
}

/**
 * Tracks function call usage. Used by captureJSCalls to inject code into the page.
 * @param {function(...*): *} funcRef The function call to track.
 * @param {!Set} set An empty set to populate with stack traces. Should be
 *     on the global object.
 * @return {function(...*): *} A wrapper around the original function.
 */
function captureJSCallUsage(funcRef, set) {
  const originalFunc = funcRef;
  const originalPrepareStackTrace = Error.prepareStackTrace;

  return function() {
    // Note: this function runs in the context of the page that is being audited.

    const args = [...arguments]; // callee's arguments.

    // See v8's Stack Trace API https://github.com/v8/v8/wiki/Stack-Trace-API#customizing-stack-traces
    Error.prepareStackTrace = function(error, structStackTrace) {
      // First frame is the function we injected (the one that just threw).
      // Second, is the actual callsite of the funcRef we're after.
      const callFrame = structStackTrace[1];
      const file = callFrame.getFileName();
      const line = callFrame.getLineNumber();
      const col = callFrame.getColumnNumber();
      const stackTrace = structStackTrace.slice(1).map(
          callsite => callsite.toString());
      return {url: file, args, line, col, stackTrace}; // return value is e.stack
    };
    const e = new Error(`__called ${funcRef.name}__`);
    set.add(JSON.stringify(e.stack));

    // Restore prepareStackTrace so future errors use v8's formatter and not
    // our custom one.
    Error.prepareStackTrace = originalPrepareStackTrace;

    return originalFunc.apply(this, arguments);
  };
}

module.exports = Driver;

},{"../../lib/element":18,"../../lib/emulation":19,"../../lib/log.js":21,"../../lib/network-recorder":23,"events":195,"url":204}],14:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Connection = require('./connection.js');
const log = require('../../lib/log.js');

/* globals chrome */

class ExtensionConnection extends Connection {

  constructor() {
    super();
    this._tabId = null;

    this._onEvent = this._onEvent.bind(this);
    this._onUnexpectedDetach = this._onUnexpectedDetach.bind(this);
  }

  _onEvent(source, method, params) {
    // log events received
    log.log('<=', method, params);
    this.emitNotification(method, params);
  }

  _onUnexpectedDetach(debuggee, detachReason) {
    this._detachCleanup();
    throw new Error('Lighthouse detached from browser: ' + detachReason);
  }

  _detachCleanup() {
    this._tabId = null;
    chrome.debugger.onEvent.removeListener(this._onEvent);
    chrome.debugger.onDetach.removeListener(this._onUnexpectedDetach);
    this.dispose();
  }

  /**
   * @override
   * @return {!Promise}
   */
  connect() {
    if (this._tabId !== null) {
      return Promise.resolve();
    }

    return this._queryCurrentTab()
      .then(tab => {
        const tabId = this._tabId = tab.id;
        chrome.debugger.onEvent.addListener(this._onEvent);
        chrome.debugger.onDetach.addListener(this._onUnexpectedDetach);

        return new Promise((resolve, reject) => {
          chrome.debugger.attach({tabId}, '1.1', _ => {
            if (chrome.runtime.lastError) {
              return reject(chrome.runtime.lastError);
            }
            resolve(tabId);
          });
        });
      });
  }

  /**
   * @override
   * @return {!Promise}
   */
  disconnect() {
    if (this._tabId === null) {
      return Promise.resolve();
    }

    const tabId = this._tabId;
    return new Promise((resolve, reject) => {
      chrome.debugger.detach({tabId}, _ => {
        if (chrome.runtime.lastError) {
          return reject(chrome.runtime.lastError);
        }
        resolve();
      });
    }).then(_ => this._detachCleanup());
  }

  reloadForCleanStateIfNeeded(options) {
    // Reload the page to remove any side-effects (like disabling JavaScript).
    const status = 'Reloading page to reset state';
    log.log('status', status);
    return this.gotoURL(options.url).then(_ => {
      log.log('statusEnd', status);
    });
  }

  /**
   * @override
   * @param {!string} method
   * @param {!Object} params
   * @return {!Promise}
   */
  sendCommand(command, params) {
    return new Promise((resolve, reject) => {
      log.formatProtocol('method => browser', {method: command, params: params}, 'verbose');
      if (!this._tabId) {
        log.error('No tabId set for sendCommand');
      }
      chrome.debugger.sendCommand({tabId: this._tabId}, command, params, result => {
        if (chrome.runtime.lastError) {
          log.formatProtocol('method <= browser ERR', {method: command, params: result}, 'error');
          return reject(chrome.runtime.lastError);
        }

        if (result.wasThrown) {
          log.formatProtocol('method <= browser ERR', {method: command, params: result}, 'error');
          return reject(result.exceptionDetails);
        }

        log.formatProtocol('method <= browser OK', {method: command, params: result}, 'verbose');
        resolve(result);
      });
    });
  }

  _queryCurrentTab() {
    return new Promise((resolve, reject) => {
      const queryOpts = {
        active: true,
        lastFocusedWindow: true,
        windowType: 'normal'
      };

      chrome.tabs.query(queryOpts, (tabs => {
        if (chrome.runtime.lastError) {
          return reject(chrome.runtime.lastError);
        }
        if (tabs.length === 0) {
          const message = 'Couldn\'t resolve current tab. Please file a bug.';
          return reject(new Error(message));
        }
        resolve(tabs[0]);
      }));
    });
  }

  /**
   * Used by lighthouse-background to kick off the run on the current page
   */
  getCurrentTabURL() {
    return this._queryCurrentTab().then(tab => tab.url);
  }
}

module.exports = ExtensionConnection;

},{"../../lib/log.js":21,"./connection.js":12}],15:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Connection = require('./connection.js');

/* eslint-disable no-unused-vars */

/**
 * @interface
 */
class Port {
  /**
   * @param {!string} eventName, 'message', 'close'
   * @param {function(string|undefined)} cb
   */
  on(eventName, cb) { }

  /**
   * @param {string} message
   */
  send(message) { }

  close() { }
}

/* eslint-enable no-unused-vars */

class RawConnection extends Connection {
  constructor(port) {
    super();
    this._port = port;
    this._port.on('message', this.handleRawMessage.bind(this));
    this._port.on('close', this.dispose.bind(this));
  }

  /**
   * @override
   * @return {!Promise}
   */
  connect() {
    return Promise.resolve();
  }

  /**
   * @override
   */
  disconnect() {
    this._port.close();
    return Promise.resolve();
  }

  /**
   * @override
   * @param {string} message
   */
  sendRawMessage(message) {
    this._port.send(message);
  }
}

module.exports = RawConnection;

},{"./connection.js":12}],16:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const log = require('../lib/log.js');
const Audit = require('../audits/audit');
const path = require('path');

/**
 * Class that drives browser to load the page and runs gatherer lifecycle hooks.
 * Execution sequence when GatherRunner.run() is called:
 *
 * 1. Setup
 *   A. driver.connect()
 *   B. GatherRunner.setupDriver()
 *     i. beginEmulation
 *     ii. cleanAndDisableBrowserCaches
 *     iii. clearDataForOrigin
 *
 * 2. For each pass in the config:
 *   A. GatherRunner.beforePass()
 *     i. navigate to about:blank
 *     ii. all gatherer's beforePass()
 *   B. GatherRunner.pass()
 *     i. GatherRunner.loadPage()
 *       b. beginTrace (if requested) & beginNetworkCollect
 *       c. navigate to options.url (and wait for onload)
 *     ii. all gatherer's pass()
 *   C. GatherRunner.afterPass()
 *     i. endTrace (if requested) & endNetworkCollect
 *     ii. all gatherer's afterPass()
 *
 * 3. Teardown
 *   A. reloadForCleanStateIfNeeded
 *   B. driver.disconnect()
 *   C. collect all artifacts and return them
 */
class GatherRunner {
  /**
   * Loads about:blank and waits there briefly. Since a Page.reload command does
   * not let a service worker take over, we navigate away and then come back to
   * reload. We do not `waitForLoad` on about:blank since a page load event is
   * never fired on it.
   * @param {!Driver} driver
   * @return {!Promise}
   */
  static loadBlank(driver) {
    return driver.gotoURL('about:blank')
      .then(_ => new Promise((resolve, reject) => setTimeout(resolve, 300)));
  }

  /**
   * Loads options.url with specified options.
   * @param {!Driver} driver
   * @param {!Object} options
   * @return {!Promise}
   */
  static loadPage(driver, options) {
    return Promise.resolve()
      // Begin tracing only if requested by config.
      .then(_ => options.config.recordTrace && driver.beginTrace())
      // Network is always recorded for internal use, even if not saved as artifact.
      .then(_ => driver.beginNetworkCollect(options))
      // Navigate.
      .then(_ => driver.gotoURL(options.url, {
        waitForLoad: true,
        disableJavaScript: !!options.disableJavaScript,
        flags: options.flags,
      }));
  }

  static setupDriver(driver, options) {
    log.log('status', 'Initializing…');
    // Enable emulation if required.
    return Promise.resolve(options.flags.mobile && driver.beginEmulation())
      .then(_ => driver.enableRuntimeEvents())
      .then(_ => driver.cleanAndDisableBrowserCaches())
      .then(_ => driver.clearDataForOrigin(options.url));
  }

  /**
   * Navigates to about:blank and calls beforePass() on gatherers before tracing
   * has started and before navigation to the target page.
   * @param {!Object} options
   * @return {!Promise}
   */
  static beforePass(options) {
    const pass = GatherRunner.loadBlank(options.driver);

    return options.config.gatherers.reduce((chain, gatherer) => {
      return chain.then(_ => {
        return gatherer.beforePass(options);
      });
    }, pass);
  }

  /**
   * Navigates to requested URL and then runs pass() on gatherers while trace
   * (if requested) is still being recorded.
   * @param {!Object} options
   * @return {!Promise}
   */
  static pass(options) {
    const driver = options.driver;
    const config = options.config;
    const gatherers = config.gatherers;

    const gatherernames = gatherers.map(g => g.name).join(', ');
    const status = 'Loading page & waiting for onload';
    log.log('status', status, gatherernames);

    const pass = GatherRunner.loadPage(driver, options).then(_ => {
      log.log('statusEnd', status);
    });

    return gatherers.reduce((chain, gatherer) => {
      return chain.then(_ => gatherer.pass(options));
    }, pass);
  }

  /**
   * Ends tracing and collects trace data (if requested for this pass), and runs
   * afterPass() on gatherers with trace data passed in. Promise resolves with
   * object containing trace and network data.
   * @param {!Object} options
   * @return {!Promise}
   */
  static afterPass(options) {
    const driver = options.driver;
    const config = options.config;
    const gatherers = config.gatherers;
    const passData = {};

    let pass = Promise.resolve();

    if (config.recordTrace) {
      pass = pass.then(_ => {
        log.log('status', 'Retrieving trace');
        return driver.endTrace();
      }).then(traceContents => {
        // Before Chrome 54.0.2816 (codereview.chromium.org/2161583004),
        // traceContents was an array of trace events; after, traceContents is
        // an object with a traceEvents property. Normalize to object form.
        passData.trace = Array.isArray(traceContents) ?
            {traceEvents: traceContents} : traceContents;
        log.verbose('statusEnd', 'Retrieving trace');
      });
    }

    const status = 'Retrieving network records';
    pass = pass.then(_ => {
      log.log('status', status);
      return driver.endNetworkCollect();
    }).then(networkRecords => {
      // Network records only given to gatherers if requested by config.
      config.recordNetwork && (passData.networkRecords = networkRecords);
      log.verbose('statusEnd', status);
    });

    pass = gatherers.reduce((chain, gatherer) => {
      const status = `Retrieving: ${gatherer.name}`;
      return chain.then(_ => {
        log.log('status', status);
        return gatherer.afterPass(options, passData);
      }).then(ret => {
        log.verbose('statusEnd', status);
        return ret;
      });
    }, pass);

    // Resolve on tracing data using passName from config.
    return pass.then(_ => passData);
  }

  static run(passes, options) {
    const driver = options.driver;
    const tracingData = {
      traces: {},
      networkRecords: {}
    };

    if (typeof options.url !== 'string' || options.url.length === 0) {
      return Promise.reject(new Error('You must provide a url to the driver'));
    }

    if (typeof options.flags === 'undefined') {
      options.flags = {};
    }

    if (typeof options.config === 'undefined') {
      return Promise.reject(new Error('You must provide a config'));
    }

    // Default mobile emulation and page loading to true.
    // The extension will switch these off initially.
    if (typeof options.flags.mobile === 'undefined') {
      options.flags.mobile = true;
    }

    passes = this.instantiateGatherers(passes, options.config.configDir);

    return driver.connect()
      .then(_ => GatherRunner.setupDriver(driver, options))

      // Run each pass
      .then(_ => {
        // If the main document redirects, we'll update this to keep track
        let urlAfterRedirects;
        return passes.reduce((chain, config, passIndex) => {
          const runOptions = Object.assign({}, options, {config});
          return chain
            .then(_ => GatherRunner.beforePass(runOptions))
            .then(_ => GatherRunner.pass(runOptions))
            .then(_ => GatherRunner.afterPass(runOptions))
            .then(passData => {
              // If requested by config, merge trace and network data for this
              // pass into tracingData.
              const passName = config.passName || Audit.DEFAULT_PASS;
              config.recordTrace && (tracingData.traces[passName] = passData.trace);
              config.recordNetwork &&
                  (tracingData.networkRecords[passName] = passData.networkRecords);

              if (passIndex === 0) {
                urlAfterRedirects = runOptions.url;
              }
            });
        }, Promise.resolve()).then(_ => {
          options.url = urlAfterRedirects;
        });
      })
      .then(_ => {
        // We dont need to hold up the reporting for the reload/disconnect,
        // so we will not return a promise in here.
        driver.reloadForCleanStateIfNeeded(options).then(_ => {
          log.log('status', 'Disconnecting from browser...');
          driver.disconnect();
        });
      })
      .then(_ => {
        // Collate all the gatherer results.
        const computedArtifacts = this.instantiateComputedArtifacts();
        const artifacts = Object.assign({}, computedArtifacts, tracingData);

        passes.forEach(pass => {
          pass.gatherers.forEach(gatherer => {
            if (typeof gatherer.artifact === 'undefined') {
              throw new Error(`${gatherer.constructor.name} failed to provide an artifact.`);
            }

            artifacts[gatherer.name] = gatherer.artifact;
          });
        });
        return artifacts;
      });
  }

  static getGathererClass(nameOrGathererClass, configPath) {
    const Runner = require('../runner');
    const coreList = Runner.getGathererList();

    let GathererClass;
    if (typeof nameOrGathererClass === 'string') {
      const name = nameOrGathererClass;

      // See if the gatherer is a Lighthouse core gatherer.
      const coreGatherer = coreList.find(a => a === `${name}.js`);
      let requirePath = `./gatherers/${name}`;
      if (!coreGatherer) {
        // Otherwise, attempt to find it elsewhere. This throws if not found.
        requirePath = Runner.resolvePlugin(name, configPath, 'gatherer');
      }

      GathererClass = require(requirePath);

      this.assertValidGatherer(GathererClass, name);
    } else {
      GathererClass = nameOrGathererClass;
      this.assertValidGatherer(GathererClass);
    }

    return GathererClass;
  }

  static assertValidGatherer(GathererDefinition, gathererName) {
    const gathererInstance = new GathererDefinition();
    gathererName = gathererName || gathererInstance.name || 'gatherer';

    if (typeof gathererInstance.beforePass !== 'function') {
      throw new Error(`${gathererName} has no beforePass() method.`);
    }

    if (typeof gathererInstance.pass !== 'function') {
      throw new Error(`${gathererName} has no pass() method.`);
    }

    if (typeof gathererInstance.afterPass !== 'function') {
      throw new Error(`${gathererName} has no afterPass() method.`);
    }

    if (typeof gathererInstance.artifact !== 'object') {
      throw new Error(`${gathererName} has no artifact property.`);
    }
  }

  static instantiateComputedArtifacts() {
    const computedArtifacts = {};
    ["computed-artifact.js","critical-request-chains.js","pushed-requests.js","screenshots.js","speedline.js"].forEach(function(file) {
      // Drop `.js` suffix to keep browserify import happy.
      file = file.replace(/\.js$/, '');
      const ArtifactClass = require('./computed/' + file);
      const artifact = new ArtifactClass();
      // define the request* function that will be exposed on `artifacts`
      computedArtifacts['request' + artifact.name] = artifact.request.bind(artifact);
    });
    return computedArtifacts;
  }

  static instantiateGatherers(passes, rootPath) {
    return passes.map(pass => {
      pass.gatherers = pass.gatherers.map(gatherer => {
        // If this is already instantiated, don't do anything else.
        if (typeof gatherer !== 'string') {
          return gatherer;
        }

        const GathererClass = GatherRunner.getGathererClass(gatherer, rootPath);
        return new GathererClass();
      });

      return pass;
    });
  }
}

module.exports = GatherRunner;

},{"../audits/audit":"../audits/audit","../lib/log.js":21,"../runner":27,"path":198}],17:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const log = require('./log.js');

class ConsoleQuieter {

  static mute(opts) {
    ConsoleQuieter._logs = ConsoleQuieter._logs || [];

    console.log = function() {
      ConsoleQuieter._logs.push({type: 'log', args: arguments, prefix: opts.prefix});
    };
    console.warn = function() {
      ConsoleQuieter._logs.push({type: 'warn', args: arguments, prefix: opts.prefix});
    };
    console.error = function() {
      ConsoleQuieter._logs.push({type: 'error', args: arguments, prefix: opts.prefix});
    };
  }

  static unmuteAndFlush() {
    console.log = ConsoleQuieter._consolelog;
    console.warn = ConsoleQuieter._consolewarn;
    console.error = ConsoleQuieter._consoleerror;

    ConsoleQuieter._logs.forEach(entry => {
      log.verbose(`${entry.prefix}-${entry.type}`, ...entry.args);
    });
    ConsoleQuieter._logs = [];
  }
}

ConsoleQuieter._consolelog = console.log.bind(console);
ConsoleQuieter._consolewarn = console.warn.bind(console);
ConsoleQuieter._consoleerror = console.error.bind(console);

module.exports = ConsoleQuieter;

},{"./log.js":21}],18:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

class Element {

  constructor(element, driver) {
    if (!element || !driver) {
      throw Error('Driver and element required to create Element');
    }
    this.driver = driver;
    this.element = element;
  }

  /**
   * @param {!string} name Attribute name
   * @return {!Promise<?string>} The attribute value or null if not found
   */
  getAttribute(name) {
    return this.driver
      .sendCommand('DOM.getAttributes', {
        nodeId: this.element.nodeId
      })
      /**
       * @param {!{attributes: !Array<!string>}} resp The element attribute names & values are interleaved
       */
      .then(resp => {
        const attrIndex = resp.attributes.indexOf(name);
        if (attrIndex === -1) {
          return null;
        }
        return resp.attributes[attrIndex + 1];
      });
  }
}

module.exports = Element;

},{}],19:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Nexus 5X metrics adapted from emulated_devices/module.json
 */
const NEXUS5X_EMULATION_METRICS = {
  mobile: true,
  screenWidth: 412,
  screenHeight: 732,
  width: 412,
  height: 732,
  positionX: 0,
  positionY: 0,
  scale: 1,
  deviceScaleFactor: 2.625,
  fitWindow: false,
  screenOrientation: {
    angle: 0,
    type: 'portraitPrimary'
  }
};

const NEXUS5X_USERAGENT = {
  userAgent: 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 5 Build/MRA58N) AppleWebKit/537.36' +
    '(KHTML, like Gecko) Chrome/52.0.2743.8 Mobile Safari/537.36'
};

const TYPICAL_MOBILE_THROTTLING_METRICS = {
  latency: 150, // 150ms
  downloadThroughput: 1.6 * 1024 * 1024 / 8, // 1.6Mbps
  uploadThroughput: 750 * 1024 / 8, // 750Kbps
  offline: false
};

const OFFLINE_METRICS = {
  offline: true,
  // values of 0 remove any active throttling. crbug.com/456324#c9
  latency: 0,
  downloadThroughput: 0,
  uploadThroughput: 0
};

const NO_THROTTLING_METRICS = {
  latency: 0,
  downloadThroughput: 0,
  uploadThroughput: 0,
  offline: false
};

function enableNexus5X(driver) {
  /**
   * Finalizes touch emulation by enabling `"ontouchstart" in window` feature detect
   * to work. Messy hack, though copied verbatim from DevTools' emulation/TouchModel.js
   * where it's been working for years. addScriptToEvaluateOnLoad runs before any of the
   * page's JavaScript executes.
   */
  /* eslint-disable no-proto */ /* global window, document */ /* istanbul ignore next */
  const injectedTouchEventsFunction = function() {
    const touchEvents = ['ontouchstart', 'ontouchend', 'ontouchmove', 'ontouchcancel'];
    var recepients = [window.__proto__, document.__proto__];
    for (var i = 0; i < touchEvents.length; ++i) {
      for (var j = 0; j < recepients.length; ++j) {
        if (!(touchEvents[i] in recepients[j])) {
          Object.defineProperty(recepients[j], touchEvents[i], {
            value: null, writable: true, configurable: true, enumerable: true
          });
        }
      }
    }
  };
  /* eslint-enable */

  return Promise.all([
    driver.sendCommand('Emulation.setDeviceMetricsOverride', NEXUS5X_EMULATION_METRICS),
    // Network.enable must be called for UA overriding to work
    driver.sendCommand('Network.enable'),
    driver.sendCommand('Network.setUserAgentOverride', NEXUS5X_USERAGENT),
    driver.sendCommand('Emulation.setTouchEmulationEnabled', {
      enabled: true,
      configuration: 'mobile'
    }),
    driver.sendCommand('Page.addScriptToEvaluateOnLoad', {
      scriptSource: '(' + injectedTouchEventsFunction.toString() + ')()'
    })
  ]);
}

function enableNetworkThrottling(driver) {
  return driver.sendCommand('Network.emulateNetworkConditions', TYPICAL_MOBILE_THROTTLING_METRICS);
}

function disableNetworkThrottling(driver) {
  return driver.sendCommand('Network.emulateNetworkConditions', NO_THROTTLING_METRICS);
}

function goOffline(driver) {
  return driver.sendCommand('Network.emulateNetworkConditions', OFFLINE_METRICS);
}

module.exports = {
  enableNexus5X,
  enableNetworkThrottling,
  disableNetworkThrottling,
  goOffline
};

},{}],20:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * @param {!Manifest=} manifest
 * @return {boolean} Does the manifest have any icons?
 */
function doExist(manifest) {
  if (!manifest || !manifest.icons) {
    return false;
  }
  if (manifest.icons.value.length === 0) {
    return false;
  }
  return true;
}

/**
 * @param {number} sizeRequirement
 * @param {!Manifest} manifest
 * @return {!Array<string>} Value of satisfactory sizes (eg. ['192x192', '256x256'])
 */
function sizeAtLeast(sizeRequirement, manifest) {
  // An icon can be provided for a single size, or for multiple sizes.
  // To handle both, we flatten all found sizes into a single array.
  const iconValues = manifest.icons.value;
  const nestedSizes = iconValues.map(icon => icon.value.sizes.value);
  const flattenedSizes = [].concat.apply([], nestedSizes);

  return flattenedSizes
      // First, filter out any undefined values, in case an icon was defined without a size
      .filter(size => typeof size === 'string')
      // discard sizes that are not AAxBB (eg. "any")
      .filter(size => /\d+x\d+/.test(size))
      .filter(size => {
        // Split the '24x24' strings into ['24','24'] arrays
        const sizeStrs = size.split(/x/i);
        // Cast the ['24','24'] strings into [24,24] numbers
        const sizeNums = [parseFloat(sizeStrs[0]), parseFloat(sizeStrs[1])];
        // Only keep sizes that are as big as our required size
        const areIconsBigEnough = sizeNums[0] >= sizeRequirement && sizeNums[1] >= sizeRequirement;
        // Square is required: https://code.google.com/p/chromium/codesearch#chromium/src/chrome/browser/manifest/manifest_icon_selector.cc&q=ManifestIconSelector::IconSizesContainsBiggerThanMinimumSize&sq=package:chromium
        const areIconsSquare = sizeNums[0] === sizeNums[1];
        return areIconsBigEnough && areIconsSquare;
      });
}

module.exports = {
  doExist,
  sizeAtLeast
};

},{}],21:[function(require,module,exports){
(function (process){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const debug = require('debug');
const EventEmitter = require('events').EventEmitter;

function setLevel(level) {
  if (level === 'verbose') {
    debug.enable('*');
  } else if (level === 'error') {
    debug.enable('*:error');
  } else {
    debug.enable('*, -*:verbose');
  }
}

const loggers = {};
function _log(title, logargs) {
  const args = [...logargs].slice(1);
  if (!loggers[title]) {
    loggers[title] = debug(title);
  }
  return loggers[title](...args);
}

class Emitter extends EventEmitter {
  /**
   * Fires off all status updates. Listen with
   * `require('lib/log').events.addListener('status', callback)`
   */
  issueStatus(title, args) {
    if (title === 'status' || title === 'statusEnd') {
      this.emit(title, args);
    }
  }

  /**
   * Fires off all warnings. Listen with
   * `require('lib/log').events.addListener('warning', callback)`
   */
  issueWarning(args) {
    this.emit('warning', args);
  }
}

/**
 * A simple formatting utility for event logging.
 * @param {string} prefix
 * @param {!Object} data A JSON-serializable object of event data to log.
 * @param {string=} level Optional logging level. Defaults to 'log'.
 */
function formatProtocol(prefix, data, level) {
  const columns = (!process || process.browser) ? Infinity : process.stdout.columns;
  const maxLength = columns - data.method.length - prefix.length - 18;
  // IO.read blacklisted here to avoid logging megabytes of trace data
  const snippet = (data.params && data.method !== 'IO.read') ?
      JSON.stringify(data.params).substr(0, maxLength) : '';
  level = level || 'log';
  _log(`${prefix}:${level}`, prefix, data.method, snippet);
}

module.exports = {
  setLevel,
  formatProtocol,
  events: new Emitter(),
  log(title) {
    this.events.issueStatus(title, arguments);
    return _log(title, arguments);
  },

  warn(title) {
    this.events.issueWarning(arguments);
    return _log(`${title}:warn`, arguments);
  },

  error(title) {
    return _log(`${title}:error`, arguments);
  },

  verbose(title) {
    this.events.issueStatus(title, arguments);
    return _log(`${title}:verbose`, arguments);
  }
};

}).call(this,require('_process'))
},{"_process":199,"debug":234,"events":195}],22:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const url = require('url');
const validateColor = require('./web-inspector').Color.parse;

const ALLOWED_DISPLAY_VALUES = [
  'fullscreen',
  'standalone',
  'minimal-ui',
  'browser'
];
/**
 * All display-mode fallbacks, including when unset, lead to default display mode 'browser'.
 * @see https://w3c.github.io/manifest/#dfn-default-display-mode
 */
const DEFAULT_DISPLAY_MODE = 'browser';

const ALLOWED_ORIENTATION_VALUES = [
  'any',
  'natural',
  'landscape',
  'portrait',
  'portrait-primary',
  'portrait-secondary',
  'landscape-primary',
  'landscape-secondary'
];

function parseString(raw, trim) {
  let value;
  let debugString;

  if (typeof raw === 'string') {
    value = trim ? raw.trim() : raw;
  } else {
    if (raw !== undefined) {
      debugString = 'ERROR: expected a string.';
    }
    value = undefined;
  }

  return {
    raw,
    value,
    debugString
  };
}

function parseColor(raw) {
  const color = parseString(raw);

  // Finished if color missing or not a string.
  if (color.value === undefined) {
    return color;
  }

  // Use DevTools's color parser to check CSS3 Color parsing.
  const validatedColor = validateColor(color.raw);
  if (!validatedColor) {
    color.value = undefined;
    color.debugString = 'ERROR: color parsing failed.';
  }

  return color;
}

function parseName(jsonInput) {
  return parseString(jsonInput.name, true);
}

function parseShortName(jsonInput) {
  return parseString(jsonInput.short_name, true);
}

/**
 * Returns whether the urls are of the same origin. See https://html.spec.whatwg.org/#same-origin
 * @param {string} url1
 * @param {string} url2
 * @return {boolean}
 */
function checkSameOrigin(url1, url2) {
  const parsed1 = url.parse(url1);
  const parsed2 = url.parse(url2);

  return parsed1.protocol === parsed2.protocol &&
      parsed1.hostname === parsed2.hostname &&
      parsed1.port === parsed2.port;
}

/**
 * https://w3c.github.io/manifest/#start_url-member
 */
function parseStartUrl(jsonInput, manifestUrl, documentUrl) {
  const raw = jsonInput.start_url;

  // 8.10(3) - discard the empty string and non-strings.
  if (raw === '') {
    return {
      raw,
      value: documentUrl,
      debugString: 'ERROR: start_url string empty'
    };
  }
  const parsedAsString = parseString(raw);
  if (!parsedAsString.value) {
    parsedAsString.value = documentUrl;
    return parsedAsString;
  }

  // 8.10(4) - construct URL with raw as input and manifestUrl as the base.
  let startUrl;
  try {
    // TODO(bckenny): need better URL constructor to do this properly. See
    // https://github.com/GoogleChrome/lighthouse/issues/602
    startUrl = url.resolve(manifestUrl, raw);
  } catch (e) {
    // 8.10(5) - discard invalid URLs.
    return {
      raw,
      value: documentUrl,
      debugString: 'ERROR: invalid start_url relative to ${manifestUrl}'
    };
  }

  // 8.10(6) - discard start_urls that are not same origin as documentUrl.
  if (!checkSameOrigin(startUrl, documentUrl)) {
    return {
      raw,
      value: documentUrl,
      debugString: 'ERROR: start_url must be same-origin as document'
    };
  }

  return {
    raw,
    value: startUrl
  };
}

function parseDisplay(jsonInput) {
  const display = parseString(jsonInput.display, true);

  if (!display.value) {
    display.value = DEFAULT_DISPLAY_MODE;
    return display;
  }

  display.value = display.value.toLowerCase();
  if (ALLOWED_DISPLAY_VALUES.indexOf(display.value) === -1) {
    display.debugString = 'ERROR: \'display\' has invalid value ' + display.value +
        ` will fall back to ${DEFAULT_DISPLAY_MODE}.`;
    display.value = DEFAULT_DISPLAY_MODE;
  }

  return display;
}

function parseOrientation(jsonInput) {
  const orientation = parseString(jsonInput.orientation, true);

  if (orientation.value &&
      ALLOWED_ORIENTATION_VALUES.indexOf(orientation.value.toLowerCase()) === -1) {
    orientation.value = undefined;
    orientation.debugString = 'ERROR: \'orientation\' has an invalid value, will be ignored.';
  }

  return orientation;
}

function parseIcon(raw, manifestUrl) {
  // 9.4(3)
  const src = parseString(raw.src, true);
  // 9.4(4) - discard if trimmed value is the empty string.
  if (src.value === '') {
    src.value = undefined;
  }
  if (src.value) {
    // TODO(bckenny): need better URL constructor to do this properly. See
    // https://github.com/GoogleChrome/lighthouse/issues/602
    // 9.4(4) - construct URL with manifest URL as the base
    src.value = url.resolve(manifestUrl, src.value);
  }

  const type = parseString(raw.type, true);

  const density = {
    raw: raw.density,
    value: 1,
    debugString: undefined
  };
  if (density.raw !== undefined) {
    density.value = parseFloat(density.raw);
    if (isNaN(density.value) || !isFinite(density.value) || density.value <= 0) {
      density.value = 1;
      density.debugString = 'ERROR: icon density cannot be NaN, +∞, or less than or equal to +0.';
    }
  }

  const sizes = parseString(raw.sizes);
  if (sizes.value !== undefined) {
    const set = new Set();
    sizes.value.trim().split(/\s+/).forEach(size => set.add(size.toLowerCase()));
    sizes.value = set.size > 0 ? Array.from(set) : undefined;
  }

  return {
    raw,
    value: {
      src,
      type,
      density,
      sizes
    },
    debugString: undefined
  };
}

function parseIcons(jsonInput, manifestUrl) {
  const raw = jsonInput.icons;

  if (raw === undefined) {
    return {
      raw,
      value: [],
      debugString: undefined
    };
  }

  if (!Array.isArray(raw)) {
    return {
      raw,
      value: [],
      debugString: 'ERROR: \'icons\' expected to be an array but is not.'
    };
  }

  // TODO(bckenny): spec says to skip icons missing `src`, so debug messages on
  // individual icons are lost. Warn instead?
  const value = raw
    // 9.6(3)(1)
    .filter(icon => icon.src !== undefined)
    // 9.6(3)(2)(1)
    .map(icon => parseIcon(icon, manifestUrl))
    // 9.6(3)(2)(2)
    .filter(parsedIcon => parsedIcon.value.src.value !== undefined);

  return {
    raw,
    value,
    debugString: undefined
  };
}

function parseApplication(raw) {
  const platform = parseString(raw.platform, true);
  const id = parseString(raw.id, true);

  // 10.2.(2) and 10.2.(3)
  const appUrl = parseString(raw.url, true);
  if (appUrl.value) {
    try {
      // TODO(bckenny): need better URL constructor to do this properly. See
      // https://github.com/GoogleChrome/lighthouse/issues/602
      // 10.2.(4) - attempt to construct URL.
      appUrl.value = url.parse(appUrl.value).href;
    } catch (e) {
      appUrl.value = undefined;
      appUrl.debugString = 'ERROR: invalid application URL ${raw.url}';
    }
  }

  return {
    raw,
    value: {
      platform,
      id,
      url: appUrl
    },
    debugString: undefined
  };
}

function parseRelatedApplications(jsonInput) {
  const raw = jsonInput.related_applications;

  if (raw === undefined) {
    return {
      raw,
      value: undefined,
      debugString: undefined
    };
  }

  if (!Array.isArray(raw)) {
    return {
      raw,
      value: undefined,
      debugString: 'ERROR: \'related_applications\' expected to be an array but is not.'
    };
  }

  // TODO(bckenny): spec says to skip apps missing `platform`, so debug messages
  // on individual apps are lost. Warn instead?
  const value = raw
    .filter(application => !!application.platform)
    .map(parseApplication)
    .filter(parsedApp => !!parsedApp.value.id.value || !!parsedApp.value.url.value);

  return {
    raw,
    value,
    debugString: undefined
  };
}

function parsePreferRelatedApplications(jsonInput) {
  const raw = jsonInput.prefer_related_applications;
  let value;
  let debugString;

  if (typeof raw === 'boolean') {
    value = raw;
  } else {
    if (raw !== undefined) {
      debugString = 'ERROR: \'prefer_related_applications\' expected to be a boolean.';
    }
    value = undefined;
  }

  return {
    raw,
    value,
    debugString
  };
}

function parseThemeColor(jsonInput) {
  return parseColor(jsonInput.theme_color);
}

function parseBackgroundColor(jsonInput) {
  return parseColor(jsonInput.background_color);
}

/**
 * Parse a manifest from the given inputs.
 * @param {string} string Manifest JSON string.
 * @param {string} manifestUrl URL of manifest file.
 * @param {string} documentUrl URL of document containing manifest link element.
 * @return {!ManifestNode<(!Manifest|undefined)>}
 */
function parse(string, manifestUrl, documentUrl) {
  if (manifestUrl === undefined || documentUrl === undefined) {
    throw new Error('Manifest and document URLs required for manifest parsing.');
  }

  let jsonInput;

  try {
    jsonInput = JSON.parse(string);
  } catch (e) {
    return {
      raw: string,
      value: undefined,
      debugString: 'ERROR: file isn\'t valid JSON: ' + e
    };
  }

  /* eslint-disable camelcase */
  const manifest = {
    name: parseName(jsonInput),
    short_name: parseShortName(jsonInput),
    start_url: parseStartUrl(jsonInput, manifestUrl, documentUrl),
    display: parseDisplay(jsonInput),
    orientation: parseOrientation(jsonInput),
    icons: parseIcons(jsonInput, manifestUrl),
    related_applications: parseRelatedApplications(jsonInput),
    prefer_related_applications: parsePreferRelatedApplications(jsonInput),
    theme_color: parseThemeColor(jsonInput),
    background_color: parseBackgroundColor(jsonInput)
  };
  /* eslint-enable camelcase */

  return {
    raw: string,
    value: manifest,
    debugString: undefined
  };
}

module.exports = parse;

},{"./web-inspector":26,"url":204}],23:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const NetworkManager = require('./web-inspector').NetworkManager;
const EventEmitter = require('events').EventEmitter;
const log = require('../lib/log.js');

class NetworkRecorder extends EventEmitter {
  constructor(recordArray) {
    super();

    this._records = recordArray;
    this.networkManager = NetworkManager.createWithFakeTarget();

    this.startedRequestCount = 0;
    this.finishedRequestCount = 0;

    this.networkManager.addEventListener(this.EventTypes.RequestStarted,
        this.onRequestStarted.bind(this));
    this.networkManager.addEventListener(this.EventTypes.RequestFinished,
        this.onRequestFinished.bind(this));

    this.onRequestWillBeSent = this.onRequestWillBeSent.bind(this);
    this.onRequestServedFromCache = this.onRequestServedFromCache.bind(this);
    this.onResponseReceived = this.onResponseReceived.bind(this);
    this.onDataReceived = this.onDataReceived.bind(this);
    this.onLoadingFinished = this.onLoadingFinished.bind(this);
    this.onLoadingFailed = this.onLoadingFailed.bind(this);
    this.onResourceChangedPriority = this.onResourceChangedPriority.bind(this);
  }

  get EventTypes() {
    return NetworkManager.Events;
  }

  activeRequestCount() {
    return this.startedRequestCount - this.finishedRequestCount;
  }

  isIdle() {
    return this.activeRequestCount() === 0;
  }

  /**
   * Listener for the NetworkManager's RequestStarted event, which includes both
   * web socket and normal request creation.
   * @private
   */
  onRequestStarted() {
    this.startedRequestCount++;

    const activeCount = this.activeRequestCount();
    log.verbose('NetworkRecorder', `Request started. ${activeCount} requests in progress` +
        ` (${this.startedRequestCount} started and ${this.finishedRequestCount} finished).`);

    // If only one request in progress, emit event that we've transitioned from
    // idle to busy.
    if (activeCount === 1) {
      this.emit('networkbusy');
    }
  }

  /**
   * Listener for the NetworkManager's RequestFinished event, which includes
   * request finish, failure, and redirect, as well as the closing of web
   * sockets.
   * @param {!WebInspector.NetworkRequest} request
   * @private
   */
  onRequestFinished(request) {
    this.finishedRequestCount++;
    this._records.push(request.data);
    this.emit('requestloaded', request.data);

    const activeCount = this.activeRequestCount();
    log.verbose('NetworkRecorder', `Request finished. ${activeCount} requests in progress` +
        ` (${this.startedRequestCount} started and ${this.finishedRequestCount} finished).`);

    // If no requests in progress, emit event that we've transitioned from busy
    // to idle.
    if (this.isIdle()) {
      this.emit('networkidle');
    }
  }

  // There are a few differences between the debugging protocol naming and
  // the parameter naming used in NetworkManager. These are noted below.

  onRequestWillBeSent(data) {
    // NOTE: data.timestamp -> time, data.type -> resourceType
    this.networkManager._dispatcher.requestWillBeSent(data.requestId,
        data.frameId, data.loaderId, data.documentURL, data.request,
        data.timestamp, data.wallTime, data.initiator, data.redirectResponse,
        data.type);
  }

  onRequestServedFromCache(data) {
    this.networkManager._dispatcher.requestServedFromCache(data.requestId);
  }

  onResponseReceived(data) {
    // NOTE: data.timestamp -> time, data.type -> resourceType
    this.networkManager._dispatcher.responseReceived(data.requestId,
        data.frameId, data.loaderId, data.timestamp, data.type, data.response);
  }

  onDataReceived(data) {
    // NOTE: data.timestamp -> time
    this.networkManager._dispatcher.dataReceived(data.requestId, data.timestamp,
        data.dataLength, data.encodedDataLength);
  }

  onLoadingFinished(data) {
    // NOTE: data.timestamp -> finishTime
    this.networkManager._dispatcher.loadingFinished(data.requestId,
        data.timestamp, data.encodedDataLength);
  }

  onLoadingFailed(data) {
    // NOTE: data.timestamp -> time, data.type -> resourceType,
    // data.errorText -> localizedDescription
    this.networkManager._dispatcher.loadingFailed(data.requestId,
        data.timestamp, data.type, data.errorText, data.canceled,
        data.blockedReason);
  }

  onResourceChangedPriority(data) {
    this.networkManager._dispatcher.resourceChangedPriority(data.requestId,
        data.newPriority, data.timestamp);
  }

  static recordsFromLogs(logs) {
    const records = [];
    const nr = new NetworkRecorder(records);
    const dispatcher = method => {
      switch (method) {
        case 'Network.requestWillBeSent': return nr.onRequestWillBeSent;
        case 'Network.requestServedFromCache': return nr.onRequestServedFromCache;
        case 'Network.responseReceived': return nr.onResponseReceived;
        case 'Network.dataReceived': return nr.onDataReceived;
        case 'Network.loadingFinished': return nr.onLoadingFinished;
        case 'Network.loadingFailed': return nr.onLoadingFailed;
        case 'Network.resourceChangedPriority': return nr.onResourceChangedPriority;
        default: return () => {};
      }
    };

    logs.forEach(networkEvent => {
      dispatcher(networkEvent.method)(networkEvent.params);
    });

    return records;
  }
}

module.exports = NetworkRecorder;

},{"../lib/log.js":21,"./web-inspector":26,"events":195}],24:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

const WebInspector = require('../web-inspector');
const ConsoleQuieter = require('../console-quieter');

// Polyfill the bottom-up and topdown tree sorting.
const TimelineModelTreeView =
    require('devtools-timeline-model/lib/timeline-model-treeview.js')(WebInspector);

class TimelineModel {

  constructor(events) {
    this.init(events);
  }

  init(events) {
    // (devtools) tracing model
    this._tracingModel =
        new WebInspector.TracingModel(new WebInspector.TempFileBackingStorage('tracing'));
    // timeline model
    this._timelineModel =
        new WebInspector.TimelineModel(WebInspector.TimelineUIUtils.visibleEventsFilter());

    if (typeof events === 'string') {
      events = JSON.parse(events);
    }
    if (events.hasOwnProperty('traceEvents')) {
      events = events.traceEvents;
    }

    // populate with events
    this._tracingModel.reset();

    ConsoleQuieter.mute({prefix: 'timelineModel'});
    this._tracingModel.addEvents(events);
    this._tracingModel.tracingComplete();
    this._timelineModel.setEvents(this._tracingModel);
    ConsoleQuieter.unmuteAndFlush();

    return this;
  }

  _createAggregator() {
    return WebInspector.AggregatedTimelineTreeView.prototype._createAggregator();
  }

  timelineModel() {
    return this._timelineModel;
  }

  tracingModel() {
    return this._tracingModel;
  }

  topDown() {
    var filters = [];
    filters.push(WebInspector.TimelineUIUtils.visibleEventsFilter());
    filters.push(new WebInspector.ExcludeTopLevelFilter());
    var nonessentialEvents = [
      WebInspector.TimelineModel.RecordType.EventDispatch,
      WebInspector.TimelineModel.RecordType.FunctionCall,
      WebInspector.TimelineModel.RecordType.TimerFire
    ];
    filters.push(new WebInspector.ExclusiveNameFilter(nonessentialEvents));

    var topDown = WebInspector.TimelineProfileTree.buildTopDown(
        this._timelineModel.mainThreadEvents(),
        filters, /* startTime */ 0, /* endTime */ Infinity,
        WebInspector.TimelineAggregator.eventId);
    return topDown;
  }

  bottomUp() {
    var topDown = this.topDown();
    var noGrouping = WebInspector.TimelineAggregator.GroupBy.None;
    var noGroupAggregator = this._createAggregator().groupFunction(noGrouping);
    return WebInspector.TimelineProfileTree.buildBottomUp(topDown, noGroupAggregator);
  }

 /**
  * @param  {!string} grouping Allowed values: None Category Subdomain Domain URL EventName
  * @return {!WebInspector.TimelineProfileTree.Node} A grouped and sorted tree
  */
  bottomUpGroupBy(grouping) {
    var topDown = this.topDown();

    var groupSetting = WebInspector.TimelineAggregator.GroupBy[grouping];
    var groupingAggregator = this._createAggregator().groupFunction(groupSetting);
    var bottomUpGrouped =
        WebInspector.TimelineProfileTree.buildBottomUp(topDown, groupingAggregator);

    // sort the grouped tree, in-place
    new TimelineModelTreeView(bottomUpGrouped).sortingChanged('self', 'desc');
    return bottomUpGrouped;
  }

  frameModel() {
    var frameModel = new WebInspector.TimelineFrameModel(event =>
      WebInspector.TimelineUIUtils.eventStyle(event).category.name
    );
    frameModel.addTraceEvents({ /* target */ },
      this._timelineModel.inspectedTargetEvents(), this._timelineModel.sessionId() || '');
    return frameModel;
  }

  filmStripModel() {
    return new WebInspector.FilmStripModel(this._tracingModel);
  }

  interactionModel() {
    var irModel = new WebInspector.TimelineIRModel();
    irModel.populate(this._timelineModel);
    return irModel;
  }

}

module.exports = TimelineModel;

},{"../console-quieter":17,"../web-inspector":26,"devtools-timeline-model/lib/timeline-model-treeview.js":236}],25:[function(require,module,exports){
(function (global){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

if (typeof global.window === 'undefined') {
  global.window = global;
}

// The ideal input response latency, the time between the input task and the
// first frame of the response.
const BASE_RESPONSE_LATENCY = 16;

// we need gl-matrix and jszip for traceviewer
// since it has internal forks for isNode and they get mixed up during
// browserify, we require them locally here and global-ize them.

// from catapult/tracing/tracing/base/math.html
const glMatrixModule = require('gl-matrix');
Object.keys(glMatrixModule).forEach(exportName => {
  global[exportName] = glMatrixModule[exportName];
});
// from catapult/tracing/tracing/extras/importer/jszip.html
global.JSZip = require('jszip/dist/jszip.min.js');
global.mannwhitneyu = {};

global.HTMLImportsLoader = {};
global.HTMLImportsLoader.hrefToAbsolutePath = function(path) {
  if (path === '/gl-matrix-min.js') {
    return '../../../lib/empty-stub.js';
  }
  if (path === '/jszip.min.js') {
    return 'jszip/dist/jszip.min.js';
  }
  if (path === '/mannwhitneyu.js') {
    return '../../../lib/empty-stub.js';
  }
};

require('../../third_party/traceviewer-js/');
const traceviewer = global.tr;

class TraceProcessor {
  get RESPONSE() {
    return 'Response';
  }

  get ANIMATION() {
    return 'Animation';
  }

  get LOAD() {
    return 'Load';
  }

  // Create the importer and import the trace contents to a model.
  init(trace) {
    const io = new traceviewer.importer.ImportOptions();
    io.showImportWarnings = false;
    io.pruneEmptyContainers = false;
    io.shiftWorldToZero = true;

    const model = new traceviewer.Model();
    const importer = new traceviewer.importer.Import(model, io);
    importer.importTraces([trace]);

    return model;
  }

  /**
   * Find a main thread from supplied model with matching processId and
   * threadId.
   * @param {!Object} model TraceProcessor Model
   * @param {number} processId
   * @param {number} threadId
   * @return {!Object}
   * @private
   */
  static _findMainThreadFromIds(model, processId, threadId) {
    const modelHelper = model.getOrCreateHelper(traceviewer.model.helpers.ChromeModelHelper);
    const renderHelpers = traceviewer.b.dictionaryValues(modelHelper.rendererHelpers);
    const mainThread = renderHelpers.find(helper => {
      return helper.mainThread &&
        helper.pid === processId &&
        helper.mainThread.tid === threadId;
    }).mainThread;

    return mainThread;
  }

  /**
   * Calculate duration at specified percentiles for given population of
   * durations.
   * If one of the durations overlaps the end of the window, the full
   * duration should be in the duration array, but the length not included
   * within the window should be given as `clippedLength`. For instance, if a
   * 50ms duration occurs 10ms before the end of the window, `50` should be in
   * the `durations` array, and `clippedLength` should be set to 40.
   * @see https://docs.google.com/document/d/18gvP-CBA2BiBpi3Rz1I1ISciKGhniTSZ9TY0XCnXS7E/preview
   * @param {!Array<number>} durations Array of durations, sorted in ascending order.
   * @param {number} totalTime Total time (in ms) of interval containing durations.
   * @param {!Array<number>} percentiles Array of percentiles of interest, in ascending order.
   * @param {number=} clippedLength Optional length clipped from a duration overlapping end of window. Default of 0.
   * @return {!Array<{percentile: number, time: number}>}
   * @private
   */
  static _riskPercentiles(durations, totalTime, percentiles, clippedLength) {
    clippedLength = clippedLength || 0;

    let busyTime = 0;
    for (let i = 0; i < durations.length; i++) {
      busyTime += durations[i];
    }
    busyTime -= clippedLength;

    // Start with idle time already complete.
    let completedTime = totalTime - busyTime;
    let duration = 0;
    let cdfTime = completedTime;
    const results = [];

    let durationIndex = -1;
    let remainingCount = durations.length + 1;
    if (clippedLength > 0) {
      // If there was a clipped duration, one less in count since one hasn't started yet.
      remainingCount--;
    }

    // Find percentiles of interest, in order.
    for (const percentile of percentiles) {
      // Loop over durations, calculating a CDF value for each until it is above
      // the target percentile.
      const percentileTime = percentile * totalTime;
      while (cdfTime < percentileTime && durationIndex < durations.length - 1) {
        completedTime += duration;
        remainingCount -= (duration < 0 ? -1 : 1);

        if (clippedLength > 0 && clippedLength < durations[durationIndex + 1]) {
          duration = -clippedLength;
          clippedLength = 0;
        } else {
          durationIndex++;
          duration = durations[durationIndex];
        }

        // Calculate value of CDF (multiplied by totalTime) for the end of this duration.
        cdfTime = completedTime + Math.abs(duration) * remainingCount;
      }

      // Negative results are within idle time (0ms wait by definition), so clamp at zero.
      results.push({
        percentile,
        time: Math.max(0, (percentileTime - completedTime) / remainingCount) + BASE_RESPONSE_LATENCY
      });
    }

    return results;
  }

  /**
   * Calculates the maximum queueing time (in ms) of high priority tasks for
   * selected percentiles within a window of the main thread.
   * @see https://docs.google.com/document/d/18gvP-CBA2BiBpi3Rz1I1ISciKGhniTSZ9TY0XCnXS7E/preview
   * @param {!traceviewer.Model} model
   * @param {{traceEvents: !Array<!Object>}} trace
   * @param {number=} startTime Optional start time (in ms) of range of interest. Defaults to trace start.
   * @param {number=} endTime Optional end time (in ms) of range of interest. Defaults to trace end.
   * @param {!Array<number>=} percentiles Optional array of percentiles to compute. Defaults to [0.5, 0.75, 0.9, 0.99, 1].
   * @return {!Array<{percentile: number, time: number}>}
   */
  static getRiskToResponsiveness(model, trace, startTime, endTime, percentiles) {
    // Range of responsiveness we care about. Default to bounds of model.
    startTime = startTime === undefined ? model.bounds.min : startTime;
    endTime = endTime === undefined ? model.bounds.max : endTime;
    const totalTime = endTime - startTime;
    if (percentiles) {
      percentiles.sort((a, b) => a - b);
    } else {
      percentiles = [0.5, 0.75, 0.9, 0.99, 1];
    }

    // Find the main thread via the first TracingStartedInPage event in the trace
    const startEvent = trace.traceEvents.find(event => {
      return event.name === 'TracingStartedInPage';
    });
    const mainThread = TraceProcessor._findMainThreadFromIds(model, startEvent.pid, startEvent.tid);

    // Find durations of all slices in range of interest.
    // TODO(bckenny): filter for top level slices ourselves?
    const durations = [];
    let clippedLength = 0;
    mainThread.sliceGroup.topLevelSlices.forEach(slice => {
      // Discard slices outside range.

      if (slice.end <= startTime || slice.start >= endTime) {
        return;
      }

      // Clip any at edges of range.
      let duration = slice.duration;
      let sliceStart = slice.start;
      if (sliceStart < startTime) {
        // Any part of task before window can be discarded.
        sliceStart = startTime;
        duration = slice.end - sliceStart;
      }
      if (slice.end > endTime) {
        // Any part of task after window must be clipped but accounted for.
        clippedLength = duration - (endTime - sliceStart);
      }

      durations.push(duration);
    });
    durations.sort((a, b) => a - b);

    // Actual calculation of percentiles done in _riskPercentiles.
    return TraceProcessor._riskPercentiles(durations, totalTime, percentiles, clippedLength);
  }

  /**
   * Uses traceviewer's statistics package to create a log-normal distribution.
   * Specified by providing the median value, at which the score will be 0.5,
   * and the falloff, the initial point of diminishing returns where any
   * improvement in value will yield increasingly smaller gains in score. Both
   * values should be in the same units (e.g. milliseconds). See
   *   https://www.desmos.com/calculator/tx1wcjk8ch
   * for an interactive view of the relationship between these parameters and
   * the typical parameterization (location and shape) of the log-normal
   * distribution.
   * @param {number} median
   * @param {number} falloff
   * @return {!Statistics.LogNormalDistribution}
   */
  static getLogNormalDistribution(median, falloff) {
    const location = Math.log(median);

    // The "falloff" value specified the location of the smaller of the positive
    // roots of the third derivative of the log-normal CDF. Calculate the shape
    // parameter in terms of that value and the median.
    const logRatio = Math.log(falloff / median);
    const shape = 0.5 * Math.sqrt(1 - 3 * logRatio -
        Math.sqrt((logRatio - 3) * (logRatio - 3) - 8));

    return new traceviewer.b.Statistics.LogNormalDistribution(location, shape);
  }
}

module.exports = TraceProcessor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../third_party/traceviewer-js/":79,"gl-matrix":237,"jszip/dist/jszip.min.js":251}],26:[function(require,module,exports){
(function (global){
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

/**
 * Stubbery to allow portions of the DevTools frontend to be used in lighthouse. `WebInspector`
 * technically lives on the global object but should be accessed through a normal `require` call.
 */
module.exports = (function() {
  if (global.WebInspector) {
    return global.WebInspector;
  }

  // Global pollution.
  // Check below is to make it worker-friendly where global is worker's self.
  if (global.self !== global) {
    global.self = global;
  }

  if (typeof global.window === 'undefined') {
    global.window = global;
  }

  global.Runtime = {};
  global.Runtime.experiments = {
    isEnabled(experimentName) {
      switch (experimentName) {
        case 'timelineLatencyInfo':
          return true;
        default:
          return false;
      }
    }
  };
  global.Runtime.queryParam = function(arg) {
    switch (arg) {
      case 'remoteFrontend':
        return false;
      case 'ws':
        return false;
      default:
        throw Error('Mock queryParam case not implemented.');
    }
  };

  global.TreeElement = {};
  global.WorkerRuntime = {};

  global.Protocol = {
    Agents() {}
  };

  global.WebInspector = {};
  const WebInspector = global.WebInspector;
  WebInspector._moduleSettings = {
    cacheDisabled: {
      addChangeListener() {},
      get() {
        return false;
      }
    },
    monitoringXHREnabled: {
      addChangeListener() {},
      get() {
        return false;
      }
    },
    showNativeFunctionsInJSProfile: {
      addChangeListener() {},
      get() {
        return true;
      }
    }
  };
  WebInspector.moduleSetting = function(settingName) {
    return this._moduleSettings[settingName];
  };

  // Enum from chromium//src/third_party/WebKit/Source/core/loader/MixedContentChecker.h
  global.NetworkAgent = {
    RequestMixedContentType: {
      Blockable: 'blockable',
      OptionallyBlockable: 'optionally-blockable',
      None: 'none'
    },
    BlockedReason: {
      CSP: 'csp',
      MixedContent: 'mixed-content',
      Origin: 'origin',
      Inspector: 'inspector',
      Other: 'other'
    },
    InitiatorType: {
      Other: 'other',
      Parser: 'parser',
      Redirect: 'redirect',
      Script: 'script'
    }
  };

  // Enum from SecurityState enum in protocol's Security domain
  global.SecurityAgent = {
    SecurityState: {
      Unknown: 'unknown',
      Neutral: 'neutral',
      Insecure: 'insecure',
      Warning: 'warning',
      Secure: 'secure',
      Info: 'info'
    }
  };
  // From https://chromium.googlesource.com/chromium/src/third_party/WebKit/Source/devtools/+/master/protocol.json#93
  global.PageAgent = {
    ResourceType: {
      Document: 'document',
      Stylesheet: 'stylesheet',
      Image: 'image',
      Media: 'media',
      Font: 'font',
      Script: 'script',
      TextTrack: 'texttrack',
      XHR: 'xhr',
      Fetch: 'fetch',
      EventSource: 'eventsource',
      WebSocket: 'websocket',
      Manifest: 'manifest',
      Other: 'other'
    }
  };
  // Dependencies for network-recorder
  require('chrome-devtools-frontend/front_end/common/Object.js');
  require('chrome-devtools-frontend/front_end/common/ParsedURL.js');
  require('chrome-devtools-frontend/front_end/common/ResourceType.js');
  require('chrome-devtools-frontend/front_end/common/UIString.js');
  require('chrome-devtools-frontend/front_end/platform/utilities.js');
  require('chrome-devtools-frontend/front_end/sdk/Target.js');
  require('chrome-devtools-frontend/front_end/sdk/TargetManager.js');
  require('chrome-devtools-frontend/front_end/sdk/NetworkManager.js');
  require('chrome-devtools-frontend/front_end/sdk/NetworkRequest.js');

  // Dependencies for timeline-model
  WebInspector.targetManager = {
    observeTargets() { },
    addEventListener() { }
  };
  WebInspector.settings = {
    createSetting() {
      return {
        get() {
          return false;
        },
        addChangeListener() {}
      };
    }
  };
  WebInspector.console = {
    error() {}
  };
  WebInspector.VBox = function() {};
  WebInspector.HBox = function() {};
  WebInspector.ViewportDataGrid = function() {};
  WebInspector.ViewportDataGridNode = function() {};
  global.WorkerRuntime.Worker = function() {};

  require('chrome-devtools-frontend/front_end/common/SegmentedRange.js');
  require('chrome-devtools-frontend/front_end/bindings/TempFile.js');
  require('chrome-devtools-frontend/front_end/sdk/TracingModel.js');
  require('chrome-devtools-frontend/front_end/sdk/ProfileTreeModel.js');
  require('chrome-devtools-frontend/front_end/timeline/TimelineUIUtils.js');
  require('chrome-devtools-frontend/front_end/timeline_model/TimelineJSProfile.js');
  require('chrome-devtools-frontend/front_end/sdk/CPUProfileDataModel.js');
  require('chrome-devtools-frontend/front_end/timeline_model/LayerTreeModel.js');
  require('chrome-devtools-frontend/front_end/timeline_model/TimelineModel.js');
  require('chrome-devtools-frontend/front_end/ui_lazy/SortableDataGrid.js');
  require('chrome-devtools-frontend/front_end/timeline/TimelineTreeView.js');
  require('chrome-devtools-frontend/front_end/timeline_model/TimelineProfileTree.js');
  require('chrome-devtools-frontend/front_end/components_lazy/FilmStripModel.js');
  require('chrome-devtools-frontend/front_end/timeline_model/TimelineIRModel.js');
  require('chrome-devtools-frontend/front_end/timeline_model/TimelineFrameModel.js');

  // DevTools makes a few assumptions about using backing storage to hold traces.
  WebInspector.DeferredTempFile = function() {};
  WebInspector.DeferredTempFile.prototype = {
    write: function() {},
    finishWriting: function() {}
  };

  // Mock for WebInspector code that writes to console.
  WebInspector.ConsoleMessage = function() {};
  WebInspector.ConsoleMessage.MessageSource = {
    Network: 'network'
  };
  WebInspector.ConsoleMessage.MessageLevel = {
    Log: 'log'
  };
  WebInspector.ConsoleMessage.MessageType = {
    Log: 'log'
  };

  // Mock NetworkLog
  WebInspector.NetworkLog = function(target) {
    this._requests = new Map();
    target.networkManager.addEventListener(
      WebInspector.NetworkManager.Events.RequestStarted, this._onRequestStarted, this);
  };

  WebInspector.NetworkLog.prototype = {
    requestForURL: function(url) {
      return this._requests.get(url) || null;
    },

    _onRequestStarted: function(event) {
      var request = event.data;
      if (this._requests.has(request.url)) {
        return;
      }
      this._requests.set(request.url, request);
    }
  };

  // Dependencies for color parsing.
  require('chrome-devtools-frontend/front_end/common/Color.js');

  /**
   * Creates a new WebInspector NetworkManager using a mocked Target.
   * @return {!WebInspector.NetworkManager}
   */
  WebInspector.NetworkManager.createWithFakeTarget = function() {
    // Mocked-up WebInspector Target for NetworkManager
    const fakeNetworkAgent = {
      enable() {}
    };
    const fakeConsoleModel = {
      addMessage() {},
      target() {}
    };
    const fakeTarget = {
      _modelByConstructor: new Map(),
      get consoleModel() {
        return fakeConsoleModel;
      },
      networkAgent() {
        return fakeNetworkAgent;
      },
      registerNetworkDispatcher() { },
      model() { }
    };

    fakeTarget.networkManager = new WebInspector.NetworkManager(fakeTarget);
    fakeTarget.networkLog = new WebInspector.NetworkLog(fakeTarget);

    WebInspector.NetworkLog.fromTarget = () => {
      return fakeTarget.networkLog;
    };

    return fakeTarget.networkManager;
  };

  // Dependencies for CSS parsing.
  require('chrome-devtools-frontend/front_end/common/TextRange.js');
  const gonzales = require('chrome-devtools-frontend/front_end/gonzales/gonzales-scss.js');
  require('chrome-devtools-frontend/front_end/gonzales/SCSSParser.js');

  // Mostly taken from from chrome-devtools-frontend/front_end/gonzales/SCSSParser.js.
  WebInspector.SCSSParser.prototype.parse = function(content) {
    var ast = null;
    try {
      ast = gonzales.parse(content, {syntax: 'css'});
    } catch (e) {
      return [];
    }

    /** @type {!{properties: !Array<!Gonzales.Node>, node: !Gonzales.Node}} */
    var rootBlock = {
      properties: [],
      node: ast
    };
    /** @type {!Array<!{properties: !Array<!Gonzales.Node>, node: !Gonzales.Node}>} */
    var blocks = [rootBlock];
    ast.selectors = [];
    WebInspector.SCSSParser.extractNodes(ast, blocks, rootBlock);

    return ast;
  };

  return WebInspector;
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"chrome-devtools-frontend/front_end/bindings/TempFile.js":206,"chrome-devtools-frontend/front_end/common/Color.js":207,"chrome-devtools-frontend/front_end/common/Object.js":208,"chrome-devtools-frontend/front_end/common/ParsedURL.js":209,"chrome-devtools-frontend/front_end/common/ResourceType.js":210,"chrome-devtools-frontend/front_end/common/SegmentedRange.js":211,"chrome-devtools-frontend/front_end/common/TextRange.js":212,"chrome-devtools-frontend/front_end/common/UIString.js":213,"chrome-devtools-frontend/front_end/components_lazy/FilmStripModel.js":214,"chrome-devtools-frontend/front_end/gonzales/SCSSParser.js":215,"chrome-devtools-frontend/front_end/gonzales/gonzales-scss.js":216,"chrome-devtools-frontend/front_end/platform/utilities.js":217,"chrome-devtools-frontend/front_end/sdk/CPUProfileDataModel.js":218,"chrome-devtools-frontend/front_end/sdk/NetworkManager.js":219,"chrome-devtools-frontend/front_end/sdk/NetworkRequest.js":220,"chrome-devtools-frontend/front_end/sdk/ProfileTreeModel.js":221,"chrome-devtools-frontend/front_end/sdk/Target.js":222,"chrome-devtools-frontend/front_end/sdk/TargetManager.js":223,"chrome-devtools-frontend/front_end/sdk/TracingModel.js":224,"chrome-devtools-frontend/front_end/timeline/TimelineTreeView.js":225,"chrome-devtools-frontend/front_end/timeline/TimelineUIUtils.js":226,"chrome-devtools-frontend/front_end/timeline_model/LayerTreeModel.js":227,"chrome-devtools-frontend/front_end/timeline_model/TimelineFrameModel.js":228,"chrome-devtools-frontend/front_end/timeline_model/TimelineIRModel.js":229,"chrome-devtools-frontend/front_end/timeline_model/TimelineJSProfile.js":230,"chrome-devtools-frontend/front_end/timeline_model/TimelineModel.js":231,"chrome-devtools-frontend/front_end/timeline_model/TimelineProfileTree.js":232,"chrome-devtools-frontend/front_end/ui_lazy/SortableDataGrid.js":233}],27:[function(require,module,exports){
(function (process,__dirname){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const Driver = require('./gather/drivers/driver.js');
const GatherRunner = require('./gather/gather-runner');
const Aggregate = require('./aggregator/aggregate');
const assetSaver = require('./lib/asset-saver');
const log = require('./lib/log');

const path = require('path');
const url = require('url');

class Runner {
  static run(connection, opts) {
    // Clean opts input.
    opts.flags = opts.flags || {};

    // Default mobile emulation and page loading to true.
    // The extension will switch these off initially.
    if (typeof opts.flags.mobile === 'undefined') {
      opts.flags.mobile = true;
    }

    const config = opts.config;

    // save the initialUrl provided by the user
    opts.initialUrl = opts.url;
    if (typeof opts.initialUrl !== 'string' || opts.initialUrl.length === 0) {
      return Promise.reject(new Error('You must provide a url to the driver'));
    }
    const parsedURL = url.parse(opts.url);
    // canonicalize URL with any trailing slashes neccessary
    opts.url = url.format(parsedURL);

    if (!parsedURL.protocol || !parsedURL.hostname) {
      const err = new Error('The url provided should have a proper protocol and hostname.');
      return Promise.reject(err);
    }
    // If the URL isn't https and is also not localhost complain to the user.
    if (!parsedURL.protocol.includes('https') && parsedURL.hostname !== 'localhost') {
      log.warn('Lighthouse', 'The URL provided should be on HTTPS');
      log.warn('Lighthouse', 'Performance stats will be skewed redirecting from HTTP to HTTPS.');
    }

    // Check that there are passes & audits...
    const validPassesAndAudits = config.passes && config.audits;

    // ... or that there are artifacts & audits.
    const validArtifactsAndAudits = config.artifacts && config.audits;

    // Make a run, which can be .then()'d with whatever needs to run (based on the config).
    let run = Promise.resolve();

    // If there are passes run the GatherRunner and gather the artifacts. If not, we will need
    // to check that there are artifacts specified in the config, and throw if not.
    if (validPassesAndAudits || validArtifactsAndAudits) {
      if (validPassesAndAudits) {
        opts.driver = opts.driverMock || new Driver(connection);
        // Finally set up the driver to gather.
        run = run.then(_ => GatherRunner.run(config.passes, opts));
      } else if (validArtifactsAndAudits) {
        run = run.then(_ => {
          return Object.assign(GatherRunner.instantiateComputedArtifacts(), config.artifacts);
        });
      }

      // Ignoring these two flags for coverage as this functionality is not exposed by the module.
      /* istanbul ignore next */
      if (opts.flags.saveArtifacts) {
        run = run.then(artifacts => {
          opts.flags.saveArtifacts && assetSaver.saveArtifacts(artifacts);
          return artifacts;
        });
      }
      if (opts.flags.saveAssets) {
        run = run.then(artifacts => {
          return assetSaver.saveAssets(opts, artifacts)
            .then(_ => artifacts);
        });
      }

      // Now run the audits.
      const auditResults = [];
      run = run.then(artifacts => config.audits.reduce((chain, audit) => {
        const status = `Evaluating: ${audit.meta.description}`;
        // Run each audit sequentially, the auditResults array has all our fine work
        return chain.then(_ => {
          log.log('status', status);
          return audit.audit(artifacts);
        }).then(ret => {
          log.verbose('statusEnd', status);
          auditResults.push(ret);
        });
      }, Promise.resolve()).then(_ => auditResults));
    } else if (config.auditResults) {
      // If there are existing audit results, surface those here.
      run = run.then(_ => config.auditResults);
    } else {
      const err = Error(
          'The config must provide passes and audits, artifacts and audits, or auditResults');
      return Promise.reject(err);
    }

    // Format and aggregate results before returning.
    run = run
      .then(auditResults => {
        const formattedAudits = auditResults.reduce((formatted, audit) => {
          formatted[audit.name] = audit;
          return formatted;
        }, {});

        // Only run aggregations if needed.
        let aggregations = [];
        if (config.aggregations) {
          aggregations = config.aggregations.map(a => Aggregate.aggregate(a, auditResults));
        }

        return {
          lighthouseVersion: require('../package').version,
          generatedTime: (new Date()).toJSON(),
          initialUrl: opts.initialUrl,
          url: opts.url,
          audits: formattedAudits,
          aggregations
        };
      });

    return run;
  }

  /**
   * Returns list of audit names for external querying.
   * @return {!Array<string>}
   */
  static getAuditList() {
    return ["aria-allowed-attr.js","aria-valid-attr.js","audit.js","cache-start-url.js","color-contrast.js","content-width.js","critical-request-chains.js","dobetterweb","estimated-input-latency.js","first-meaningful-paint.js","geolocation-on-start.js","image-alt.js","is-on-https.js","label.js","manifest-background-color.js","manifest-display.js","manifest-exists.js","manifest-icons-min-144.js","manifest-icons-min-192.js","manifest-name.js","manifest-short-name-length.js","manifest-short-name.js","manifest-start-url.js","manifest-theme-color.js","meta-theme-color.js","redirects-http.js","screenshots.js","service-worker.js","speed-index-metric.js","tabindex.js","time-to-interactive.js","user-timings.js","viewport.js","without-javascript.js","works-offline.js"]
        .filter(f => /\.js$/.test(f));
  }

  /**
   * Returns list of gatherer names for external querying.
   * @return {!Array<string>}
   */
  static getGathererList() {
    return ["accessibility.js","cache-contents.js","content-width.js","dobetterweb","gatherer.js","geolocation-on-start.js","html-without-javascript.js","html.js","http-redirect.js","https.js","manifest.js","offline.js","service-worker.js","styles.js","theme-color.js","url.js","viewport.js"]
        .filter(f => /\.js$/.test(f));
  }

  /**
   * Resolves the location of the specified plugin and returns an absolute
   * string path to the file. Used for loading custom audits and gatherers.
   * Throws an error if no plugin is found.
   * @param {string} plugin
   * @param {string=} configDir The absolute path to the directory of the config file, if there is one.
   * @param {string=} category Optional plugin category (e.g. 'audit') for better error messages.
   * @return {string}
   * @throws {Error}
   */
  static resolvePlugin(plugin, configDir, category) {
    // First try straight `require()`. Unlikely to be specified relative to this
    // file, but adds support for Lighthouse plugins in npm modules as
    // `require()` walks up parent directories looking inside any node_modules/
    // present. Also handles absolute paths.
    try {
      return require.resolve(plugin);
    } catch (e) {}

    // See if the plugin resolves relative to the current working directory.
    // Most useful to handle the case of invoking Lighthouse as a module, since
    // then the config is an object and so has no path.
    const cwdPath = path.resolve(process.cwd(), plugin);
    try {
      return require.resolve(cwdPath);
    } catch (e) {}

    const errorString = 'Unable to locate ' +
        (category ? `${category}: ` : '') +
        `${plugin} (tried to require() from '${__dirname}' and load from '${cwdPath}'`;

    if (!configDir) {
      throw new Error(errorString + ')');
    }

    // Finally, try looking up relative to the config file path. Just like the
    // relative path passed to `require()` is found relative to the file it's
    // in, this allows plugin paths to be specified relative to the config file.
    const relativePath = path.resolve(configDir, plugin);
    try {
      return require.resolve(relativePath);
    } catch (requireError) {}

    throw new Error(errorString + ` and '${relativePath}')`);
  }
}

module.exports = Runner;

}).call(this,require('_process'),"/../lighthouse-core")
},{"../package":256,"./aggregator/aggregate":1,"./gather/drivers/driver.js":13,"./gather/gather-runner":16,"./lib/asset-saver":193,"./lib/log":21,"_process":199,"path":198,"url":204}],28:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

'use strict';

/**
 * The global object.
 * @type {!Object}
 * @const
 */

/** Platform, package, object property, and Event support. */

global.tr = function () {
  if (global.tr) {
    console.warn('Base was multiply initialized. First init wins.');
    return global.tr;
  }

  /**
   * Builds an object structure for the provided namespace path,
   * ensuring that names that already exist are not overwritten. For
   * example:
   * 'a.b.c' -> a = {};a.b={};a.b.c={};
   * @param {string} name Name of the object that this file defines.
   * @private
   */
  function exportPath(name) {
    var parts = name.split('.');
    var cur = global;

    for (var part; parts.length && (part = parts.shift());) {
      if (part in cur) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
    return cur;
  };

  function isExported(name) {
    var parts = name.split('.');
    var cur = global;

    for (var part; parts.length && (part = parts.shift());) {
      if (part in cur) {
        cur = cur[part];
      } else {
        return false;
      }
    }
    return true;
  }

  function isDefined(name) {
    var parts = name.split('.');

    var curObject = global;

    for (var i = 0; i < parts.length; i++) {
      var partName = parts[i];
      var nextObject = curObject[partName];
      if (nextObject === undefined) return false;
      curObject = nextObject;
    }
    return true;
  }

  var panicElement = undefined;
  var rawPanicMessages = [];
  function showPanicElementIfNeeded() {
    if (panicElement) return;

    var panicOverlay = document.createElement('div');
    panicOverlay.style.backgroundColor = 'white';
    panicOverlay.style.border = '3px solid red';
    panicOverlay.style.boxSizing = 'border-box';
    panicOverlay.style.color = 'black';
    panicOverlay.style.display = '-webkit-flex';
    panicOverlay.style.height = '100%';
    panicOverlay.style.left = 0;
    panicOverlay.style.padding = '8px';
    panicOverlay.style.position = 'fixed';
    panicOverlay.style.top = 0;
    panicOverlay.style.webkitFlexDirection = 'column';
    panicOverlay.style.width = '100%';

    panicElement = document.createElement('div');
    panicElement.style.webkitFlex = '1 1 auto';
    panicElement.style.overflow = 'auto';
    panicOverlay.appendChild(panicElement);

    if (!document.body) {
      setTimeout(function () {
        document.body.appendChild(panicOverlay);
      }, 150);
    } else {
      document.body.appendChild(panicOverlay);
    }
  }

  function showPanic(panicTitle, panicDetails) {
    if (tr.isHeadless) {
      if (panicDetails instanceof Error) throw panicDetails;
      throw new Error('Panic: ' + panicTitle + ':\n' + panicDetails);
    }

    if (panicDetails instanceof Error) panicDetails = panicDetails.stack;

    showPanicElementIfNeeded();
    var panicMessageEl = document.createElement('div');
    panicMessageEl.innerHTML = '<h2 id="message"></h2>' + '<pre id="details"></pre>';
    panicMessageEl.querySelector('#message').textContent = panicTitle;
    panicMessageEl.querySelector('#details').textContent = panicDetails;
    panicElement.appendChild(panicMessageEl);

    rawPanicMessages.push({
      title: panicTitle,
      details: panicDetails
    });
  }

  function hasPanic() {
    return rawPanicMessages.length !== 0;
  }
  function getPanicText() {
    return rawPanicMessages.map(function (msg) {
      return msg.title;
    }).join(', ');
  }

  function exportTo(namespace, fn) {
    var obj = exportPath(namespace);
    var exports = fn();

    for (var propertyName in exports) {
      // Maybe we should check the prototype chain here? The current usage
      // pattern is always using an object literal so we only care about own
      // properties.
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports, propertyName);
      if (propertyDescriptor) Object.defineProperty(obj, propertyName, propertyDescriptor);
    }
  };

  /**
   * Initialization which must be deferred until run-time.
   */
  function initialize() {
    if (global.isVinn) {
      tr.isVinn = true;
    } else if (global.process && global.process.versions.node) {
      tr.isNode = true;
    } else {
      tr.isVinn = false;
      tr.isNode = false;
      tr.doc = document;

      tr.isMac = /Mac/.test(navigator.platform);
      tr.isWindows = /Win/.test(navigator.platform);
      tr.isChromeOS = /CrOS/.test(navigator.userAgent);
      tr.isLinux = /Linux/.test(navigator.userAgent);
    }
    tr.isHeadless = tr.isVinn || tr.isNode;
  }

  return {
    initialize: initialize,

    exportTo: exportTo,
    isExported: isExported,
    isDefined: isDefined,

    showPanic: showPanic,
    hasPanic: hasPanic,
    getPanicText: getPanicText
  };
}();

tr.initialize();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],29:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {

  function Base64() {}

  function b64ToUint6(nChr) {
    if (nChr > 64 && nChr < 91) return nChr - 65;
    if (nChr > 96 && nChr < 123) return nChr - 71;
    if (nChr > 47 && nChr < 58) return nChr + 4;
    if (nChr === 43) return 62;
    if (nChr === 47) return 63;
    return 0;
  }

  Base64.getDecodedBufferLength = function (input) {
    return input.length * 3 + 1 >> 2;
  };

  Base64.EncodeArrayBufferToString = function (input) {
    // http://stackoverflow.com/questions/9267899/
    var binary = '';
    var bytes = new Uint8Array(input);
    var len = bytes.byteLength;
    for (var i = 0; i < len; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  };

  Base64.DecodeToTypedArray = function (input, output) {

    var nInLen = input.length;
    var nOutLen = nInLen * 3 + 1 >> 2;
    var nMod3 = 0;
    var nMod4 = 0;
    var nUint24 = 0;
    var nOutIdx = 0;

    if (nOutLen > output.byteLength) throw new Error('Output buffer too small to decode.');

    for (var nInIdx = 0; nInIdx < nInLen; nInIdx++) {
      nMod4 = nInIdx & 3;
      nUint24 |= b64ToUint6(input.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
      if (nMod4 === 3 || nInLen - nInIdx === 1) {
        for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
          output.setUint8(nOutIdx, nUint24 >>> (16 >>> nMod3 & 24) & 255);
        }
        nUint24 = 0;
      }
    }
    return nOutIdx - 1;
  };

  /*
   * Wrapper of btoa
   * The reason is that window object has a builtin btoa,
   * but we also want to use btoa when it is headless.
   * For example we want to use it in a mapper
   */
  Base64.btoa = function (input) {
    return btoa(input);
  };

  /*
   * Wrapper of atob
   * The reason is that window object has a builtin atob,
   * but we also want to use atob when it is headless.
   * For example we want to use it in a mapper
   */
  Base64.atob = function (input) {
    return atob(input);
  };

  return {
    Base64: Base64
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],30:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

/**
 * @fileoverview Helper code for working with tracing categories.
 *
 */
global.tr.exportTo('tr.b', function () {

  // Cached values for getCategoryParts.
  var categoryPartsFor = {};

  /**
   * Categories are stored in comma-separated form, e.g: 'a,b' meaning
   * that the event is part of the a and b category.
   *
   * This function returns the category split by string, caching the
   * array for performance.
   *
   * Do not mutate the returned array!!!!
   */
  function getCategoryParts(category) {
    var parts = categoryPartsFor[category];
    if (parts !== undefined) return parts;
    parts = category.split(',');
    categoryPartsFor[category] = parts;
    return parts;
  }

  return {
    getCategoryParts: getCategoryParts
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],31:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  function clamp01(value) {
    return Math.max(0, Math.min(1, value));
  }

  function Color(opt_r, opt_g, opt_b, opt_a) {
    this.r = Math.floor(opt_r) || 0;
    this.g = Math.floor(opt_g) || 0;
    this.b = Math.floor(opt_b) || 0;
    this.a = opt_a;
  }

  Color.fromString = function (str) {
    var tmp;
    var values;
    if (str.substr(0, 4) == 'rgb(') {
      tmp = str.substr(4, str.length - 5);
      values = tmp.split(',').map(function (v) {
        return v.replace(/^\s+/, '', 'g');
      });
      if (values.length != 3) throw new Error('Malformatted rgb-expression');
      return new Color(parseInt(values[0]), parseInt(values[1]), parseInt(values[2]));
    } else if (str.substr(0, 5) == 'rgba(') {
      tmp = str.substr(5, str.length - 6);
      values = tmp.split(',').map(function (v) {
        return v.replace(/^\s+/, '', 'g');
      });
      if (values.length != 4) throw new Error('Malformatted rgb-expression');
      return new Color(parseInt(values[0]), parseInt(values[1]), parseInt(values[2]), parseFloat(values[3]));
    } else if (str[0] == '#' && str.length == 7) {
      return new Color(parseInt(str.substr(1, 2), 16), parseInt(str.substr(3, 2), 16), parseInt(str.substr(5, 2), 16));
    } else {
      throw new Error('Unrecognized string format.');
    }
  };

  Color.lerp = function (a, b, percent) {
    if (a.a !== undefined && b.a !== undefined) return Color.lerpRGBA(a, b, percent);
    return Color.lerpRGB(a, b, percent);
  };

  Color.lerpRGB = function (a, b, percent) {
    return new Color((b.r - a.r) * percent + a.r, (b.g - a.g) * percent + a.g, (b.b - a.b) * percent + a.b);
  };

  Color.lerpRGBA = function (a, b, percent) {
    return new Color((b.r - a.r) * percent + a.r, (b.g - a.g) * percent + a.g, (b.b - a.b) * percent + a.b, (b.a - a.a) * percent + a.a);
  };

  Color.fromDict = function (dict) {
    return new Color(dict.r, dict.g, dict.b, dict.a);
  };

  /**
   * Converts an HSL triplet with alpha to an RGB color.
   * |h| Hue value in [0, 1].
   * |s| Saturation value in [0, 1].
   * |l| Lightness in [0, 1].
   * |a| Alpha in [0, 1]
   */
  Color.fromHSLExplicit = function (h, s, l, a) {
    var r, g, b;
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }

    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return new Color(Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255), a);
  };

  Color.fromHSL = function (hsl) {
    return Color.fromHSLExplicit(hsl.h, hsl.s, hsl.l, hsl.a);
  };

  Color.prototype = {
    clone: function () {
      var c = new Color();
      c.r = this.r;
      c.g = this.g;
      c.b = this.b;
      c.a = this.a;
      return c;
    },

    blendOver: function (bgColor) {
      var oneMinusThisAlpha = 1 - this.a;
      var outA = this.a + bgColor.a * oneMinusThisAlpha;
      var bgBlend = bgColor.a * oneMinusThisAlpha / bgColor.a;
      return new Color(this.r * this.a + bgColor.r * bgBlend, this.g * this.a + bgColor.g * bgBlend, this.b * this.a + bgColor.b * bgBlend, outA);
    },

    brighten: function (opt_k) {
      var k;
      k = opt_k || 0.45;

      return new Color(Math.min(255, this.r + Math.floor(this.r * k)), Math.min(255, this.g + Math.floor(this.g * k)), Math.min(255, this.b + Math.floor(this.b * k)), this.a);
    },

    lighten: function (k, opt_maxL) {
      var maxL = opt_maxL !== undefined ? opt_maxL : 1.0;
      var hsl = this.toHSL();
      hsl.l = clamp01(hsl.l + k);
      return Color.fromHSL(hsl);
    },

    darken: function (opt_k) {
      var k;
      if (opt_k !== undefined) k = opt_k;else k = 0.45;

      return new Color(Math.min(255, this.r - Math.floor(this.r * k)), Math.min(255, this.g - Math.floor(this.g * k)), Math.min(255, this.b - Math.floor(this.b * k)), this.a);
    },

    desaturate: function (opt_desaturateFactor) {
      var desaturateFactor;
      if (opt_desaturateFactor !== undefined) desaturateFactor = opt_desaturateFactor;else desaturateFactor = 1;

      var hsl = this.toHSL();
      hsl.s = clamp01(hsl.s * (1 - desaturateFactor));
      return Color.fromHSL(hsl);
    },

    withAlpha: function (a) {
      return new Color(this.r, this.g, this.b, a);
    },

    toString: function () {
      if (this.a !== undefined) {
        return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + this.a + ')';
      }
      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
    },

    /**
     * Returns a dict {h, s, l, a} with:
     * |h| Hue value in [0, 1].
     * |s| Saturation value in [0, 1].
     * |l| Lightness in [0, 1].
     * |a| Alpha in [0, 1]
     */
    toHSL: function () {
      var r = this.r / 255;
      var g = this.g / 255;
      var b = this.b / 255;

      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);

      var h, s;
      var l = (max + min) / 2;
      if (min === max) {
        h = 0;
        s = 0;
      } else {
        var delta = max - min;
        if (l > 0.5) s = delta / (2 - max - min);else s = delta / (max + min);

        if (r === max) {
          h = (g - b) / delta;
          if (g < b) h += 6;
        } else if (g === max) {
          h = 2 + (b - r) / delta;
        } else {
          h = 4 + (r - g) / delta;
        }
        h /= 6;
      }

      return { h: h, s: s, l: l, a: this.a };
    },

    toStringWithAlphaOverride: function (alpha) {
      return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + alpha + ')';
    }
  };

  return {
    Color: Color
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],32:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");
require("./color.js");
require("./iteration_helpers.js");

'use strict';

/**
 * @fileoverview Provides color scheme related functions.
 */
global.tr.exportTo('tr.b', function () {
  // Basic constants...
  var generalPurposeColors = [new tr.b.Color(122, 98, 135), new tr.b.Color(150, 83, 105), new tr.b.Color(44, 56, 189), new tr.b.Color(99, 86, 147), new tr.b.Color(104, 129, 107), new tr.b.Color(130, 178, 55), new tr.b.Color(87, 109, 147), new tr.b.Color(111, 145, 88), new tr.b.Color(81, 152, 131), new tr.b.Color(142, 91, 111), new tr.b.Color(81, 163, 70), new tr.b.Color(148, 94, 86), new tr.b.Color(144, 89, 118), new tr.b.Color(83, 150, 97), new tr.b.Color(105, 94, 139), new tr.b.Color(89, 144, 122), new tr.b.Color(105, 119, 128), new tr.b.Color(96, 128, 137), new tr.b.Color(145, 88, 145), new tr.b.Color(88, 145, 144), new tr.b.Color(90, 100, 143), new tr.b.Color(121, 97, 136), new tr.b.Color(111, 160, 73), new tr.b.Color(112, 91, 142), new tr.b.Color(86, 147, 86), new tr.b.Color(63, 100, 170), new tr.b.Color(81, 152, 107), new tr.b.Color(60, 164, 173), new tr.b.Color(143, 72, 161), new tr.b.Color(159, 74, 86)];

  var reservedColorsByName = {
    thread_state_uninterruptible: new tr.b.Color(182, 125, 143),
    thread_state_iowait: new tr.b.Color(255, 140, 0),
    thread_state_running: new tr.b.Color(126, 200, 148),
    thread_state_runnable: new tr.b.Color(133, 160, 210),
    thread_state_sleeping: new tr.b.Color(240, 240, 240),
    thread_state_unknown: new tr.b.Color(199, 155, 125),

    background_memory_dump: new tr.b.Color(0, 180, 180),
    light_memory_dump: new tr.b.Color(0, 0, 180),
    detailed_memory_dump: new tr.b.Color(180, 0, 180),

    generic_work: new tr.b.Color(125, 125, 125),

    good: new tr.b.Color(0, 125, 0),
    bad: new tr.b.Color(180, 125, 0),
    terrible: new tr.b.Color(180, 0, 0),

    black: new tr.b.Color(0, 0, 0),

    rail_response: new tr.b.Color(67, 135, 253),
    rail_animation: new tr.b.Color(244, 74, 63),
    rail_idle: new tr.b.Color(238, 142, 0),
    rail_load: new tr.b.Color(13, 168, 97),
    startup: new tr.b.Color(230, 230, 0),

    used_memory_column: new tr.b.Color(0, 0, 255),
    older_used_memory_column: new tr.b.Color(153, 204, 255),
    tracing_memory_column: new tr.b.Color(153, 153, 153),

    heap_dump_stack_frame: new tr.b.Color(128, 128, 128),
    heap_dump_object_type: new tr.b.Color(0, 0, 255),
    heap_dump_child_node_arrow: new tr.b.Color(204, 102, 0),

    cq_build_running: new tr.b.Color(255, 255, 119),
    cq_build_passed: new tr.b.Color(153, 238, 102),
    cq_build_failed: new tr.b.Color(238, 136, 136),
    cq_build_abandoned: new tr.b.Color(187, 187, 187),

    cq_build_attempt_runnig: new tr.b.Color(222, 222, 75),
    cq_build_attempt_passed: new tr.b.Color(103, 218, 35),
    cq_build_attempt_failed: new tr.b.Color(197, 81, 81)
  };

  // Some constants we'll need for later lookups.
  var numGeneralPurposeColorIds = generalPurposeColors.length;
  var numReservedColorIds = tr.b.dictionaryLength(reservedColorsByName);
  var numColorsPerVariant = numGeneralPurposeColorIds + numReservedColorIds;

  function ColorScheme() {}

  /*
   * A flat array of tr.b.Color values of the palette, and their variants.
   *
   * This array is made up of a set of base colors, repeated N times to form
   * a set of variants on that base color.
   *
   * Within the base colors, there are "general purpose" colors,
   * which can be used for random color selection, and
   * reserved colors, which are used when specific colors
   * need to be used, e.g. where red is desired.
   *
   * The variants are automatically generated from the base colors. The 0th
   * variant is the default apeparance of the color, and the varaiants are
   * mutations of that color, e.g. several brightening levels and desaturations.
   *
   * For example, a very simple version of this array looks like the following:
   *     0: Generic Color 0
   *     1: Generic Color 1
   *     2: Named Color 'foo'
   *     3: Brightened Generic Color 0
   *     4: Brightened Generic Color 1
   *     5: Brightened Named Color 'foo'
   */
  var paletteBase = [];
  paletteBase.push.apply(paletteBase, generalPurposeColors);
  paletteBase.push.apply(paletteBase, tr.b.dictionaryValues(reservedColorsByName));
  ColorScheme.colors = [];
  ColorScheme.properties = {};
  ColorScheme.properties = {
    numColorsPerVariant: numColorsPerVariant
  };

  function pushVariant(func) {
    var variantColors = paletteBase.map(func);
    ColorScheme.colors.push.apply(ColorScheme.colors, variantColors);
  }

  // Basic colors.
  pushVariant(function (c) {
    return c;
  });

  // Brightened variants.
  ColorScheme.properties.brightenedOffsets = [];
  ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
  pushVariant(function (c) {
    return c.lighten(0.3, 0.9);
  });

  ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
  pushVariant(function (c) {
    return c.lighten(0.48, 0.9);
  });

  ColorScheme.properties.brightenedOffsets.push(ColorScheme.colors.length);
  pushVariant(function (c) {
    return c.lighten(0.65, 0.9);
  });

  // Desaturated variants.
  ColorScheme.properties.dimmedOffsets = [];
  ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
  pushVariant(function (c) {
    return c.desaturate();
  });
  ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
  pushVariant(function (c) {
    return c.desaturate(0.5);
  });
  ColorScheme.properties.dimmedOffsets.push(ColorScheme.colors.length);
  pushVariant(function (c) {
    return c.desaturate(0.3);
  });

  /**
   * A toString'd representation of ColorScheme.colors.
   */
  ColorScheme.colorsAsStrings = ColorScheme.colors.map(function (c) {
    return c.toString();
  });

  // Build reservedColorNameToIdMap.
  var reservedColorNameToIdMap = function () {
    var m = new Map();
    var i = generalPurposeColors.length;
    tr.b.iterItems(reservedColorsByName, function (key, value) {
      m.set(key, i++);
    });
    return m;
  }();

  /**
   * @param {String} name The color name.
   * @return {Number} The color ID for the given color name.
   */
  ColorScheme.getColorIdForReservedName = function (name) {
    var id = reservedColorNameToIdMap.get(name);
    if (id === undefined) throw new Error('Unrecognized color ') + name;
    return id;
  };

  ColorScheme.getColorForReservedNameAsString = function (reservedName) {
    var id = ColorScheme.getColorIdForReservedName(reservedName);
    return ColorScheme.colorsAsStrings[id];
  };

  /**
   * Computes a simplistic hashcode of the provide name. Used to chose colors
   * for slices.
   * @param {string} name The string to hash.
   */
  ColorScheme.getStringHash = function (name) {
    var hash = 0;
    for (var i = 0; i < name.length; ++i) hash = (hash + 37 * hash + 11 * name.charCodeAt(i)) % 0xFFFFFFFF;
    return hash;
  };

  // Previously computed string color IDs. They are based on a stable hash, so
  // it is safe to save them throughout the program time.
  var stringColorIdCache = new Map();

  /**
   * @return {Number} A color ID that is stably associated to the provided via
   * the getStringHash method. The color ID will be chosen from the general
   * purpose ID space only, e.g. no reserved ID will be used.
   */
  ColorScheme.getColorIdForGeneralPurposeString = function (string) {
    if (stringColorIdCache.get(string) === undefined) {
      var hash = ColorScheme.getStringHash(string);
      stringColorIdCache.set(string, hash % numGeneralPurposeColorIds);
    }
    return stringColorIdCache.get(string);
  };

  return {
    ColorScheme: ColorScheme
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28,"./color.js":31,"./iteration_helpers.js":41}],33:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./event_target.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var Event;
  if (tr.isHeadless) {
    /**
     * Creates a new event to be used with tr.b.EventTarget or DOM EventTarget
     * objects.
     * @param {string} type The name of the event.
     * @param {boolean=} opt_bubbles Whether the event bubbles.
     *     Default is false.
     * @param {boolean=} opt_preventable Whether the default action of the event
     *     can be prevented.
     * @constructor
     * @extends {Event}
     */
    function HeadlessEvent(type, opt_bubbles, opt_preventable) {
      this.type = type;
      this.bubbles = opt_bubbles !== undefined ? !!opt_bubbles : false;
      this.cancelable = opt_preventable !== undefined ? !!opt_preventable : false;

      this.defaultPrevented = false;
      this.cancelBubble = false;
    };

    HeadlessEvent.prototype = {
      preventDefault: function () {
        this.defaultPrevented = true;
      },

      stopPropagation: function () {
        this.cancelBubble = true;
      }
    };
    Event = HeadlessEvent;
  } else {
    /**
     * Creates a new event to be used with tr.b.EventTarget or DOM EventTarget
     * objects.
     * @param {string} type The name of the event.
     * @param {boolean=} opt_bubbles Whether the event bubbles.
     *     Default is false.
     * @param {boolean=} opt_preventable Whether the default action of the event
     *     can be prevented.
     * @constructor
     * @extends {Event}
     */
    function TrEvent(type, opt_bubbles, opt_preventable) {
      var e = tr.doc.createEvent('Event');
      e.initEvent(type, !!opt_bubbles, !!opt_preventable);
      e.__proto__ = global.Event.prototype;
      return e;
    };

    TrEvent.prototype = {
      __proto__: global.Event.prototype
    };
    Event = TrEvent;
  }

  /**
   * Dispatches a simple event on an event target.
   * @param {!EventTarget} target The event target to dispatch the event on.
   * @param {string} type The type of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles or not.
   * @param {boolean=} opt_cancelable Whether the default action of the event
   *     can be prevented.
   * @param {!Object=} opt_fields
   *
   * @return {boolean} If any of the listeners called {@code preventDefault}
   *     during the dispatch this will return false.
   */
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable, opt_fields) {
    var e = new tr.b.Event(type, opt_bubbles, opt_cancelable);
    if (opt_fields) {
      tr.b.iterItems(opt_fields, function (name, value) {
        e[name] = value;
      });
    }
    return target.dispatchEvent(e);
  }

  return {
    Event: Event,
    dispatchSimpleEvent: dispatchSimpleEvent
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./event_target.js":34}],34:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

/**
 * @fileoverview This contains an implementation of the EventTarget interface
 * as defined by DOM Level 2 Events.
 */
global.tr.exportTo('tr.b', function () {

  /**
   * Creates a new EventTarget. This class implements the DOM level 2
   * EventTarget interface and can be used wherever those are used.
   * @constructor
   */
  function EventTarget() {}
  EventTarget.decorate = function (target) {
    for (var k in EventTarget.prototype) {
      if (k == 'decorate') continue;
      var v = EventTarget.prototype[k];
      if (typeof v !== 'function') continue;
      target[k] = v;
    }
  };

  EventTarget.prototype = {

    /**
     * Adds an event listener to the target.
     * @param {string} type The name of the event.
     * @param {!Function|{handleEvent:Function}} handler The handler for the
     *     event. This is called when the event is dispatched.
     */
    addEventListener: function (type, handler) {
      if (!this.listeners_) this.listeners_ = Object.create(null);
      if (!(type in this.listeners_)) {
        this.listeners_[type] = [handler];
      } else {
        var handlers = this.listeners_[type];
        if (handlers.indexOf(handler) < 0) handlers.push(handler);
      }
    },

    /**
     * Removes an event listener from the target.
     * @param {string} type The name of the event.
     * @param {!Function|{handleEvent:Function}} handler The handler for the
     *     event.
     */
    removeEventListener: function (type, handler) {
      if (!this.listeners_) return;
      if (type in this.listeners_) {
        var handlers = this.listeners_[type];
        var index = handlers.indexOf(handler);
        if (index >= 0) {
          // Clean up if this was the last listener.
          if (handlers.length == 1) delete this.listeners_[type];else handlers.splice(index, 1);
        }
      }
    },

    /**
     * Dispatches an event and calls all the listeners that are listening to
     * the type of the event.
     * @param {!cr.event.Event} event The event to dispatch.
     * @return {boolean} Whether the default action was prevented. If someone
     *     calls preventDefault on the event object then this returns false.
     */
    dispatchEvent: function (event) {
      if (!this.listeners_) return true;

      // Since we are using DOM Event objects we need to override some of the
      // properties and methods so that we can emulate this correctly.
      var self = this;
      event.__defineGetter__('target', function () {
        return self;
      });
      var realPreventDefault = event.preventDefault;
      event.preventDefault = function () {
        realPreventDefault.call(this);
        this.rawReturnValue = false;
      };

      var type = event.type;
      var prevented = 0;
      if (type in this.listeners_) {
        // Clone to prevent removal during dispatch
        var handlers = this.listeners_[type].concat();
        for (var i = 0, handler; handler = handlers[i]; i++) {
          if (handler.handleEvent) prevented |= handler.handleEvent.call(handler, event) === false;else prevented |= handler.call(this, event) === false;
        }
      }

      return !prevented && event.rawReturnValue;
    },

    hasEventListener: function (type) {
      return this.listeners_[type] !== undefined;
    }
  };

  var EventTargetHelper = {
    decorate: function (target) {
      for (var k in EventTargetHelper) {
        if (k == 'decorate') continue;
        var v = EventTargetHelper[k];
        if (typeof v !== 'function') continue;
        target[k] = v;
      }
      target.listenerCounts_ = {};
    },

    addEventListener: function (type, listener, useCapture) {
      this.__proto__.addEventListener.call(this, type, listener, useCapture);
      if (this.listenerCounts_[type] === undefined) this.listenerCounts_[type] = 0;
      this.listenerCounts_[type]++;
    },

    removeEventListener: function (type, listener, useCapture) {
      this.__proto__.removeEventListener.call(this, type, listener, useCapture);
      this.listenerCounts_[type]--;
    },

    hasEventListener: function (type) {
      return this.listenerCounts_[type] > 0;
    }
  };

  // Export
  return {
    EventTarget: EventTarget,
    EventTargetHelper: EventTargetHelper
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],35:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./event_target.js");
require("./extension_registry_base.js");
require("./extension_registry_basic.js");
require("./extension_registry_type_based.js");
require("./iteration_helpers.js");

'use strict';

/**
 * @fileoverview Helper code for defining extension registries, which can be
 * used to make a part of trace-viewer extensible.
 *
 * This file provides two basic types of extension registries:
 * - Generic: register a type with metadata, query for those types based on
 *            a predicate
 *
 * - TypeName-based: register a type that handles some combination
 *                   of tracing categories or typeNames, then query
 *                   for it based on a category, typeName or both.
 *
 * When you register subtypes, you pass the constructor for the
 * subtype, and any metadata you want associated with the subtype. Use metadata
 * instead of stuffing fields onto the constructor. E.g.:
 *     registry.register(MySubclass, {titleWhenShownInTabStrip: 'MySub'})
 *
 * Some registries want a default object that is returned when a more precise
 * subtype has been registered. To provide one, set the defaultConstructor
 * option on the registry options.
 *
 * TODO: Extension registry used to make reference to mandatoryBaseType but it
 * was never enforced. We may want to add it back in the future in order to
 * enforce the types that can be put into a given registry.
 */
global.tr.exportTo('tr.b', function () {

  function decorateExtensionRegistry(registry, registryOptions) {
    if (registry.register) throw new Error('Already has registry');

    registryOptions.freeze();
    if (registryOptions.mode == tr.b.BASIC_REGISTRY_MODE) {
      tr.b._decorateBasicExtensionRegistry(registry, registryOptions);
    } else if (registryOptions.mode == tr.b.TYPE_BASED_REGISTRY_MODE) {
      tr.b._decorateTypeBasedExtensionRegistry(registry, registryOptions);
    } else {
      throw new Error('Unrecognized mode');
    }

    // Make it an event target.
    if (registry.addEventListener === undefined) tr.b.EventTarget.decorate(registry);
  }

  return {
    decorateExtensionRegistry: decorateExtensionRegistry
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./event_target.js":34,"./extension_registry_base.js":36,"./extension_registry_basic.js":37,"./extension_registry_type_based.js":38,"./iteration_helpers.js":41}],36:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  function RegisteredTypeInfo(constructor, metadata) {
    this.constructor = constructor;
    this.metadata = metadata;
  };

  var BASIC_REGISTRY_MODE = 'BASIC_REGISTRY_MODE';
  var TYPE_BASED_REGISTRY_MODE = 'TYPE_BASED_REGISTRY_MODE';
  var ALL_MODES = { BASIC_REGISTRY_MODE: true, TYPE_BASED_REGISTRY_MODE: true };

  function ExtensionRegistryOptions(mode) {
    if (mode === undefined) throw new Error('Mode is required');
    if (!ALL_MODES[mode]) throw new Error('Not a mode.');

    this.mode_ = mode;
    this.defaultMetadata_ = {};
    this.defaultConstructor_ = undefined;
    this.defaultTypeInfo_ = undefined;
    this.frozen_ = false;
  }
  ExtensionRegistryOptions.prototype = {
    freeze: function () {
      if (this.frozen_) throw new Error('Frozen');
      this.frozen_ = true;
    },

    get mode() {
      return this.mode_;
    },

    get defaultMetadata() {
      return this.defaultMetadata_;
    },

    set defaultMetadata(defaultMetadata) {
      if (this.frozen_) throw new Error('Frozen');
      this.defaultMetadata_ = defaultMetadata;
      this.defaultTypeInfo_ = undefined;
    },

    get defaultConstructor() {
      return this.defaultConstructor_;
    },

    set defaultConstructor(defaultConstructor) {
      if (this.frozen_) throw new Error('Frozen');
      this.defaultConstructor_ = defaultConstructor;
      this.defaultTypeInfo_ = undefined;
    },

    get defaultTypeInfo() {
      if (this.defaultTypeInfo_ === undefined && this.defaultConstructor_) {
        this.defaultTypeInfo_ = new RegisteredTypeInfo(this.defaultConstructor, this.defaultMetadata);
      }
      return this.defaultTypeInfo_;
    },

    validateConstructor: function (constructor) {
      if (!this.mandatoryBaseClass) return;
      var curProto = constructor.prototype.__proto__;
      var ok = false;
      while (curProto) {
        if (curProto === this.mandatoryBaseClass.prototype) {
          ok = true;
          break;
        }
        curProto = curProto.__proto__;
      }
      if (!ok) throw new Error(constructor + 'must be subclass of ' + registry);
    }
  };

  return {
    BASIC_REGISTRY_MODE: BASIC_REGISTRY_MODE,
    TYPE_BASED_REGISTRY_MODE: TYPE_BASED_REGISTRY_MODE,

    ExtensionRegistryOptions: ExtensionRegistryOptions,
    RegisteredTypeInfo: RegisteredTypeInfo
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],37:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./event.js");
require("./extension_registry_base.js");

'use strict';

global.tr.exportTo('tr.b', function () {

  var RegisteredTypeInfo = tr.b.RegisteredTypeInfo;
  var ExtensionRegistryOptions = tr.b.ExtensionRegistryOptions;

  function decorateBasicExtensionRegistry(registry, extensionRegistryOptions) {
    var savedStateStack = [];
    registry.registeredTypeInfos_ = [];

    registry.register = function (constructor, opt_metadata) {
      if (registry.findIndexOfRegisteredConstructor(constructor) !== undefined) throw new Error('Handler already registered for ' + constructor);

      extensionRegistryOptions.validateConstructor(constructor);

      var metadata = {};
      for (var k in extensionRegistryOptions.defaultMetadata) metadata[k] = extensionRegistryOptions.defaultMetadata[k];
      if (opt_metadata) {
        for (var k in opt_metadata) metadata[k] = opt_metadata[k];
      }

      var typeInfo = new RegisteredTypeInfo(constructor, metadata);

      var e = new tr.b.Event('will-register');
      e.typeInfo = typeInfo;
      registry.dispatchEvent(e);

      registry.registeredTypeInfos_.push(typeInfo);

      e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.pushCleanStateBeforeTest = function () {
      savedStateStack.push(registry.registeredTypeInfos_);
      registry.registeredTypeInfos_ = [];

      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };
    registry.popCleanStateAfterTest = function () {
      registry.registeredTypeInfos_ = savedStateStack[0];
      savedStateStack.splice(0, 1);

      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.findIndexOfRegisteredConstructor = function (constructor) {
      for (var i = 0; i < registry.registeredTypeInfos_.length; i++) if (registry.registeredTypeInfos_[i].constructor == constructor) return i;
      return undefined;
    };

    registry.unregister = function (constructor) {
      var foundIndex = registry.findIndexOfRegisteredConstructor(constructor);
      if (foundIndex === undefined) throw new Error(constructor + ' not registered');
      registry.registeredTypeInfos_.splice(foundIndex, 1);

      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.getAllRegisteredTypeInfos = function () {
      return registry.registeredTypeInfos_;
    };

    registry.findTypeInfo = function (constructor) {
      var foundIndex = this.findIndexOfRegisteredConstructor(constructor);
      if (foundIndex !== undefined) return this.registeredTypeInfos_[foundIndex];
      return undefined;
    };

    registry.findTypeInfoMatching = function (predicate, opt_this) {
      opt_this = opt_this ? opt_this : undefined;
      for (var i = 0; i < registry.registeredTypeInfos_.length; ++i) {
        var typeInfo = registry.registeredTypeInfos_[i];
        if (predicate.call(opt_this, typeInfo)) return typeInfo;
      }
      return extensionRegistryOptions.defaultTypeInfo;
    };

    registry.findTypeInfoWithName = function (name) {
      if (typeof name !== 'string') throw new Error('Name is not a string.');
      var typeInfo = registry.findTypeInfoMatching(function (ti) {
        return ti.constructor.name === name;
      });
      if (typeInfo) return typeInfo;
      return undefined;
    };
  }

  return {
    _decorateBasicExtensionRegistry: decorateBasicExtensionRegistry
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./event.js":33,"./extension_registry_base.js":36}],38:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./category_util.js");
require("./event.js");
require("./extension_registry_base.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var getCategoryParts = tr.b.getCategoryParts;

  var RegisteredTypeInfo = tr.b.RegisteredTypeInfo;
  var ExtensionRegistryOptions = tr.b.ExtensionRegistryOptions;

  function decorateTypeBasedExtensionRegistry(registry, extensionRegistryOptions) {
    var savedStateStack = [];

    registry.registeredTypeInfos_ = [];

    registry.categoryPartToTypeInfoMap_ = new Map();
    registry.typeNameToTypeInfoMap_ = new Map();

    registry.register = function (constructor, metadata) {

      extensionRegistryOptions.validateConstructor(constructor);

      var typeInfo = new RegisteredTypeInfo(constructor, metadata || extensionRegistryOptions.defaultMetadata);

      typeInfo.typeNames = [];
      typeInfo.categoryParts = [];
      if (metadata && metadata.typeName) typeInfo.typeNames.push(metadata.typeName);
      if (metadata && metadata.typeNames) {
        typeInfo.typeNames.push.apply(typeInfo.typeNames, metadata.typeNames);
      }
      if (metadata && metadata.categoryParts) {
        typeInfo.categoryParts.push.apply(typeInfo.categoryParts, metadata.categoryParts);
      }

      if (typeInfo.typeNames.length === 0 && typeInfo.categoryParts.length === 0) throw new Error('typeName or typeNames must be provided');

      // Sanity checks...
      typeInfo.typeNames.forEach(function (typeName) {
        if (registry.typeNameToTypeInfoMap_.has(typeName)) throw new Error('typeName ' + typeName + ' already registered');
      });
      typeInfo.categoryParts.forEach(function (categoryPart) {
        if (registry.categoryPartToTypeInfoMap_.has(categoryPart)) {
          throw new Error('categoryPart ' + categoryPart + ' already registered');
        }
      });

      var e = new tr.b.Event('will-register');
      e.typeInfo = typeInfo;
      registry.dispatchEvent(e);

      // Actual registration.
      typeInfo.typeNames.forEach(function (typeName) {
        registry.typeNameToTypeInfoMap_.set(typeName, typeInfo);
      });
      typeInfo.categoryParts.forEach(function (categoryPart) {
        registry.categoryPartToTypeInfoMap_.set(categoryPart, typeInfo);
      });
      registry.registeredTypeInfos_.push(typeInfo);

      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.pushCleanStateBeforeTest = function () {
      savedStateStack.push({
        registeredTypeInfos: registry.registeredTypeInfos_,
        typeNameToTypeInfoMap: registry.typeNameToTypeInfoMap_,
        categoryPartToTypeInfoMap: registry.categoryPartToTypeInfoMap_
      });
      registry.registeredTypeInfos_ = [];
      registry.typeNameToTypeInfoMap_ = new Map();
      registry.categoryPartToTypeInfoMap_ = new Map();
      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.popCleanStateAfterTest = function () {
      var state = savedStateStack[0];
      savedStateStack.splice(0, 1);

      registry.registeredTypeInfos_ = state.registeredTypeInfos;
      registry.typeNameToTypeInfoMap_ = state.typeNameToTypeInfoMap;
      registry.categoryPartToTypeInfoMap_ = state.categoryPartToTypeInfoMap;
      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.unregister = function (constructor) {
      var typeInfoIndex = -1;
      for (var i = 0; i < registry.registeredTypeInfos_.length; i++) {
        if (registry.registeredTypeInfos_[i].constructor == constructor) {
          typeInfoIndex = i;
          break;
        }
      }
      if (typeInfoIndex === -1) throw new Error(constructor + ' not registered');

      var typeInfo = registry.registeredTypeInfos_[typeInfoIndex];
      registry.registeredTypeInfos_.splice(typeInfoIndex, 1);
      typeInfo.typeNames.forEach(function (typeName) {
        registry.typeNameToTypeInfoMap_.delete(typeName);
      });
      typeInfo.categoryParts.forEach(function (categoryPart) {
        registry.categoryPartToTypeInfoMap_.delete(categoryPart);
      });
      var e = new tr.b.Event('registry-changed');
      registry.dispatchEvent(e);
    };

    registry.getTypeInfo = function (category, typeName) {
      if (category) {
        var categoryParts = getCategoryParts(category);
        for (var i = 0; i < categoryParts.length; i++) {
          var categoryPart = categoryParts[i];
          var typeInfo = registry.categoryPartToTypeInfoMap_.get(categoryPart);
          if (typeInfo !== undefined) return typeInfo;
        }
      }
      var typeInfo = registry.typeNameToTypeInfoMap_.get(typeName);
      if (typeInfo !== undefined) return typeInfo;

      return extensionRegistryOptions.defaultTypeInfo;
    };

    // TODO(nduca): Remove or rename.
    registry.getConstructor = function (category, typeName) {
      var typeInfo = registry.getTypeInfo(category, typeName);
      if (typeInfo) return typeInfo.constructor;
      return undefined;
    };
  }

  return {
    _decorateTypeBasedExtensionRegistry: decorateTypeBasedExtensionRegistry
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./category_util.js":30,"./event.js":33,"./extension_registry_base.js":36}],39:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var nextGUID = 1;

  var UUID4_PATTERN = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';

  var GUID = {
    /* Allocate an integer GUID.
     *
     * These GUIDs are not unique between loads, but are fast to generate, and
     * consume very little memory.
     *
     * @return {number} globally unique id.
     */
    allocateSimple: function () {
      return nextGUID++;
    },

    /* Return the last GUID allocated without allocating a new one.
     *
     * @return {number} last guid.
     */
    getLastSimpleGuid: function () {
      return nextGUID - 1;
    },

    /* Generate a random string UUID.
     *
     * Version 4 random UUIDs are practically guaranteed to be unique between
     * loads, so they can be serialized and compared with results from other
     * loads. These are slower to generate and consume more memory than simple
     * GUIDs.
     *
     * @return {string} universally unique id.
     */
    allocateUUID4: function () {
      return UUID4_PATTERN.replace(/[xy]/g, function (c) {
        var r = parseInt(Math.random() * 16);
        if (c === 'y') r = (r & 3) + 8;
        return r.toString(16);
      });
    }
  };

  return {
    GUID: GUID
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],40:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  function max(a, b) {
    if (a === undefined) return b;
    if (b === undefined) return a;
    return Math.max(a, b);
  }

  /**
   * This class implements an interval tree.
   *    See: http://wikipedia.org/wiki/Interval_tree
   *
   * Internally the tree is a Red-Black tree. The insertion/colour is done using
   * the Left-leaning Red-Black Trees algorithm as described in:
   *       http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf
   *
   * @param {function} beginPositionCb Callback to retrieve the begin position.
   * @param {function} endPositionCb Callback to retrieve the end position.
   *
   * @constructor
   */
  function IntervalTree(beginPositionCb, endPositionCb) {
    this.beginPositionCb_ = beginPositionCb;
    this.endPositionCb_ = endPositionCb;

    this.root_ = undefined;
    this.size_ = 0;
  }

  IntervalTree.prototype = {
    /**
     * Insert events into the interval tree.
     *
     * @param {Object} datum The object to insert.
     */
    insert: function (datum) {
      var startPosition = this.beginPositionCb_(datum);
      var endPosition = this.endPositionCb_(datum);

      var node = new IntervalTreeNode(datum, startPosition, endPosition);
      this.size_++;

      this.root_ = this.insertNode_(this.root_, node);
      this.root_.colour = Colour.BLACK;
      return datum;
    },

    insertNode_: function (root, node) {
      if (root === undefined) return node;

      if (root.leftNode && root.leftNode.isRed && root.rightNode && root.rightNode.isRed) this.flipNodeColour_(root);

      if (node.key < root.key) root.leftNode = this.insertNode_(root.leftNode, node);else if (node.key === root.key) root.merge(node);else root.rightNode = this.insertNode_(root.rightNode, node);

      if (root.rightNode && root.rightNode.isRed && (root.leftNode === undefined || !root.leftNode.isRed)) root = this.rotateLeft_(root);

      if (root.leftNode && root.leftNode.isRed && root.leftNode.leftNode && root.leftNode.leftNode.isRed) root = this.rotateRight_(root);

      return root;
    },

    rotateRight_: function (node) {
      var sibling = node.leftNode;
      node.leftNode = sibling.rightNode;
      sibling.rightNode = node;
      sibling.colour = node.colour;
      node.colour = Colour.RED;
      return sibling;
    },

    rotateLeft_: function (node) {
      var sibling = node.rightNode;
      node.rightNode = sibling.leftNode;
      sibling.leftNode = node;
      sibling.colour = node.colour;
      node.colour = Colour.RED;
      return sibling;
    },

    flipNodeColour_: function (node) {
      node.colour = this.flipColour_(node.colour);
      node.leftNode.colour = this.flipColour_(node.leftNode.colour);
      node.rightNode.colour = this.flipColour_(node.rightNode.colour);
    },

    flipColour_: function (colour) {
      return colour === Colour.RED ? Colour.BLACK : Colour.RED;
    },

    /* The high values are used to find intersection. It should be called after
     * all of the nodes are inserted. Doing it each insert is _slow_. */
    updateHighValues: function () {
      this.updateHighValues_(this.root_);
    },

    /* There is probably a smarter way to do this by starting from the inserted
     * node, but need to handle the rotations correctly. Went the easy route
     * for now. */
    updateHighValues_: function (node) {
      if (node === undefined) return undefined;

      node.maxHighLeft = this.updateHighValues_(node.leftNode);
      node.maxHighRight = this.updateHighValues_(node.rightNode);

      return max(max(node.maxHighLeft, node.highValue), node.maxHighRight);
    },

    validateFindArguments_: function (queryLow, queryHigh) {
      if (queryLow === undefined || queryHigh === undefined) throw new Error('queryLow and queryHigh must be defined');
      if (typeof queryLow !== 'number' || typeof queryHigh !== 'number') throw new Error('queryLow and queryHigh must be numbers');
    },

    /**
     * Retrieve all overlapping intervals.
     *
     * @param {number} queryLow The low value for the intersection interval.
     * @param {number} queryHigh The high value for the intersection interval.
     * @return {Array} All [begin, end] pairs inside intersecting intervals.
     */
    findIntersection: function (queryLow, queryHigh) {
      this.validateFindArguments_(queryLow, queryHigh);
      if (this.root_ === undefined) return [];

      var ret = [];
      this.root_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      return ret;
    },

    /**
     * Returns the number of nodes in the tree.
     */
    get size() {
      return this.size_;
    },

    /**
     * Returns the root node in the tree.
     */
    get root() {
      return this.root_;
    },

    /**
     * Dumps out the [lowValue, highValue] pairs for each node in depth-first
     * order.
     */
    dump_: function () {
      if (this.root_ === undefined) return [];
      return this.root_.dump();
    }
  };

  var Colour = {
    RED: 'red',
    BLACK: 'black'
  };

  function IntervalTreeNode(datum, lowValue, highValue) {
    this.lowValue_ = lowValue;

    this.data_ = [{
      datum: datum,
      high: highValue,
      low: lowValue
    }];

    this.colour_ = Colour.RED;

    this.parentNode_ = undefined;
    this.leftNode_ = undefined;
    this.rightNode_ = undefined;

    this.maxHighLeft_ = undefined;
    this.maxHighRight_ = undefined;
  }

  IntervalTreeNode.prototype = {
    appendIntersectionsInto_: function (ret, queryLow, queryHigh) {
      /* This node starts has a start point at or further right then queryHigh
       * so we know this node is out and all right children are out. Just need
       * to check left */
      if (this.lowValue_ >= queryHigh) {
        if (!this.leftNode_) return;
        return this.leftNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      }

      /* If we have a maximum left high value that is bigger then queryLow we
       * need to check left for matches */
      if (this.maxHighLeft_ > queryLow) {
        this.leftNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      }

      /* We know that this node starts before queryHigh, if any of it's data
       * ends after queryLow we need to add those nodes */
      if (this.highValue > queryLow) {
        for (var i = this.data.length - 1; i >= 0; --i) {
          /* data nodes are sorted by high value, so as soon as we see one
           * before low value we're done. */
          if (this.data[i].high < queryLow) break;

          ret.push(this.data[i].datum);
        }
      }

      /* check for matches in the right tree */
      if (this.rightNode_) {
        this.rightNode_.appendIntersectionsInto_(ret, queryLow, queryHigh);
      }
    },

    get colour() {
      return this.colour_;
    },

    set colour(colour) {
      this.colour_ = colour;
    },

    get key() {
      return this.lowValue_;
    },

    get lowValue() {
      return this.lowValue_;
    },

    get highValue() {
      return this.data_[this.data_.length - 1].high;
    },

    set leftNode(left) {
      this.leftNode_ = left;
    },

    get leftNode() {
      return this.leftNode_;
    },

    get hasLeftNode() {
      return this.leftNode_ !== undefined;
    },

    set rightNode(right) {
      this.rightNode_ = right;
    },

    get rightNode() {
      return this.rightNode_;
    },

    get hasRightNode() {
      return this.rightNode_ !== undefined;
    },

    set parentNode(parent) {
      this.parentNode_ = parent;
    },

    get parentNode() {
      return this.parentNode_;
    },

    get isRootNode() {
      return this.parentNode_ === undefined;
    },

    set maxHighLeft(high) {
      this.maxHighLeft_ = high;
    },

    get maxHighLeft() {
      return this.maxHighLeft_;
    },

    set maxHighRight(high) {
      this.maxHighRight_ = high;
    },

    get maxHighRight() {
      return this.maxHighRight_;
    },

    get data() {
      return this.data_;
    },

    get isRed() {
      return this.colour_ === Colour.RED;
    },

    merge: function (node) {
      for (var i = 0; i < node.data.length; i++) this.data_.push(node.data[i]);
      this.data_.sort(function (a, b) {
        return a.high - b.high;
      });
    },

    dump: function () {
      var ret = {};
      if (this.leftNode_) ret['left'] = this.leftNode_.dump();

      ret['data'] = this.data_.map(function (d) {
        return [d.low, d.high];
      });

      if (this.rightNode_) ret['right'] = this.rightNode_.dump();

      return ret;
    }
  };

  return {
    IntervalTree: IntervalTree
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],41:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {

  /**
   * Converts any object which is either (a) an iterable, or (b) an
   * "array-ish" object (has length property and can be indexed into)
   * into an array.
   */
  function asArray(x) {
    var values = [];
    if (x[Symbol.iterator]) for (var value of x) values.push(value);else for (var i = 0; i < x.length; i++) values.push(x[i]);
    return values;
  }

  /**
   * Returns the only element in the iterable. If the iterable is empty or has
   * more than one element, an error is thrown.
   */
  function getOnlyElement(iterable) {
    var iterator = iterable[Symbol.iterator]();

    var firstIteration = iterator.next();
    if (firstIteration.done) throw new Error('getOnlyElement was passed an empty iterable.');

    var secondIteration = iterator.next();
    if (!secondIteration.done) throw new Error('getOnlyElement was passed an iterable with multiple elements.');

    return firstIteration.value;
  }

  /**
   * Returns the first element in the iterable. If the iterable is empty, an
   * error is thrown.
   */
  function getFirstElement(iterable) {
    var iterator = iterable[Symbol.iterator]();
    var result = iterator.next();
    if (result.done) throw new Error('getFirstElement was passed an empty iterable.');

    return result.value;
  }

  function compareArrays(x, y, elementCmp) {
    var minLength = Math.min(x.length, y.length);
    for (var i = 0; i < minLength; i++) {
      var tmp = elementCmp(x[i], y[i]);
      if (tmp) return tmp;
    }
    if (x.length == y.length) return 0;

    if (x[i] === undefined) return -1;

    return 1;
  }

  /**
   * Compares two values when one or both might be undefined. Undefined
   * values are sorted after defined.
   */
  function comparePossiblyUndefinedValues(x, y, cmp, opt_this) {
    if (x !== undefined && y !== undefined) return cmp.call(opt_this, x, y);
    if (x !== undefined) return -1;
    if (y !== undefined) return 1;
    return 0;
  }

  /**
   * Compares two numeric values when one or both might be undefined or NaNs.
   * Undefined / NaN values are sorted after others.
   */
  function compareNumericWithNaNs(x, y) {
    if (!isNaN(x) && !isNaN(y)) return x - y;
    if (isNaN(x)) return 1;
    if (isNaN(y)) return -1;
    return 0;
  }

  function concatenateArrays() /*arguments*/{
    var values = [];
    for (var i = 0; i < arguments.length; i++) {
      if (!(arguments[i] instanceof Array)) throw new Error('Arguments ' + i + 'is not an array');
      values.push.apply(values, arguments[i]);
    }
    return values;
  }

  function concatenateObjects() /*arguments*/{
    var result = {};
    for (var i = 0; i < arguments.length; i++) {
      var object = arguments[i];
      for (var j in object) {
        result[j] = object[j];
      }
    }
    return result;
  }

  function cloneDictionary(dict) {
    var clone = {};
    for (var k in dict) {
      clone[k] = dict[k];
    }
    return clone;
  }

  function dictionaryKeys(dict) {
    var keys = [];
    for (var key in dict) keys.push(key);
    return keys;
  }

  function dictionaryValues(dict) {
    var values = [];
    for (var key in dict) values.push(dict[key]);
    return values;
  }

  function dictionaryLength(dict) {
    var n = 0;
    for (var key in dict) n++;
    return n;
  }

  function dictionaryContainsValue(dict, value) {
    for (var key in dict) if (dict[key] === value) return true;
    return false;
  }

  /**
   * Returns true if all the elements of the iterable pass the predicate.
   */
  function every(iterable, predicate) {
    for (var x of iterable) if (!predicate(x)) return false;
    return true;
  }

  /**
   * Returns a new dictionary with items grouped by the return value of the
   * specified function being called on each item.
   * @param {!Array.<!*>} ary The array being iterated through
   * @param {!function(!*):!*} callback The mapping function between the array
   * value and the map key.
   * @param {*=} opt_this
   */
  function group(ary, callback, opt_this, opt_arrayConstructor) {
    var arrayConstructor = opt_arrayConstructor || Array;
    var results = {};
    for (var element of ary) {
      var key = callback.call(opt_this, element);
      if (!(key in results)) results[key] = new arrayConstructor();
      results[key].push(element);
    }
    return results;
  }

  /**
   * Returns a new Map with items grouped by the return value of the
   * specified function being called on each item.
   * @param {!Array.<!*>} ary The array being iterated through
   * @param {!function(!*):!*} callback The mapping function between the array
   * value and the map key.
   * @param {*=} opt_this
   */
  function groupIntoMap(ary, callback, opt_this, opt_arrayConstructor) {
    var arrayConstructor = opt_arrayConstructor || Array;
    var results = new Map();
    for (var element of ary) {
      var key = callback.call(opt_this, element);
      var items = results.get(key);
      if (items === undefined) {
        items = new arrayConstructor();
        results.set(key, items);
      }
      items.push(element);
    }
    return results;
  }

  function iterItems(dict, fn, opt_this) {
    opt_this = opt_this || this;
    var keys = Object.keys(dict);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      fn.call(opt_this, key, dict[key]);
    }
  }

  /**
   * Create a new dictionary with the same keys as the original dictionary
   * mapped to the results of the provided function called on the corresponding
   * entries in the original dictionary, i.e. result[key] = fn(key, dict[key])
   * for all keys in dict (own enumerable properties only).
   *
   * Example:
   *   var srcDict = {a: 10, b: 15};
   *   var dstDict = mapItems(srcDict, function(k, v) { return 2 * v; });
   *   // srcDict is unmodified and dstDict is now equal to {a: 20, b: 30}.
   */
  function mapItems(dict, fn, opt_this) {
    opt_this = opt_this || this;
    var result = {};
    var keys = Object.keys(dict);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      result[key] = fn.call(opt_this, key, dict[key]);
    }
    return result;
  }

  function filterItems(dict, predicate, opt_this) {
    opt_this = opt_this || this;
    var result = {};
    var keys = Object.keys(dict);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = dict[key];
      if (predicate.call(opt_this, key, value)) result[key] = value;
    }
    return result;
  }

  function iterObjectFieldsRecursively(object, func) {
    if (!(object instanceof Object)) return;

    if (object instanceof Array) {
      for (var i = 0; i < object.length; i++) {
        func(object, i, object[i]);
        iterObjectFieldsRecursively(object[i], func);
      }
      return;
    }

    for (var key in object) {
      var value = object[key];
      func(object, key, value);
      iterObjectFieldsRecursively(value, func);
    }
  }

  /**
   * Convert an array of dictionaries to a dictionary of arrays.
   *
   * The keys of the resulting dictionary are a union of the keys of all
   * dictionaries in the provided array. Each array in the resulting dictionary
   * has the same length as the provided array and contains the values of its
   * key in the dictionaries in the provided array. Example:
   *
   *   INPUT:
   *
   *     [
   *       {a: 6, b: 5      },
   *       undefined,
   *       {a: 4, b: 3, c: 2},
   *       {      b: 1, c: 0}
   *     ]
   *
   *   OUTPUT:
   *
   *     {
   *       a: [6,         undefined, 4, undefined],
   *       b: [5,         undefined, 3, 1        ],
   *       c: [undefined, undefined, 2, 0        ]
   *     }
   *
   * @param {!Array} array Array of items to be inverted. If opt_dictGetter
   *     is not provided, all elements of the array must be either undefined,
   *     or dictionaries.
   * @param {?(function(*): (!Object|undefined))=} opt_dictGetter Optional
   *     function mapping defined elements of array to dictionaries.
   * @param {*=} opt_this Optional 'this' context for opt_dictGetter.
   */
  function invertArrayOfDicts(array, opt_dictGetter, opt_this) {
    opt_this = opt_this || this;
    var result = {};
    for (var i = 0; i < array.length; i++) {
      var item = array[i];
      if (item === undefined) continue;
      var dict = opt_dictGetter ? opt_dictGetter.call(opt_this, item) : item;
      if (dict === undefined) continue;
      for (var key in dict) {
        var valueList = result[key];
        if (valueList === undefined) result[key] = valueList = new Array(array.length);
        valueList[i] = dict[key];
      }
    }
    return result;
  }

  /**
   * Convert an array to a dictionary.
   *
   * Every element in the array is mapped in the dictionary to the key returned
   * by the provided function:
   *
   *   dictionary[valueToKeyFn(element)] = element;
   *
   * @param {!Array} array Arbitrary array.
   * @param {function(*): string} valueToKeyFn Function mapping array elements
   *     to dictionary keys.
   * @param {*=} opt_this Optional 'this' context for valueToKeyFn.
   */
  function arrayToDict(array, valueToKeyFn, opt_this) {
    opt_this = opt_this || this;
    var result = {};
    var length = array.length;
    for (var i = 0; i < length; i++) {
      var value = array[i];
      var key = valueToKeyFn.call(opt_this, value);
      result[key] = value;
    }
    return result;
  }

  /** Returns the value passed in. */
  function identity(d) {
    return d;
  }

  /**
   * Returns the index of the first element in |ary| for which |opt_func|
   * returns a truthy value.
   *
   * @param {!Array} ary The array being searched
   * @param {function(*): *=} opt_func The test function which accepts an array
   *     element and returns a value that is coerced to a boolean. Defaults to
   *     the identity function.
   * @param {*=} opt_this Optional 'this' context for opt_func.
   */
  function findFirstIndexInArray(ary, opt_func, opt_this) {
    var func = opt_func || identity;
    for (var i = 0; i < ary.length; i++) {
      if (func.call(opt_this, ary[i], i)) return i;
    }
    return -1;
  }

  /**
   * Returns the value of the first element in |ary| for which |opt_func|
   * returns a truthy value.
   *
   * @param {!Array} ary The array being searched.
   * @param {function(*): *=} opt_func The test function which accepts an array
   *     element and returns a value that is coerced to a boolean. Defaults to
   *     the identity function.
   * @param {*=} opt_this Optional 'this' context for opt_func.
   */
  function findFirstInArray(ary, opt_func, opt_this) {
    var i = findFirstIndexInArray(ary, opt_func, opt_func);
    if (i === -1) return undefined;
    return ary[i];
  }

  /**
   * Returns the key of the first dictionary entry for which |opt_func| returns
   * a truthy value.
   *
   * @param {!Object} dict The dictionary being searched.
   * @param {function(*, *): *=} opt_func The test function which accepts a
   *     dictionary key as its first parameter, the corresponding dictionary
   *     value as its second parameter, and returns a value that is coerced to a
   *     boolean. Defaults to the identity function (which returns the key).
   * @param {*=} opt_this Optional 'this' context for opt_func.
   */
  function findFirstKeyInDictMatching(dict, opt_func, opt_this) {
    var func = opt_func || identity;
    for (var key in dict) {
      if (func.call(opt_this, key, dict[key])) return key;
    }
    return undefined;
  }

  /** Returns the values in an ES6 Map object. */
  function mapValues(map) {
    var values = [];
    for (var value of map.values()) values.push(value);
    return values;
  }

  /**
   * Calls |fn| on each entry in an ES6 Map.
   *
   * @param {!Map} The map whose entries are being processed.
   * @param {function(*, *): *} The function which accepts a map key as its
   *     first parameter and a map value as its second parameter. Any return
   *     value is ignored.
   * @param {*=} opt_this Optional 'this' context for fn.
   */
  function iterMapItems(map, fn, opt_this) {
    opt_this = opt_this || this;
    for (var key of map.keys()) fn.call(opt_this, key, map.get(key));
  }

  return {
    asArray: asArray,
    concatenateArrays: concatenateArrays,
    concatenateObjects: concatenateObjects,
    compareArrays: compareArrays,
    comparePossiblyUndefinedValues: comparePossiblyUndefinedValues,
    compareNumericWithNaNs: compareNumericWithNaNs,
    cloneDictionary: cloneDictionary,
    dictionaryLength: dictionaryLength,
    dictionaryKeys: dictionaryKeys,
    dictionaryValues: dictionaryValues,
    dictionaryContainsValue: dictionaryContainsValue,
    every: every,
    getOnlyElement: getOnlyElement,
    getFirstElement: getFirstElement,
    group: group,
    groupIntoMap: groupIntoMap,
    iterItems: iterItems,
    mapItems: mapItems,
    filterItems: filterItems,
    iterObjectFieldsRecursively: iterObjectFieldsRecursively,
    invertArrayOfDicts: invertArrayOfDicts,
    arrayToDict: arrayToDict,
    identity: identity,
    findFirstIndexInArray: findFirstIndexInArray,
    findFirstInArray: findFirstInArray,
    findFirstKeyInDictMatching: findFirstKeyInDictMatching,
    mapValues: mapValues,
    iterMapItems: iterMapItems
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],42:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

// In node, the script-src for gl-matrix-min above brings in glmatrix into
// a module, instead of into the global scope. Whereas, Tracing code
// assumes that glMatrix is in the global scope. So, in Node only, we
// require() it in, and then take all its exports and shove them into the
// global scope by hand.
(function () {
  if (tr.isNode) {
    var glMatrixAbsPath = HTMLImportsLoader.hrefToAbsolutePath('/gl-matrix-min.js');
    var glMatrixModule = require(glMatrixAbsPath);
    for (var exportName in glMatrixModule) {
      global[exportName] = glMatrixModule[exportName];
    }
  }
})(this);

'use strict';

global.tr.exportTo('tr.b', function () {
  /* Returns true when x and y are within delta of each other. */
  function approximately(x, y, delta) {
    if (delta === undefined) delta = 1e-9;
    return Math.abs(x - y) < delta;
  }

  function clamp(x, lo, hi) {
    return Math.min(Math.max(x, lo), hi);
  }

  function lerp(percentage, lo, hi) {
    var range = hi - lo;
    return lo + percentage * range;
  }

  function normalize(value, lo, hi) {
    return (value - lo) / (hi - lo);
  }

  function deg2rad(deg) {
    return Math.PI * deg / 180.0;
  }

  /* The Gauss error function gives the probability that a measurement (which is
   * under the influence of normally distributed errors with standard deviation
   * sigma = 1) is less than x from the mean value of the standard normal
   * distribution.
   * https://www.desmos.com/calculator/t1v4bdpske
   *
   * @param {number} x A tolerance for error.
   * @return {number} The probability that a measurement is less than |x| from
   * the mean value of the standard normal distribution.
   */
  function erf(x) {
    // save the sign of x
    // erf(-x) = -erf(x);
    var sign = x >= 0 ? 1 : -1;
    x = Math.abs(x);

    // constants
    var a1 = 0.254829592;
    var a2 = -0.284496736;
    var a3 = 1.421413741;
    var a4 = -1.453152027;
    var a5 = 1.061405429;
    var p = 0.3275911;

    // Abramowitz and Stegun formula 7.1.26
    // maximum error: 1.5e-7
    var t = 1.0 / (1.0 + p * x);
    var y = 1.0 - ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
    return sign * y;
  }

  var tmpVec2 = vec2.create();
  var tmpVec2b = vec2.create();
  var tmpVec4 = vec4.create();
  var tmpMat2d = mat2d.create();

  vec2.createFromArray = function (arr) {
    if (arr.length != 2) throw new Error('Should be length 2');
    var v = vec2.create();
    vec2.set(v, arr[0], arr[1]);
    return v;
  };

  vec2.createXY = function (x, y) {
    var v = vec2.create();
    vec2.set(v, x, y);
    return v;
  };

  vec2.toString = function (a) {
    return '[' + a[0] + ', ' + a[1] + ']';
  };

  vec2.addTwoScaledUnitVectors = function (out, u1, scale1, u2, scale2) {
    // out = u1 * scale1 + u2 * scale2
    vec2.scale(tmpVec2, u1, scale1);
    vec2.scale(tmpVec2b, u2, scale2);
    vec2.add(out, tmpVec2, tmpVec2b);
  };

  vec2.interpolatePiecewiseFunction = function (points, x) {
    if (x < points[0][0]) return points[0][1];
    for (var i = 1; i < points.length; ++i) {
      if (x < points[i][0]) {
        var percent = normalize(x, points[i - 1][0], points[i][0]);
        return lerp(percent, points[i - 1][1], points[i][1]);
      }
    }
    return points[points.length - 1][1];
  };

  vec3.createXYZ = function (x, y, z) {
    var v = vec3.create();
    vec3.set(v, x, y, z);
    return v;
  };

  vec3.toString = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
  };

  mat2d.translateXY = function (out, x, y) {
    vec2.set(tmpVec2, x, y);
    mat2d.translate(out, out, tmpVec2);
  };

  mat2d.scaleXY = function (out, x, y) {
    vec2.set(tmpVec2, x, y);
    mat2d.scale(out, out, tmpVec2);
  };

  vec4.unitize = function (out, a) {
    out[0] = a[0] / a[3];
    out[1] = a[1] / a[3];
    out[2] = a[2] / a[3];
    out[3] = 1;
    return out;
  };

  vec2.copyFromVec4 = function (out, a) {
    vec4.unitize(tmpVec4, a);
    vec2.copy(out, tmpVec4);
  };

  return {
    approximately: approximately,
    clamp: clamp,
    lerp: lerp,
    normalize: normalize,
    deg2rad: deg2rad,
    erf: erf
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],43:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

/**
 * @fileoverview Multi-dimensional view data structure.
 *
 * A multi-dimensional view provides a hierarchical representation of a
 * collection of multi-dimensional paths with associated scalar values. Unlike
 * separate single-dimensional views (e.g. one tree for each dimension),
 * multi-dimensional views facilitate aggregation over combinations of
 * substrings of the path dimensions (rather than just substrings of a single
 * path dimension).
 *
 * Every view consists of multi-dimensional nodes (see MultiDimensionalViewNode
 * for more details). This file also provides a builder class for constructing
 * top-down and bottom-up representations of arbitrary collections of
 * multi-dimensional paths (see MultiDimensionalViewBuilder for more details).
 *
 * Example: Given the following collection of two dimensional paths:
 *
 *   <===================== Path =====================>   <== Total values ===>
 *    <------- dimension 0 ------->  <- dimension 1 ->    <- v 0 ->  <- v 1 ->
 *   [['Run()', 'Exec()', 'Call()'], ['Obj', 'View']  ]: [1        , 3
 *   [['Run()', 'Exec()', 'Call()'], ['Obj', 'Widget']]: [2        , 5
 *   [['Run()', 'Exec()', 'Load()'], ['Obj']          ]: [4        , 11
 *   [['Run()', 'Exec()']          , ['int']          ]: [8        , 7
 *   [['Run()']                    , ['Obj', 'Window']]: [16       , 0
 *   [['Stop()']                   , ['Obj']          ]: [32       , 13
 *
 * a multi-dimensional view provides a recursive breakdown of the aggregated
 * values, e.g. (total values shown in square brackets):
 *
 *   (root): [63, 39]
 *     |
 *     | break down by 0th dimension
 *     v
 *   Run():  [31, 26]
 *     |
 *     | break down by 0th dimension
 *     v
 *   Exec(): [15, 26]
 *     |
 *     | break down by 1st dimension
 *     v
 *   Obj:    [7, 19]
 *     |
 *     | break down by 0th dimension again
 *     v
 *   Call(): [3, 8]
 *     |
 *     | break down by 1st dimension again
 *     v
 *   View:   [1, 3]
 *
 * Observe that the recursive breakdown above is over both dimensions.
 * Furthermore, the underlying single-dimension paths (Run() -> Exec() -> Call()
 * and Obj -> View) can be arbitrarily interleaved in the breakdown.
 */
global.tr.exportTo('tr.b', function () {

  /**
   * Node of a multi-dimensional view.
   *
   * The structure of a view is encoded in the nodes using links to their
   * children wrt each dimension. The diagram below shows how the nodes
   * corresponding to the following four two-dimensional view paths:
   *
   *   1. [['A', 'B'], ['1', '2']]
   *   2. [['A', 'C'], ['1', '2']]
   *   3. [['A', 'B'], ['1', '3']]
   *   4. [['A', 'C'], ['1', '3']]
   *
   * can be reached from the root of a two-dimensional view using these links
   * ('*' stands for undefined):
   *
   *                       +---------------------+
   *                       | title: [*,*] (root) |
   *                       +---------------------+
   *                     children wrt    children wrt
   *                    0th dimension    1st dimension
   *                              |        :
   *              _______A________|        :........1.........
   *             |                                           :
   *             v                                           v
   *         +--------------+                     +--------------+
   *         | title: [A,*] |                     | title: [*,1] |
   *         +--------------+                     +--------------+
   *    children wrt   children wrt         children wrt   children wrt
   *   0th dimension   1st dimension       0th dimension   1st dimension
   *           | |       :.....1......    _____A_____|       : :
   *        _B_| |__C__              :   |             ...2..: :.3..
   *       |           |             :   |             :           :
   *       v           v             v   v             v           v
   *   +-------+   +-------+       +-------+       +-------+   +-------+
   *   | [B,*] |   | [C,*] |       | [A,1] |       | [*,2] |   | [*,3] |
   *   +-------+   +-------+       +-------+       +-------+   +-------+
   *       :        ___:_____B______| | : :......3.....|....       |
   *       :.1..   |   :.1..    __C___| :...2...    _A_|   :    _A_|
   *           :   |       :   |               :   |       :   |
   *           v   v       v   v               v   v       v   v
   *         +-------+   +-------+           +-------+   +-------+
   *         | [B,1] |   | [C,1] |           | [A,2] |   | [A,3] |
   *         +-------+   +-------+           +-------+   +-------+
   *           :   :       :   :.......3.......||..........   ||
   *           :   :..3....:................   BC         :   BC
   *           :     ______:_______________:___||         :   ||
   *           2    |      2        _______:____|   ______:___||
   *           :    |      :       |       :       |      :    |
   *           v    v      v       v       v       v      v    v
   *       +----------+   +----------+   +----------+   +----------+
   *       |  [B,2]   |   |  [C,2]   |   |  [B,3]   |   |  [C,3]   |
   *       | (node 1) |   | (node 2) |   | (node 3) |   | (node 4) |
   *       +----------+   +----------+   +----------+   +----------+
   *
   * The self/total values of a node represents the aggregated values of all
   * paths (in the collection from which the view was built) matching the node
   * excluding/including the node's descendants.
   *
   * Terminology examples:
   *
   *   - Children of [A,*] wrt 0th dimension: [B,*], [C,*]
   *   - Children of [A,*] (wrt all dimensions): [B,*], [C,*], [A,1]
   *   - Descendants of [A,*] wrt 1st dimension: [A,1], [A,2], [A,3]
   *   - Single-dimensional descendants of [A,*]: [A,1], [A,2], [A,3], [B,*],
   *     [C,*]
   *   - Descendants of [A,*] (wrt all dimensions): [A,1], [A,2], [A,3], [B,*],
   *     [C,*], [B,1], [C,1], [B,2], [C,2], [B,3], [C,3]
   *
   * @{constructor}
   */
  function MultiDimensionalViewNode(title, valueCount) {
    // List of titles of this node wrt each dimension.
    this.title = title;

    // Map from child name to child node for each dimension.
    var dimensions = title.length;
    this.children = new Array(dimensions);
    for (var i = 0; i < dimensions; i++) this.children[i] = new Map();

    // For each value index (from 0 to |valueCount| - 1), we store the self and
    // total values together with a Boolean flag whether the value is only a
    // lower bound (i.e. aggregated from children rather than provided
    // directly).
    this.values = new Array(valueCount);
    for (var v = 0; v < valueCount; v++) this.values[v] = { self: 0, total: 0, totalState: NOT_PROVIDED };
  }

  /**
   * States of total values stored in multi-dimensional view nodes.
   *
   * @enum
   */
  MultiDimensionalViewNode.TotalState = {
    // Neither total nor self value was provided for either the node or any of
    // its descendants.
    NOT_PROVIDED: 0,

    // The total value was NOT provided for the node, but the self value was
    // provided for the node or the total or self value was provided for at
    // least one of its descendants.
    LOWER_BOUND: 1,

    // The total value was provided for the node.
    EXACT: 2
  };
  // Cache the total value states to avoid repeated object field lookups.
  var NOT_PROVIDED = MultiDimensionalViewNode.TotalState.NOT_PROVIDED;
  var LOWER_BOUND = MultiDimensionalViewNode.TotalState.LOWER_BOUND;
  var EXACT = MultiDimensionalViewNode.TotalState.EXACT;

  MultiDimensionalViewNode.prototype = {
    /** Duck type <tr-ui-b-table> rows. */
    get subRows() {
      return tr.b.mapValues(this.children[0]);
    }
  };

  /**
   * Builder for multi-dimensional views.
   *
   * Given a collection of multi-dimensional paths, a builder can be used to
   * construct the following three representations of the paths:
   *
   *   1. Top-down tree view
   *      A multi-dimensional path in the view corresponds to all paths in the
   *      collection that have it as their prefix.
   *
   *   2. Top-down heavy view
   *      A multi-dimensional path in the view corresponds to all paths in the
   *      collection that have it as their substring
   *
   *   3. Bottom-up heavy view
   *      A multi-dimensional path in the view corresponds to all paths in the
   *      collection that have it as their substring reversed.
   *
   * For example, the following collection of 2-dimensional paths (with single
   * values):
   *
   *                  2-dimensional path                | self
   *    Time (0th dimension) | Activity (1st dimension) | value
   *   ========================+========================+=======
   *    Saturday             | Cooking                  |   1 h
   *    Saturday             | Sports -> Football       |   2 h
   *    Sunday               | Sports -> Basketball     |   3 h
   *
   * gives rise to the following top-down tree view, which aggregates the
   * scalar values over prefixes of the given paths:
   *
   *                              +---------+
   *                              |    *    |
   *                              |    *    |
   *                              | self=0  |
   *                              | total=6 |
   *                              +---------+
   *                                | : | :
   *         _________Cooking_______| : | :............Sunday............
   *        |                         : |                               :
   *        |            ...Saturday..: |_Sports_                       :
   *        |            :                       |                      :
   *        v            v                       v                      v
   *   +---------+  +---------+            +---------+             +---------+
   *   |    *    |  |   Sat   |            |    *    |             |   Sun   |
   *   | Cooking |  |    *    |            | Sports  |             |    *    |
   *   | self=0  |  | self=0  |            | self=0  |             | self=0  |
   *   | total=1 |  | total=3 |            | total=5 |             | total=3 |
   *   +---------+  +---------+            +---------+             +---------+
   *      :          |   |                   : | | :                     |
   *    Saturday     | Sports                : | | :                  Sports
   *      :          |   |  .....Saturday....: | | :.....Sunday.......   |
   *      :    _Cook_|   |  :            _Foot_| |_Bask_             :   |
   *      :   |          |  :           |               |            :   |
   *      v   v          v  v           v               v            v   v
   *   +---------+  +---------+  +------------+  +--------------+  +---------+
   *   |   Sat   |  |   Sat   |  |     *      |  |      *       |  |   Sun   |
   *   | Cooking |  | Sports  |  | S/Football |  | S/Basketball |  | Sports  |
   *   | self=1  |  | self=0  |  | self=0     |  | self=0       |  | self=0  |
   *   | total=1 |  | total=2 |  | total=2    |  | total=3      |  | total=3 |
   *   +---------+  +---------+  +------------+  +--------------+  +---------+
   *                    |              :                 :               |
   *                    |_Foot_  ..Sat.:                 :.Sun..   _Bask_|
   *                           | :                             :  |
   *                           v v                             v  v
   *                     +------------+                   +--------------+
   *                     |    Sat     |                   |     Sun      |
   *                     | S/Football |                   | S/Basketball |
   *                     | self=2     |                   | self=3       |
   *                     | total=2    |                   | total=3      |
   *                     +------------+                   +--------------+
   *
   * To build a multi-dimensional view of a collection of multi-dimensional
   * paths, you create a builder, add the paths to it and then use it to
   * construct the view. For example, the following code generates the
   * 2-dimensional top-down tree view shown above:
   *
   *   var builder = new MultiDimensionalViewBuilder(2);
   *   builder.addPath([['Saturday'], ['Cooking']], [1], SELF);
   *   builder.addPath([['Saturday'], ['Sports', 'Football']], [2], SELF);
   *   builder.addPath([['Sunday'], ['Sports', 'Basketball']], [3], SELF);
   *   var treeViewRoot = builder.buildTopDownTreeView();
   *
   * The heavy views can be constructed analogously (by calling
   * buildTopDownHeavyView() or buildBottomUpHeavyView() at the end instead).
   *
   * Note that the same builder can be used to construct both the tree and
   * heavy views (for the same collection of paths). However, no more paths can
   * be added once either view has been built.
   *
   * @{constructor}
   */
  function MultiDimensionalViewBuilder(dimensions, valueCount) {
    if (typeof dimensions !== 'number' || dimensions < 0) throw new Error('Dimensions must be a non-negative number');
    this.dimensions_ = dimensions;

    if (typeof valueCount !== 'number' || valueCount < 0) throw new Error('Number of values must be a non-negative number');
    this.valueCount_ = valueCount;

    this.buildRoot_ = this.createRootNode_();
    this.topDownTreeViewRoot_ = undefined;
    this.topDownHeavyViewRoot_ = undefined;
    this.bottomUpHeavyViewNode_ = undefined;

    this.maxDimensionDepths_ = new Array(dimensions);
    for (var d = 0; d < dimensions; d++) this.maxDimensionDepths_[d] = 0;
  }

  /** @{enum} */
  MultiDimensionalViewBuilder.ValueKind = {
    SELF: 0,
    TOTAL: 1
  };

  /**
   * Types of multi-dimensional views provided by MultiDimensionalViewBuilder.
   *
   * @enum
   */
  MultiDimensionalViewBuilder.ViewType = {
    TOP_DOWN_TREE_VIEW: 0,
    TOP_DOWN_HEAVY_VIEW: 1,
    BOTTOM_UP_HEAVY_VIEW: 2
  };

  MultiDimensionalViewBuilder.prototype = {
    /**
     * Add values associated with a multi-dimensional path to the tree.
     *
     * The path must have the same number of dimensions as the builder. Its
     * elements must be single-dimension paths (lists of strings) of arbitrary
     * length (empty for the root of the given dimension). Starting from the
     * root of the tree, each single-dimension path is traversed from left to
     * right to reach the node corresponding to the whole path.
     *
     * The length of the provided list of values must be equal to the builder's
     * value count. The builder supports adding both kinds of values
     * (self/total) wrt all value indices for an arbitrary multi-dimensional
     * path. The rationale for adding total values (in addition to/instead of
     * self values) is to cater for missing sub-paths. Example: Consider the
     * following collection of single-dimensional paths (with single values):
     *
     *   [['Loop::Run()', 'Execute()', 'FunctionBig']]:       self=99000
     *   [['Loop::Run()', 'Execute()', 'FunctionSmall1']]:    self=1
     *   [['Loop::Run()', 'Execute()', 'FunctionSmall2']]:    self=1
     *   ...
     *   [['Loop::Run()', 'Execute()', 'FunctionSmall1000']]: self=1
     *
     * If we required that only self values could be added to the builder, then
     * all of the 1001 paths would need to be provided (most likely in a trace)
     * to obtain the correct total of [['Loop::Run()', 'Execute()']]. However,
     * since we allow adding total values as well, only the following 2 paths
     * need to be provided to get the correct numbers explaining 99% of the
     * aggregated total value:
     *
     *   [['Loop::Run()', 'Execute()']]:                total=100000
     *   [['Loop::Run()', 'Execute()', 'FunctionBig']]: self=99000
     *
     * In other words, the long tail containing 1000 small paths need not be
     * dumped (greatly reducing the size of a trace where applicable).
     *
     * Important: No paths can be added to a builder once either view has been
     * built!
     */
    addPath: function (path, values, valueKind) {
      if (this.buildRoot_ === undefined) {
        throw new Error('Paths cannot be added after either view has been built');
      }
      if (path.length !== this.dimensions_) throw new Error('Path must be ' + this.dimensions_ + '-dimensional');
      if (values.length !== this.valueCount_) throw new Error('Must provide ' + this.valueCount_ + ' values');

      var isTotal;
      switch (valueKind) {
        case MultiDimensionalViewBuilder.ValueKind.SELF:
          isTotal = false;
          break;
        case MultiDimensionalViewBuilder.ValueKind.TOTAL:
          isTotal = true;
          break;
        default:
          throw new Error('Invalid value kind: ' + valueKind);
      }

      var node = this.buildRoot_;
      for (var d = 0; d < path.length; d++) {
        var singleDimensionPath = path[d];
        var singleDimensionPathLength = singleDimensionPath.length;
        this.maxDimensionDepths_[d] = Math.max(this.maxDimensionDepths_[d], singleDimensionPathLength);
        for (var i = 0; i < singleDimensionPathLength; i++) node = this.getOrCreateChildNode_(node, d, singleDimensionPath[i]);
      }

      for (var v = 0; v < this.valueCount_; v++) {
        var addedValue = values[v];
        if (addedValue === undefined) continue;
        var nodeValue = node.values[v];
        if (isTotal) {
          nodeValue.total += addedValue;
          nodeValue.totalState = EXACT;
        } else {
          nodeValue.self += addedValue;
          nodeValue.totalState = Math.max(nodeValue.totalState, LOWER_BOUND);
        }
      }
    },

    buildView: function (viewType) {
      switch (viewType) {
        case MultiDimensionalViewBuilder.ViewType.TOP_DOWN_TREE_VIEW:
          return this.buildTopDownTreeView();
        case MultiDimensionalViewBuilder.ViewType.TOP_DOWN_HEAVY_VIEW:
          return this.buildTopDownHeavyView();
        case MultiDimensionalViewBuilder.ViewType.BOTTOM_UP_HEAVY_VIEW:
          return this.buildBottomUpHeavyView();
        default:
          throw new Error('Unknown multi-dimensional view type: ' + viewType);
      }
    },

    /**
     * Build the top-down tree view of the multi-dimensional view.
     *
     * Note that no more paths can be added to the builder once either view has
     * been built.
     */
    buildTopDownTreeView: function () {
      if (this.topDownTreeViewRoot_ === undefined) {
        var treeViewRoot = this.buildRoot_;
        this.buildRoot_ = undefined;

        this.setUpMissingChildRelationships_(treeViewRoot, 0 /* firstDimensionToSetUp */);
        this.finalizeTotalValues_(treeViewRoot, 0 /* firstDimensionToFinalize */
        , new WeakMap() /* dimensionalSelfSumsMap */);

        this.topDownTreeViewRoot_ = treeViewRoot;
      }

      return this.topDownTreeViewRoot_;
    },

    /**
     * Build the top-down heavy view of the multi-dimensional view.
     *
     * Note that no more paths can be added to the builder once either view has
     * been built.
     */
    buildTopDownHeavyView: function () {
      if (this.topDownHeavyViewRoot_ === undefined) {
        this.topDownHeavyViewRoot_ = this.buildGenericHeavyView_(this.addDimensionToTopDownHeavyViewNode_.bind(this));
      }
      return this.topDownHeavyViewRoot_;
    },

    /**
     * Build the bottom-up heavy view of the multi-dimensional view.
     *
     * Note that no more paths can be added to the builder once either view has
     * been built.
     */
    buildBottomUpHeavyView: function () {
      if (this.bottomUpHeavyViewNode_ === undefined) {
        this.bottomUpHeavyViewNode_ = this.buildGenericHeavyView_(this.addDimensionToBottomUpHeavyViewNode_.bind(this));
      }
      return this.bottomUpHeavyViewNode_;
    },

    createRootNode_: function () {
      return new MultiDimensionalViewNode(new Array(this.dimensions_) /* title */, this.valueCount_);
    },

    getOrCreateChildNode_: function (parentNode, dimension, childDimensionTitle) {
      if (dimension < 0 || dimension >= this.dimensions_) throw new Error('Invalid dimension');

      var dimensionChildren = parentNode.children[dimension];

      var childNode = dimensionChildren.get(childDimensionTitle);
      if (childNode !== undefined) return childNode;

      var childTitle = parentNode.title.slice();
      childTitle[dimension] = childDimensionTitle;
      childNode = new MultiDimensionalViewNode(childTitle, this.valueCount_);
      dimensionChildren.set(childDimensionTitle, childNode);

      return childNode;
    },

    /**
     * Set up missing child relationships.
     *
     * When an arbitrary multi-dimensional path [path1, path2, ..., pathN] is
     * added to the build tree (see addPath), only the nodes on the path1 ->
     * path2 -> ... -> pathN chain are created (i.e. no interleavings of the
     * single-dimensional paths are added to the tree). This method recursively
     * adds all the missing paths.
     *
     * Two-dimensional example:
     *
     *    Initial build tree   .       After path      .  After missing child
     *        (root only)      .    [[A, B], [1, 2]]   .   relationships were
     *                         .       was added       .        set up
     *                         .                       .
     *           +---+         .         +---+         .         +---+
     *           |*,*|         .         |*,*|         .         |*,*|
     *           +---+         .         +---+         .         +---+
     *                         .         A             .         A   1
     *                         .         |             .         |   :
     *                         .         v             .         v   V
     *                         .     +---+             .     +---+   +---+
     *                         .     |A,*|             .     |A,*|   |*,1|
     *                         .     +---+             .     +---+   +---+
     *                         .     B                 .     B   1   A   2
     *                         .     |                 .     |   :   |   :
     *                         .     v                 .     v   v   v   v
     *                         . +---+                 . +---+   +---+   +---+
     *                         . |B,*|                 . |B,*|   |A,1|   |*,2|
     *                         . +---+                 . +---+   +---+   +---+
     *                         .     1                 .     1   B   2   A
     *                         .     :                 .     :   |   :   |
     *                         .     v                 .     v   v   v   v
     *                         .     +---+             .     +---+   +---+
     *                         .     |B,1|             .     |B,1|   |A,2|
     *                         .     +---+             .     +---+   +---+
     *                         .         2             .         2   B
     *                         .         :             .         :   |
     *                         .         v             .         v   V
     *                         .         +---+         .         +---+
     *                         .         |B,2|         .         |B,2|
     *                         .         +---+         .         +---+
     */
    setUpMissingChildRelationships_: function (node, firstDimensionToSetUp) {
      // Missing child relationships of this node wrt dimensions 0, ...,
      // (firstDimensionToSetUp - 1) and all descendants of the associated
      // children have already been set up. Now we do the same for dimensions
      // firstDimensionToSetUp, ..., (this.dimensions_ - 1).
      for (var d = firstDimensionToSetUp; d < this.dimensions_; d++) {
        // Step 1. Gather the names of all children wrt the current dimension.
        var currentDimensionChildTitles = new Set(node.children[d].keys());
        for (var i = 0; i < d; i++) {
          for (var previousDimensionChildNode of node.children[i].values()) {
            for (var previousDimensionGrandChildTitle of previousDimensionChildNode.children[d].keys()) {
              currentDimensionChildTitles.add(previousDimensionGrandChildTitle);
            }
          }
        }

        // Step 2. Add missing children wrt the current dimension and
        // recursively set up its missing child relationships.
        for (var currentDimensionChildTitle of currentDimensionChildTitles) {
          // Add a missing child (if it doesn't exist).
          var currentDimensionChildNode = this.getOrCreateChildNode_(node, d, currentDimensionChildTitle);

          // Set-up child relationships (of the child node) wrt dimensions 0,
          // ..., d - 1.
          for (var i = 0; i < d; i++) {
            for (var previousDimensionChildNode of node.children[i].values()) {
              var previousDimensionGrandChildNode = previousDimensionChildNode.children[d].get(currentDimensionChildTitle);
              if (previousDimensionGrandChildNode !== undefined) {
                currentDimensionChildNode.children[i].set(previousDimensionChildNode.title[i], previousDimensionGrandChildNode);
              }
            }
          }

          // Set-up child relationships (of the child node) wrt dimensions d,
          // ..., (this.dimensions_ - 1).
          this.setUpMissingChildRelationships_(currentDimensionChildNode, d);
        }
      }
    },

    /**
     * Finalize the total values of a multi-dimensional tree.
     *
     * The intermediate builder tree, a node of which we want to finalize
     * recursively, already has the right shape. The only thing that needs to
     * be done is to propagate self and total values from subsumed child nodes
     * in each dimension and update total value states appropriately.
     *
     * To derive the expression for the lower bound on the total value wrt
     * value index V (from 1 to |this.valueCount_| - 1), we rely on the
     * following assumptions:
     *
     *   1. Self/total values associated with different value indices are
     *      independent. From this point onwards, "self/total value" refers to
     *      self/total value wrt the fixed value index V.
     *
     *   2. Each node's self value does NOT overlap with the self or total value
     *      of any other node.
     *
     *   3. The total values of a node's children wrt a single dimension (e.g.
     *      [path1/A, path2] and [path1/B, path2]) do NOT overlap.
     *
     *   4. The total values of a node's children wrt different dimensions
     *      (e.g. [path1/A, path2] and [path1, path2/1]) MIGHT overlap.
     *
     * As a consequence of assumptions 1 and 3, the total value of a node can
     * be split into the part that cannot overlap (so-called "self-sum") and
     * the part that can overlap (so-called "residual"):
     *
     *   total(N, V) = selfSum(N, V) + residual(N, V)                   (A)
     *
     * where the self-sum is calculated as the sum of the node's self value
     * plus the sum of its descendants' self values (summed over all
     * dimensions):
     *
     *   selfSum(N, V) = self(N, V) + sum over all descendants C of N {
     *       self(C, V)                                                 (B)
     *   }
     *
     * Observe that the residual of a node does not include any self value (of
     * any node in the view). Furthermore, by assumption 2, we derive that the
     * residuals of a node's children wrt a single dimension don't overlap. On
     * the other hand, the residuals of a node's children wrt different
     * dimensions might overlap. This gives us the following lower bound on the
     * residual of a node:
     *
     *   residual(N, V) >= minResidual(N, V) = max over dimensions D {
     *       sum over children C of N at dimension D {
     *           residual(C, V)                                         (C)
     *       }
     *   })
     *
     * By combining equation (A) and inequality (C), we get a lower bound on
     * the total value of a node:
     *
     *   total(N, V) >= selfSum(N, V) + minResidual(N, V)
     *
     * For example, given a two-dimensional node [path1, path2] with self value
     * 10 and four children (2 wrt each dimension):
     *
     *    Child            | Self value | Total value
     *   ==================+============+=============
     *    [path1/A, path2] |         21 |          30
     *    [path1/B, path2] |         25 |          32
     *    [path1, path2/1] |         3  |          15
     *    [path1, path2/2] |         40 |          41
     *
     * and assuming that the children have no further descendants (i.e. their
     * residual values are equal to the differences between their total and
     * self values), the lower bound on the total value of [path1, path2] is:
     *
     *   total([path1, path2], 0)
     *       >= selfSum([path1, path2], 0) +
     *          minResidual([path1, path2], 0)
     *        = self([path1, path2], 0) +
     *          sum over all descendants C of [path1, path2] {
     *              self (C, 0)
     *          } +
     *          max over dimensions D {
     *              sum over children C of [path1, path2] at dimension D {
     *                  residual(C, 0)
     *              }
     *          }
     *        = self([path1, path2], 0) +
     *          ((self([path1/A, path2], 0) + self([path1/B, path2], 0)) +
     *           (self([path1, path2/1], 0) + self([path1, path2/2], 0))) +
     *          max(residual([path1/A, path2], 0) +
     *              residual([path1/B, path2], 0),
     *              residual([path1, path2/1], 0) +
     *              residual([path1, path2/2], 0))
     *        = 10 +
     *          ((21 + 25) + (3 + 40)) +
     *          max((30 - 21) + (32 - 25), (15 - 3) + (41 - 40))
     *        = 115
     *
     * To reduce the complexity of the calculation, we keep a temporary list of
     * dimensional self-sums for each node that we have already visited. For a
     * given node, the Kth element in the list is equal to the self size of the
     * node plus the sum of self sizes of all its descendants wrt dimensions 0
     * to K (inclusive). The list has two important properties:
     *
     *   1. The last element in the list is equal to the self-sum of the
     *      associated node (equation (B)).
     *
     *   2. The calculation of the list can be performed recursively using the
     *      lists of the associated node's children (avoids square complexity
     *      in the size of the graph):
     *
     *        dimensionalSelfSum(N, V)[D] =
     *            self(N, V) +
     *            sum I = 0 to D {
     *                sum over children C of N at dimension I {
     *                    dimensionalSelfSum(C, V)[I]
     *                }
     *            }
     *
     * This method also (recursively) ensures that, for each value index V, if
     * at least one of the descendants C of node N has at least a LOWER_BOUND
     * on total(C, V), then the N will also be marked as having a LOWER_BOUND
     * on total(N, V) (unless N contains the EXACT value of total(N, V), in
     * which case its relevant totalState won't be modified).
     */
    finalizeTotalValues_: function (node, firstDimensionToFinalize, dimensionalSelfSumsMap) {
      // Dimension D -> Value index V -> dimensionalSelfSum(|node|, V)[D].
      var dimensionalSelfSums = new Array(this.dimensions_);

      // Value index V -> minResidual(|node|, V).
      var minResidual = new Array(this.valueCount_);
      for (var v = 0; v < this.valueCount_; v++) minResidual[v] = 0;

      // Value index V -> |node| value V.
      var nodeValues = node.values;

      // Value index V -> dimensionalSelfSum(|node|, V)[|d|].
      var nodeSelfSums = new Array(this.valueCount_);
      for (var v = 0; v < this.valueCount_; v++) nodeSelfSums[v] = nodeValues[v].self;

      for (var d = 0; d < this.dimensions_; d++) {
        // Value index V -> sum over children C of |node| at dimension |d| {
        // residual(C, V) }.
        var childResidualSums = new Array(this.valueCount_);
        for (var v = 0; v < this.valueCount_; v++) childResidualSums[v] = 0;

        for (var childNode of node.children[d].values()) {
          if (d >= firstDimensionToFinalize) this.finalizeTotalValues_(childNode, d, dimensionalSelfSumsMap);
          // Dimension D -> Value index V ->
          // dimensionalSelfSum(|childNode|, V)[D].
          var childNodeSelfSums = dimensionalSelfSumsMap.get(childNode);
          var childNodeValues = childNode.values;
          for (var v = 0; v < this.valueCount_; v++) {
            nodeSelfSums[v] += childNodeSelfSums[d][v];
            var residual = childNodeValues[v].total - childNodeSelfSums[this.dimensions_ - 1][v];
            childResidualSums[v] += residual;
            if (childNodeValues[v].totalState > NOT_PROVIDED) {
              nodeValues[v].totalState = Math.max(nodeValues[v].totalState, LOWER_BOUND);
            }
          }
        }

        dimensionalSelfSums[d] = nodeSelfSums.slice();
        for (var v = 0; v < this.valueCount_; v++) minResidual[v] = Math.max(minResidual[v], childResidualSums[v]);
      }

      for (var v = 0; v < this.valueCount_; v++) {
        nodeValues[v].total = Math.max(nodeValues[v].total, nodeSelfSums[v] + minResidual[v]);
      }

      if (dimensionalSelfSumsMap.has(node)) throw new Error('Internal error: Node finalized more than once');
      dimensionalSelfSumsMap.set(node, dimensionalSelfSums);
    },

    /**
     * Build a generic heavy view of the multi-dimensional view.
     */
    buildGenericHeavyView_: function (treeViewNodeHandler) {
      // 1. Clone the root node of the top-down tree view node (except
      // children).
      var treeViewRoot = this.buildTopDownTreeView();
      var heavyViewRoot = this.createRootNode_();
      heavyViewRoot.values = treeViewRoot.values;

      // 2. Create recursion depth trackers (to avoid total value
      // double-counting).
      var recursionDepthTrackers = new Array(this.dimensions_);
      for (var d = 0; d < this.dimensions_; d++) {
        recursionDepthTrackers[d] = new RecursionDepthTracker(this.maxDimensionDepths_[d], d);
      }

      // 3. Add all paths associated with the single-dimensional descendants of
      // the top-down tree view root node to the heavy view root node
      // (depending on the type of the target heavy view).
      this.addDimensionsToGenericHeavyViewNode_(treeViewRoot, heavyViewRoot, 0 /* startDimension */, recursionDepthTrackers, false /* previousDimensionsRecursive */, treeViewNodeHandler);

      // 4. Set up missing child relationships.
      this.setUpMissingChildRelationships_(heavyViewRoot, 0 /* firstDimensionToSetUp */);

      return heavyViewRoot;
    },

    /**
     * Add all paths associated with the single-dimensional descendants of a
     * top-down tree-view node wrt multiple dimensions to a generic heavy-view
     * node (depending on the type of the target heavy view).
     */
    addDimensionsToGenericHeavyViewNode_: function (treeViewParentNode, heavyViewParentNode, startDimension, recursionDepthTrackers, previousDimensionsRecursive, treeViewNodeHandler) {
      for (var d = startDimension; d < this.dimensions_; d++) {
        this.addDimensionDescendantsToGenericHeavyViewNode_(treeViewParentNode, heavyViewParentNode, d, recursionDepthTrackers, previousDimensionsRecursive, treeViewNodeHandler);
      }
    },

    /**
     * Add all paths associated with the descendants of a top-down tree-view
     * node wrt a single dimension to a generic heavy-view node (depending on
     * the type of the target heavy view).
     */
    addDimensionDescendantsToGenericHeavyViewNode_: function (treeViewParentNode, heavyViewParentNode, currentDimension, recursionDepthTrackers, previousDimensionsRecursive, treeViewNodeHandler) {
      var treeViewChildren = treeViewParentNode.children[currentDimension];
      var recursionDepthTracker = recursionDepthTrackers[currentDimension];
      for (var treeViewChildNode of treeViewChildren.values()) {
        recursionDepthTracker.push(treeViewChildNode);

        // Add all paths associated with the child node to the heavy view-node
        // parent node.
        treeViewNodeHandler(treeViewChildNode, heavyViewParentNode, currentDimension, recursionDepthTrackers, previousDimensionsRecursive);

        // Recursively add all paths associated with the descendants of the
        // tree view child node wrt the current dimension to the heavy-view
        // parent node.
        this.addDimensionDescendantsToGenericHeavyViewNode_(treeViewChildNode, heavyViewParentNode, currentDimension, recursionDepthTrackers, previousDimensionsRecursive, treeViewNodeHandler);

        recursionDepthTracker.pop();
      }
    },

    /**
     * Add a top-down tree-view child node together with its single-dimensional
     * subtree to a top-down heavy-view parent node (tree-view node handler for
     * top-down heavy view).
     *
     * Sample resulting top-down heavy view:
     *
     *       +----------------+                    +-----------------+
     *       |     source     |                    |   destination   |
     *       | tree-view root |  ===============>  | heavy-view root |
     *       |     self=0     |                    |     self=0      |
     *       |    total=48    |                    |    total=48     |
     *       +----------------+                    +-----------------+
     *         |            |                  ______|      |      |______
     *         v            v                 v             v             v
     *    +----------+ +----------+      +----------+ +----------+ +----------+
     *    |    A*    | |    B     |      |    A***  | |    B     | |    C     |
     *    | self=10  | | self=12  |      | self=13  | | self=13  | | self=2   |
     *    | total=30 | | total=18 |      | total=30 | | total=34 | | total=7  |
     *    +----------+ +----------+      +----------+ +----------+ +----------+
     *         |                              :            :   :.........
     *         v                              v            v            v
     *    +----------+                   ............ ............ ............
     *    |    B     |                   :    B     : :    A     : :    C     :
     *    | self=1   |                   : self=1   : : self=3   : : self=2   :
     *    | total=16 |                   : total=16 : : total=8  : : total=7  :
     *    +----------+                   ............ ............ ............
     *         |   |________                  :   :.........
     *         v            v                 v            v
     *    +----------+ +----------+      ............ ............
     *    |    A**   | |    C     |      :    A     : :    C     :
     *    | self=3   | | self=2   |      : self=3   : : self=2   :
     *    | total=8  | | total=7  |      : total=8  : : total=7  :
     *    +----------+ +----------+      ............ ............
     *
     * Observe that care needs to be taken when dealing with recursion to avoid
     * double-counting, e.g. the total value of A** (8) was not added to the
     * total value of A*** (30) because it is already included in the total
     * value of A* (30) (which was also added to A***). That is why we need to
     * keep track of the path we traversed along the current dimension (to
     * determine whether total value should be added or not).
     */
    addDimensionToTopDownHeavyViewNode_: function (treeViewChildNode, heavyViewParentNode, currentDimension, recursionDepthTrackers, previousDimensionsRecursive) {
      this.addDimensionToTopDownHeavyViewNodeRecursively_(treeViewChildNode, heavyViewParentNode, currentDimension, recursionDepthTrackers, previousDimensionsRecursive, 1 /* subTreeDepth */);
    },

    addDimensionToTopDownHeavyViewNodeRecursively_: function (treeViewChildNode, heavyViewParentNode, currentDimension, recursionDepthTrackers, previousDimensionsRecursive, subTreeDepth) {
      var recursionDepthTracker = recursionDepthTrackers[currentDimension];
      var currentDimensionRecursive = subTreeDepth <= recursionDepthTracker.recursionDepth;
      var currentOrPreviousDimensionsRecursive = currentDimensionRecursive || previousDimensionsRecursive;

      var dimensionTitle = treeViewChildNode.title[currentDimension];
      var heavyViewChildNode = this.getOrCreateChildNode_(heavyViewParentNode, currentDimension, dimensionTitle);

      this.addNodeValues_(treeViewChildNode, heavyViewChildNode, !currentOrPreviousDimensionsRecursive /* addTotal */);

      // Add the descendants of the tree-view child node wrt the next
      // dimensions as children of the heavy-view child node.
      this.addDimensionsToGenericHeavyViewNode_(treeViewChildNode, heavyViewChildNode, currentDimension + 1, recursionDepthTrackers, currentOrPreviousDimensionsRecursive, this.addDimensionToTopDownHeavyViewNode_.bind(this));

      for (var treeViewGrandChildNode of treeViewChildNode.children[currentDimension].values()) {
        recursionDepthTracker.push(treeViewGrandChildNode);

        // Recursively add the tree-view grandchild node to the heavy-view
        // child node.
        this.addDimensionToTopDownHeavyViewNodeRecursively_(treeViewGrandChildNode, heavyViewChildNode, currentDimension, recursionDepthTrackers, previousDimensionsRecursive, subTreeDepth + 1);

        recursionDepthTracker.pop();
      }
    },

    /**
     * Add a top-down tree-view child node together with all its ancestors wrt
     * the given dimension as descendants of a bottom-up heavy-view parent node
     * in the reverse order (tree-view node handler for bottom-up heavy view).
     *
     * Sample resulting bottom-up heavy view:
     *
     *       +----------------+                    +-----------------+
     *       |     source     |                    |   destination   |
     *       | tree-view root |  ===============>  | heavy-view root |
     *       |     self=0     |                    |     self=0      |
     *       |    total=48    |                    |    total=48     |
     *       +----------------+                    +-----------------+
     *         |            |                  ______|      |      |______
     *         v            v                 v             v             v
     *    +----------+ +----------+      +----------+ +----------+ +----------+
     *    |    A*    | |    B     |      |    A***  | |    B     | |    C     |
     *    | self=10  | | self=12  |      | self=13  | | self=13  | | self=2   |
     *    | total=30 | | total=18 |      | total=30 | | total=34 | | total=7  |
     *    +----------+ +----------+      +----------+ +----------+ +----------+
     *         |                              :            :            :
     *         v                              v            v            v
     *    +----------+                   ............ ............ ............
     *    |    B#    |                   :    B     : :    A     : :    B##   :
     *    | self=1   |                   : self=3   : : self=1   : : self=2   :
     *    | total=16 |                   : total=8  : : total=16 : : total=7  :
     *    +----------+                   ............ ............ ............
     *         |   |________                  :                         :
     *         v            v                 v                         v
     *    +----------+ +----------+      ............              ............
     *    |    A**   | |    C     |      :    A     :              :    A     :
     *    | self=3   | | self=2   |      : self=3   :              : self=2   :
     *    | total=8  | | total=7  |      : total=8  :              : total=7  :
     *    +----------+ +----------+      ............              ............
     *
     * Similarly to the construction of the top-down heavy view, care needs to
     * be taken when dealing with recursion to avoid double-counting, e.g. the
     * total value of A** (8) was not added to the total value of A*** (30)
     * because it is already included in the total value of A* (30) (which was
     * also added to A***). That is why we need to keep track of the path we
     * traversed along the current dimension (to determine whether total value
     * should be added or not).
     *
     * Note that when we add an ancestor (B#) of a top-down tree-view node (C)
     * to the bottom-up heavy view, the values of the original tree-view node
     * (C) (rather than the ancestor's values) are added to the corresponding
     * heavy-view node (B##).
     */
    addDimensionToBottomUpHeavyViewNode_: function (treeViewChildNode, heavyViewParentNode, currentDimension, recursionDepthTrackers, previousDimensionsRecursive) {
      var recursionDepthTracker = recursionDepthTrackers[currentDimension];
      var bottomIndex = recursionDepthTracker.bottomIndex;
      var topIndex = recursionDepthTracker.topIndex;
      var firstNonRecursiveIndex = bottomIndex + recursionDepthTracker.recursionDepth;
      var viewNodePath = recursionDepthTracker.viewNodePath;

      var trackerAncestorNode = recursionDepthTracker.trackerAncestorNode;
      var heavyViewDescendantNode = heavyViewParentNode;
      for (var i = bottomIndex; i < topIndex; i++) {
        var treeViewAncestorNode = viewNodePath[i];
        var dimensionTitle = treeViewAncestorNode.title[currentDimension];
        heavyViewDescendantNode = this.getOrCreateChildNode_(heavyViewDescendantNode, currentDimension, dimensionTitle);

        var currentDimensionRecursive = i < firstNonRecursiveIndex;
        var currentOrPreviousDimensionsRecursive = currentDimensionRecursive || previousDimensionsRecursive;

        // The self and total values are taken from the original top-down tree
        // view child node (rather than the ancestor node).
        this.addNodeValues_(treeViewChildNode, heavyViewDescendantNode, !currentOrPreviousDimensionsRecursive);

        // Add the descendants of the tree-view child node wrt the next
        // dimensions as children of the heavy-view child node.
        this.addDimensionsToGenericHeavyViewNode_(treeViewChildNode, heavyViewDescendantNode, currentDimension + 1, recursionDepthTrackers, currentOrPreviousDimensionsRecursive, this.addDimensionToBottomUpHeavyViewNode_.bind(this));
      }
    },

    addNodeValues_: function (sourceNode, targetNode, addTotal) {
      var targetNodeValues = targetNode.values;
      var sourceNodeValues = sourceNode.values;
      for (var v = 0; v < this.valueCount_; v++) {
        var targetNodeValue = targetNodeValues[v];
        var sourceNodeValue = sourceNodeValues[v];
        targetNodeValue.self += sourceNodeValue.self;
        if (addTotal) {
          targetNodeValue.total += sourceNodeValue.total;
          if (sourceNodeValue.totalState > NOT_PROVIDED) {
            targetNodeValue.totalState = Math.max(targetNodeValue.totalState, LOWER_BOUND);
          }
        }
      }
    }
  };

  /**
   * Recursion depth tracker.
   *
   * This class tracks the recursion depth of the current stack (updated via
   * the push and pop methods). The recursion depth of a stack is the lengh of
   * its longest leaf suffix that is repeated within the stack itself.
   *
   * For example, the recursion depth of the stack A -> B -> C -> A -> B -> B
   * -> C (where C is the leaf node) is 2 because the suffix B -> C is repeated
   * within it.
   *
   * @{constructor}
   */
  function RecursionDepthTracker(maxDepth, dimension) {
    this.titlePath = new Array(maxDepth);
    this.viewNodePath = new Array(maxDepth);
    this.bottomIndex = this.topIndex = maxDepth;

    this.dimension_ = dimension;
    this.currentTrackerNode_ = this.createNode_(0 /* recursionDepth */, undefined /* parent */);
  }

  RecursionDepthTracker.prototype = {
    push: function (viewNode) {
      if (this.bottomIndex === 0) throw new Error('Cannot push to a full tracker');
      var title = viewNode.title[this.dimension_];
      this.bottomIndex--;
      this.titlePath[this.bottomIndex] = title;
      this.viewNodePath[this.bottomIndex] = viewNode;

      var childTrackerNode = this.currentTrackerNode_.children.get(title);
      if (childTrackerNode !== undefined) {
        // Child node already exists, so we don't need to calculate anything.
        this.currentTrackerNode_ = childTrackerNode;
        return;
      }

      // Child node doesn't exist yet, so we need to calculate its recursion
      // depth.
      var maxLengths = zFunction(this.titlePath, this.bottomIndex);
      var recursionDepth = 0;
      for (var i = 0; i < maxLengths.length; i++) recursionDepth = Math.max(recursionDepth, maxLengths[i]);

      childTrackerNode = this.createNode_(recursionDepth, this.currentTrackerNode_);
      this.currentTrackerNode_.children.set(title, childTrackerNode);
      this.currentTrackerNode_ = childTrackerNode;
    },

    pop: function () {
      if (this.bottomIndex === this.topIndex) throw new Error('Cannot pop from an empty tracker');

      this.titlePath[this.bottomIndex] = undefined;
      this.viewNodePath[this.bottomIndex] = undefined;
      this.bottomIndex++;

      this.currentTrackerNode_ = this.currentTrackerNode_.parent;
    },

    get recursionDepth() {
      return this.currentTrackerNode_.recursionDepth;
    },

    createNode_: function (recursionDepth, parent) {
      return {
        recursionDepth: recursionDepth,
        parent: parent,
        children: new Map()
      };
    }
  };

  /**
   * Calculate the Z-function of (a suffix of) a list.
   *
   * Z-function: Given a list (or a string) of length n, for each index i from
   * 1 to n - 1, find the length z[i] of the longest substring starting at
   * position i which is also a prefix of the list. This function returns the
   * list of maximum lengths z.
   *
   * Mathematically, for each i from 1 to n - 1, z[i] is the maximum value such
   * that [list[0], ..., list[i - 1]] = [list[i], ..., list[i + z[i] - 1]].
   * z[0] is defined to be zero for convenience.
   *
   * Example:
   *
   *   Input (list): ['A', 'B', 'A', 'C', 'A', 'B', 'A']
   *   Output (z):   [ 0 ,  0 ,  1 ,  0 ,  3 ,  0 ,  1 ]
   *
   * Unlike the brute-force approach (which is O(n^2) in the worst case), the
   * complexity of this implementation is linear in the size of the list, i.e.
   * O(n).
   *
   * Source: http://e-maxx-eng.github.io/string/z-function.html
   */
  function zFunction(list, startIndex) {
    var n = list.length - startIndex;
    if (n === 0) return [];

    var z = new Array(n);
    z[0] = 0;

    for (var i = 1, left = 0, right = 0; i < n; ++i) {
      var maxLength;
      if (i <= right) maxLength = Math.min(right - i + 1, z[i - left]);else maxLength = 0;

      while (i + maxLength < n && list[startIndex + maxLength] === list[startIndex + i + maxLength]) {
        ++maxLength;
      }

      if (i + maxLength - 1 > right) {
        left = i;
        right = i + maxLength - 1;
      }

      z[i] = maxLength;
    }

    return z;
  }

  return {
    MultiDimensionalViewBuilder: MultiDimensionalViewBuilder,
    MultiDimensionalViewNode: MultiDimensionalViewNode,

    // Exports below are for testing only.
    RecursionDepthTracker: RecursionDepthTracker,
    zFunction: zFunction
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],44:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var PERCENTILE_PRECISION = 1e-7;
  /**
   * A function that consists of linear pieces.
   * See https://en.wikipedia.org/wiki/Piecewise_linear_function.
   * @constructor
   */
  function PiecewiseLinearFunction() {
    this.pieces = [];
  }

  PiecewiseLinearFunction.prototype = {
    /**
     * Push a linear piece defined by linear interpolation between.
     * (x1, y1) and (x2, y2).
     * Pieces must be pushed in the order of increasing x coordinate.
     */
    push: function (x1, y1, x2, y2) {
      if (x1 >= x2) throw new Error('Invalid segment');
      if (this.pieces.length > 0 && this.pieces[this.pieces.length - 1].x2 > x1) {
        throw new Error('Potentially overlapping segments');
      }
      if (x1 < x2) this.pieces.push(new Piece(x1, y1, x2, y2));
    },

    /**
     *  Returns the size of the set A such that for all x in A: f(x) < y.
     */
    partBelow: function (y) {
      return this.pieces.reduce((acc, p) => acc + p.partBelow(y), 0);
    },

    get min() {
      return this.pieces.reduce((acc, p) => Math.min(acc, p.min), Infinity);
    },

    get max() {
      return this.pieces.reduce((acc, p) => Math.max(acc, p.max), -Infinity);
    },

    get average() {
      var weightedSum = 0;
      var totalWeight = 0;
      this.pieces.forEach(function (piece) {
        weightedSum += piece.width * piece.average;
        totalWeight += piece.width;
      });
      if (totalWeight === 0) return 0;
      return weightedSum / totalWeight;
    },

    /**
    * Returns the minimum possible value y such that the percentage of x points
    * that have f(x) <= y is approximately equal to the given |percent|.
    */
    percentile: function (percent) {
      if (!(percent >= 0 && percent <= 1)) throw new Error('percent must be [0,1]');
      var lower = this.min;
      var upper = this.max;
      var total = this.partBelow(upper);
      if (total === 0) return 0;
      while (upper - lower > PERCENTILE_PRECISION) {
        var middle = (lower + upper) / 2;
        var below = this.partBelow(middle);
        if (below / total < percent) lower = middle;else upper = middle;
      }
      return (lower + upper) / 2;
    }
  };

  /**
  * A linear segment from (x1, y1) to (x2, y2).
  * @constructor
  */
  function Piece(x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }

  Piece.prototype = {
    /**
    * The total length of all x points such that f(x) < y.
    * More formally:
    * max(x2 - x1) such that for all x in [x1 .. x2]: f(x) < y.
    */
    partBelow: function (y) {
      var width = this.width;
      if (width === 0) return 0;
      var minY = this.min;
      var maxY = this.max;
      if (y >= maxY) return width;
      if (y < minY) return 0;
      return (y - minY) / (maxY - minY) * width;
    },

    get min() {
      return Math.min(this.y1, this.y2);
    },

    get max() {
      return Math.max(this.y1, this.y2);
    },

    get average() {
      return (this.y1 + this.y2) / 2;
    },

    get width() {
      return this.x2 - this.x1;
    }
  };

  return {
    PiecewiseLinearFunction: PiecewiseLinearFunction
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],45:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");
require("./math.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var tmpVec2s = [];
  for (var i = 0; i < 8; i++) tmpVec2s[i] = vec2.create();

  var tmpVec2a = vec4.create();
  var tmpVec4a = vec4.create();
  var tmpVec4b = vec4.create();
  var tmpMat4 = mat4.create();
  var tmpMat4b = mat4.create();

  var p00 = vec2.createXY(0, 0);
  var p10 = vec2.createXY(1, 0);
  var p01 = vec2.createXY(0, 1);
  var p11 = vec2.createXY(1, 1);

  var lerpingVecA = vec2.create();
  var lerpingVecB = vec2.create();
  function lerpVec2(out, a, b, amt) {
    vec2.scale(lerpingVecA, a, amt);
    vec2.scale(lerpingVecB, b, 1 - amt);
    vec2.add(out, lerpingVecA, lerpingVecB);
    vec2.normalize(out, out);
    return out;
  }

  /**
   * @constructor
   */
  function Quad() {
    this.p1 = vec2.create();
    this.p2 = vec2.create();
    this.p3 = vec2.create();
    this.p4 = vec2.create();
  }

  Quad.fromXYWH = function (x, y, w, h) {
    var q = new Quad();
    vec2.set(q.p1, x, y);
    vec2.set(q.p2, x + w, y);
    vec2.set(q.p3, x + w, y + h);
    vec2.set(q.p4, x, y + h);
    return q;
  };

  Quad.fromRect = function (r) {
    return new Quad.fromXYWH(r.x, r.y, r.width, r.height);
  };

  Quad.from4Vecs = function (p1, p2, p3, p4) {
    var q = new Quad();
    vec2.set(q.p1, p1[0], p1[1]);
    vec2.set(q.p2, p2[0], p2[1]);
    vec2.set(q.p3, p3[0], p3[1]);
    vec2.set(q.p4, p4[0], p4[1]);
    return q;
  };

  Quad.from8Array = function (arr) {
    if (arr.length != 8) throw new Error('Array must be 8 long');
    var q = new Quad();
    q.p1[0] = arr[0];
    q.p1[1] = arr[1];
    q.p2[0] = arr[2];
    q.p2[1] = arr[3];
    q.p3[0] = arr[4];
    q.p3[1] = arr[5];
    q.p4[0] = arr[6];
    q.p4[1] = arr[7];
    return q;
  };

  Quad.prototype = {
    pointInside: function (point) {
      return pointInImplicitQuad(point, this.p1, this.p2, this.p3, this.p4);
    },

    boundingRect: function () {
      var x0 = Math.min(this.p1[0], this.p2[0], this.p3[0], this.p4[0]);
      var y0 = Math.min(this.p1[1], this.p2[1], this.p3[1], this.p4[1]);

      var x1 = Math.max(this.p1[0], this.p2[0], this.p3[0], this.p4[0]);
      var y1 = Math.max(this.p1[1], this.p2[1], this.p3[1], this.p4[1]);

      return new tr.b.Rect.fromXYWH(x0, y0, x1 - x0, y1 - y0);
    },

    clone: function () {
      var q = new Quad();
      vec2.copy(q.p1, this.p1);
      vec2.copy(q.p2, this.p2);
      vec2.copy(q.p3, this.p3);
      vec2.copy(q.p4, this.p4);
      return q;
    },

    scale: function (s) {
      var q = new Quad();
      this.scaleFast(q, s);
      return q;
    },

    scaleFast: function (dstQuad, s) {
      vec2.copy(dstQuad.p1, this.p1, s);
      vec2.copy(dstQuad.p2, this.p2, s);
      vec2.copy(dstQuad.p3, this.p3, s);
      vec2.copy(dstQuad.p3, this.p3, s);
    },

    isRectangle: function () {
      // Simple rectangle check. Note: will not handle out-of-order components.
      var bounds = this.boundingRect();
      return bounds.x == this.p1[0] && bounds.y == this.p1[1] && bounds.width == this.p2[0] - this.p1[0] && bounds.y == this.p2[1] && bounds.width == this.p3[0] - this.p1[0] && bounds.height == this.p3[1] - this.p2[1] && bounds.x == this.p4[0] && bounds.height == this.p4[1] - this.p2[1];
    },

    projectUnitRect: function (rect) {
      var q = new Quad();
      this.projectUnitRectFast(q, rect);
      return q;
    },

    projectUnitRectFast: function (dstQuad, rect) {
      var v12 = tmpVec2s[0];
      var v14 = tmpVec2s[1];
      var v23 = tmpVec2s[2];
      var v43 = tmpVec2s[3];
      var l12, l14, l23, l43;

      vec2.sub(v12, this.p2, this.p1);
      l12 = vec2.length(v12);
      vec2.scale(v12, v12, 1 / l12);

      vec2.sub(v14, this.p4, this.p1);
      l14 = vec2.length(v14);
      vec2.scale(v14, v14, 1 / l14);

      vec2.sub(v23, this.p3, this.p2);
      l23 = vec2.length(v23);
      vec2.scale(v23, v23, 1 / l23);

      vec2.sub(v43, this.p3, this.p4);
      l43 = vec2.length(v43);
      vec2.scale(v43, v43, 1 / l43);

      var b12 = tmpVec2s[0];
      var b14 = tmpVec2s[1];
      var b23 = tmpVec2s[2];
      var b43 = tmpVec2s[3];
      lerpVec2(b12, v12, v43, rect.y);
      lerpVec2(b43, v12, v43, 1 - rect.bottom);
      lerpVec2(b14, v14, v23, rect.x);
      lerpVec2(b23, v14, v23, 1 - rect.right);

      vec2.addTwoScaledUnitVectors(tmpVec2a, b12, l12 * rect.x, b14, l14 * rect.y);
      vec2.add(dstQuad.p1, this.p1, tmpVec2a);

      vec2.addTwoScaledUnitVectors(tmpVec2a, b12, l12 * -(1.0 - rect.right), b23, l23 * rect.y);
      vec2.add(dstQuad.p2, this.p2, tmpVec2a);

      vec2.addTwoScaledUnitVectors(tmpVec2a, b43, l43 * -(1.0 - rect.right), b23, l23 * -(1.0 - rect.bottom));
      vec2.add(dstQuad.p3, this.p3, tmpVec2a);

      vec2.addTwoScaledUnitVectors(tmpVec2a, b43, l43 * rect.left, b14, l14 * -(1.0 - rect.bottom));
      vec2.add(dstQuad.p4, this.p4, tmpVec2a);
    },

    toString: function () {
      return 'Quad(' + vec2.toString(this.p1) + ', ' + vec2.toString(this.p2) + ', ' + vec2.toString(this.p3) + ', ' + vec2.toString(this.p4) + ')';
    }
  };

  function sign(p1, p2, p3) {
    return (p1[0] - p3[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p3[1]);
  }

  function pointInTriangle2(pt, p1, p2, p3) {
    var b1 = sign(pt, p1, p2) < 0.0;
    var b2 = sign(pt, p2, p3) < 0.0;
    var b3 = sign(pt, p3, p1) < 0.0;
    return b1 == b2 && b2 == b3;
  }

  function pointInImplicitQuad(point, p1, p2, p3, p4) {
    return pointInTriangle2(point, p1, p2, p3) || pointInTriangle2(point, p1, p3, p4);
  }

  return {
    pointInTriangle2: pointInTriangle2,
    pointInImplicitQuad: pointInImplicitQuad,
    Quad: Quad
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28,"./math.js":42}],46:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./utils.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var ESTIMATED_IDLE_PERIOD_LENGTH_MILLISECONDS = 10;
  // The maximum amount of time that we allow for a task to get scheduled
  // in idle time before forcing the task to run.
  var REQUEST_IDLE_CALLBACK_TIMEOUT_MILLISECONDS = 100;

  // Setting this to true will cause stack traces to get dumped into the
  // tasks. When an exception happens the original stack will be printed.
  //
  // NOTE: This should never be set committed as true.
  var recordRAFStacks = false;

  var pendingPreAFs = [];
  var pendingRAFs = [];
  var pendingIdleCallbacks = [];
  var currentRAFDispatchList = undefined;

  var rafScheduled = false;
  var idleWorkScheduled = false;

  function scheduleRAF() {
    if (rafScheduled) return;
    rafScheduled = true;
    if (tr.isHeadless) {
      Promise.resolve().then(function () {
        processRequests(false, 0);
      }, function (e) {
        console.log(e.stack);
        throw e;
      });
    } else {
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(processRequests.bind(this, false));
      } else {
        var delta = Date.now() - window.performance.now();
        window.webkitRequestAnimationFrame(function (domTimeStamp) {
          processRequests(false, domTimeStamp - delta);
        });
      }
    }
  }

  function nativeRequestIdleCallbackSupported() {
    return !tr.isHeadless && window.requestIdleCallback;
  }

  function scheduleIdleWork() {
    if (idleWorkScheduled) return;
    if (!nativeRequestIdleCallbackSupported()) {
      scheduleRAF();
      return;
    }
    idleWorkScheduled = true;
    window.requestIdleCallback(function (deadline, didTimeout) {
      processIdleWork(false /* forceAllTasksToRun */, deadline);
    }, { timeout: REQUEST_IDLE_CALLBACK_TIMEOUT_MILLISECONDS });
  }

  function onAnimationFrameError(e, opt_stack) {
    console.log(e.stack);
    if (tr.isHeadless) throw e;

    if (opt_stack) console.log(opt_stack);

    if (e.message) console.error(e.message, e.stack);else console.error(e);
  }

  function runTask(task, frameBeginTime) {
    try {
      task.callback.call(task.context, frameBeginTime);
    } catch (e) {
      tr.b.onAnimationFrameError(e, task.stack);
    }
  }

  function processRequests(forceAllTasksToRun, frameBeginTime) {
    rafScheduled = false;

    var currentPreAFs = pendingPreAFs;
    currentRAFDispatchList = pendingRAFs;
    pendingPreAFs = [];
    pendingRAFs = [];
    var hasRAFTasks = currentPreAFs.length || currentRAFDispatchList.length;

    for (var i = 0; i < currentPreAFs.length; i++) runTask(currentPreAFs[i], frameBeginTime);

    while (currentRAFDispatchList.length > 0) runTask(currentRAFDispatchList.shift(), frameBeginTime);
    currentRAFDispatchList = undefined;

    if (!hasRAFTasks && !nativeRequestIdleCallbackSupported() || forceAllTasksToRun) {
      // We assume that we want to do a fixed maximum amount of optional work
      // per frame. Hopefully rAF will eventually pass this in for us.
      var rafCompletionDeadline = frameBeginTime + ESTIMATED_IDLE_PERIOD_LENGTH_MILLISECONDS;
      processIdleWork(forceAllTasksToRun, {
        timeRemaining: function () {
          return rafCompletionDeadline - window.performance.now();
        }
      });
    }

    if (pendingIdleCallbacks.length > 0) scheduleIdleWork();
  }

  function processIdleWork(forceAllTasksToRun, deadline) {
    idleWorkScheduled = false;
    while (pendingIdleCallbacks.length > 0) {
      runTask(pendingIdleCallbacks.shift());
      // Check timer after running at least one idle task to avoid buggy
      // window.performance.now() on some platforms from blocking the idle
      // task queue.
      if (!forceAllTasksToRun && (tr.isHeadless || deadline.timeRemaining() <= 0)) {
        break;
      }
    }

    if (pendingIdleCallbacks.length > 0) scheduleIdleWork();
  }

  function getStack_() {
    if (!recordRAFStacks) return '';

    var stackLines = tr.b.stackTrace();
    // Strip off getStack_.
    stackLines.shift();
    return stackLines.join('\n');
  }

  function requestPreAnimationFrame(callback, opt_this) {
    pendingPreAFs.push({
      callback: callback,
      context: opt_this || global,
      stack: getStack_() });
    scheduleRAF();
  }

  function requestAnimationFrameInThisFrameIfPossible(callback, opt_this) {
    if (!currentRAFDispatchList) {
      requestAnimationFrame(callback, opt_this);
      return;
    }
    currentRAFDispatchList.push({
      callback: callback,
      context: opt_this || global,
      stack: getStack_() });
    return;
  }

  function requestAnimationFrame(callback, opt_this) {
    pendingRAFs.push({
      callback: callback,
      context: opt_this || global,
      stack: getStack_() });
    scheduleRAF();
  }

  function requestIdleCallback(callback, opt_this) {
    pendingIdleCallbacks.push({
      callback: callback,
      context: opt_this || global,
      stack: getStack_() });
    scheduleIdleWork();
  }

  function forcePendingRAFTasksToRun(frameBeginTime) {
    if (!rafScheduled) return;
    processRequests(false, frameBeginTime);
  }

  function forceAllPendingTasksToRunForTest() {
    if (!rafScheduled && !idleWorkScheduled) return;
    processRequests(true, 0);
  }

  return {
    onAnimationFrameError: onAnimationFrameError,
    requestPreAnimationFrame: requestPreAnimationFrame,
    requestAnimationFrame: requestAnimationFrame,
    requestAnimationFrameInThisFrameIfPossible: requestAnimationFrameInThisFrameIfPossible,
    requestIdleCallback: requestIdleCallback,
    forcePendingRAFTasksToRun: forcePendingRAFTasksToRun,
    forceAllPendingTasksToRunForTest: forceAllPendingTasksToRunForTest
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils.js":59}],47:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");
require("./iteration_helpers.js");
require("./math.js");

'use strict';

/**
 * @fileoverview Quick range computations.
 */
global.tr.exportTo('tr.b', function () {

  function Range() {
    this.isEmpty_ = true;
    this.min_ = undefined;
    this.max_ = undefined;
  }

  Range.prototype = {
    __proto__: Object.prototype,

    reset: function () {
      this.isEmpty_ = true;
      this.min_ = undefined;
      this.max_ = undefined;
    },

    get isEmpty() {
      return this.isEmpty_;
    },

    addRange: function (range) {
      if (range.isEmpty) return;
      this.addValue(range.min);
      this.addValue(range.max);
    },

    addValue: function (value) {
      if (this.isEmpty_) {
        this.max_ = value;
        this.min_ = value;
        this.isEmpty_ = false;
        return;
      }
      this.max_ = Math.max(this.max_, value);
      this.min_ = Math.min(this.min_, value);
    },

    set min(min) {
      this.isEmpty_ = false;
      this.min_ = min;
    },

    get min() {
      if (this.isEmpty_) return undefined;
      return this.min_;
    },

    get max() {
      if (this.isEmpty_) return undefined;
      return this.max_;
    },

    set max(max) {
      this.isEmpty_ = false;
      this.max_ = max;
    },

    get range() {
      if (this.isEmpty_) return undefined;
      return this.max_ - this.min_;
    },

    get center() {
      return (this.min_ + this.max_) * 0.5;
    },

    get duration() {
      if (this.isEmpty_) return 0;
      return this.max_ - this.min_;
    },

    normalize: function (x) {
      return tr.b.normalize(x, this.min, this.max);
    },

    lerp: function (x) {
      return tr.b.lerp(x, this.min, this.max);
    },

    equals: function (that) {
      if (this.isEmpty && that.isEmpty) return true;
      if (this.isEmpty != that.isEmpty) return false;
      return tr.b.approximately(this.min, that.min) && tr.b.approximately(this.max, that.max);
    },

    containsExplicitRangeInclusive: function (min, max) {
      if (this.isEmpty) return false;
      return this.min_ <= min && max <= this.max_;
    },

    containsExplicitRangeExclusive: function (min, max) {
      if (this.isEmpty) return false;
      return this.min_ < min && max < this.max_;
    },

    intersectsExplicitRangeInclusive: function (min, max) {
      if (this.isEmpty) return false;
      return this.min_ <= max && min <= this.max_;
    },

    intersectsExplicitRangeExclusive: function (min, max) {
      if (this.isEmpty) return false;
      return this.min_ < max && min < this.max_;
    },

    containsRangeInclusive: function (range) {
      if (range.isEmpty) return false;
      return this.containsExplicitRangeInclusive(range.min_, range.max_);
    },

    containsRangeExclusive: function (range) {
      if (range.isEmpty) return false;
      return this.containsExplicitRangeExclusive(range.min_, range.max_);
    },

    intersectsRangeInclusive: function (range) {
      if (range.isEmpty) return false;
      return this.intersectsExplicitRangeInclusive(range.min_, range.max_);
    },

    intersectsRangeExclusive: function (range) {
      if (range.isEmpty) return false;
      return this.intersectsExplicitRangeExclusive(range.min_, range.max_);
    },

    findExplicitIntersectionDuration: function (min, max) {
      var min = Math.max(this.min, min);
      var max = Math.min(this.max, max);
      if (max < min) return 0;
      return max - min;
    },

    findIntersection: function (range) {
      if (this.isEmpty || range.isEmpty) return new Range();

      var min = Math.max(this.min, range.min);
      var max = Math.min(this.max, range.max);

      if (max < min) return new Range();

      return Range.fromExplicitRange(min, max);
    },

    toJSON: function () {
      if (this.isEmpty_) return { isEmpty: true };
      return {
        isEmpty: false,
        max: this.max,
        min: this.min
      };
    },

    /**
     * Returns a slice of the input array that intersects with this range
     * inclusively.
     * If the range does not have a min, it is treated as unbounded from below.
     * Similarly, if max is undefined, the range is unbounded from above.
     *
     * @param {Array} array The array of elements to be filtered.
     * @param {Funcation=} opt_keyFunc A function that extracts a numeric value,
     *        to be used in comparisons, from an element of the array. If not
     *        specified, array elements themselves will be used.
     * @param {Object=} opt_this An optional this argument to be passed to
     *        opt_keyFunc.
     */
    filterArray: function (array, opt_keyFunc, opt_this) {
      if (this.isEmpty_) return [];
      // Binary search. |test| is a function that should return true when we
      // need to explore the left branch and false to explore the right branch.
      function binSearch(test) {
        var i0 = 0;
        var i1 = array.length;
        while (i0 < i1) {
          var i = Math.trunc((i0 + i1) / 2);
          if (test(i)) i1 = i; // Explore the left branch.
          else i0 = i + 1; // Explore the right branch.
        }
        return i1;
      }

      var keyFunc = opt_keyFunc || tr.b.identity;
      function getValue(index) {
        return keyFunc.call(opt_this, array[index]);
      }

      var first = binSearch(function (i) {
        return this.min_ === undefined || this.min_ <= getValue(i);
      }.bind(this));
      var last = binSearch(function (i) {
        return this.max_ !== undefined && this.max_ < getValue(i);
      }.bind(this));
      return array.slice(first, last);
    }
  };

  Range.fromDict = function (d) {
    if (d.isEmpty === true) {
      return new Range();
    } else if (d.isEmpty === false) {
      var range = new Range();
      range.min = d.min;
      range.max = d.max;
      return range;
    } else {
      throw new Error('Not a range');
    }
  };

  Range.fromExplicitRange = function (min, max) {
    var range = new Range();
    range.min = min;
    range.max = max;
    return range;
  };

  Range.compareByMinTimes = function (a, b) {
    if (!a.isEmpty && !b.isEmpty) return a.min_ - b.min_;

    if (a.isEmpty && !b.isEmpty) return -1;

    if (!a.isEmpty && b.isEmpty) return 1;

    return 0;
  };

  Range.PERCENT_RANGE = Range.fromExplicitRange(0, 1);
  Object.freeze(Range.PERCENT_RANGE);

  return {
    Range: Range
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28,"./iteration_helpers.js":41,"./math.js":42}],48:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");
require("./iteration_helpers.js");

'use strict';

/**
 * @fileoverview Provides event merging functionality for grouping/analysis.
 */
global.tr.exportTo('tr.b', function () {
  function convertEventsToRanges(events) {
    return events.map(function (event) {
      return tr.b.Range.fromExplicitRange(event.start, event.end);
    });
  }

  function mergeRanges(inRanges, mergeThreshold, mergeFunction) {
    var remainingEvents = inRanges.slice();
    remainingEvents.sort(function (x, y) {
      return x.min - y.min;
    });

    if (remainingEvents.length <= 1) {
      var merged = [];
      if (remainingEvents.length == 1) {
        merged.push(mergeFunction(remainingEvents));
      }
      return merged;
    }

    var mergedEvents = [];

    var currentMergeBuffer = [];
    var rightEdge;
    function beginMerging() {
      currentMergeBuffer.push(remainingEvents[0]);
      remainingEvents.splice(0, 1);
      rightEdge = currentMergeBuffer[0].max;
    }

    function flushCurrentMergeBuffer() {
      if (currentMergeBuffer.length == 0) return;

      mergedEvents.push(mergeFunction(currentMergeBuffer));
      currentMergeBuffer = [];

      // Refill merge buffer if needed.
      if (remainingEvents.length != 0) beginMerging();
    }

    beginMerging();

    while (remainingEvents.length) {
      var currentEvent = remainingEvents[0];

      var distanceFromRightEdge = currentEvent.min - rightEdge;
      if (distanceFromRightEdge < mergeThreshold) {
        rightEdge = Math.max(rightEdge, currentEvent.max);
        remainingEvents.splice(0, 1);
        currentMergeBuffer.push(currentEvent);
        continue;
      }

      // Too big a gap.
      flushCurrentMergeBuffer();
    }
    flushCurrentMergeBuffer();

    return mergedEvents;
  }

  // Pass in |opt_totalRange| in order to find empty ranges before the first of
  // |inRanges| and after the last of |inRanges|.
  function findEmptyRangesBetweenRanges(inRanges, opt_totalRange) {
    if (opt_totalRange && opt_totalRange.isEmpty) opt_totalRange = undefined;

    var emptyRanges = [];
    if (!inRanges.length) {
      if (opt_totalRange) emptyRanges.push(opt_totalRange);
      return emptyRanges;
    }

    inRanges = inRanges.slice();
    inRanges.sort(function (x, y) {
      return x.min - y.min;
    });
    if (opt_totalRange && opt_totalRange.min < inRanges[0].min) {
      emptyRanges.push(tr.b.Range.fromExplicitRange(opt_totalRange.min, inRanges[0].min));
    }

    inRanges.forEach(function (range, index) {
      for (var otherIndex = 0; otherIndex < inRanges.length; ++otherIndex) {
        if (index === otherIndex) continue;
        var other = inRanges[otherIndex];

        if (other.min > range.max) {
          // |inRanges| is sorted, so |other| is the first range after |range|,
          // and there is an empty range between them.
          emptyRanges.push(tr.b.Range.fromExplicitRange(range.max, other.min));
          return;
        }
        // Otherwise, |other| starts before |range| ends, so |other| might
        // possibly contain the end of |range|.

        if (other.max > range.max) {
          // |other| does contain the end of |range|, so no empty range starts
          // at the end of this |range|.
          return;
        }
      }
      if (opt_totalRange && range.max < opt_totalRange.max) {
        emptyRanges.push(tr.b.Range.fromExplicitRange(range.max, opt_totalRange.max));
      }
    });
    return emptyRanges;
  }

  return {
    convertEventsToRanges: convertEventsToRanges,
    findEmptyRangesBetweenRanges: findEmptyRangesBetweenRanges,
    mergeRanges: mergeRanges
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28,"./iteration_helpers.js":41}],49:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");
require("./math.js");

'use strict';

global.tr.exportTo('tr.b', function () {

  /**
   * Tracks a 2D bounding box.
   * @constructor
   */
  function Rect() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  };
  Rect.fromXYWH = function (x, y, w, h) {
    var rect = new Rect();
    rect.x = x;
    rect.y = y;
    rect.width = w;
    rect.height = h;
    return rect;
  };
  Rect.fromArray = function (ary) {
    if (ary.length != 4) throw new Error('ary.length must be 4');
    var rect = new Rect();
    rect.x = ary[0];
    rect.y = ary[1];
    rect.width = ary[2];
    rect.height = ary[3];
    return rect;
  };

  Rect.prototype = {
    __proto__: Object.prototype,

    get left() {
      return this.x;
    },

    get top() {
      return this.y;
    },

    get right() {
      return this.x + this.width;
    },

    get bottom() {
      return this.y + this.height;
    },

    toString: function () {
      return 'Rect(' + this.x + ', ' + this.y + ', ' + this.width + ', ' + this.height + ')';
    },

    toArray: function () {
      return [this.x, this.y, this.width, this.height];
    },

    clone: function () {
      var rect = new Rect();
      rect.x = this.x;
      rect.y = this.y;
      rect.width = this.width;
      rect.height = this.height;
      return rect;
    },

    enlarge: function (pad) {
      var rect = new Rect();
      this.enlargeFast(rect, pad);
      return rect;
    },

    enlargeFast: function (out, pad) {
      out.x = this.x - pad;
      out.y = this.y - pad;
      out.width = this.width + 2 * pad;
      out.height = this.height + 2 * pad;
      return out;
    },

    size: function () {
      return { width: this.width, height: this.height };
    },

    scale: function (s) {
      var rect = new Rect();
      this.scaleFast(rect, s);
      return rect;
    },

    scaleSize: function (s) {
      return Rect.fromXYWH(this.x, this.y, this.width * s, this.height * s);
    },

    scaleFast: function (out, s) {
      out.x = this.x * s;
      out.y = this.y * s;
      out.width = this.width * s;
      out.height = this.height * s;
      return out;
    },

    translate: function (v) {
      var rect = new Rect();
      this.translateFast(rect, v);
      return rect;
    },

    translateFast: function (out, v) {
      out.x = this.x + v[0];
      out.y = this.x + v[1];
      out.width = this.width;
      out.height = this.height;
      return out;
    },

    asUVRectInside: function (containingRect) {
      var rect = new Rect();
      rect.x = (this.x - containingRect.x) / containingRect.width;
      rect.y = (this.y - containingRect.y) / containingRect.height;
      rect.width = this.width / containingRect.width;
      rect.height = this.height / containingRect.height;
      return rect;
    },

    intersects: function (that) {
      var ok = true;
      ok &= this.x < that.right;
      ok &= this.right > that.x;
      ok &= this.y < that.bottom;
      ok &= this.bottom > that.y;
      return ok;
    },

    equalTo: function (rect) {
      return rect && this.x === rect.x && this.y === rect.y && this.width === rect.width && this.height === rect.height;
    }
  };

  return {
    Rect: Rect
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28,"./math.js":42}],50:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  /***
  * An object of this class computes basic statistics online in O(1).
  * Usage:
  * 1. Create an instance.
  * 2. Add numbers using the |add| method.
  * 3. Query statistics.
  * 4. Repeat from step 2.
  */
  class RunningStatistics {
    constructor() {
      this.mean_ = 0;
      this.count_ = 0;
      this.max_ = -Infinity;
      this.min_ = Infinity;
      this.sum_ = 0;
      this.variance_ = 0;

      // Mean of logarithms of absolute values of samples, or undefined if any
      // samples were <= 0.
      this.meanlogs_ = 0;
    }

    get count() {
      return this.count_;
    }

    get geometricMean() {
      if (this.meanlogs_ === undefined) return 0;
      return Math.exp(this.meanlogs_);
    }

    get mean() {
      if (this.count_ == 0) return undefined;
      return this.mean_;
    }

    get max() {
      return this.max_;
    }

    get min() {
      return this.min_;
    }

    get sum() {
      return this.sum_;
    }

    get variance() {
      if (this.count_ == 0) return undefined;
      if (this.count_ == 1) return 0;
      return this.variance_ / (this.count_ - 1);
    }

    get stddev() {
      if (this.count_ == 0) return undefined;
      return Math.sqrt(this.variance);
    }

    add(x) {
      this.count_++;
      this.max_ = Math.max(this.max_, x);
      this.min_ = Math.min(this.min_, x);
      this.sum_ += x;

      // The geometric mean is computed using the arithmetic mean of logarithms.
      if (x <= 0) this.meanlogs_ = undefined;else if (this.meanlogs_ !== undefined) this.meanlogs_ += (Math.log(Math.abs(x)) - this.meanlogs_) / this.count;

      // The following uses Welford's algorithm for computing running mean
      // and variance. See http://www.johndcook.com/blog/standard_deviation.
      if (this.count_ === 1) {
        this.mean_ = x;
        this.variance_ = 0;
      } else {
        var oldMean = this.mean_;
        var oldVariance = this.variance_;
        // Using the 2nd formula for updating the mean yields better precision
        // but it doesn't work for the case oldMean is Infinity. Hence we handle
        // that case separately.
        if (oldMean === Infinity || oldMean === -Infinity) {
          this.mean_ = this.sum_ / this.count_;
        } else {
          this.mean_ = oldMean + (x - oldMean) / this.count_;
        }
        this.variance_ = oldVariance + (x - oldMean) * (x - this.mean_);
      }
    }

    merge(other) {
      var result = new RunningStatistics();
      result.count_ = this.count_ + other.count_;
      result.sum_ = this.sum_ + other.sum_;
      result.min_ = Math.min(this.min_, other.min_);
      result.max_ = Math.max(this.max_, other.max_);
      if (result.count === 0) {
        result.mean_ = 0;
        result.variance_ = 0;
        result.meanlogs_ = 0;
      } else {
        // Combine the mean and the variance using the formulas from
        // https://goo.gl/ddcAep.
        result.mean_ = result.sum / result.count;
        var deltaMean = (this.mean || 0) - (other.mean || 0);
        result.variance_ = this.variance_ + other.variance_ + this.count * other.count * deltaMean * deltaMean / result.count;

        // Merge the arithmetic means of logarithms of absolute values of
        // samples, weighted by counts.
        if (this.meanlogs_ === undefined || other.meanlogs_ === undefined) {
          result.meanlogs_ = undefined;
        } else {
          result.meanlogs_ = (this.count * this.meanlogs_ + other.count * other.meanlogs_) / result.count;
        }
      }
      return result;
    }

    asDict() {
      if (!this.count) {
        return [];
      }
      // It's more efficient to serialize these fields in an array. If you
      // add any other fields, you should re-evaluate whether it would be more
      // efficient to serialize as a dict.
      return [this.count_, this.max_, this.meanlogs_, this.mean_, this.min_, this.sum_, this.variance_];
    }

    static fromDict(dict) {
      var result = new RunningStatistics();
      if (dict.length != 7) {
        return result;
      }

      var _dict = _slicedToArray(dict, 7);

      result.count_ = _dict[0];
      result.max_ = _dict[1];
      result.meanlogs_ = _dict[2];
      result.mean_ = _dict[3];
      result.min_ = _dict[4];
      result.sum_ = _dict[5];
      result.variance_ = _dict[6];

      return result;
    }
  }

  return {
    RunningStatistics: RunningStatistics
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],51:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./color.js");
require("./iteration_helpers.js");
require("./math.js");

'use strict';
global.tr.exportTo('tr.b', function () {
  /**
   * Generate pretty colors!
   * http://basecase.org/env/on-rainbows
   * https://mycarta.wordpress.com/2012/10/06/the-rainbow-is-deadlong-live-the-rainbow-part-3/
   *
   * Set brightness = 0 to always generate black.
   * Set brightness = 2 to always generate white.
   * Set brightness = 1 to generate saturated colors.
   *
   * @constructor
   * @param {number=} opt_a alpha opacity in [0,1]
   * @param {number=} opt_brightness in [0,2]
   */
  function SinebowColorGenerator(opt_a, opt_brightness) {
    this.a_ = opt_a === undefined ? 1 : opt_a;
    this.brightness_ = opt_brightness === undefined ? 1 : opt_brightness;
    this.colorIndex_ = 0;
    this.keyToColor = {};
  }

  SinebowColorGenerator.prototype = {
    colorForKey: function (key) {
      if (!this.keyToColor[key]) this.keyToColor[key] = this.nextColor();
      return this.keyToColor[key];
    },

    nextColor: function () {
      var components = SinebowColorGenerator.nthColor(this.colorIndex_++);
      return tr.b.Color.fromString(SinebowColorGenerator.calculateColor(components[0], components[1], components[2], this.a_, this.brightness_));
    }
  };

  SinebowColorGenerator.PHI = (1 + Math.sqrt(5)) / 2;

  SinebowColorGenerator.sinebow_ = function (h) {
    h += 0.5;
    h = -h;
    var r = Math.sin(Math.PI * h);
    var g = Math.sin(Math.PI * (h + 1 / 3));
    var b = Math.sin(Math.PI * (h + 2 / 3));
    r *= r;g *= g;b *= b;
    // Roughly correct for human perception.
    // https://en.wikipedia.org/wiki/Luma_%28video%29
    // Multiply by 2 to normalize all values to 0.5.
    // (Halfway between black and white.)
    var y = 2 * (0.2989 * r + 0.5870 * g + 0.1140 * b);
    r /= y;g /= y;b /= y;
    return [256 * r, 256 * g, 256 * b];
  };

  SinebowColorGenerator.nthColor = function (n) {
    return SinebowColorGenerator.sinebow_(n * this.PHI);
  };

  SinebowColorGenerator.calculateColor = function (r, g, b, a, brightness) {
    if (brightness <= 1) {
      r *= brightness;
      g *= brightness;
      b *= brightness;
    } else {
      r = tr.b.lerp(tr.b.normalize(brightness, 1, 2), r, 255);
      g = tr.b.lerp(tr.b.normalize(brightness, 1, 2), g, 255);
      b = tr.b.lerp(tr.b.normalize(brightness, 1, 2), b, 255);
    }
    r = Math.round(r);
    g = Math.round(g);
    b = Math.round(b);
    return 'rgba(' + r + ',' + g + ',' + b + ', ' + a + ')';
  };

  return {
    SinebowColorGenerator: SinebowColorGenerator
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./color.js":31,"./iteration_helpers.js":41,"./math.js":42}],52:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

/**
 * @fileoverview Helper functions for doing intersections and iteration
 * over sorted arrays and intervals.
 *
 */
global.tr.exportTo('tr.b', function () {
  /**
   * Finds the first index in the array whose value is >= loVal.
   *
   * The key for the search is defined by the mapFn. This array must
   * be prearranged such that ary.map(mapFn) would also be sorted in
   * ascending order.
   *
   * @param {Array} ary An array of arbitrary objects.
   * @param {function():*} mapFn Callback that produces a key value
   *     from an element in ary.
   * @param {number} loVal Value for which to search.
   * @return {Number} Offset o into ary where all ary[i] for i <= o
   *     are < loVal, or ary.length if loVal is greater than all elements in
   *     the array.
   */
  function findLowIndexInSortedArray(ary, mapFn, loVal) {
    if (ary.length == 0) return 1;

    var low = 0;
    var high = ary.length - 1;
    var i, comparison;
    var hitPos = -1;
    while (low <= high) {
      i = Math.floor((low + high) / 2);
      comparison = mapFn(ary[i]) - loVal;
      if (comparison < 0) {
        low = i + 1;continue;
      } else if (comparison > 0) {
        high = i - 1;continue;
      } else {
        hitPos = i;
        high = i - 1;
      }
    }
    // return where we hit, or failing that the low pos
    return hitPos != -1 ? hitPos : low;
  }

  // From devtools/front_end/platform/utilities.js upperBound
  function findHighIndexInSortedArray(ary, mapFn, loVal, hiVal) {
    var lo = loVal || 0;
    var hi = hiVal !== undefined ? hiVal : ary.length;
    while (lo < hi) {
      var mid = lo + hi >> 1;
      if (mapFn(ary[mid]) >= 0) lo = mid + 1;else hi = mid;
    }
    return hi;
  }

  /**
   * Finds an index in an array of intervals that either intersects
   * the provided loVal, or if no intersection is found, -1 or ary.length.
   *
   * The array of intervals is defined implicitly via two mapping functions
   * over the provided ary. mapLoFn determines the lower value of the interval,
   * mapWidthFn the width. Intersection is lower-inclusive, e.g. [lo,lo+w).
   *
   * The array of intervals formed by this mapping must be non-overlapping and
   * sorted in ascending order by loVal.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an  element in the array.
   * @param {function():*} mapWidthFn Callback that produces the width for the
   *     interval represented by an  element in the array.
   * @param {number} loVal The low value for the search.
   * @return {Number} An index in the array that intersects or is first-above
   *     loVal, -1 if none found and loVal is below than all the intervals,
   *     ary.length if loVal is greater than all the intervals.
   */
  function findIndexInSortedIntervals(ary, mapLoFn, mapWidthFn, loVal) {
    var first = findLowIndexInSortedArray(ary, mapLoFn, loVal);
    if (first == 0) {
      if (loVal >= mapLoFn(ary[0]) && loVal < mapLoFn(ary[0]) + mapWidthFn(ary[0], 0)) {
        return 0;
      } else {
        return -1;
      }
    } else if (first < ary.length) {
      if (loVal >= mapLoFn(ary[first]) && loVal < mapLoFn(ary[first]) + mapWidthFn(ary[first], first)) {
        return first;
      } else if (loVal >= mapLoFn(ary[first - 1]) && loVal < mapLoFn(ary[first - 1]) + mapWidthFn(ary[first - 1], first - 1)) {
        return first - 1;
      } else {
        return ary.length;
      }
    } else if (first == ary.length) {
      if (loVal >= mapLoFn(ary[first - 1]) && loVal < mapLoFn(ary[first - 1]) + mapWidthFn(ary[first - 1], first - 1)) {
        return first - 1;
      } else {
        return ary.length;
      }
    } else {
      return ary.length;
    }
  }

  /**
   * Finds an index in an array of sorted closed intervals that either
   * intersects the provided val, or if no intersection is found, -1 or
   *  ary.length.
   *
   * The array of intervals is defined implicitly via two mapping functions
   * over the provided ary. mapLoFn determines the lower value of the interval,
   * mapHiFn the high. Intersection is closed, e.g. [lo,hi], unlike with
   * findIndexInSortedIntervals, which is right-open.
   *
   * The array of intervals formed by this mapping must be non-overlapping, and
   * sorted in ascending order by val.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an  element in the array.
   * @param {function():*} mapHiFn Callback that produces the high for the
   *     interval represented by an  element in the array.
   * @param {number} val The value for the search.
   * @return {Number} An index in the array that intersects or is first-above
   *     val, -1 if none found and val is below than all the intervals,
   *     ary.length if val is greater than all the intervals.
   */
  function findIndexInSortedClosedIntervals(ary, mapLoFn, mapHiFn, val) {
    var i = findLowIndexInSortedArray(ary, mapLoFn, val);
    if (i === 0) {
      if (val >= mapLoFn(ary[0], 0) && val <= mapHiFn(ary[0], 0)) {
        return 0;
      } else {
        return -1;
      }
    } else if (i < ary.length) {
      if (val >= mapLoFn(ary[i - 1], i - 1) && val <= mapHiFn(ary[i - 1], i - 1)) {
        return i - 1;
      } else if (val >= mapLoFn(ary[i], i) && val <= mapHiFn(ary[i], i)) {
        return i;
      } else {
        return ary.length;
      }
    } else if (i == ary.length) {
      if (val >= mapLoFn(ary[i - 1], i - 1) && val <= mapHiFn(ary[i - 1], i - 1)) {
        return i - 1;
      } else {
        return ary.length;
      }
    } else {
      return ary.length;
    }
  }

  /**
   * Calls cb for all intervals in the implicit array of intervals
   * defnied by ary, mapLoFn and mapHiFn that intersect the range
   * [loVal,hiVal)
   *
   * This function uses the same scheme as findLowIndexInSortedArray
   * to define the intervals. The same restrictions on sortedness and
   * non-overlappingness apply.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   * nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   * interval represented by an element in the array.
   * @param {function():*} mapWidthFn Callback that produces the width for the
   * interval represented by an element in the array.
   * @param {number} loVal The low value for the search, inclusive.
   * @param {number} hiVal The high value for the search, non inclusive.
   * @param {function():*} cb The function to run for intersecting intervals.
   */
  function iterateOverIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal, hiVal, cb) {
    if (ary.length == 0) return;

    if (loVal > hiVal) return;

    var i = findLowIndexInSortedArray(ary, mapLoFn, loVal);
    if (i == -1) {
      return;
    }
    if (i > 0) {
      var hi = mapLoFn(ary[i - 1]) + mapWidthFn(ary[i - 1], i - 1);
      if (hi >= loVal) {
        cb(ary[i - 1], i - 1);
      }
    }
    if (i == ary.length) {
      return;
    }

    for (var n = ary.length; i < n; i++) {
      var lo = mapLoFn(ary[i]);
      if (lo >= hiVal) break;
      cb(ary[i], i);
    }
  }

  /**
   * Non iterative version of iterateOverIntersectingIntervals.
   *
   * @return {Array} Array of elements in ary that intersect loVal, hiVal.
   */
  function getIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal, hiVal) {
    var tmp = [];
    iterateOverIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal, hiVal, function (d) {
      tmp.push(d);
    });
    return tmp;
  }

  /**
   * Finds the element in the array whose value is closest to |val|.
   *
   * The same restrictions on sortedness as for findLowIndexInSortedArray apply.
   *
   * @param {Array} ary An array of arbitrary objects.
   * @param {function():*} mapFn Callback that produces a key value
   *     from an element in ary.
   * @param {number} val Value for which to search.
   * @param {number} maxDiff Maximum allowed difference in value between |val|
   *     and an element's value.
   * @return {object} Object in the array whose value is closest to |val|, or
   *     null if no object is within range.
   */
  function findClosestElementInSortedArray(ary, mapFn, val, maxDiff) {
    if (ary.length === 0) return null;

    var aftIdx = findLowIndexInSortedArray(ary, mapFn, val);
    var befIdx = aftIdx > 0 ? aftIdx - 1 : 0;

    if (aftIdx === ary.length) aftIdx -= 1;

    var befDiff = Math.abs(val - mapFn(ary[befIdx]));
    var aftDiff = Math.abs(val - mapFn(ary[aftIdx]));

    if (befDiff > maxDiff && aftDiff > maxDiff) return null;

    var idx = befDiff < aftDiff ? befIdx : aftIdx;
    return ary[idx];
  }

  /**
   * Finds the closest interval in the implicit array of intervals
   * defined by ary, mapLoFn and mapHiFn.
   *
   * This function uses the same scheme as findLowIndexInSortedArray
   * to define the intervals. The same restrictions on sortedness and
   * non-overlappingness apply.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapHiFn.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an element in the array.
   * @param {function():*} mapHiFn Callback that produces the high for the
   *     interval represented by an element in the array.
   * @param {number} val The value for the search.
   * @param {number} maxDiff Maximum allowed difference in value between |val|
   *     and an interval's low or high value.
   * @return {interval} Interval in the array whose high or low value is closest
   *     to |val|, or null if no interval is within range.
   */
  function findClosestIntervalInSortedIntervals(ary, mapLoFn, mapHiFn, val, maxDiff) {
    if (ary.length === 0) return null;

    var idx = findLowIndexInSortedArray(ary, mapLoFn, val);
    if (idx > 0) idx -= 1;

    var hiInt = ary[idx];
    var loInt = hiInt;

    if (val > mapHiFn(hiInt) && idx + 1 < ary.length) loInt = ary[idx + 1];

    var loDiff = Math.abs(val - mapLoFn(loInt));
    var hiDiff = Math.abs(val - mapHiFn(hiInt));

    if (loDiff > maxDiff && hiDiff > maxDiff) return null;

    if (loDiff < hiDiff) return loInt;else return hiInt;
  }

  return {
    findLowIndexInSortedArray: findLowIndexInSortedArray,
    findHighIndexInSortedArray: findHighIndexInSortedArray,
    findIndexInSortedIntervals: findIndexInSortedIntervals,
    findIndexInSortedClosedIntervals: findIndexInSortedClosedIntervals,
    iterateOverIntersectingIntervals: iterateOverIntersectingIntervals,
    getIntersectingIntervals: getIntersectingIntervals,
    findClosestElementInSortedArray: findClosestElementInSortedArray,
    findClosestIntervalInSortedIntervals: findClosestIntervalInSortedIntervals
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],53:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./math.js");
require("./range.js");

'use strict';

// In node, the script-src for mannwhitneyu above brings in mannwhitneyui
// into a module, instead of into the global scope. Whereas this file
// assumes that mannwhitneyu is in the global scope. So, in Node only, we
// require() it in, and then take all its exports and shove them into the
// global scope by hand.
(function () {
  if (tr.isNode) {
    var mwuAbsPath = HTMLImportsLoader.hrefToAbsolutePath('/mannwhitneyu.js');
    var mwuModule = require(mwuAbsPath);
    for (var exportName in mwuModule) {
      global[exportName] = mwuModule[exportName];
    }
  }
})(this);

'use strict';

// TODO(charliea): Remove:
/* eslint-disable catapult-camelcase */

global.tr.exportTo('tr.b', function () {
  var identity = x => x;

  var Statistics = {};

  /* Returns the quotient, or zero if the denominator is zero.*/
  Statistics.divideIfPossibleOrZero = function (numerator, denominator) {
    if (denominator === 0) return 0;
    return numerator / denominator;
  };

  Statistics.sum = function (ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var ret = 0;
    var i = 0;
    for (var elt of ary) ret += func.call(opt_this, elt, i++);
    return ret;
  };

  Statistics.mean = function (ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var sum = 0;
    var i = 0;

    for (var elt of ary) sum += func.call(opt_this, elt, i++);

    if (i === 0) return undefined;

    return sum / i;
  };

  Statistics.geometricMean = function (ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var i = 0;
    var logsum = 0;

    // The geometric mean is expressed as the arithmetic mean of logarithms
    // in order to prevent overflow.
    for (var elt of ary) {
      var x = func.call(opt_this, elt, i++);
      if (x <= 0) return 0;
      logsum += Math.log(Math.abs(x));
    }

    if (i === 0) return 1;

    return Math.exp(logsum / i);
  };

  // Returns undefined if the sum of the weights is zero.
  Statistics.weightedMean = function (ary, weightCallback, opt_valueCallback, opt_this) {
    var valueCallback = opt_valueCallback || identity;
    var numerator = 0;
    var denominator = 0;
    var i = -1;

    for (var elt of ary) {
      i++;
      var value = valueCallback.call(opt_this, elt, i);
      if (value === undefined) continue;
      var weight = weightCallback.call(opt_this, elt, i, value);
      numerator += weight * value;
      denominator += weight;
    }

    if (denominator === 0) return undefined;

    return numerator / denominator;
  };

  Statistics.variance = function (ary, opt_func, opt_this) {
    if (ary.length === 0) return undefined;
    if (ary.length === 1) return 0;
    var func = opt_func || identity;
    var mean = Statistics.mean(ary, func, opt_this);
    var sumOfSquaredDistances = Statistics.sum(ary, function (d, i) {
      var v = func.call(this, d, i) - mean;
      return v * v;
    }, opt_this);
    return sumOfSquaredDistances / (ary.length - 1);
  };

  Statistics.stddev = function (ary, opt_func, opt_this) {
    if (ary.length == 0) return undefined;
    return Math.sqrt(Statistics.variance(ary, opt_func, opt_this));
  };

  Statistics.max = function (ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var ret = -Infinity;
    var i = 0;
    for (var elt of ary) ret = Math.max(ret, func.call(opt_this, elt, i++));
    return ret;
  };

  Statistics.min = function (ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var ret = Infinity;
    var i = 0;
    for (var elt of ary) ret = Math.min(ret, func.call(opt_this, elt, i++));
    return ret;
  };

  Statistics.range = function (ary, opt_func, opt_this) {
    var func = opt_func || identity;
    var ret = new tr.b.Range();
    var i = 0;
    for (var elt of ary) ret.addValue(func.call(opt_this, elt, i++));
    return ret;
  };

  Statistics.percentile = function (ary, percent, opt_func, opt_this) {
    if (!(percent >= 0 && percent <= 1)) throw new Error('percent must be [0,1]');

    var func = opt_func || identity;
    var tmp = new Array(ary.length);
    var i = 0;
    for (var elt of ary) tmp[i] = func.call(opt_this, elt, i++);
    tmp.sort((a, b) => a - b);
    var idx = Math.floor((ary.length - 1) * percent);
    return tmp[idx];
  };

  /**
   * Sorts the samples, and map them linearly to the range [0,1].
   *
   * They're mapped such that for the N samples, the first sample is 0.5/N and
   * the last sample is (N-0.5)/N.
   *
   * Background: The discrepancy of the sample set i/(N-1); i=0, ..., N-1 is
   * 2/N, twice the discrepancy of the sample set (i+1/2)/N; i=0, ..., N-1. In
   * our case we don't want to distinguish between these two cases, as our
   * original domain is not bounded (it is for Monte Carlo integration, where
   * discrepancy was first used).
   **/
  Statistics.normalizeSamples = function (samples) {
    if (samples.length === 0) {
      return {
        normalized_samples: samples,
        scale: 1.0
      };
    }
    // Create a copy to make sure that we don't mutate original |samples| input.
    samples = samples.slice().sort(function (a, b) {
      return a - b;
    });
    var low = Math.min.apply(null, samples);
    var high = Math.max.apply(null, samples);
    var newLow = 0.5 / samples.length;
    var newHigh = (samples.length - 0.5) / samples.length;
    if (high - low === 0.0) {
      // Samples is an array of 0.5 in this case.
      samples = Array.apply(null, new Array(samples.length)).map(function () {
        return 0.5;
      });
      return {
        normalized_samples: samples,
        scale: 1.0
      };
    }
    var scale = (newHigh - newLow) / (high - low);
    for (var i = 0; i < samples.length; i++) {
      samples[i] = (samples[i] - low) * scale + newLow;
    }
    return {
      normalized_samples: samples,
      scale: scale
    };
  };

  /**
   * Computes the discrepancy of a set of 1D samples from the interval [0,1].
   *
   * The samples must be sorted. We define the discrepancy of an empty set
   * of samples to be zero.
   *
   * http://en.wikipedia.org/wiki/Low-discrepancy_sequence
   * http://mathworld.wolfram.com/Discrepancy.html
   */
  Statistics.discrepancy = function (samples, opt_locationCount) {
    if (samples.length === 0) return 0.0;

    var maxLocalDiscrepancy = 0;
    var invSampleCount = 1.0 / samples.length;
    var locations = [];
    // For each location, stores the number of samples less than that location.
    var countLess = [];
    // For each location, stores the number of samples less than or equal to
    // that location.
    var countLessEqual = [];

    if (opt_locationCount !== undefined) {
      // Generate list of equally spaced locations.
      var sampleIndex = 0;
      for (var i = 0; i < opt_locationCount; i++) {
        var location = i / (opt_locationCount - 1);
        locations.push(location);
        while (sampleIndex < samples.length && samples[sampleIndex] < location) {
          sampleIndex += 1;
        }
        countLess.push(sampleIndex);
        while (sampleIndex < samples.length && samples[sampleIndex] <= location) {
          sampleIndex += 1;
        }
        countLessEqual.push(sampleIndex);
      }
    } else {
      // Populate locations with sample positions. Append 0 and 1 if necessary.
      if (samples[0] > 0.0) {
        locations.push(0.0);
        countLess.push(0);
        countLessEqual.push(0);
      }
      for (var i = 0; i < samples.length; i++) {
        locations.push(samples[i]);
        countLess.push(i);
        countLessEqual.push(i + 1);
      }
      if (samples[-1] < 1.0) {
        locations.push(1.0);
        countLess.push(samples.length);
        countLessEqual.push(samples.length);
      }
    }

    // Compute discrepancy as max(overshoot, -undershoot), where
    // overshoot = max(countClosed(i, j)/N - length(i, j)) for all i < j,
    // undershoot = min(countOpen(i, j)/N - length(i, j)) for all i < j,
    // N = len(samples),
    // countClosed(i, j) is the number of points between i and j
    // including ends,
    // countOpen(i, j) is the number of points between i and j excluding ends,
    // length(i, j) is locations[i] - locations[j].

    // The following algorithm is modification of Kadane's algorithm,
    // see https://en.wikipedia.org/wiki/Maximum_subarray_problem.

    // The maximum of (countClosed(k, i-1)/N - length(k, i-1)) for any k < i-1.
    var maxDiff = 0;
    // The minimum of (countOpen(k, i-1)/N - length(k, i-1)) for any k < i-1.
    var minDiff = 0;
    for (var i = 1; i < locations.length; i++) {
      var length = locations[i] - locations[i - 1];
      var countClosed = countLessEqual[i] - countLess[i - 1];
      var countOpen = countLess[i] - countLessEqual[i - 1];
      // Number of points that are added if we extend a closed range that
      // ends at location (i-1).
      var countClosedIncrement = countLessEqual[i] - countLessEqual[i - 1];
      // Number of points that are added if we extend an open range that
      // ends at location (i-1).
      var countOpenIncrement = countLess[i] - countLess[i - 1];

      // Either extend the previous optimal range or start a new one.
      maxDiff = Math.max(countClosedIncrement * invSampleCount - length + maxDiff, countClosed * invSampleCount - length);
      minDiff = Math.min(countOpenIncrement * invSampleCount - length + minDiff, countOpen * invSampleCount - length);

      maxLocalDiscrepancy = Math.max(maxDiff, -minDiff, maxLocalDiscrepancy);
    }
    return maxLocalDiscrepancy;
  };

  /**
   * A discrepancy based metric for measuring timestamp jank.
   *
   * timestampsDiscrepancy quantifies the largest area of jank observed in a
   * series of timestamps.  Note that this is different from metrics based on
   * the max_time_interval. For example, the time stamp series A = [0,1,2,3,5,6]
   *  and B = [0,1,2,3,5,7] have the same max_time_interval = 2, but
   * Discrepancy(B) > Discrepancy(A).
   *
   * Two variants of discrepancy can be computed:
   *
   * Relative discrepancy is following the original definition of
   * discrepancy. It characterized the largest area of jank, relative to the
   * duration of the entire time stamp series.  We normalize the raw results,
   * because the best case discrepancy for a set of N samples is 1/N (for
   * equally spaced samples), and we want our metric to report 0.0 in that
   * case.
   *
   * Absolute discrepancy also characterizes the largest area of jank, but its
   * value wouldn't change (except for imprecisions due to a low
   * |interval_multiplier|) if additional 'good' intervals were added to an
   * exisiting list of time stamps.  Its range is [0,inf] and the unit is
   * milliseconds.
   *
   * The time stamp series C = [0,2,3,4] and D = [0,2,3,4,5] have the same
   * absolute discrepancy, but D has lower relative discrepancy than C.
   *
   * |timestamps| may be a list of lists S = [S_1, S_2, ..., S_N], where each
   * S_i is a time stamp series. In that case, the discrepancy D(S) is:
   * D(S) = max(D(S_1), D(S_2), ..., D(S_N))
   **/
  Statistics.timestampsDiscrepancy = function (timestamps, opt_absolute, opt_locationCount) {
    if (timestamps.length === 0) return 0.0;

    if (opt_absolute === undefined) opt_absolute = true;

    if (Array.isArray(timestamps[0])) {
      var rangeDiscrepancies = timestamps.map(function (r) {
        return Statistics.timestampsDiscrepancy(r);
      });
      return Math.max.apply(null, rangeDiscrepancies);
    }

    var s = Statistics.normalizeSamples(timestamps);
    var samples = s.normalized_samples;
    var sampleScale = s.scale;
    var discrepancy = Statistics.discrepancy(samples, opt_locationCount);
    var invSampleCount = 1.0 / samples.length;
    if (opt_absolute === true) {
      // Compute absolute discrepancy
      discrepancy /= sampleScale;
    } else {
      // Compute relative discrepancy
      discrepancy = tr.b.clamp((discrepancy - invSampleCount) / (1.0 - invSampleCount), 0.0, 1.0);
    }
    return discrepancy;
  };

  /**
   * A discrepancy based metric for measuring duration jank.
   *
   * DurationsDiscrepancy computes a jank metric which measures how irregular a
   * given sequence of intervals is. In order to minimize jank, each duration
   * should be equally long. This is similar to how timestamp jank works,
   * and we therefore reuse the timestamp discrepancy function above to compute
   * a similar duration discrepancy number.
   *
   * Because timestamp discrepancy is defined in terms of timestamps, we first
   * convert the list of durations to monotonically increasing timestamps.
   *
   * Args:
   *  durations: List of interval lengths in milliseconds.
   *  absolute: See TimestampsDiscrepancy.
   *  opt_locationCount: See TimestampsDiscrepancy.
   **/
  Statistics.durationsDiscrepancy = function (durations, opt_absolute, opt_locationCount) {
    if (durations.length === 0) return 0.0;

    var timestamps = durations.reduce(function (prev, curr, index, array) {
      prev.push(prev[prev.length - 1] + curr);
      return prev;
    }, [0]);
    return Statistics.timestampsDiscrepancy(timestamps, opt_absolute, opt_locationCount);
  };

  /**
   * Modifies |samples| in-place to reduce its length down to |count|.
   *
   * @param {!Array} samples
   * @param {number} count
   * @return {!Array}
   */
  Statistics.uniformlySampleArray = function (samples, count) {
    if (samples.length <= count) {
      return samples;
    }
    while (samples.length > count) {
      var i = parseInt(Math.random() * samples.length);
      samples.splice(i, 1);
    }
    return samples;
  };

  /**
   * A mechanism to uniformly sample elements from an arbitrary long stream.
   *
   * Call this method every time a new element is obtained from the stream,
   * passing always the same |samples| array and the |numSamples| you desire.
   * Also pass in the current |streamLength|, which is the same as the index of
   * |newElement| within that stream.
   *
   * The |samples| array will possibly be updated, replacing one of its element
   * with |newElements|. The length of |samples| will not be more than
   * |numSamples|.
   *
   * This method guarantees that after |streamLength| elements have been
   * processed each one has equal probability of being in |samples|. The order
   * of samples is not preserved though.
   *
   * Args:
   *  samples: Array of elements that have already been selected. Start with [].
   *  streamLength: The current length of the stream, up to |newElement|.
   *  newElement: The element that was just extracted from the stream.
   *  numSamples: The total number of samples desired.
   **/
  Statistics.uniformlySampleStream = function (samples, streamLength, newElement, numSamples) {
    if (streamLength <= numSamples) {
      if (samples.length >= streamLength) samples[streamLength - 1] = newElement;else samples.push(newElement);
      return;
    }

    var probToKeep = numSamples / streamLength;
    if (Math.random() > probToKeep) return; // New sample was rejected.

    // Keeping it, replace an alement randomly.
    var index = Math.floor(Math.random() * numSamples);
    samples[index] = newElement;
  };

  /**
   * A mechanism to merge two arrays of uniformly sampled elements in a way that
   * ensures elements in the final array are still sampled uniformly.
   *
   * This works similarly to sampleStreamUniform. The |samplesA| array will be
   * updated, some of its elements replaced by elements from |samplesB| in a
   * way that ensure that elements will be sampled uniformly.
   *
   * Args:
   *  samplesA: Array of uniformly sampled elements, will be updated.
   *  streamLengthA: The length of the stream from which |samplesA| was sampled.
   *  samplesB: Other array of uniformly sampled elements, will NOT be updated.
   *  streamLengthB: The length of the stream from which |samplesB| was sampled.
   *  numSamples: The total number of samples desired, both in |samplesA| and
   *      |samplesB|.
   **/
  Statistics.mergeSampledStreams = function (samplesA, streamLengthA, samplesB, streamLengthB, numSamples) {
    if (streamLengthB < numSamples) {
      // samplesB has not reached max capacity so every sample of stream B were
      // chosen with certainty. Add them one by one into samplesA.
      var nbElements = Math.min(streamLengthB, samplesB.length);
      for (var i = 0; i < nbElements; ++i) {
        Statistics.uniformlySampleStream(samplesA, streamLengthA + i + 1, samplesB[i], numSamples);
      }
      return;
    }
    if (streamLengthA < numSamples) {
      // samplesA has not reached max capacity so every sample of stream A were
      // chosen with certainty. Add them one by one into samplesB.
      var nbElements = Math.min(streamLengthA, samplesA.length);
      var tempSamples = samplesB.slice();
      for (var i = 0; i < nbElements; ++i) {
        Statistics.uniformlySampleStream(tempSamples, streamLengthB + i + 1, samplesA[i], numSamples);
      }
      // Copy that back into the first vector.
      for (var i = 0; i < tempSamples.length; ++i) {
        samplesA[i] = tempSamples[i];
      }
      return;
    }

    // Both sample arrays are at max capacity, use the power of maths!
    // Elements in samplesA have been selected with probability
    // numSamples / streamLengthA. Same for samplesB. For each index of the
    // array we keep samplesA[i] with probability
    //   P = streamLengthA / (streamLengthA + streamLengthB)
    // and replace it with samplesB[i] with probability 1-P.
    // The total probability of keeping it is therefore
    //   numSamples / streamLengthA *
    //                      streamLengthA / (streamLengthA + streamLengthB)
    //   = numSamples / (streamLengthA + streamLengthB)
    // A similar computation shows we have the same probability of keeping any
    // element in samplesB. Magic!
    var nbElements = Math.min(numSamples, samplesB.length);
    var probOfSwapping = streamLengthB / (streamLengthA + streamLengthB);
    for (var i = 0; i < nbElements; ++i) {
      if (Math.random() < probOfSwapping) {
        samplesA[i] = samplesB[i];
      }
    }
  };

  /* Continuous distributions are defined by probability density functions.
   *
   * Random variables are referred to by capital letters: X, Y, Z.
   * Particular values from these distributions are referred to by lowercase
   * letters like |x|.
   * The probability that |X| ever exactly equals |x| is P(X==x) = 0.
   *
   * For a discrete probability distribution, see tr.v.Histogram.
   */
  function Distribution() {}

  Distribution.prototype = {
    /* The probability density of the random variable at value |x| is the
     * relative likelihood for this random variable to take on the given value
     * |x|.
     *
     * @param {number} x A value from the random distribution.
     * @return {number} probability density at x.
     */
    computeDensity: function (x) {
      throw Error('Not implemented');
    },

    /* A percentile is the probability that a sample from the distribution is
     * less than the given value |x|. This function is monotonically increasing.
     *
     * @param {number} x A value from the random distribution.
     * @return {number} P(X<x).
     */
    computePercentile: function (x) {
      throw Error('Not implemented');
    },

    /* A complementary percentile is the probability that a sample from the
     * distribution is greater than the given value |x|. This function is
     * monotonically decreasing.
     *
     * @param {number} x A value from the random distribution.
     * @return {number} P(X>x).
     */
    computeComplementaryPercentile: function (x) {
      return 1 - this.computePercentile(x);
    },

    /* Compute the mean of the probability distribution.
     *
     * @return {number} mean.
     */
    get mean() {
      throw Error('Not implemented');
    },

    /* The mode of a distribution is the most likely value.
     * The maximum of the computeDensity() function is at this mode.
     * @return {number} mode.
     */
    get mode() {
      throw Error('Not implemented');
    },

    /* The median is the center value of the distribution.
     * computePercentile(median) = computeComplementaryPercentile(median) = 0.5
     *
     * @return {number} median.
     */
    get median() {
      throw Error('Not implemented');
    },

    /* The standard deviation is a measure of how dispersed or spread out the
     * distribution is (this statistic has the same units as the values).
     *
     * @return {number} standard deviation.
     */
    get standardDeviation() {
      throw Error('Not implemented');
    },

    /* An alternative measure of how spread out the distribution is,
     * the variance is the square of the standard deviation.
     * @return {number} variance.
     */
    get variance() {
      throw Error('Not implemented');
    }
  };

  Statistics.UniformDistribution = function (opt_range) {
    if (!opt_range) opt_range = tr.b.Range.fromExplicitRange(0, 1);
    this.range = opt_range;
  };

  Statistics.UniformDistribution.prototype = {
    __proto__: Distribution.prototype,

    computeDensity: function (x) {
      return 1 / this.range.range;
    },

    computePercentile: function (x) {
      return tr.b.normalize(x, this.range.min, this.range.max);
    },

    get mean() {
      return this.range.center;
    },

    get mode() {
      return undefined;
    },

    get median() {
      return this.mean;
    },

    get standardDeviation() {
      return Math.sqrt(this.variance);
    },

    get variance() {
      return Math.pow(this.range.range, 2) / 12;
    }
  };

  /* The Normal or Gaussian distribution, or bell curve, is common in complex
   * processes such as are found in many of the natural sciences.  If Z is the
   * standard normal distribution with mean = 0 and variance = 1, then the
   * general normal distribution is Y = mean + Z*sqrt(variance).
   * https://www.desmos.com/calculator/tqtbjm4s3z
   */
  Statistics.NormalDistribution = function (opt_mean, opt_variance) {
    this.mean_ = opt_mean || 0;
    this.variance_ = opt_variance || 1;
    this.standardDeviation_ = Math.sqrt(this.variance_);
  };

  Statistics.NormalDistribution.prototype = {
    __proto__: Distribution.prototype,

    computeDensity: function (x) {
      var scale = 1.0 / (this.standardDeviation * Math.sqrt(2.0 * Math.PI));
      var exponent = -Math.pow(x - this.mean, 2) / (2.0 * this.variance);
      return scale * Math.exp(exponent);
    },

    computePercentile: function (x) {
      var standardizedX = (x - this.mean) / Math.sqrt(2.0 * this.variance);
      return (1.0 + tr.b.erf(standardizedX)) / 2.0;
    },

    get mean() {
      return this.mean_;
    },

    get median() {
      return this.mean;
    },

    get mode() {
      return this.mean;
    },

    get standardDeviation() {
      return this.standardDeviation_;
    },

    get variance() {
      return this.variance_;
    }
  };

  /* The log-normal distribution is a continuous probability distribution of a
   * random variable whose logarithm is normally distributed.
   * If Y is the general normal distribution, then X = exp(Y) is the general
   * log-normal distribution.
   * X will have different parameters from Y,
   * so the mean of Y is called the "location" of X,
   * and the standard deviation of Y is called the "shape" of X.
   * The standard lognormal distribution exp(Z) has location = 0 and shape = 1.
   * https://www.desmos.com/calculator/tqtbjm4s3z
   */
  Statistics.LogNormalDistribution = function (opt_location, opt_shape) {
    this.normalDistribution_ = new Statistics.NormalDistribution(opt_location, Math.pow(opt_shape || 1, 2));
  };

  Statistics.LogNormalDistribution.prototype = {
    __proto__: Statistics.NormalDistribution.prototype,

    computeDensity: function (x) {
      return this.normalDistribution_.computeDensity(Math.log(x)) / x;
    },

    computePercentile: function (x) {
      return this.normalDistribution_.computePercentile(Math.log(x));
    },

    get mean() {
      return Math.exp(this.normalDistribution_.mean + this.normalDistribution_.variance / 2);
    },

    get variance() {
      var nm = this.normalDistribution_.mean;
      var nv = this.normalDistribution_.variance;
      return Math.exp(2 * (nm + nv)) - Math.exp(2 * nm + nv);
    },

    get standardDeviation() {
      return Math.sqrt(this.variance);
    },

    get median() {
      return Math.exp(this.normalDistribution_.mean);
    },

    get mode() {
      return Math.exp(this.normalDistribution_.mean - this.normalDistribution_.variance);
    }
  };

  /**
   * Instead of describing a LogNormalDistribution in terms of its "location"
   * and "shape", it can also be described in terms of its median
   * and the point at which its complementary cumulative distribution
   * function bends between the linear-ish region in the middle and the
   * exponential-ish region. When the distribution is used to compute
   * percentiles for log-normal random processes such as latency, as the latency
   * improves, it hits a point of diminishing returns, when it becomes
   * relatively difficult to improve the score further. This point of
   * diminishing returns is the first x-intercept of the third derivative of the
   * CDF, which is the second derivative of the PDF.
   *
   * https://www.desmos.com/calculator/cg5rnftabn
   *
   * @param {number} median The median of the distribution.
   * @param {number} diminishingReturns The point of diminishing returns.
   * @return {LogNormalDistribution}
   */
  Statistics.LogNormalDistribution.fromMedianAndDiminishingReturns = function (median, diminishingReturns) {
    diminishingReturns = Math.log(diminishingReturns / median);
    var shape = Math.sqrt(1 - 3 * diminishingReturns - Math.sqrt(Math.pow(diminishingReturns - 3, 2) - 8)) / 2;
    var location = Math.log(median);
    return new Statistics.LogNormalDistribution(location, shape);
  };

  // p-values less than this indicate statistical significance.
  Statistics.DEFAULT_ALPHA = 0.05;

  /** @enum */
  Statistics.Significance = {
    INSIGNIFICANT: -1,
    DONT_CARE: 0,
    SIGNIFICANT: 1
  };

  /**
   * @typedef {Object} HypothesisTestResult
   * @property {number} p
   * @property {number} U
   * @property {!tr.b.Statistics.Significance} significance
   */

  /**
   * @param {!Array.<number>} a
   * @param {!Array.<number>} b
   * @param {number=} opt_alpha
   * @return {!HypothesisTestResult}
   */
  Statistics.mwu = function (a, b, opt_alpha) {
    var result = mannwhitneyu.test(a, b);
    var alpha = opt_alpha || Statistics.DEFAULT_ALPHA;
    result.significance = result.p < alpha ? Statistics.Significance.SIGNIFICANT : Statistics.Significance.INSIGNIFICANT;
    return result;
  };

  return {
    Statistics: Statistics
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./math.js":42,"./range.js":47}],54:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./raf.js");
require("./timing.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var Timing = tr.b.Timing;
  /**
   * A task is a combination of a run callback, a set of subtasks, and an after
   * task.
   *
   * When executed, a task does the following things:
   * 1. Runs its callback
   * 2. Runs its subtasks
   * 3. Runs its after callback.
   *
   * The list of subtasks and after task can be mutated inside step #1 but as
   * soon as the task's callback returns, the subtask list and after task is
   * fixed and cannot be changed again.
   *
   * Use task.after().after().after() to describe the toplevel passes that make
   * up your computation. Then, use subTasks to add detail to each subtask as it
   * runs. For example:
   *    var pieces = [];
   *    taskA = new Task(function() { pieces = getPieces(); });
   *    taskA.after(function(taskA) {
   *      pieces.forEach(function(piece) {
   *        taskA.subTask(function(taskB) { piece.process(); }, this);
   *      });
   *    });
   *
   * @constructor
   */
  function Task(runCb, thisArg) {
    if (runCb !== undefined && thisArg === undefined) throw new Error('Almost certainly, you meant to pass a thisArg.');
    this.runCb_ = runCb;
    this.thisArg_ = thisArg;
    this.afterTask_ = undefined;
    this.subTasks_ = [];
  }

  Task.prototype = {
    get name() {
      return this.runCb_.name;
    },

    /*
     * See constructor documentation on semantics of subtasks.
     */
    subTask: function (cb, thisArg) {
      if (cb instanceof Task) this.subTasks_.push(cb);else this.subTasks_.push(new Task(cb, thisArg));
      return this.subTasks_[this.subTasks_.length - 1];
    },

    /**
     * Runs the current task and returns the task that should be executed next.
     */
    run: function () {
      if (this.runCb_ !== undefined) this.runCb_.call(this.thisArg_, this);
      var subTasks = this.subTasks_;
      this.subTasks_ = undefined; // Prevent more subTasks from being posted.

      if (!subTasks.length) return this.afterTask_;

      // If there are subtasks, then we want to execute all the subtasks and
      // then this task's afterTask. To make this happen, we update the
      // afterTask of all the subtasks so the point upward to each other, e.g.
      // subTask[0].afterTask to subTask[1] and so on. Then, the last subTask's
      // afterTask points at this task's afterTask.
      for (var i = 1; i < subTasks.length; i++) subTasks[i - 1].afterTask_ = subTasks[i];
      subTasks[subTasks.length - 1].afterTask_ = this.afterTask_;
      return subTasks[0];
    },

    /*
     * See constructor documentation on semantics of after tasks.
     */
    after: function (cb, thisArg) {
      if (this.afterTask_) throw new Error('Has an after task already');
      if (cb instanceof Task) this.afterTask_ = cb;else this.afterTask_ = new Task(cb, thisArg);
      return this.afterTask_;
    },

    /*
     * See constructor documentation on semantics of after tasks.
     * Note: timedAfter doesn't work when a task throws an exception.
     * This is because task system doesn't support catching currently.
     * At the time of writing, this is considered to be an acceptable tradeoff.
     */
    timedAfter: function (groupName, cb, thisArg, opt_args) {
      if (cb.name === '') throw new Error('Anonymous Task is not allowed');
      return this.namedTimedAfter(groupName, cb.name, cb, thisArg, opt_args);
    },

    /*
     * See constructor documentation on semantics of after tasks.
     * Note: namedTimedAfter doesn't work when a task throws an exception.
     * This is because task system doesn't support catching currently.
     * At the time of writing, this is considered to be an acceptable tradeoff.
     */
    namedTimedAfter: function (groupName, name, cb, thisArg, opt_args) {
      if (this.afterTask_) throw new Error('Has an after task already');
      var realTask;
      if (cb instanceof Task) realTask = cb;else realTask = new Task(cb, thisArg);
      this.afterTask_ = new Task(function (task) {
        var markedTask = Timing.mark(groupName, name, opt_args);
        task.subTask(realTask, thisArg);
        task.subTask(function () {
          markedTask.end();
        }, thisArg);
      }, thisArg);
      return this.afterTask_;
    },

    /*
     * Adds a task after the chain of tasks.
     */
    enqueue: function (cb, thisArg) {
      var lastTask = this;
      while (lastTask.afterTask_) lastTask = lastTask.afterTask_;
      return lastTask.after(cb, thisArg);
    }
  };

  Task.RunSynchronously = function (task) {
    var curTask = task;
    while (curTask) curTask = curTask.run();
  };

  /**
   * Runs a task using raf.requestIdleCallback, returning
   * a promise for its completion.
   */
  Task.RunWhenIdle = function (task) {
    return new Promise(function (resolve, reject) {
      var curTask = task;
      function runAnother() {
        try {
          curTask = curTask.run();
        } catch (e) {
          reject(e);
          console.error(e.stack);
          return;
        }

        if (curTask) {
          tr.b.requestIdleCallback(runAnother);
          return;
        }

        resolve();
      }
      tr.b.requestIdleCallback(runAnother);
    });
  };

  return {
    Task: Task
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./raf.js":46,"./timing.js":56}],55:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./unit_scale.js");

'use strict';

/**
 * @fileoverview Time currentDisplayUnit
 */
global.tr.exportTo('tr.b', function () {
  var msDisplayMode = {
    scale: 1e-3,
    suffix: 'ms',
    // Compares a < b with adjustments to precision errors.
    roundedLess: function (a, b) {
      return Math.round(a * 1000) < Math.round(b * 1000);
    },
    formatSpec: {
      unit: 's',
      unitPrefix: tr.b.UnitScale.Metric.MILLI,
      minimumFractionDigits: 3
    }
  };

  var nsDisplayMode = {
    scale: 1e-9,
    suffix: 'ns',
    // Compares a < b with adjustments to precision errors.
    roundedLess: function (a, b) {
      return Math.round(a * 1000000) < Math.round(b * 1000000);
    },
    formatSpec: {
      unit: 's',
      unitPrefix: tr.b.UnitScale.Metric.NANO,
      maximumFractionDigits: 0
    }
  };

  var TimeDisplayModes = {
    ns: nsDisplayMode,
    ms: msDisplayMode
  };

  return {
    TimeDisplayModes: TimeDisplayModes
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./unit_scale.js":58}],56:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");
require("./base64.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var Base64 = tr.b.Base64;

  function computeUserTimingMarkName(groupName, functionName, opt_args) {
    if (groupName === undefined) throw new Error('getMeasureString should have group name');
    if (functionName === undefined) throw new Error('getMeasureString should have function name');
    var userTimingMarkName = groupName + ':' + functionName;
    if (opt_args !== undefined) {
      userTimingMarkName += '/';
      userTimingMarkName += Base64.btoa(JSON.stringify(opt_args));
    }
    return userTimingMarkName;
  }

  function Timing() {}

  Timing.nextMarkNumber = 0;

  Timing.mark = function (groupName, functionName, opt_args) {
    if (tr.isHeadless) {
      return {
        end: function () {}
      };
    }
    var userTimingMarkName = computeUserTimingMarkName(groupName, functionName, opt_args);
    var markBeginName = 'tvcm.mark' + Timing.nextMarkNumber++;
    var markEndName = 'tvcm.mark' + Timing.nextMarkNumber++;
    window.performance.mark(markBeginName);
    return {
      end: function () {
        window.performance.mark(markEndName);
        window.performance.measure(userTimingMarkName, markBeginName, markEndName);
      }
    };
  };

  Timing.wrap = function (groupName, callback, opt_args) {
    if (groupName === undefined) throw new Error('Timing.wrap should have group name');
    if (callback.name === '') throw new Error('Anonymous function is not allowed');
    return Timing.wrapNamedFunction(groupName, callback.name, callback, opt_args);
  };

  Timing.wrapNamedFunction = function (groupName, functionName, callback, opt_args) {
    function timedNamedFunction() {
      var markedTime = Timing.mark(groupName, functionName, opt_args);
      try {
        callback.apply(this, arguments);
      } finally {
        markedTime.end();
      }
    }
    return timedNamedFunction;
  };

  function TimedNamedPromise(groupName, name, executor, opt_args) {
    var markedTime = Timing.mark(groupName, name, opt_args);
    var promise = new Promise(executor);
    promise.then(function (result) {
      markedTime.end();
      return result;
    }, function (e) {
      markedTime.end();
      throw e;
    });
    return promise;
  }

  return {
    _computeUserTimingMarkName: computeUserTimingMarkName, // export for testing
    TimedNamedPromise: TimedNamedPromise,
    Timing: Timing
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28,"./base64.js":29}],57:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./event.js");
require("./event_target.js");
require("./iteration_helpers.js");
require("./time_display_modes.js");
require("./unit_scale.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  var TimeDisplayModes = tr.b.TimeDisplayModes;

  var PLUS_MINUS_SIGN = String.fromCharCode(177);

  function max(a, b) {
    if (a === undefined) return b;
    if (b === undefined) return a;
    return a.scale > b.scale ? a : b;
  }

  /** @enum */
  var ImprovementDirection = {
    DONT_CARE: 0,
    BIGGER_IS_BETTER: 1,
    SMALLER_IS_BETTER: 2
  };

  /** @constructor */
  function Unit(unitName, jsonName, basePrefix, isDelta, improvementDirection, formatSpec) {
    this.unitName = unitName;
    this.jsonName = jsonName;
    this.basePrefix = basePrefix;
    this.isDelta = isDelta;
    this.improvementDirection = improvementDirection;
    this.formatSpec_ = formatSpec;

    // Example: powerInWattsDelta_biggerIsBetter -> powerInWatts.
    this.baseUnit = undefined;

    // Example: energyInJoules_smallerIsBetter ->
    // energyInJoulesDelta_smallerIsBetter.
    this.correspondingDeltaUnit = undefined;
  }

  Unit.prototype = {
    asJSON: function () {
      return this.jsonName;
    },

    get unitString() {
      // TODO(benjhayden): Refactor with format() and test.
      var formatSpec = this.formatSpec_;
      if (typeof formatSpec === 'function') formatSpec = formatSpec();
      if (!formatSpec.unit) {
        return '';
      }

      var unitString = '';
      var unitPrefix = formatSpec.unitPrefix;
      if (unitPrefix !== undefined) {
        var selectedPrefix;
        if (unitPrefix instanceof Array) {
          selectedPrefix = unitPrefix[0];
        } else {
          selectedPrefix = unitPrefix;
        }
        unitString += selectedPrefix.symbol || '';
      }
      unitString += formatSpec.unit;

      return unitString;
    },

    format: function (value, opt_context) {
      var context = opt_context || {};
      var formatSpec = this.formatSpec_;
      if (typeof formatSpec === 'function') formatSpec = formatSpec();

      function resolveProperty(propertyName) {
        if (propertyName in context) return context[propertyName];else if (propertyName in formatSpec) return formatSpec[propertyName];else return undefined;
      }

      var signString = '';
      if (value < 0) {
        signString = '-';
        value = -value; // Treat positive and negative values symmetrically.
      } else if (this.isDelta) {
        signString = value === 0 ? PLUS_MINUS_SIGN : '+';
      }

      var unitString = '';
      if (formatSpec.unit) {
        if (formatSpec.unitHasPrecedingSpace !== false) unitString += ' ';
        var unitPrefix = resolveProperty('unitPrefix');
        if (unitPrefix !== undefined) {
          var selectedPrefix;
          if (unitPrefix instanceof Array) {
            var i = 0;
            while (i < unitPrefix.length - 1 && value / unitPrefix[i + 1].value >= 1) {
              i++;
            }
            selectedPrefix = unitPrefix[i];
          } else {
            selectedPrefix = unitPrefix;
          }
          unitString += selectedPrefix.symbol || '';
          value = tr.b.convertUnit(value, this.basePrefix, selectedPrefix);
        } else {
          value = tr.b.convertUnit(value, this.basePrefix, tr.b.UnitScale.Metric.NONE);
        }
        unitString += formatSpec.unit;
      }

      var minimumFractionDigits = resolveProperty('minimumFractionDigits');
      var maximumFractionDigits = resolveProperty('maximumFractionDigits');

      // If the context overrides only one of the two |*FractionDigits|
      // properties and the other one is provided by the unit, we might need to
      // shift the other property so that
      // |minimumFractionDigits| <= |maximumFractionDigits|.
      if (minimumFractionDigits > maximumFractionDigits) {
        if ('minimumFractionDigits' in context && !('maximumFractionDigits' in context)) {
          // Only minimumFractionDigits was overriden by context.
          maximumFractionDigits = minimumFractionDigits;
        } else if ('maximumFractionDigits' in context && !('minimumFractionDigits' in context)) {
          // Only maximumFractionDigits was overriden by context.
          minimumFractionDigits = maximumFractionDigits;
        }
      }

      var numberString = value.toLocaleString(undefined, {
        minimumFractionDigits: minimumFractionDigits,
        maximumFractionDigits: maximumFractionDigits
      });

      return signString + numberString + unitString;
    }
  };

  Unit.reset = function () {
    Unit.currentTimeDisplayMode = TimeDisplayModes.ms;
  };

  Unit.timestampFromUs = function (us) {
    return tr.b.convertUnit(us, tr.b.UnitScale.Metric.MICRO, tr.b.UnitScale.Metric.MILLI);
  };

  Object.defineProperty(Unit, 'currentTimeDisplayMode', {
    get: function () {
      return Unit.currentTimeDisplayMode_;
    },
    // Use tr-v-ui-preferred-display-unit element instead of directly setting.
    set: function (value) {
      if (Unit.currentTimeDisplayMode_ === value) return;

      Unit.currentTimeDisplayMode_ = value;
      Unit.dispatchEvent(new tr.b.Event('display-mode-changed'));
    }
  });

  Unit.didPreferredTimeDisplayUnitChange = function () {
    var largest = undefined;
    var els = tr.b.findDeepElementsMatching(document.body, 'tr-v-ui-preferred-display-unit');
    els.forEach(function (el) {
      largest = max(largest, el.preferredTimeDisplayMode);
    });

    Unit.currentDisplayUnit = largest === undefined ? TimeDisplayModes.ms : largest;
  };

  Unit.byName = {};
  Unit.byJSONName = {};

  Unit.fromJSON = function (object) {
    var u = Unit.byJSONName[object];
    if (u) {
      return u;
    }
    throw new Error('Unrecognized unit');
  };

  /**
   * Define all combinations of a unit with isDelta and improvementDirection
   * flags. For example, the following code:
   *
   *   Unit.define({
   *     baseUnitName: 'powerInWatts'
   *     baseJsonName: 'W'
   *     formatSpec: {
   *       // Specification of how the unit should be formatted (unit symbol,
   *       // unit prefix, fraction digits, etc), or a function returning such
   *       // a specification.
   *     }
   *   });
   *
   * generates the following six units (JSON names shown in parentheses):
   *
   *   Unit.byName.powerInWatts (W)
   *   Unit.byName.powerInWatts_smallerIsBetter (W_smallerIsBetter)
   *   Unit.byName.powerInWatts_biggerIsBetter (W_biggerIsBetter)
   *   Unit.byName.powerInWattsDelta (WDelta)
   *   Unit.byName.powerInWattsDelta_smallerIsBetter (WDelta_smallerIsBetter)
   *   Unit.byName.powerInWattsDelta_biggerIsBetter (WDelta_biggerIsBetter)
   *
   * with the appropriate flags and formatting code (including +/- prefixes
   * for deltas).
   */
  Unit.define = function (params) {
    var definedUnits = [];

    tr.b.iterItems(ImprovementDirection, function (_, improvementDirection) {
      var regularUnit = Unit.defineUnitVariant_(params, false, improvementDirection);
      var deltaUnit = Unit.defineUnitVariant_(params, true, improvementDirection);

      regularUnit.correspondingDeltaUnit = deltaUnit;
      deltaUnit.correspondingDeltaUnit = deltaUnit;
      definedUnits.push(regularUnit, deltaUnit);
    });

    var baseUnit = Unit.byName[params.baseUnitName];
    definedUnits.forEach(u => u.baseUnit = baseUnit);
  };

  Unit.nameSuffixForImprovementDirection = function (improvementDirection) {
    switch (improvementDirection) {
      case ImprovementDirection.DONT_CARE:
        return '';
      case ImprovementDirection.BIGGER_IS_BETTER:
        return '_biggerIsBetter';
      case ImprovementDirection.SMALLER_IS_BETTER:
        return '_smallerIsBetter';
      default:
        throw new Error('Unknown improvement direction: ' + improvementDirection);
    }
  };

  Unit.defineUnitVariant_ = function (params, isDelta, improvementDirection) {
    var nameSuffix = isDelta ? 'Delta' : '';
    nameSuffix += Unit.nameSuffixForImprovementDirection(improvementDirection);

    var unitName = params.baseUnitName + nameSuffix;
    var jsonName = params.baseJsonName + nameSuffix;
    if (Unit.byName[unitName] !== undefined) throw new Error('Unit \'' + unitName + '\' already exists');
    if (Unit.byJSONName[jsonName] !== undefined) throw new Error('JSON unit \'' + jsonName + '\' alread exists');

    var basePrefix = params.basePrefix ? params.basePrefix : tr.b.UnitScale.Metric.NONE;
    var unit = new Unit(unitName, jsonName, basePrefix, isDelta, improvementDirection, params.formatSpec);
    Unit.byName[unitName] = unit;
    Unit.byJSONName[jsonName] = unit;

    return unit;
  };

  tr.b.EventTarget.decorate(Unit);
  Unit.reset();

  // Known display units follow.
  //////////////////////////////////////////////////////////////////////////////

  Unit.define({
    baseUnitName: 'timeDurationInMs',
    baseJsonName: 'ms',
    basePrefix: tr.b.UnitScale.Metric.MILLI,
    formatSpec: function () {
      return Unit.currentTimeDisplayMode_.formatSpec;
    }
  });

  Unit.define({
    baseUnitName: 'timeStampInMs',
    baseJsonName: 'tsMs',
    basePrefix: tr.b.UnitScale.Metric.MILLI,
    formatSpec: function () {
      return Unit.currentTimeDisplayMode_.formatSpec;
    }
  });

  Unit.define({
    baseUnitName: 'normalizedPercentage',
    baseJsonName: 'n%',
    formatSpec: {
      unit: '%',
      unitPrefix: { value: 0.01 },
      unitHasPrecedingSpace: false,
      minimumFractionDigits: 3,
      maximumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'sizeInBytes',
    baseJsonName: 'sizeInBytes',
    formatSpec: {
      unit: 'B',
      unitPrefix: tr.b.UnitScale.Binary.AUTO,
      minimumFractionDigits: 1,
      maximumFractionDigits: 1
    }
  });

  Unit.define({
    baseUnitName: 'energyInJoules',
    baseJsonName: 'J',
    formatSpec: {
      unit: 'J',
      minimumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'powerInWatts',
    baseJsonName: 'W',
    formatSpec: {
      unit: 'W',
      minimumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'unitlessNumber',
    baseJsonName: 'unitless',
    formatSpec: {
      minimumFractionDigits: 3,
      maximumFractionDigits: 3
    }
  });

  Unit.define({
    baseUnitName: 'count',
    baseJsonName: 'count',
    formatSpec: {
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }
  });

  Unit.define({
    baseUnitName: 'sigma',
    baseJsonName: 'sigma',
    formatSpec: {
      unit: String.fromCharCode(963),
      minimumFractionDigits: 1,
      maximumFractionDigits: 1
    }
  });

  return {
    ImprovementDirection: ImprovementDirection,
    Unit: Unit
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./event.js":33,"./event_target.js":34,"./iteration_helpers.js":41,"./time_display_modes.js":55,"./unit_scale.js":58}],58:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./iteration_helpers.js");

'use strict';

var GREEK_SMALL_LETTER_MU = String.fromCharCode(956);

global.tr.exportTo('tr.b', function () {

  var UnitScale = {};

  function defineUnitScale(name, prefixes) {
    if (UnitScale[name] !== undefined) throw new Error('Unit scale \'' + name + '\' already exists');
    if (prefixes.AUTO !== undefined) {
      throw new Error('\'AUTO\' unit prefix will be added automatically ' + 'for unit scale \'' + name + '\'');
    }

    // If the 'AUTO' unit prefix is used, the prefix that results in
    // the absolute formatted value being as close to the [1, 1024) interval as
    // possible is used. Example: 1023 and 1024 bytes are displayed as
    // "1,023.0 B" and "1.0 KiB", respectively.
    prefixes.AUTO = tr.b.dictionaryValues(prefixes);
    prefixes.AUTO.sort((a, b) => a.value - b.value);

    UnitScale[name] = prefixes;
  }

  /**
   * Converts |value| from |fromPrefix| (e.g. kilo) to |toPrefix| (e.g. mega).
   *
   * Returns undefined if |value| is undefined.
   * |fromPrefix| and |toPrefix| need not come from the same UnitScale.
   *
   * @param {(undefined|number)} value
   * @param {!object} fromPrefix
   * @param {!object} toPrefix
   * @return {(undefined|number)}
   */
  function convertUnit(value, fromPrefix, toPrefix) {
    if (value === undefined) return undefined;
    return value * (fromPrefix.value / toPrefix.value);
  }

  // See https://en.wikipedia.org/wiki/Binary_prefix.
  defineUnitScale('Binary', {
    NONE: { value: Math.pow(1024, 0), symbol: '' },
    KIBI: { value: Math.pow(1024, 1), symbol: 'Ki' },
    MEBI: { value: Math.pow(1024, 2), symbol: 'Mi' },
    GIBI: { value: Math.pow(1024, 3), symbol: 'Gi' },
    TEBI: { value: Math.pow(1024, 4), symbol: 'Ti' }
  });

  // See https://en.wikipedia.org/wiki/Metric_prefix.
  defineUnitScale('Metric', {
    NANO: { value: 1e-9, symbol: 'n' },
    MICRO: { value: 1e-6, symbol: GREEK_SMALL_LETTER_MU },
    MILLI: { value: 1e-3, symbol: 'm' },
    NONE: { value: 1, symbol: '' },
    KILO: { value: 1e3, symbol: 'k' },
    MEGA: { value: 1e6, symbol: 'M' },
    GIGA: { value: 1e9, symbol: 'G' }
  });

  return {
    UnitScale: UnitScale,
    convertUnit: convertUnit
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./iteration_helpers.js":41}],59:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./base.js");

'use strict';

global.tr.exportTo('tr.b', function () {
  /**
   * Adds a {@code getInstance} static method that always return the same
   * instance object.
   * @param {!Function} ctor The constructor for the class to add the static
   *     method to.
   */
  function addSingletonGetter(ctor) {
    ctor.getInstance = function () {
      return ctor.instance_ || (ctor.instance_ = new ctor());
    };
  }

  function deepCopy(value) {
    if (!(value instanceof Object)) {
      if (value === undefined || value === null) return value;
      if (typeof value == 'string') return value.substring();
      if (typeof value == 'boolean') return value;
      if (typeof value == 'number') return value;
      throw new Error('Unrecognized: ' + typeof value);
    }

    var object = value;
    if (object instanceof Array) {
      var res = new Array(object.length);
      for (var i = 0; i < object.length; i++) res[i] = deepCopy(object[i]);
      return res;
    }

    if (object.__proto__ != Object.prototype) throw new Error('Can only clone simple types');
    var res = {};
    for (var key in object) {
      res[key] = deepCopy(object[key]);
    }
    return res;
  }

  function normalizeException(e) {
    if (e === undefined || e === null) {
      return {
        typeName: 'UndefinedError',
        message: 'Unknown: null or undefined exception',
        stack: 'Unknown'
      };
    }

    if (typeof e == 'string') {
      return {
        typeName: 'StringError',
        message: e,
        stack: [e]
      };
    }

    var typeName;
    if (e.name) {
      typeName = e.name;
    } else if (e.constructor) {
      if (e.constructor.name) {
        typeName = e.constructor.name;
      } else {
        typeName = 'AnonymousError';
      }
    } else {
      typeName = 'ErrorWithNoConstructor';
    }

    var msg = e.message ? e.message : 'Unknown';
    return {
      typeName: typeName,
      message: msg,
      stack: e.stack ? e.stack : [msg]
    };
  }

  function stackTraceAsString() {
    return new Error().stack + '';
  }
  function stackTrace() {
    var stack = stackTraceAsString();
    stack = stack.split('\n');
    return stack.slice(2);
  }

  function getUsingPath(path, fromDict) {
    var parts = path.split('.');
    var cur = fromDict;

    for (var part; parts.length && (part = parts.shift());) {
      if (!parts.length) {
        return cur[part];
      } else if (part in cur) {
        cur = cur[part];
      } else {
        return undefined;
      }
    }
    return undefined;
  }

  /**
   * Format date as a string "YYYY-MM-DD HH:mm:ss". The timezone is implicitly
   * UTC. This format is based on the ISO format, but without milliseconds and
   * the 'T' is replaced with a space for legibility.
   *
   * @param {!Date} date
   * @return {string}
   */
  function formatDate(date) {
    return date.toISOString().replace('T', ' ').slice(0, 19);
  }

  return {
    addSingletonGetter: addSingletonGetter,

    deepCopy: deepCopy,

    normalizeException: normalizeException,
    stackTrace: stackTrace,
    stackTraceAsString: stackTraceAsString,
    formatDate: formatDate,

    getUsingPath: getUsingPath
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./base.js":28}],60:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/extension_registry.js");

'use strict';

/**
 * @fileoverview Base class for auditors.
 */
global.tr.exportTo('tr.c', function () {
  function Auditor(model) {
    this.model_ = model;
  }

  Auditor.prototype = {
    __proto__: Object.prototype,

    get model() {
      return this.model_;
    },

    /**
     * Called by the Model after baking slices. May modify model.
     */
    runAnnotate: function () {},

    /**
     * Called by import to install userFriendlyCategoryDriver.
     */
    installUserFriendlyCategoryDriverIfNeeded: function () {},

    /**
     * Called by the Model after importing. Should not modify model, except
     * for adding interaction ranges and audits.
     */
    runAudit: function () {}
  };

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Auditor;
  tr.b.decorateExtensionRegistry(Auditor, options);

  return {
    Auditor: Auditor
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/extension_registry.js":35}],61:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

global.tr.exportTo('tr.c', function () {
  function makeCaseInsensitiveRegex(pattern) {
    // See https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/
    // Regular_Expressions.
    pattern = pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return new RegExp(pattern, 'i');
  }

  /**
   * @constructor The generic base class for filtering a Model based on
   * various rules. The base class returns true for everything.
   */
  function Filter() {}

  Filter.prototype = {
    __proto__: Object.prototype,

    matchCounter: function (counter) {
      return true;
    },

    matchCpu: function (cpu) {
      return true;
    },

    matchProcess: function (process) {
      return true;
    },

    matchSlice: function (slice) {
      return true;
    },

    matchThread: function (thread) {
      return true;
    }
  };

  /**
   * @constructor A filter that matches objects by their name or category
   * case insensitive.
   * .findAllObjectsMatchingFilter
   */
  function TitleOrCategoryFilter(text) {
    Filter.call(this);
    this.regex_ = makeCaseInsensitiveRegex(text);

    if (!text.length) throw new Error('Filter text is empty.');
  }
  TitleOrCategoryFilter.prototype = {
    __proto__: Filter.prototype,

    matchSlice: function (slice) {
      if (slice.title === undefined && slice.category === undefined) return false;

      return this.regex_.test(slice.title) || !!slice.category && this.regex_.test(slice.category);
    }
  };

  /**
   * @constructor A filter that matches objects with the exact given title.
   */
  function ExactTitleFilter(text) {
    Filter.call(this);
    this.text_ = text;

    if (!text.length) throw new Error('Filter text is empty.');
  }
  ExactTitleFilter.prototype = {
    __proto__: Filter.prototype,

    matchSlice: function (slice) {
      return slice.title === this.text_;
    }
  };

  /**
   * @constructor A filter that matches objects by their full text contents
   * (title, category, args). Note that for performance this filter applies a
   * regex against all the keys of the slice arguments instead of recursing
   * through any embedded sub-objects.
   */
  function FullTextFilter(text) {
    Filter.call(this);
    this.regex_ = makeCaseInsensitiveRegex(text);
    this.titleOrCategoryFilter_ = new TitleOrCategoryFilter(text);
  }
  FullTextFilter.prototype = {
    __proto__: Filter.prototype,

    matchObject_: function (obj) {
      for (var key in obj) {
        if (!obj.hasOwnProperty(key)) continue;
        if (this.regex_.test(key)) return true;
        if (this.regex_.test(obj[key])) return true;
      }
      return false;
    },

    matchSlice: function (slice) {
      if (this.titleOrCategoryFilter_.matchSlice(slice)) return true;
      return this.matchObject_(slice.args);
    }
  };

  return {
    Filter: Filter,
    TitleOrCategoryFilter: TitleOrCategoryFilter,
    ExactTitleFilter: ExactTitleFilter,
    FullTextFilter: FullTextFilter
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],62:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../../model/async_slice.js");
require("../../../model/event_set.js");
require("../../../model/helpers/chrome_model_helper.js");

'use strict';

global.tr.exportTo('tr.e.cc', function () {
  var AsyncSlice = tr.model.AsyncSlice;
  var EventSet = tr.model.EventSet;

  var UI_COMP_NAME = 'INPUT_EVENT_LATENCY_UI_COMPONENT';
  var ORIGINAL_COMP_NAME = 'INPUT_EVENT_LATENCY_ORIGINAL_COMPONENT';
  var BEGIN_COMP_NAME = 'INPUT_EVENT_LATENCY_BEGIN_RWH_COMPONENT';
  var END_COMP_NAME = 'INPUT_EVENT_LATENCY_TERMINATED_FRAME_SWAP_COMPONENT';

  var MAIN_RENDERER_THREAD_NAME = 'CrRendererMain';
  var COMPOSITOR_THREAD_NAME = 'Compositor';

  var POSTTASK_FLOW_EVENT = 'disabled-by-default-toplevel.flow';
  var IPC_FLOW_EVENT = 'disabled-by-default-ipc.flow';

  var INPUT_EVENT_TYPE_NAMES = {
    CHAR: 'Char',
    CLICK: 'GestureClick',
    CONTEXT_MENU: 'ContextMenu',
    FLING_CANCEL: 'GestureFlingCancel',
    FLING_START: 'GestureFlingStart',
    KEY_DOWN: 'KeyDown',
    KEY_DOWN_RAW: 'RawKeyDown',
    KEY_UP: 'KeyUp',
    LATENCY_SCROLL_UPDATE: 'ScrollUpdate',
    MOUSE_DOWN: 'MouseDown',
    MOUSE_ENTER: 'MouseEnter',
    MOUSE_LEAVE: 'MouseLeave',
    MOUSE_MOVE: 'MouseMove',
    MOUSE_UP: 'MouseUp',
    MOUSE_WHEEL: 'MouseWheel',
    PINCH_BEGIN: 'GesturePinchBegin',
    PINCH_END: 'GesturePinchEnd',
    PINCH_UPDATE: 'GesturePinchUpdate',
    SCROLL_BEGIN: 'GestureScrollBegin',
    SCROLL_END: 'GestureScrollEnd',
    SCROLL_UPDATE: 'GestureScrollUpdate',
    SCROLL_UPDATE_RENDERER: 'ScrollUpdate',
    SHOW_PRESS: 'GestureShowPress',
    TAP: 'GestureTap',
    TAP_CANCEL: 'GestureTapCancel',
    TAP_DOWN: 'GestureTapDown',
    TOUCH_CANCEL: 'TouchCancel',
    TOUCH_END: 'TouchEnd',
    TOUCH_MOVE: 'TouchMove',
    TOUCH_START: 'TouchStart',
    UNKNOWN: 'UNKNOWN'
  };

  function InputLatencyAsyncSlice() {
    AsyncSlice.apply(this, arguments);
    this.associatedEvents_ = new EventSet();
    this.typeName_ = undefined;
    if (!this.isLegacyEvent) this.determineModernTypeName_();
  }

  InputLatencyAsyncSlice.prototype = {
    __proto__: AsyncSlice.prototype,

    // Legacy InputLatencyAsyncSlices involve a top-level slice titled
    // "InputLatency" containing a subSlice whose title starts with
    // "InputLatency:". Modern InputLatencyAsyncSlices involve a single
    // top-level slice whose title starts with "InputLatency::".
    // Legacy subSlices are not available at construction time, so
    // determineLegacyTypeName_() must be called at get time.
    // So this returns false for the legacy subSlice events titled like
    // "InputLatency:Foo" even though they are technically legacy events.
    get isLegacyEvent() {
      return this.title === 'InputLatency';
    },

    get typeName() {
      if (!this.typeName_) this.determineLegacyTypeName_();
      return this.typeName_;
    },

    checkTypeName_: function () {
      if (!this.typeName_) throw 'Unable to determine typeName';
      var found = false;
      for (var typeName in INPUT_EVENT_TYPE_NAMES) {
        if (this.typeName === INPUT_EVENT_TYPE_NAMES[typeName]) {
          found = true;
          break;
        }
      }
      if (!found) this.typeName_ = INPUT_EVENT_TYPE_NAMES.UNKNOWN;
    },

    determineModernTypeName_: function () {
      // This method works both on modern events titled like
      // "InputLatency::Foo" and also on the legacy subSlices titled like
      // "InputLatency:Foo". Modern events' titles contain 2 colons, whereas the
      // legacy subSlices events contain 1 colon.

      var lastColonIndex = this.title.lastIndexOf(':');
      if (lastColonIndex < 0) return;

      var characterAfterLastColonIndex = lastColonIndex + 1;
      this.typeName_ = this.title.slice(characterAfterLastColonIndex);

      // Check that the determined typeName is known.
      this.checkTypeName_();
    },

    determineLegacyTypeName_: function () {
      // Iterate over all descendent subSlices.
      for (var subSlice of this.enumerateAllDescendents()) {

        // If |subSlice| is not an InputLatencyAsyncSlice, then ignore it.
        var subSliceIsAInputLatencyAsyncSlice = subSlice instanceof InputLatencyAsyncSlice;
        if (!subSliceIsAInputLatencyAsyncSlice) continue;

        // If |subSlice| does not have a typeName, then ignore it.
        if (!subSlice.typeName) continue;

        // If |this| already has a typeName and |subSlice| has a different
        // typeName, then explode!
        if (this.typeName_ && subSlice.typeName_) {
          var subSliceHasDifferentTypeName = this.typeName_ !== subSlice.typeName_;
          if (subSliceHasDifferentTypeName) {
            throw 'InputLatencyAsyncSlice.determineLegacyTypeName_() ' + ' found multiple typeNames';
          }
        }

        // The typeName of |this| top-level event is whatever the typeName of
        // |subSlice| is. Set |this.typeName_| to the subSlice's typeName.
        this.typeName_ = subSlice.typeName_;
      }

      // If typeName could not be determined, then explode!
      if (!this.typeName_) throw 'InputLatencyAsyncSlice.determineLegacyTypeName_() failed';

      // Check that the determined typeName is known.
      this.checkTypeName_();
    },

    getRendererHelper: function (sourceSlices) {
      var traceModel = this.startThread.parent.model;
      var modelHelper = traceModel.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
      if (!modelHelper) return undefined;

      var mainThread = undefined;
      var compositorThread = undefined;

      for (var i in sourceSlices) {
        if (sourceSlices[i].parentContainer.name === MAIN_RENDERER_THREAD_NAME) mainThread = sourceSlices[i].parentContainer;else if (sourceSlices[i].parentContainer.name === COMPOSITOR_THREAD_NAME) compositorThread = sourceSlices[i].parentContainer;

        if (mainThread && compositorThread) break;
      }

      var rendererHelpers = modelHelper.rendererHelpers;

      var pids = Object.keys(rendererHelpers);
      for (var i = 0; i < pids.length; i++) {
        var pid = pids[i];
        var rendererHelper = rendererHelpers[pid];
        if (rendererHelper.mainThread === mainThread || rendererHelper.compositorThread === compositorThread) return rendererHelper;
      }

      return undefined;
    },

    addEntireSliceHierarchy: function (slice) {
      this.associatedEvents_.push(slice);
      slice.iterateAllSubsequentSlices(function (subsequentSlice) {
        this.associatedEvents_.push(subsequentSlice);
      }, this);
    },

    addDirectlyAssociatedEvents: function (flowEvents) {
      var slices = [];

      flowEvents.forEach(function (flowEvent) {
        this.associatedEvents_.push(flowEvent);
        var newSource = flowEvent.startSlice.mostTopLevelSlice;
        if (slices.indexOf(newSource) === -1) slices.push(newSource);
      }, this);

      var lastFlowEvent = flowEvents[flowEvents.length - 1];
      var lastSource = lastFlowEvent.endSlice.mostTopLevelSlice;
      if (slices.indexOf(lastSource) === -1) slices.push(lastSource);

      return slices;
    },

    // Find the Latency::ScrollUpdate slice that corresponds to the
    // InputLatency::GestureScrollUpdate slice.
    // The C++ CL that makes this connection is at:
    // https://codereview.chromium.org/1178963003
    addScrollUpdateEvents: function (rendererHelper) {
      if (!rendererHelper || !rendererHelper.compositorThread) return;

      var compositorThread = rendererHelper.compositorThread;
      var gestureScrollUpdateStart = this.start;
      var gestureScrollUpdateEnd = this.end;

      var allCompositorAsyncSlices = compositorThread.asyncSliceGroup.slices;

      for (var i in allCompositorAsyncSlices) {
        var slice = allCompositorAsyncSlices[i];

        if (slice.title !== 'Latency::ScrollUpdate') continue;

        var parentId = slice.args.data.INPUT_EVENT_LATENCY_FORWARD_SCROLL_UPDATE_TO_MAIN_COMPONENT.sequence_number;

        if (parentId === undefined) {
          // Old trace, we can only rely on the timestamp to find the slice
          if (slice.start < gestureScrollUpdateStart || slice.start >= gestureScrollUpdateEnd) continue;
        } else {
          // New trace, we can definitively find the latency slice by comparing
          // its sequence number with gesture id
          if (parseInt(parentId) !== parseInt(this.id)) continue;
        }

        slice.associatedEvents.forEach(function (event) {
          this.associatedEvents_.push(event);
        }, this);
        break;
      }
    },

    // Return true if the slice hierarchy is tracked by LatencyInfo of other
    // input latency events. If the slice hierarchy is tracked by both, this
    // function still returns true.
    belongToOtherInputs: function (slice, flowEvents) {
      var fromOtherInputs = false;

      slice.iterateEntireHierarchy(function (subsequentSlice) {
        if (fromOtherInputs) return;

        subsequentSlice.inFlowEvents.forEach(function (inflow) {
          if (fromOtherInputs) return;

          if (inflow.category.indexOf('input') > -1) {
            if (flowEvents.indexOf(inflow) === -1) fromOtherInputs = true;
          }
        }, this);
      }, this);

      return fromOtherInputs;
    },

    // Return true if |event| triggers slices of other inputs.
    triggerOtherInputs: function (event, flowEvents) {
      if (event.outFlowEvents === undefined || event.outFlowEvents.length === 0) return false;

      // Once we fix the bug of flow event binding, there should exist one and
      // only one outgoing flow (PostTask) from ScheduleBeginImplFrameDeadline
      // and PostComposite.
      var flow = event.outFlowEvents[0];

      if (flow.category !== POSTTASK_FLOW_EVENT || !flow.endSlice) return false;

      var endSlice = flow.endSlice;
      if (this.belongToOtherInputs(endSlice.mostTopLevelSlice, flowEvents)) return true;

      return false;
    },

    // Follow outgoing flow of subsequentSlices in the current hierarchy.
    // We also handle cases where different inputs interfere with each other.
    followSubsequentSlices: function (event, queue, visited, flowEvents) {
      var stopFollowing = false;
      var inputAck = false;

      event.iterateAllSubsequentSlices(function (slice) {
        if (stopFollowing) return;

        // Do not follow TaskQueueManager::RunTask because it causes
        // many false events to be included.
        if (slice.title === 'TaskQueueManager::RunTask') return;

        // Do not follow ScheduledActionSendBeginMainFrame because the real
        // main thread BeginMainFrame is already traced by LatencyInfo flow.
        if (slice.title === 'ThreadProxy::ScheduledActionSendBeginMainFrame') return;

        // Do not follow ScheduleBeginImplFrameDeadline that triggers an
        // OnBeginImplFrameDeadline that is tracked by another LatencyInfo.
        if (slice.title === 'Scheduler::ScheduleBeginImplFrameDeadline') {
          if (this.triggerOtherInputs(slice, flowEvents)) return;
        }

        // Do not follow PostComposite that triggers CompositeImmediately
        // that is tracked by another LatencyInfo.
        if (slice.title === 'CompositorImpl::PostComposite') {
          if (this.triggerOtherInputs(slice, flowEvents)) return;
        }

        // Stop following the rest of the current slice hierarchy if
        // FilterAndSendWebInputEvent occurs after ProcessInputEventAck.
        if (slice.title === 'InputRouterImpl::ProcessInputEventAck') inputAck = true;
        if (inputAck && slice.title === 'InputRouterImpl::FilterAndSendWebInputEvent') stopFollowing = true;

        this.followCurrentSlice(slice, queue, visited);
      }, this);
    },

    // Follow outgoing flow events of the current slice.
    followCurrentSlice: function (event, queue, visited) {
      event.outFlowEvents.forEach(function (outflow) {
        if ((outflow.category === POSTTASK_FLOW_EVENT || outflow.category === IPC_FLOW_EVENT) && outflow.endSlice) {
          this.associatedEvents_.push(outflow);

          var nextEvent = outflow.endSlice.mostTopLevelSlice;
          if (!visited.contains(nextEvent)) {
            visited.push(nextEvent);
            queue.push(nextEvent);
          }
        }
      }, this);
    },

    backtraceFromDraw: function (beginImplFrame, visited) {
      var pendingEventQueue = [];
      pendingEventQueue.push(beginImplFrame.mostTopLevelSlice);

      while (pendingEventQueue.length !== 0) {
        var event = pendingEventQueue.pop();

        this.addEntireSliceHierarchy(event);

        // TODO(yuhao): For now, we backtrace all the way to the source input.
        // But is this really needed? I will have an entry in the design
        // doc to discuss this.
        event.inFlowEvents.forEach(function (inflow) {
          if (inflow.category === POSTTASK_FLOW_EVENT && inflow.startSlice) {
            var nextEvent = inflow.startSlice.mostTopLevelSlice;
            if (!visited.contains(nextEvent)) {
              visited.push(nextEvent);
              pendingEventQueue.push(nextEvent);
            }
          }
        }, this);
      }
    },

    sortRasterizerSlices: function (rasterWorkerThreads, sortedRasterizerSlices) {
      rasterWorkerThreads.forEach(function (rasterizer) {
        Array.prototype.push.apply(sortedRasterizerSlices, rasterizer.sliceGroup.slices);
      }, this);

      sortedRasterizerSlices.sort(function (a, b) {
        if (a.start !== b.start) return a.start - b.start;
        return a.guid - b.guid;
      });
    },

    // Find rasterization slices that have the source_prepare_tiles_id
    // same as the prepare_tiles_id of TileManager::PrepareTiles
    // The C++ CL that makes this connection is at:
    // https://codereview.chromium.org/1208683002/
    addRasterizationEvents: function (prepareTiles, rendererHelper, visited, flowEvents, sortedRasterizerSlices) {
      if (!prepareTiles.args.prepare_tiles_id) return;

      if (!rendererHelper || !rendererHelper.rasterWorkerThreads) return;

      var rasterWorkerThreads = rendererHelper.rasterWorkerThreads;
      var prepareTileId = prepareTiles.args.prepare_tiles_id;
      var pendingEventQueue = [];

      // Collect all the rasterizer tasks. Return the cached copy if possible.
      if (sortedRasterizerSlices.length === 0) this.sortRasterizerSlices(rasterWorkerThreads, sortedRasterizerSlices);

      // TODO(yuhao): Once TaskSetFinishedTaskImpl also get the prepareTileId
      // we can simply track by checking id rather than counting.
      var numFinishedTasks = 0;
      var RASTER_TASK_TITLE = 'RasterizerTaskImpl::RunOnWorkerThread';
      var IMAGEDECODE_TASK_TITLE = 'ImageDecodeTaskImpl::RunOnWorkerThread';
      var FINISHED_TASK_TITLE = 'TaskSetFinishedTaskImpl::RunOnWorkerThread';

      for (var i = 0; i < sortedRasterizerSlices.length; i++) {
        var task = sortedRasterizerSlices[i];

        if (task.title === RASTER_TASK_TITLE || task.title === IMAGEDECODE_TASK_TITLE) {
          if (task.args.source_prepare_tiles_id === prepareTileId) this.addEntireSliceHierarchy(task.mostTopLevelSlice);
        } else if (task.title === FINISHED_TASK_TITLE) {
          if (task.start > prepareTiles.start) {
            pendingEventQueue.push(task.mostTopLevelSlice);
            if (++numFinishedTasks === 3) break;
          }
        }
      }

      // Trace PostTask from rasterizer tasks.
      while (pendingEventQueue.length != 0) {
        var event = pendingEventQueue.pop();

        this.addEntireSliceHierarchy(event);
        this.followSubsequentSlices(event, pendingEventQueue, visited, flowEvents);
      }
    },

    addOtherCausallyRelatedEvents: function (rendererHelper, sourceSlices, flowEvents, sortedRasterizerSlices) {
      var pendingEventQueue = [];
      // Keep track of visited nodes when traversing a DAG
      var visitedEvents = new EventSet();
      var beginImplFrame = undefined;
      var prepareTiles = undefined;
      var sortedRasterizerSlices = [];

      sourceSlices.forEach(function (sourceSlice) {
        if (!visitedEvents.contains(sourceSlice)) {
          visitedEvents.push(sourceSlice);
          pendingEventQueue.push(sourceSlice);
        }
      }, this);

      while (pendingEventQueue.length != 0) {
        var event = pendingEventQueue.pop();

        // Push the current event chunk into associatedEvents.
        this.addEntireSliceHierarchy(event);

        this.followCurrentSlice(event, pendingEventQueue, visitedEvents);

        this.followSubsequentSlices(event, pendingEventQueue, visitedEvents, flowEvents);

        // The rasterization work (CompositorTileWorker thread) and the
        // Compositor tile manager are connect by the prepare_tiles_id
        // instead of flow events.
        var COMPOSITOR_PREPARE_TILES = 'TileManager::PrepareTiles';
        prepareTiles = event.findDescendentSlice(COMPOSITOR_PREPARE_TILES);
        if (prepareTiles) this.addRasterizationEvents(prepareTiles, rendererHelper, visitedEvents, flowEvents, sortedRasterizerSlices);

        // OnBeginImplFrameDeadline could be triggered by other inputs.
        // For now, we backtrace from it.
        // TODO(yuhao): There are more such slices that we need to backtrace
        var COMPOSITOR_ON_BIFD = 'Scheduler::OnBeginImplFrameDeadline';
        beginImplFrame = event.findDescendentSlice(COMPOSITOR_ON_BIFD);
        if (beginImplFrame) this.backtraceFromDraw(beginImplFrame, visitedEvents);
      }

      // A separate pass on GestureScrollUpdate.
      // Scroll update doesn't go through the main thread, but the compositor
      // may go back to the main thread if there is an onscroll event handler.
      // This is captured by a different flow event, which does not have the
      // same ID as the Input Latency Event, but it is technically causally
      // related to the GestureScrollUpdate input. Add them manually for now.
      var INPUT_GSU = 'InputLatency::GestureScrollUpdate';
      if (this.title === INPUT_GSU) this.addScrollUpdateEvents(rendererHelper);
    },

    get associatedEvents() {
      if (this.associatedEvents_.length !== 0) return this.associatedEvents_;

      var modelIndices = this.startThread.parent.model.modelIndices;
      var flowEvents = modelIndices.getFlowEventsWithId(this.id);

      if (flowEvents.length === 0) return this.associatedEvents_;

      // Step 1: Get events that are directly connected by the LatencyInfo
      // flow events. This gives us a small set of events that are guaranteed
      // to be associated with the input, but are almost certain incomplete.
      // We call this set "source" event set.
      // This step returns the "source" event set (sourceSlices), which is then
      // used in the second step.
      var sourceSlices = this.addDirectlyAssociatedEvents(flowEvents);

      // Step 2: Start from the previously constructed "source" event set, we
      // follow the toplevel (i.e., PostTask) and IPC flow events. Any slices
      // that are reachable from the "source" event set via PostTasks or IPCs
      // are conservatively considered associated with the input event.
      // We then deal with specific cases where flow events either over include
      // or miss capturing slices.
      var rendererHelper = this.getRendererHelper(sourceSlices);
      this.addOtherCausallyRelatedEvents(rendererHelper, sourceSlices, flowEvents);

      return this.associatedEvents_;
    },

    get inputLatency() {
      if (!('data' in this.args)) return undefined;

      var data = this.args.data;
      if (!(END_COMP_NAME in data)) return undefined;

      var latency = 0;
      var endTime = data[END_COMP_NAME].time;
      if (ORIGINAL_COMP_NAME in data) {
        latency = endTime - data[ORIGINAL_COMP_NAME].time;
      } else if (UI_COMP_NAME in data) {
        latency = endTime - data[UI_COMP_NAME].time;
      } else if (BEGIN_COMP_NAME in data) {
        latency = endTime - data[BEGIN_COMP_NAME].time;
      } else {
        throw new Error('No valid begin latency component');
      }
      return latency;
    }
  };

  var eventTypeNames = ['Char', 'ContextMenu', 'GestureClick', 'GestureFlingCancel', 'GestureFlingStart', 'GestureScrollBegin', 'GestureScrollEnd', 'GestureScrollUpdate', 'GestureShowPress', 'GestureTap', 'GestureTapCancel', 'GestureTapDown', 'GesturePinchBegin', 'GesturePinchEnd', 'GesturePinchUpdate', 'KeyDown', 'KeyUp', 'MouseDown', 'MouseEnter', 'MouseLeave', 'MouseMove', 'MouseUp', 'MouseWheel', 'RawKeyDown', 'ScrollUpdate', 'TouchCancel', 'TouchEnd', 'TouchMove', 'TouchStart'];
  var allTypeNames = ['InputLatency'];
  eventTypeNames.forEach(function (eventTypeName) {
    // Old style.
    allTypeNames.push('InputLatency:' + eventTypeName);

    // New style.
    allTypeNames.push('InputLatency::' + eventTypeName);
  });

  AsyncSlice.subTypes.register(InputLatencyAsyncSlice, {
    typeNames: allTypeNames,
    categoryParts: ['latencyInfo']
  });

  return {
    InputLatencyAsyncSlice: InputLatencyAsyncSlice,
    INPUT_EVENT_TYPE_NAMES: INPUT_EVENT_TYPE_NAMES
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../model/async_slice.js":103,"../../../model/event_set.js":120,"../../../model/helpers/chrome_model_helper.js":127}],63:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/event.js");
require("../../base/iteration_helpers.js");
require("../../base/sinebow_color_generator.js");

'use strict';

global.tr.exportTo('tr.e.chrome', function () {
  var SAME_AS_PARENT = 'same-as-parent';

  var TITLES_FOR_USER_FRIENDLY_CATEGORY = {
    composite: ['CompositingInputsUpdater::update', 'ThreadProxy::SetNeedsUpdateLayers', 'LayerTreeHost::UpdateLayers::CalcDrawProps', 'UpdateLayerTree'],

    gc: ['minorGC', 'majorGC', 'MajorGC', 'MinorGC', 'V8.GCScavenger', 'V8.GCIncrementalMarking', 'V8.GCIdleNotification', 'V8.GCContext', 'V8.GCCompactor', 'V8GCController::traceDOMWrappers'],

    iframe_creation: ['WebLocalFrameImpl::createChildframe'],

    imageDecode: ['Decode Image', 'ImageFrameGenerator::decode', 'ImageFrameGenerator::decodeAndScale'],

    input: ['HitTest', 'ScrollableArea::scrollPositionChanged', 'EventHandler::handleMouseMoveEvent'],

    layout: ['FrameView::invalidateTree', 'FrameView::layout', 'FrameView::performLayout', 'FrameView::performPostLayoutTasks', 'FrameView::performPreLayoutTasks', 'Layer::updateLayerPositionsAfterLayout', 'Layout', 'LayoutView::hitTest', 'ResourceLoadPriorityOptimizer::updateAllImageResourcePriorities', 'WebViewImpl::layout'],

    parseHTML: ['ParseHTML', 'HTMLDocumentParser::didReceiveParsedChunkFromBackgroundParser', 'HTMLDocumentParser::processParsedChunkFromBackgroundParser'],

    raster: ['DisplayListRasterSource::PerformSolidColorAnalysis', 'Picture::Raster', 'RasterBufferImpl::Playback', 'RasterTask', 'RasterizerTaskImpl::RunOnWorkerThread', 'SkCanvas::drawImageRect()', 'SkCanvas::drawPicture()', 'SkCanvas::drawTextBlob()', 'TileTaskWorkerPool::PlaybackToMemory'],

    record: ['ContentLayerDelegate::paintContents', 'DeprecatedPaintLayerCompositor::updateIfNeededRecursive', 'DeprecatedPaintLayerCompositor::updateLayerPositionsAfterLayout', 'Paint', 'Picture::Record', 'PictureLayer::Update', 'RenderLayer::updateLayerPositionsAfterLayout'],

    style: ['CSSParserImpl::parseStyleSheet.parse', 'CSSParserImpl::parseStyleSheet.tokenize', 'Document::updateStyle', 'Document::updateStyleInvalidationIfNeeded', 'ParseAuthorStyleSheet', 'RuleSet::addRulesFromSheet', 'StyleElement::processStyleSheet', 'StyleEngine::createResolver', 'StyleSheetContents::parseAuthorStyleSheet', 'UpdateLayoutTree'],

    script_parse_and_compile: ['v8.parseOnBackground', 'V8.ScriptCompiler'],

    script_execute: ['V8.Execute', 'WindowProxy::initialize'],

    resource_loading: ['ResourceFetcher::requestResource', 'ResourceDispatcher::OnReceivedData', 'ResourceDispatcher::OnRequestComplete', 'ResourceDispatcher::OnReceivedResponse', 'Resource::appendData'],

    // Where do these go?
    renderer_misc: ['DecodeFont', 'ThreadState::completeSweep' // blink_gc
    ],

    // TODO(fmeawad): https://github.com/catapult-project/catapult/issues/2572
    v8_runtime: [
      // Dynamically populated.
    ],

    [SAME_AS_PARENT]: ['SyncChannel::Send']
  };

  var COLOR_FOR_USER_FRIENDLY_CATEGORY = new tr.b.SinebowColorGenerator();
  var USER_FRIENDLY_CATEGORY_FOR_TITLE = new Map();

  for (var category in TITLES_FOR_USER_FRIENDLY_CATEGORY) {
    TITLES_FOR_USER_FRIENDLY_CATEGORY[category].forEach(function (title) {
      USER_FRIENDLY_CATEGORY_FOR_TITLE.set(title, category);
    });
  }

  // keys: event.category part
  // values: user friendly category
  var USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY = {
    netlog: 'net',
    overhead: 'overhead',
    startup: 'startup',
    gpu: 'gpu'
  };

  function ChromeUserFriendlyCategoryDriver() {}

  ChromeUserFriendlyCategoryDriver.fromEvent = function (event) {
    var userFriendlyCategory = USER_FRIENDLY_CATEGORY_FOR_TITLE.get(event.title);
    if (userFriendlyCategory) {
      if (userFriendlyCategory == SAME_AS_PARENT) {
        if (event.parentSlice) return ChromeUserFriendlyCategoryDriver.fromEvent(event.parentSlice);
      } else {
        return userFriendlyCategory;
      }
    }

    var eventCategoryParts = tr.b.getCategoryParts(event.category);
    for (var i = 0; i < eventCategoryParts.length; ++i) {
      var eventCategory = eventCategoryParts[i];
      userFriendlyCategory = USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY[eventCategory];
      if (userFriendlyCategory) return userFriendlyCategory;
    }

    return 'other';
  };

  ChromeUserFriendlyCategoryDriver.getColor = function (ufc) {
    return COLOR_FOR_USER_FRIENDLY_CATEGORY.colorForKey(ufc);
  };

  ChromeUserFriendlyCategoryDriver.ALL_TITLES = ['other'];
  for (var category in TITLES_FOR_USER_FRIENDLY_CATEGORY) {
    if (category === SAME_AS_PARENT) continue;
    ChromeUserFriendlyCategoryDriver.ALL_TITLES.push(category);
  }
  for (var category of tr.b.dictionaryValues(USER_FRIENDLY_CATEGORY_FOR_EVENT_CATEGORY)) {
    ChromeUserFriendlyCategoryDriver.ALL_TITLES.push(category);
  }
  ChromeUserFriendlyCategoryDriver.ALL_TITLES.sort();

  // Prime the color generator by iterating through all UFCs in alphabetical
  // order.
  for (var category of ChromeUserFriendlyCategoryDriver.ALL_TITLES) ChromeUserFriendlyCategoryDriver.getColor(category);

  return {
    ChromeUserFriendlyCategoryDriver: ChromeUserFriendlyCategoryDriver
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/event.js":33,"../../base/iteration_helpers.js":41,"../../base/sinebow_color_generator.js":51}],64:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../model/source_info/js_source_info.js");

'use strict';

/**
 * @fileoverview TraceCodeEntry is a wrapper around the V8 CodeEntry that
 * extracts extra context information for each item. This includes things like
 * the source file, line and if the function is a native method or not.
 */
global.tr.exportTo('tr.e.importer', function () {
  function TraceCodeEntry(address, size, name, scriptId) {
    this.id_ = tr.b.GUID.allocateSimple();
    this.address_ = address;
    this.size_ = size;

    // Stolen from DevTools TimelineJSProfileProcessor._buildCallFrame
    // Code states:
    // (empty) -> compiled
    //    ~    -> optimizable
    //    *    -> optimized
    var rePrefix = /^(\w*:)?([*~]?)(.*)$/m;
    var tokens = rePrefix.exec(name);
    var prefix = tokens[1];
    var state = tokens[2];
    var body = tokens[3];

    if (state === '*') {
      state = tr.model.source_info.JSSourceState.OPTIMIZED;
    } else if (state === '~') {
      state = tr.model.source_info.JSSourceState.OPTIMIZABLE;
    } else if (state === '') {
      state = tr.model.source_info.JSSourceState.COMPILED;
    } else {
      console.warning('Unknown v8 code state ' + state);
      state = tr.model.source_info.JSSourceState.UNKNOWN;
    }

    var rawName;
    var rawUrl;
    if (prefix === 'Script:') {
      rawName = '';
      rawUrl = body;
    } else {
      var spacePos = body.lastIndexOf(' ');
      rawName = spacePos !== -1 ? body.substr(0, spacePos) : body;
      rawUrl = spacePos !== -1 ? body.substr(spacePos + 1) : '';
    }

    function splitLineAndColumn(url) {
      var lineColumnRegEx = /(?::(\d+))?(?::(\d+))?$/;
      var lineColumnMatch = lineColumnRegEx.exec(url);
      var lineNumber;
      var columnNumber;

      if (typeof lineColumnMatch[1] === 'string') {
        lineNumber = parseInt(lineColumnMatch[1], 10);
        // Immediately convert line and column to 0-based numbers.
        lineNumber = isNaN(lineNumber) ? undefined : lineNumber - 1;
      }
      if (typeof lineColumnMatch[2] === 'string') {
        columnNumber = parseInt(lineColumnMatch[2], 10);
        columnNumber = isNaN(columnNumber) ? undefined : columnNumber - 1;
      }

      return {
        url: url.substring(0, url.length - lineColumnMatch[0].length),
        lineNumber: lineNumber,
        columnNumber: columnNumber
      };
    }

    var nativeSuffix = ' native';
    var isNative = rawName.endsWith(nativeSuffix);
    this.name_ = isNative ? rawName.slice(0, -nativeSuffix.length) : rawName;

    var urlData = splitLineAndColumn(rawUrl);
    var url = urlData.url || '';
    var line = urlData.lineNumber || 0;
    var column = urlData.columnNumber || 0;

    this.sourceInfo_ = new tr.model.source_info.JSSourceInfo(url, line, column, isNative, scriptId, state);
  };

  TraceCodeEntry.prototype = {
    get id() {
      return this.id_;
    },

    get sourceInfo() {
      return this.sourceInfo_;
    },

    get name() {
      return this.name_;
    },

    set address(address) {
      this.address_ = address;
    },

    get address() {
      return this.address_;
    },

    set size(size) {
      this.size_ = size;
    },

    get size() {
      return this.size_;
    }
  };

  return {
    TraceCodeEntry: TraceCodeEntry
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../model/source_info/js_source_info.js":153}],65:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./trace_code_entry.js");

'use strict';

global.tr.exportTo('tr.e.importer', function () {
  // This code is a tracification of:
  // devtools/front_end/timeline/TimelineJSProfile.js
  function TraceCodeMap() {
    this.banks_ = new Map();
  }

  TraceCodeMap.prototype = {
    addEntry: function (addressHex, size, name, scriptId) {
      var entry = new tr.e.importer.TraceCodeEntry(this.getAddress_(addressHex), size, name, scriptId);

      this.addEntry_(addressHex, entry);
    },

    moveEntry: function (oldAddressHex, newAddressHex, size) {
      var entry = this.getBank_(oldAddressHex).removeEntry(this.getAddress_(oldAddressHex));
      if (!entry) return;

      entry.address = this.getAddress_(newAddressHex);
      entry.size = size;
      this.addEntry_(newAddressHex, entry);
    },

    lookupEntry: function (addressHex) {
      return this.getBank_(addressHex).lookupEntry(this.getAddress_(addressHex));
    },

    addEntry_: function (addressHex, entry) {
      // FIXME: Handle bank spanning addresses ...
      this.getBank_(addressHex).addEntry(entry);
    },

    getAddress_: function (addressHex) {
      // 13 hex digits == 52 bits, double mantissa fits 53 bits.
      var bankSizeHexDigits = 13;
      addressHex = addressHex.slice(2); // cut 0x prefix.
      return parseInt(addressHex.slice(-bankSizeHexDigits), 16);
    },

    getBank_: function (addressHex) {
      addressHex = addressHex.slice(2); // cut 0x prefix.

      // 13 hex digits == 52 bits, double mantissa fits 53 bits.
      var bankSizeHexDigits = 13;
      var maxHexDigits = 16;
      var bankName = addressHex.slice(-maxHexDigits, -bankSizeHexDigits);
      var bank = this.banks_.get(bankName);
      if (!bank) {
        bank = new TraceCodeBank();
        this.banks_.set(bankName, bank);
      }
      return bank;
    }
  };

  function TraceCodeBank() {
    this.entries_ = [];
  }

  TraceCodeBank.prototype = {
    removeEntry: function (address) {
      // findLowIndexInSortedArray returns 1 for empty. Just handle the
      // empty list and bail early.
      if (this.entries_.length === 0) return undefined;

      var index = tr.b.findLowIndexInSortedArray(this.entries_, function (entry) {
        return entry.address;
      }, address);
      var entry = this.entries_[index];
      if (!entry || entry.address !== address) return undefined;

      this.entries_.splice(index, 1);
      return entry;
    },

    lookupEntry: function (address) {
      var index = tr.b.findHighIndexInSortedArray(this.entries_, function (e) {
        return address - e.address;
      }) - 1;
      var entry = this.entries_[index];
      return entry && address < entry.address + entry.size ? entry : undefined;
    },

    addEntry: function (newEntry) {
      // findLowIndexInSortedArray returns 1 for empty list. Just push the
      // new address as it's the only item.
      if (this.entries_.length === 0) this.entries_.push(newEntry);

      var endAddress = newEntry.address + newEntry.size;
      var lastIndex = tr.b.findLowIndexInSortedArray(this.entries_, function (entry) {
        return entry.address;
      }, endAddress);
      var index;
      for (index = lastIndex - 1; index >= 0; --index) {
        var entry = this.entries_[index];
        var entryEndAddress = entry.address + entry.size;
        if (entryEndAddress <= newEntry.address) break;
      }
      ++index;
      this.entries_.splice(index, lastIndex - index, newEntry);
    }
  };

  return {
    TraceCodeMap: TraceCodeMap
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./trace_code_entry.js":64}],66:[function(require,module,exports){
(function (global){
"use strict";/**
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/require("../../base/base64.js");require("../../base/color_scheme.js");require("../../base/range.js");require("../../base/unit.js");require("../../base/utils.js");require("./trace_code_entry.js");require("./trace_code_map.js");require("./v8/codemap.js");require("../../importer/context_processor.js");require("../../importer/importer.js");require("../../model/comment_box_annotation.js");require("../../model/constants.js");require("../../model/container_memory_dump.js");require("../../model/counter_series.js");require("../../model/flow_event.js");require("../../model/global_memory_dump.js");require("../../model/heap_dump.js");require("../../model/instant_event.js");require("../../model/memory_allocator_dump.js");require("../../model/model.js");require("../../model/process_memory_dump.js");require("../../model/rect_annotation.js");require("../../model/scoped_id.js");require("../../model/slice_group.js");require("../../model/vm_region.js");require("../../model/x_marker_annotation.js");require("../../value/numeric.js");'use strict';/**
 * @fileoverview TraceEventImporter imports TraceEvent-formatted data
 * into the provided model.
 */global.tr.exportTo('tr.e.importer',function(){var Base64=tr.b.Base64;var deepCopy=tr.b.deepCopy;var ColorScheme=tr.b.ColorScheme;function getEventColor(event,opt_customName){if(event.cname)return ColorScheme.getColorIdForReservedName(event.cname);else if(opt_customName||event.name){return ColorScheme.getColorIdForGeneralPurposeString(opt_customName||event.name);}}var PRODUCER='producer';var CONSUMER='consumer';var STEP='step';var BACKGROUND=tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;var LIGHT=tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;var DETAILED=tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;var MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER=[undefined,BACKGROUND,LIGHT,DETAILED];var GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX='global/';var ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX='ClockSyncEvent.';// Map from raw memory dump byte stat names to model byte stat names. See
// //base/trace_event/process_memory_maps.cc in Chromium.
var BYTE_STAT_NAME_MAP={'pc':'privateCleanResident','pd':'privateDirtyResident','sc':'sharedCleanResident','sd':'sharedDirtyResident','pss':'proportionalResident','sw':'swapped'};// See tr.model.MemoryAllocatorDump 'weak' field and
// base::trace_event::MemoryAllocatorDump::Flags::WEAK in the Chromium
// codebase.
var WEAK_MEMORY_ALLOCATOR_DUMP_FLAG=1<<0;// Object type name patterns for various compilers.
var OBJECT_TYPE_NAME_PATTERNS=[{// Clang.
prefix:'const char *WTF::getStringWithTypeName() [T = ',suffix:']'},{// GCC.
prefix:'const char* WTF::getStringWithTypeName() [with T = ',suffix:']'},{// Microsoft Visual C++
prefix:'const char *__cdecl WTF::getStringWithTypeName<',suffix:'>(void)'}];// The list of fields on the trace that are known to contain subtraces.
var SUBTRACE_FIELDS=new Set(['powerTraceAsString','systemTraceEvents']);// The complete list of fields on the trace that should not be treated as
// trace metadata.
var NON_METADATA_FIELDS=new Set(['samples','stackFrames','traceAnnotations','traceEvents']);// TODO(charliea): Replace this with the spread (...) operator in literal
// above once v8 is updated to a sufficiently recent version (>M45).
for(var subtraceField in SUBTRACE_FIELDS)NON_METADATA_FIELDS.add(subtraceField);function TraceEventImporter(model,eventData){this.importPriority=1;this.model_=model;this.events_=undefined;this.sampleEvents_=undefined;this.stackFrameEvents_=undefined;this.subtraces_=[];this.eventsWereFromString_=false;this.softwareMeasuredCpuCount_=undefined;this.allAsyncEvents_=[];this.allFlowEvents_=[];this.allObjectEvents_=[];this.contextProcessorPerThread={};this.traceEventSampleStackFramesByName_={};this.v8ProcessCodeMaps_={};this.v8ProcessRootStackFrame_={};this.v8SamplingData_=[];// For tracking async events that is used to create back-compat clock sync
// event.
this.asyncClockSyncStart_=undefined;this.asyncClockSyncFinish_=undefined;// Dump ID -> PID -> [process memory dump events].
this.allMemoryDumpEvents_={};// PID -> Object type ID -> Object type name.
this.objectTypeNameMap_={};// For old Chrome traces with no clock domain metadata, just use a
// placeholder clock domain.
this.clockDomainId_=tr.model.ClockDomainId.UNKNOWN_CHROME_LEGACY;// A function able to transform timestamps in |clockDomainId| to timestamps
// in the model clock domain.
this.toModelTime_=undefined;if(typeof eventData==='string'||eventData instanceof String){eventData=eventData.trim();// If the event data begins with a [, then we know it should end with a ].
// The reason we check for this is because some tracing implementations
// cannot guarantee that a ']' gets written to the trace file. So, we are
// forgiving and if this is obviously the case, we fix it up before
// throwing the string at JSON.parse.
if(eventData[0]==='['){eventData=eventData.replace(/\s*,\s*$/,'');if(eventData[eventData.length-1]!==']')eventData=eventData+']';}this.events_=JSON.parse(eventData);this.eventsWereFromString_=true;}else{this.events_=eventData;}this.traceAnnotations_=this.events_.traceAnnotations;// Some trace_event implementations put the actual trace events
// inside a container. E.g { ... , traceEvents: [ ] }
// If we see that, just pull out the trace events.
if(this.events_.traceEvents){var container=this.events_;this.events_=this.events_.traceEvents;// Some trace authors store subtraces as specific properties of the trace.
for(var subtraceField of SUBTRACE_FIELDS)if(container[subtraceField])this.subtraces_.push(container[subtraceField]);// Sampling data.
this.sampleEvents_=container.samples;this.stackFrameEvents_=container.stackFrames;// Some implementations specify displayTimeUnit
if(container.displayTimeUnit){var unitName=container.displayTimeUnit;var unit=tr.b.TimeDisplayModes[unitName];if(unit===undefined){throw new Error('Unit '+unitName+' is not supported.');}this.model_.intrinsicTimeUnit=unit;}// Any other fields in the container should be treated as metadata.
for(var fieldName in container){if(NON_METADATA_FIELDS.has(fieldName))continue;this.model_.metadata.push({name:fieldName,value:container[fieldName]});if(fieldName==='metadata'){var metadata=container[fieldName];if(metadata['highres-ticks'])this.model_.isTimeHighResolution=metadata['highres-ticks'];if(metadata['clock-domain'])this.clockDomainId_=metadata['clock-domain'];}}}}/**
   * @return {boolean} Whether obj is a TraceEvent array.
   */TraceEventImporter.canImport=function(eventData){// May be encoded JSON. But we dont want to parse it fully yet.
// Use a simple heuristic:
//   - eventData that starts with [ are probably trace_event
//   - eventData that starts with { are probably trace_event
// May be encoded JSON. Treat files that start with { as importable by us.
if(typeof eventData==='string'||eventData instanceof String){eventData=eventData.trim();return eventData[0]==='{'||eventData[0]==='[';}// Might just be an array of events
if(eventData instanceof Array&&eventData.length&&eventData[0].ph)return true;// Might be an object with a traceEvents field in it.
if(eventData.traceEvents){if(eventData.traceEvents instanceof Array){if(eventData.traceEvents.length&&eventData.traceEvents[0].ph)return true;if(eventData.samples.length&&eventData.stackFrames!==undefined)return true;}}return false;};TraceEventImporter.prototype={__proto__:tr.importer.Importer.prototype,get importerName(){return'TraceEventImporter';},extractSubtraces:function(){// Because subtraces can be quite large, we need to make sure that we
// don't hold a reference to the memory.
var subtraces=this.subtraces_;this.subtraces_=[];return subtraces;},/**
     * Deep copying is only needed if the trace was given to us as events.
     */deepCopyIfNeeded_:function(obj){if(obj===undefined)obj={};if(this.eventsWereFromString_)return obj;return deepCopy(obj);},/**
     * Always perform deep copying.
     */deepCopyAlways_:function(obj){if(obj===undefined)obj={};return deepCopy(obj);},/**
     * Helper to process an async event.
     */processAsyncEvent:function(event){var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);this.allAsyncEvents_.push({sequenceNumber:this.allAsyncEvents_.length,event:event,thread:thread});},/**
     * Helper to process a flow event.
     */processFlowEvent:function(event,opt_slice){var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);this.allFlowEvents_.push({refGuid:tr.b.GUID.getLastSimpleGuid(),sequenceNumber:this.allFlowEvents_.length,event:event,slice:opt_slice,// slice for events that have flow info
thread:thread});},/**
     * Helper that creates and adds samples to a Counter object based on
     * 'C' phase events.
     */processCounterEvent:function(event){var ctrName;if(event.id!==undefined)ctrName=event.name+'['+event.id+']';else ctrName=event.name;var ctr=this.model_.getOrCreateProcess(event.pid).getOrCreateCounter(event.cat,ctrName);var reservedColorId=event.cname?getEventColor(event):undefined;// Initialize the counter's series fields if needed.
if(ctr.numSeries===0){for(var seriesName in event.args){var colorId=reservedColorId||getEventColor(event,ctr.name+'.'+seriesName);ctr.addSeries(new tr.model.CounterSeries(seriesName,colorId));}if(ctr.numSeries===0){this.model_.importWarning({type:'counter_parse_error',message:'Expected counter '+event.name+' to have at least one argument to use as a value.'});// Drop the counter.
delete ctr.parent.counters[ctr.name];return;}}var ts=this.toModelTimeFromUs_(event.ts);ctr.series.forEach(function(series){var val=event.args[series.name]?event.args[series.name]:0;series.addCounterSample(ts,val);});},scopedIdForEvent_:function(event){return new tr.model.ScopedId(event.scope||tr.model.OBJECT_DEFAULT_SCOPE,event.id);},processObjectEvent:function(event){var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);this.allObjectEvents_.push({sequenceNumber:this.allObjectEvents_.length,event:event,thread:thread});if(thread.guid in this.contextProcessorPerThread){var processor=this.contextProcessorPerThread[thread.guid];var scopedId=this.scopedIdForEvent_(event);if(event.ph==='D')processor.destroyContext(scopedId);// The context processor maintains a cache of unique context objects and
// active context sets to reduce memory usage. If an object is modified,
// we should invalidate this cache, because otherwise context sets from
// before and after the modification may erroneously point to the same
// context snapshot (as both are the same set/object instances).
processor.invalidateContextCacheForSnapshot(scopedId);}},processContextEvent:function(event){var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);if(!(thread.guid in this.contextProcessorPerThread)){this.contextProcessorPerThread[thread.guid]=new tr.importer.ContextProcessor(this.model_);}var scopedId=this.scopedIdForEvent_(event);var contextType=event.name;var processor=this.contextProcessorPerThread[thread.guid];if(event.ph==='('){processor.enterContext(contextType,scopedId);}else if(event.ph===')'){processor.leaveContext(contextType,scopedId);}else{this.model_.importWarning({type:'unknown_context_phase',message:'Unknown context event phase: '+event.ph+'.'});}},setContextsFromThread_:function(thread,slice){if(thread.guid in this.contextProcessorPerThread){slice.contexts=this.contextProcessorPerThread[thread.guid].activeContexts;}},processDurationEvent:function(event){var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);var ts=this.toModelTimeFromUs_(event.ts);if(!thread.sliceGroup.isTimestampValidForBeginOrEnd(ts)){this.model_.importWarning({type:'duration_parse_error',message:'Timestamps are moving backward.'});return;}if(event.ph==='B'){var slice=thread.sliceGroup.beginSlice(event.cat,event.name,this.toModelTimeFromUs_(event.ts),this.deepCopyIfNeeded_(event.args),this.toModelTimeFromUs_(event.tts),event.argsStripped,getEventColor(event));slice.startStackFrame=this.getStackFrameForEvent_(event);this.setContextsFromThread_(thread,slice);}else if(event.ph==='I'||event.ph==='i'||event.ph==='R'){if(event.s!==undefined&&event.s!=='t')throw new Error('This should never happen');thread.sliceGroup.beginSlice(event.cat,event.name,this.toModelTimeFromUs_(event.ts),this.deepCopyIfNeeded_(event.args),this.toModelTimeFromUs_(event.tts),event.argsStripped,getEventColor(event));var slice=thread.sliceGroup.endSlice(this.toModelTimeFromUs_(event.ts),this.toModelTimeFromUs_(event.tts));slice.startStackFrame=this.getStackFrameForEvent_(event);slice.endStackFrame=undefined;}else{if(!thread.sliceGroup.openSliceCount){this.model_.importWarning({type:'duration_parse_error',message:'E phase event without a matching B phase event.'});return;}var slice=thread.sliceGroup.endSlice(this.toModelTimeFromUs_(event.ts),this.toModelTimeFromUs_(event.tts),getEventColor(event));if(event.name&&slice.title!=event.name){this.model_.importWarning({type:'title_match_error',message:'Titles do not match. Title is '+slice.title+' in openSlice, and is '+event.name+' in endSlice'});}slice.endStackFrame=this.getStackFrameForEvent_(event);this.mergeArgsInto_(slice.args,event.args,slice.title);}},mergeArgsInto_:function(dstArgs,srcArgs,eventName){for(var arg in srcArgs){if(dstArgs[arg]!==undefined){this.model_.importWarning({type:'arg_merge_error',message:'Different phases of '+eventName+' provided values for argument '+arg+'.'+' The last provided value will be used.'});}dstArgs[arg]=this.deepCopyIfNeeded_(srcArgs[arg]);}},processCompleteEvent:function(event){// Preventing the overhead slices from making it into the model. This
// only applies to legacy traces, as the overhead traces have been
// removed from the chromium code.
if(event.cat!==undefined&&event.cat.indexOf('trace_event_overhead')>-1)return undefined;var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);if(event.flow_out){if(event.flow_in)event.flowPhase=STEP;else event.flowPhase=PRODUCER;}else if(event.flow_in){event.flowPhase=CONSUMER;}var slice=thread.sliceGroup.pushCompleteSlice(event.cat,event.name,this.toModelTimeFromUs_(event.ts),this.maybeToModelTimeFromUs_(event.dur),this.maybeToModelTimeFromUs_(event.tts),this.maybeToModelTimeFromUs_(event.tdur),this.deepCopyIfNeeded_(event.args),event.argsStripped,getEventColor(event),event.bind_id);slice.startStackFrame=this.getStackFrameForEvent_(event);slice.endStackFrame=this.getStackFrameForEvent_(event,true);this.setContextsFromThread_(thread,slice);return slice;},processJitCodeEvent:function(event){if(this.v8ProcessCodeMaps_[event.pid]===undefined)this.v8ProcessCodeMaps_[event.pid]=new tr.e.importer.TraceCodeMap();var map=this.v8ProcessCodeMaps_[event.pid];var data=event.args.data;// TODO(dsinclair): There are _a lot_ of JitCode events so I'm skipping
// the display for now. Can revisit later if we want to show them.
// Handle JitCodeMoved and JitCodeAdded event.
if(event.name==='JitCodeMoved')map.moveEntry(data.code_start,data.new_code_start,data.code_len);else// event.name === 'JitCodeAdded'
map.addEntry(data.code_start,data.code_len,data.name,data.script_id);},processMetadataEvent:function(event){// V8 JIT events are currently logged as phase 'M' so we need to
// separate them out and handle specially.
if(event.name==='JitCodeAdded'||event.name==='JitCodeMoved'){this.v8SamplingData_.push(event);return;}// The metadata events aren't useful without args.
if(event.argsStripped)return;if(event.name==='process_name'){var process=this.model_.getOrCreateProcess(event.pid);process.name=event.args.name;}else if(event.name==='process_labels'){var process=this.model_.getOrCreateProcess(event.pid);var labels=event.args.labels.split(',');for(var i=0;i<labels.length;i++)process.addLabelIfNeeded(labels[i]);}else if(event.name==='process_sort_index'){var process=this.model_.getOrCreateProcess(event.pid);process.sortIndex=event.args.sort_index;}else if(event.name==='thread_name'){var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);thread.name=event.args.name;}else if(event.name==='thread_sort_index'){var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);thread.sortIndex=event.args.sort_index;}else if(event.name==='num_cpus'){var n=event.args.number;// Not all render processes agree on the cpu count in trace_event. Some
// processes will report 1, while others will report the actual cpu
// count. To deal with this, take the max of what is reported.
if(this.softwareMeasuredCpuCount_!==undefined)n=Math.max(n,this.softwareMeasuredCpuCount_);this.softwareMeasuredCpuCount_=n;}else if(event.name==='stackFrames'){var stackFrames=event.args.stackFrames;if(stackFrames===undefined){this.model_.importWarning({type:'metadata_parse_error',message:'No stack frames found in a \''+event.name+'\' metadata event'});}else{this.importStackFrames_(stackFrames,'p'+event.pid+':');}}else if(event.name==='typeNames'){var objectTypeNameMap=event.args.typeNames;if(objectTypeNameMap===undefined){this.model_.importWarning({type:'metadata_parse_error',message:'No mapping from object type IDs to names found in a \''+event.name+'\' metadata event'});}else{this.importObjectTypeNameMap_(objectTypeNameMap,event.pid);}}else if(event.name==='TraceConfig'){this.model_.metadata.push({name:'TraceConfig',value:event.args.value});}else{this.model_.importWarning({type:'metadata_parse_error',message:'Unrecognized metadata name: '+event.name});}},processInstantEvent:function(event){// V8 JIT events were logged as phase 'I' in the old format,
// so we need to separate them out and handle specially.
if(event.name==='JitCodeAdded'||event.name==='JitCodeMoved'){this.v8SamplingData_.push(event);return;}// Thread-level instant events are treated as zero-duration slices.
if(event.s==='t'||event.s===undefined){this.processDurationEvent(event);return;}var constructor;switch(event.s){case'g':constructor=tr.model.GlobalInstantEvent;break;case'p':constructor=tr.model.ProcessInstantEvent;break;default:this.model_.importWarning({type:'instant_parse_error',message:'I phase event with unknown "s" field value.'});return;}var instantEvent=new constructor(event.cat,event.name,getEventColor(event),this.toModelTimeFromUs_(event.ts),this.deepCopyIfNeeded_(event.args));switch(instantEvent.type){case tr.model.InstantEventType.GLOBAL:this.model_.instantEvents.push(instantEvent);break;case tr.model.InstantEventType.PROCESS:var process=this.model_.getOrCreateProcess(event.pid);process.instantEvents.push(instantEvent);break;default:throw new Error('Unknown instant event type: '+event.s);}},processV8Sample:function(event){var data=event.args.data;// As-per DevTools, the backend sometimes creates bogus samples. Skip it.
if(data.vm_state==='js'&&!data.stack.length)return;var rootStackFrame=this.v8ProcessRootStackFrame_[event.pid];if(!rootStackFrame){rootStackFrame=new tr.model.StackFrame(undefined/* parent */,'v8-root-stack-frame'/* id */,'v8-root-stack-frame'/* title */,0/* colorId */);this.v8ProcessRootStackFrame_[event.pid]=rootStackFrame;}function findChildWithEntryID(stackFrame,entryID){return tr.b.findFirstInArray(stackFrame.children,function(child){return child.entryID===entryID;});}var model=this.model_;function addStackFrame(lastStackFrame,entry){var childFrame=findChildWithEntryID(lastStackFrame,entry.id);if(childFrame)return childFrame;var frame=new tr.model.StackFrame(lastStackFrame,tr.b.GUID.allocateSimple(),entry.name,ColorScheme.getColorIdForGeneralPurposeString(entry.name),entry.sourceInfo);frame.entryID=entry.id;model.addStackFrame(frame);return frame;}var lastStackFrame=rootStackFrame;// There are several types of v8 sample events, gc, native, compiler, etc.
// Some of these types have stacks and some don't, we handle those two
// cases differently. For types that don't have any stack frames attached
// we synthesize one based on the type of thing that's happening so when
// we view all the samples we'll see something like 'external' or 'gc'
// as a fraction of the time spent.
if(data.stack.length>0&&this.v8ProcessCodeMaps_[event.pid]){var map=this.v8ProcessCodeMaps_[event.pid];// Stacks have the leaf node first, flip them around so the root
// comes first.
data.stack.reverse();for(var i=0;i<data.stack.length;i++){var entry=map.lookupEntry(data.stack[i]);if(entry===undefined){entry={id:'unknown',name:'unknown',sourceInfo:undefined};}lastStackFrame=addStackFrame(lastStackFrame,entry);}}else{var entry={id:data.vm_state,name:data.vm_state,sourceInfo:undefined};lastStackFrame=addStackFrame(lastStackFrame,entry);}var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);var sample=new tr.model.Sample(undefined/* cpu */,thread,'V8 Sample',this.toModelTimeFromUs_(event.ts),lastStackFrame,1/* weight */,this.deepCopyIfNeeded_(event.args));this.model_.samples.push(sample);},processTraceSampleEvent:function(event){if(event.name==='V8Sample'){this.v8SamplingData_.push(event);return;}var stackFrame=this.getStackFrameForEvent_(event);if(stackFrame===undefined){stackFrame=this.traceEventSampleStackFramesByName_[event.name];}if(stackFrame===undefined){var id='te-'+tr.b.GUID.allocateSimple();stackFrame=new tr.model.StackFrame(undefined,id,event.name,ColorScheme.getColorIdForGeneralPurposeString(event.name));this.model_.addStackFrame(stackFrame);this.traceEventSampleStackFramesByName_[event.name]=stackFrame;}var thread=this.model_.getOrCreateProcess(event.pid).getOrCreateThread(event.tid);var sample=new tr.model.Sample(undefined,thread,'Trace Event Sample',this.toModelTimeFromUs_(event.ts),stackFrame,1,this.deepCopyIfNeeded_(event.args));this.setContextsFromThread_(thread,sample);this.model_.samples.push(sample);},processMemoryDumpEvent:function(event){if(event.ph!=='v')throw new Error('Invalid memory dump event phase "'+event.ph+'".');var dumpId=event.id;if(dumpId===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory dump event (phase \''+event.ph+'\') without a dump ID.'});return;}var pid=event.pid;if(pid===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory dump event (phase\''+event.ph+'\', dump ID \''+dumpId+'\') without a PID.'});return;}// Dump ID -> PID -> [process memory dump events].
var allEvents=this.allMemoryDumpEvents_;// PID -> [process memory dump events].
var dumpIdEvents=allEvents[dumpId];if(dumpIdEvents===undefined)allEvents[dumpId]=dumpIdEvents={};// [process memory dump events].
var processEvents=dumpIdEvents[pid];if(processEvents===undefined)dumpIdEvents[pid]=processEvents=[];processEvents.push(event);},processClockSyncEvent:function(event){if(event.ph!=='c')throw new Error('Invalid clock sync event phase "'+event.ph+'".');var syncId=event.args.sync_id;if(syncId===undefined){this.model_.importWarning({type:'clock_sync_parse_error',message:'Clock sync at time '+event.ts+' without an ID.'});return;}if(event.args&&event.args.issue_ts!==undefined){// When Chrome is the tracing controller and is the requester of the
// clock sync, the clock sync event looks like:
//
//   {
//     "args": {
//       "sync_id": "abc123",
//       "issue_ts": 12340
//     }
//     "ph": "c"
//     "ts": 12345
//     ...
//   }
this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_,syncId,tr.b.Unit.timestampFromUs(event.args.issue_ts),tr.b.Unit.timestampFromUs(event.ts));}else{// When Chrome is a tracing agent and is the recipient of the clock
// sync request, the clock sync event looks like:
//
//   {
//     "args": { "sync_id": "abc123" }
//     "ph": "c"
//     "ts": 12345
//     ...
//   }
this.model_.clockSyncManager.addClockSyncMarker(this.clockDomainId_,syncId,tr.b.Unit.timestampFromUs(event.ts));}},// Because the order of Jit code events and V8 samples are not guaranteed,
// We store them in an array, sort by timestamp, and then process them.
processV8Events:function(){this.v8SamplingData_.sort(function(a,b){if(a.ts!==b.ts)return a.ts-b.ts;if(a.ph==='M'||a.ph==='I')return-1;else if(b.ph==='M'||b.ph==='I')return 1;return 0;});var length=this.v8SamplingData_.length;for(var i=0;i<length;++i){var event=this.v8SamplingData_[i];if(event.ph==='M'||event.ph==='I'){this.processJitCodeEvent(event);}else if(event.ph==='P'){this.processV8Sample(event);}}},initBackcompatClockSyncEventTracker_:function(event){if(event.name!==undefined&&event.name.startsWith(ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX)&&event.ph==='S')this.asyncClockSyncStart_=event;if(event.name!==undefined&&event.name.startsWith(ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX)&&event.ph==='F')this.asyncClockSyncFinish_=event;if(this.asyncClockSyncStart_==undefined||this.asyncClockSyncFinish_==undefined)return;// Older version of Chrome doesn't support clock sync API, hence
// telemetry get around it by marking the clock sync events with
// console.time & console.timeEnd. When we encounter async events
// with named started with 'ClockSyncEvent.' prefix, create a
// synthetic clock sync events based on their timestamps.
var syncId=this.asyncClockSyncStart_.name.substring(ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX.length);if(syncId!==this.asyncClockSyncFinish_.name.substring(ASYNC_CLOCK_SYNC_EVENT_TITLE_PREFIX.length)){throw new Error('Inconsistent clock sync id of async clock sync '+'events.');}var clockSyncEvent={ph:'c',args:{sync_id:syncId,issue_ts:this.asyncClockSyncStart_.ts},ts:this.asyncClockSyncFinish_.ts};this.asyncClockSyncStart_=undefined;this.asyncClockSyncFinish_=undefined;return clockSyncEvent;},importClockSyncMarkers:function(){var asyncClockSyncStart,asyncClockSyncFinish;for(var i=0;i<this.events_.length;i++){var event=this.events_[i];var possibleBackCompatClockSyncEvent=this.initBackcompatClockSyncEventTracker_(event);if(possibleBackCompatClockSyncEvent)this.processClockSyncEvent(possibleBackCompatClockSyncEvent);if(event.ph!=='c')continue;var eventSizeInBytes=this.model_.importOptions.trackDetailedModelStats?JSON.stringify(event).length:undefined;this.model_.stats.willProcessBasicTraceEvent('clock_sync',event.cat,event.name,event.ts,eventSizeInBytes);this.processClockSyncEvent(event);}},/**
     * Walks through the events_ list and outputs the structures discovered to
     * model_.
     */importEvents:function(){if(this.stackFrameEvents_)this.importStackFrames_(this.stackFrameEvents_,'g');if(this.traceAnnotations_)this.importAnnotations_();var importOptions=this.model_.importOptions;var trackDetailedModelStats=importOptions.trackDetailedModelStats;var modelStats=this.model_.stats;var events=this.events_;for(var eI=0;eI<events.length;eI++){var event=events[eI];if(event.args==='__stripped__'){event.argsStripped=true;event.args=undefined;}var eventSizeInBytes;if(trackDetailedModelStats)eventSizeInBytes=JSON.stringify(event).length;else eventSizeInBytes=undefined;if(event.ph==='B'||event.ph==='E'){modelStats.willProcessBasicTraceEvent('begin_end (non-compact)',event.cat,event.name,event.ts,eventSizeInBytes);this.processDurationEvent(event);}else if(event.ph==='X'){modelStats.willProcessBasicTraceEvent('begin_end (compact)',event.cat,event.name,event.ts,eventSizeInBytes);var slice=this.processCompleteEvent(event);// TODO(yuhaoz): If Chrome supports creating other events with flow,
// we will need to call processFlowEvent for them also.
// https://github.com/catapult-project/catapult/issues/1259
if(slice!==undefined&&event.bind_id!==undefined)this.processFlowEvent(event,slice);}else if(event.ph==='b'||event.ph==='e'||event.ph==='n'||event.ph==='S'||event.ph==='F'||event.ph==='T'||event.ph==='p'){modelStats.willProcessBasicTraceEvent('async',event.cat,event.name,event.ts,eventSizeInBytes);this.processAsyncEvent(event);// Note, I is historic. The instant event marker got changed, but we
// want to support loading old trace files so we have both I and i.
}else if(event.ph==='I'||event.ph==='i'||event.ph==='R'){modelStats.willProcessBasicTraceEvent('instant',event.cat,event.name,event.ts,eventSizeInBytes);this.processInstantEvent(event);}else if(event.ph==='P'){modelStats.willProcessBasicTraceEvent('samples',event.cat,event.name,event.ts,eventSizeInBytes);this.processTraceSampleEvent(event);}else if(event.ph==='C'){modelStats.willProcessBasicTraceEvent('counters',event.cat,event.name,event.ts,eventSizeInBytes);this.processCounterEvent(event);}else if(event.ph==='M'){modelStats.willProcessBasicTraceEvent('metadata',event.cat,event.name,event.ts,eventSizeInBytes);this.processMetadataEvent(event);}else if(event.ph==='N'||event.ph==='D'||event.ph==='O'){modelStats.willProcessBasicTraceEvent('objects',event.cat,event.name,event.ts,eventSizeInBytes);this.processObjectEvent(event);}else if(event.ph==='s'||event.ph==='t'||event.ph==='f'){modelStats.willProcessBasicTraceEvent('flows',event.cat,event.name,event.ts,eventSizeInBytes);this.processFlowEvent(event);}else if(event.ph==='v'){modelStats.willProcessBasicTraceEvent('memory_dumps',event.cat,event.name,event.ts,eventSizeInBytes);this.processMemoryDumpEvent(event);}else if(event.ph==='('||event.ph===')'){this.processContextEvent(event);}else if(event.ph==='c'){// No-op. Clock sync events have already been processed in
// importClockSyncMarkers().
}else{modelStats.willProcessBasicTraceEvent('unknown',event.cat,event.name,event.ts,eventSizeInBytes);this.model_.importWarning({type:'parse_error',message:'Unrecognized event phase: '+event.ph+' ('+event.name+')'});}}this.processV8Events();// Remove all the root stack frame children as they should
// already be added.
tr.b.iterItems(this.v8ProcessRootStackFrame_,function(name,frame){frame.removeAllChildren();});},importStackFrames_:function(rawStackFrames,idPrefix){var model=this.model_;for(var id in rawStackFrames){var rawStackFrame=rawStackFrames[id];var fullId=idPrefix+id;var textForColor=rawStackFrame.category?rawStackFrame.category:rawStackFrame.name;var stackFrame=new tr.model.StackFrame(undefined/* parentFrame */,fullId,rawStackFrame.name,ColorScheme.getColorIdForGeneralPurposeString(textForColor));model.addStackFrame(stackFrame);}for(var id in rawStackFrames){var fullId=idPrefix+id;var stackFrame=model.stackFrames[fullId];if(stackFrame===undefined)throw new Error('Internal error');var rawStackFrame=rawStackFrames[id];var parentId=rawStackFrame.parent;var parentStackFrame;if(parentId===undefined){parentStackFrame=undefined;}else{var parentFullId=idPrefix+parentId;parentStackFrame=model.stackFrames[parentFullId];if(parentStackFrame===undefined){this.model_.importWarning({type:'metadata_parse_error',message:'Missing parent frame with ID '+parentFullId+' for stack frame \''+stackFrame.name+'\' (ID '+fullId+').'});}}stackFrame.parentFrame=parentStackFrame;}},importObjectTypeNameMap_:function(rawObjectTypeNameMap,pid){if(pid in this.objectTypeNameMap_){this.model_.importWarning({type:'metadata_parse_error',message:'Mapping from object type IDs to names provided for pid='+pid+' multiple times.'});return;}var objectTypeNamePrefix=undefined;var objectTypeNameSuffix=undefined;var objectTypeNameMap={};for(var objectTypeId in rawObjectTypeNameMap){var rawObjectTypeName=rawObjectTypeNameMap[objectTypeId];// If we haven't figured out yet which compiler the object type names
// come from, we try to do it now.
if(objectTypeNamePrefix===undefined){for(var i=0;i<OBJECT_TYPE_NAME_PATTERNS.length;i++){var pattern=OBJECT_TYPE_NAME_PATTERNS[i];if(rawObjectTypeName.startsWith(pattern.prefix)&&rawObjectTypeName.endsWith(pattern.suffix)){objectTypeNamePrefix=pattern.prefix;objectTypeNameSuffix=pattern.suffix;break;}}}if(objectTypeNamePrefix!==undefined&&rawObjectTypeName.startsWith(objectTypeNamePrefix)&&rawObjectTypeName.endsWith(objectTypeNameSuffix)){// With compiler-specific prefix and suffix (automatically annotated
// object types).
objectTypeNameMap[objectTypeId]=rawObjectTypeName.substring(objectTypeNamePrefix.length,rawObjectTypeName.length-objectTypeNameSuffix.length);}else{// Without compiler-specific prefix and suffix (manually annotated
// object types and '[unknown]').
objectTypeNameMap[objectTypeId]=rawObjectTypeName;}}this.objectTypeNameMap_[pid]=objectTypeNameMap;},importAnnotations_:function(){for(var id in this.traceAnnotations_){var annotation=tr.model.Annotation.fromDictIfPossible(this.traceAnnotations_[id]);if(!annotation){this.model_.importWarning({type:'annotation_warning',message:'Unrecognized traceAnnotation typeName \"'+this.traceAnnotations_[id].typeName+'\"'});continue;}this.model_.addAnnotation(annotation);}},/**
     * Called by the Model after all other importers have imported their
     * events.
     */finalizeImport:function(){if(this.softwareMeasuredCpuCount_!==undefined){this.model_.kernel.softwareMeasuredCpuCount=this.softwareMeasuredCpuCount_;}this.createAsyncSlices_();this.createFlowSlices_();this.createExplicitObjects_();this.createImplicitObjects_();this.createMemoryDumps_();},/* Events can have one or more stack frames associated with them, but
     * that frame might be encoded either as a stack trace of program counters,
     * or as a direct stack frame reference. This handles either case and
     * if found, returns the stackframe.
     */getStackFrameForEvent_:function(event,opt_lookForEndEvent){var sf;var stack;if(opt_lookForEndEvent){sf=event.esf;stack=event.estack;}else{sf=event.sf;stack=event.stack;}if(stack!==undefined&&sf!==undefined){this.model_.importWarning({type:'stack_frame_and_stack_error',message:'Event at '+event.ts+' cannot have both a stack and a stackframe.'});return undefined;}if(stack!==undefined)return this.model_.resolveStackToStackFrame_(event.pid,stack);if(sf===undefined)return undefined;var stackFrame=this.model_.stackFrames['g'+sf];if(stackFrame===undefined){this.model_.importWarning({type:'sample_import_error',message:'No frame for '+sf});return;}return stackFrame;},resolveStackToStackFrame_:function(pid,stack){// TODO(alph,fmeawad): Add codemap resolution code here.
return undefined;},importSampleData:function(){if(!this.sampleEvents_)return;var m=this.model_;// If this is the only importer, then fake-create the threads.
var events=this.sampleEvents_;if(this.events_.length===0){for(var i=0;i<events.length;i++){var event=events[i];m.getOrCreateProcess(event.tid).getOrCreateThread(event.tid);}}var threadsByTid={};m.getAllThreads().forEach(function(t){threadsByTid[t.tid]=t;});for(var i=0;i<events.length;i++){var event=events[i];var thread=threadsByTid[event.tid];if(thread===undefined){m.importWarning({type:'sample_import_error',message:'Thread '+events.tid+'not found'});continue;}var cpu;if(event.cpu!==undefined)cpu=m.kernel.getOrCreateCpu(event.cpu);var stackFrame=this.getStackFrameForEvent_(event);var sample=new tr.model.Sample(cpu,thread,event.name,this.toModelTimeFromUs_(event.ts),stackFrame,event.weight);m.samples.push(sample);}},createAsyncSlices_:function(){if(this.allAsyncEvents_.length===0)return;this.allAsyncEvents_.sort(function(x,y){var d=x.event.ts-y.event.ts;if(d!==0)return d;return x.sequenceNumber-y.sequenceNumber;});var legacyEvents=[];// Group nestable async events by ID. Events with the same ID should
// belong to the same parent async event.
var nestableAsyncEventsByKey={};var nestableMeasureAsyncEventsByKey={};for(var i=0;i<this.allAsyncEvents_.length;i++){var asyncEventState=this.allAsyncEvents_[i];var event=asyncEventState.event;if(event.ph==='S'||event.ph==='F'||event.ph==='T'||event.ph==='p'){legacyEvents.push(asyncEventState);continue;}if(event.cat===undefined){this.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async events (ph: b, e, or n) require a '+'cat parameter.'});continue;}if(event.name===undefined){this.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async events (ph: b, e, or n) require a '+'name parameter.'});continue;}if(event.id===undefined){this.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async events (ph: b, e, or n) require an '+'id parameter.'});continue;}if(event.cat==='blink.user_timing'){var matched=/([^\/:]+):([^\/:]+)\/?(.*)/.exec(event.name);if(matched!==null){var key=matched[1]+':'+event.cat;event.args=JSON.parse(Base64.atob(matched[3])||'{}');if(nestableMeasureAsyncEventsByKey[key]===undefined)nestableMeasureAsyncEventsByKey[key]=[];nestableMeasureAsyncEventsByKey[key].push(asyncEventState);continue;}}var key=event.cat+':'+event.id;if(nestableAsyncEventsByKey[key]===undefined)nestableAsyncEventsByKey[key]=[];nestableAsyncEventsByKey[key].push(asyncEventState);}// Handle legacy async events.
this.createLegacyAsyncSlices_(legacyEvents);// Parse nestable measure async events into AsyncSlices.
this.createNestableAsyncSlices_(nestableMeasureAsyncEventsByKey);// Parse nestable async events into AsyncSlices.
this.createNestableAsyncSlices_(nestableAsyncEventsByKey);},createLegacyAsyncSlices_:function(legacyEvents){if(legacyEvents.length===0)return;legacyEvents.sort(function(x,y){var d=x.event.ts-y.event.ts;if(d!=0)return d;return x.sequenceNumber-y.sequenceNumber;});var asyncEventStatesByNameThenID={};for(var i=0;i<legacyEvents.length;i++){var asyncEventState=legacyEvents[i];var event=asyncEventState.event;var name=event.name;if(name===undefined){this.model_.importWarning({type:'async_slice_parse_error',message:'Async events (ph: S, T, p, or F) require a name '+' parameter.'});continue;}var id=event.id;if(id===undefined){this.model_.importWarning({type:'async_slice_parse_error',message:'Async events (ph: S, T, p, or F) require an id parameter.'});continue;}// TODO(simonjam): Add a synchronous tick on the appropriate thread.
if(event.ph==='S'){if(asyncEventStatesByNameThenID[name]===undefined)asyncEventStatesByNameThenID[name]={};if(asyncEventStatesByNameThenID[name][id]){this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.ts+', a slice of the same id '+id+' was alrady open.'});continue;}asyncEventStatesByNameThenID[name][id]=[];asyncEventStatesByNameThenID[name][id].push(asyncEventState);}else{if(asyncEventStatesByNameThenID[name]===undefined){this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.ts+', no slice named '+name+' was open.'});continue;}if(asyncEventStatesByNameThenID[name][id]===undefined){this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.ts+', no slice named '+name+' with id='+id+' was open.'});continue;}var events=asyncEventStatesByNameThenID[name][id];events.push(asyncEventState);if(event.ph==='F'){// Create a slice from start to end.
var asyncSliceConstructor=tr.model.AsyncSlice.subTypes.getConstructor(events[0].event.cat,name);var slice=new asyncSliceConstructor(events[0].event.cat,name,getEventColor(events[0].event),this.toModelTimeFromUs_(events[0].event.ts),tr.b.concatenateObjects(events[0].event.args,events[events.length-1].event.args),this.toModelTimeFromUs_(event.ts-events[0].event.ts),true,undefined,undefined,events[0].event.argsStripped);slice.startThread=events[0].thread;slice.endThread=asyncEventState.thread;slice.id=id;var stepType=events[1].event.ph;var isValid=true;// Create subSlices for each step. Skip the start and finish events,
// which are always first and last respectively.
for(var j=1;j<events.length-1;++j){if(events[j].event.ph==='T'||events[j].event.ph==='p'){isValid=this.assertStepTypeMatches_(stepType,events[j]);if(!isValid)break;}if(events[j].event.ph==='S'){this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.event.ts+', a slice named '+event.event.name+' with id='+event.event.id+' had a step before the start event.'});continue;}if(events[j].event.ph==='F'){this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.event.ts+', a slice named '+event.event.name+' with id='+event.event.id+' had a step after the finish event.'});continue;}var startIndex=j+(stepType==='T'?0:-1);var endIndex=startIndex+1;var subName=events[j].event.name;if(!events[j].event.argsStripped&&(events[j].event.ph==='T'||events[j].event.ph==='p'))subName=subName+':'+events[j].event.args.step;var asyncSliceConstructor=tr.model.AsyncSlice.subTypes.getConstructor(events[0].event.cat,subName);var subSlice=new asyncSliceConstructor(events[0].event.cat,subName,getEventColor(event,subName+j),this.toModelTimeFromUs_(events[startIndex].event.ts),this.deepCopyIfNeeded_(events[j].event.args),this.toModelTimeFromUs_(events[endIndex].event.ts-events[startIndex].event.ts),undefined,undefined,events[startIndex].event.argsStripped);subSlice.startThread=events[startIndex].thread;subSlice.endThread=events[endIndex].thread;subSlice.id=id;slice.subSlices.push(subSlice);}if(isValid){// Add |slice| to the start-thread's asyncSlices.
slice.startThread.asyncSliceGroup.push(slice);}delete asyncEventStatesByNameThenID[name][id];}}}},createNestableAsyncSlices_:function(nestableEventsByKey){for(var key in nestableEventsByKey){var eventStateEntries=nestableEventsByKey[key];// Stack of enclosing BEGIN events.
var parentStack=[];for(var i=0;i<eventStateEntries.length;++i){var eventStateEntry=eventStateEntries[i];// If this is the end of an event, match it to the start.
if(eventStateEntry.event.ph==='e'){// Walk up the parent stack to find the corresponding BEGIN for
// this END.
var parentIndex=-1;for(var k=parentStack.length-1;k>=0;--k){if(parentStack[k].event.name===eventStateEntry.event.name){parentIndex=k;break;}}if(parentIndex===-1){// Unmatched end.
eventStateEntry.finished=false;}else{parentStack[parentIndex].end=eventStateEntry;// Pop off all enclosing unmatched BEGINs util parentIndex.
while(parentIndex<parentStack.length){parentStack.pop();}}}// Inherit the current parent.
if(parentStack.length>0)eventStateEntry.parentEntry=parentStack[parentStack.length-1];if(eventStateEntry.event.ph==='b'){parentStack.push(eventStateEntry);}}var topLevelSlices=[];for(var i=0;i<eventStateEntries.length;++i){var eventStateEntry=eventStateEntries[i];// Skip matched END, as its slice will be created when we
// encounter its corresponding BEGIN.
if(eventStateEntry.event.ph==='e'&&eventStateEntry.finished===undefined){continue;}var startState=undefined;var endState=undefined;var sliceArgs=eventStateEntry.event.args||{};var sliceError=undefined;if(eventStateEntry.event.ph==='n'){startState=eventStateEntry;endState=eventStateEntry;}else if(eventStateEntry.event.ph==='b'){if(eventStateEntry.end===undefined){// Unmatched BEGIN. End it when last event with this ID ends.
eventStateEntry.end=eventStateEntries[eventStateEntries.length-1];sliceError='Slice has no matching END. End time has been adjusted.';this.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async BEGIN event at '+eventStateEntry.event.ts+' with name='+eventStateEntry.event.name+' and id='+eventStateEntry.event.id+' was unmatched.'});}else{// Include args for both END and BEGIN for a matched pair.
function concatenateArguments(args1,args2){if(args1.params===undefined||args2.params===undefined)return tr.b.concatenateObjects(args1,args2);// Make an argument object to hold the combined params.
var args3={};args3.params=tr.b.concatenateObjects(args1.params,args2.params);return tr.b.concatenateObjects(args1,args2,args3);}var endArgs=eventStateEntry.end.event.args||{};sliceArgs=concatenateArguments(sliceArgs,endArgs);}startState=eventStateEntry;endState=eventStateEntry.end;}else{// Unmatched END. Start it at the first event with this ID starts.
sliceError='Slice has no matching BEGIN. Start time has been adjusted.';this.model_.importWarning({type:'async_slice_parse_error',message:'Nestable async END event at '+eventStateEntry.event.ts+' with name='+eventStateEntry.event.name+' and id='+eventStateEntry.event.id+' was unmatched.'});startState=eventStateEntries[0];endState=eventStateEntry;}var isTopLevel=eventStateEntry.parentEntry===undefined;var asyncSliceConstructor=tr.model.AsyncSlice.subTypes.getConstructor(eventStateEntry.event.cat,eventStateEntry.event.name);var threadStart=undefined;var threadDuration=undefined;if(startState.event.tts&&startState.event.use_async_tts){threadStart=this.toModelTimeFromUs_(startState.event.tts);if(endState.event.tts){var threadEnd=this.toModelTimeFromUs_(endState.event.tts);threadDuration=threadEnd-threadStart;}}var slice=new asyncSliceConstructor(eventStateEntry.event.cat,eventStateEntry.event.name,getEventColor(endState.event),this.toModelTimeFromUs_(startState.event.ts),sliceArgs,this.toModelTimeFromUs_(endState.event.ts-startState.event.ts),isTopLevel,threadStart,threadDuration,startState.event.argsStripped);slice.startThread=startState.thread;slice.endThread=endState.thread;slice.startStackFrame=this.getStackFrameForEvent_(startState.event);slice.endStackFrame=this.getStackFrameForEvent_(endState.event);slice.id=key;if(sliceError!==undefined)slice.error=sliceError;eventStateEntry.slice=slice;// Add the slice to the topLevelSlices array if there is no parent.
// Otherwise, add the slice to the subSlices of its parent.
if(isTopLevel){topLevelSlices.push(slice);}else if(eventStateEntry.parentEntry.slice!==undefined){eventStateEntry.parentEntry.slice.subSlices.push(slice);}}for(var si=0;si<topLevelSlices.length;si++){topLevelSlices[si].startThread.asyncSliceGroup.push(topLevelSlices[si]);}}},assertStepTypeMatches_:function(stepType,event){if(stepType!=event.event.ph){this.model_.importWarning({type:'async_slice_parse_error',message:'At '+event.event.ts+', a slice named '+event.event.name+' with id='+event.event.id+' had both begin and end steps, which is not allowed.'});return false;}return true;},createFlowSlices_:function(){if(this.allFlowEvents_.length===0)return;var that=this;function validateFlowEvent(){if(event.name===undefined){that.model_.importWarning({type:'flow_slice_parse_error',message:'Flow events (ph: s, t or f) require a name parameter.'});return false;}// Support Flow API v1.
if(event.ph==='s'||event.ph==='f'||event.ph==='t'){if(event.id===undefined){that.model_.importWarning({type:'flow_slice_parse_error',message:'Flow events (ph: s, t or f) require an id parameter.'});return false;}return true;}// Support Flow API v2.
if(event.bind_id){if(event.flow_in===undefined&&event.flow_out===undefined){that.model_.importWarning({type:'flow_slice_parse_error',message:'Flow producer or consumer require flow_in or flow_out.'});return false;}return true;}return false;}var createFlowEvent=function(thread,event,opt_slice){var startSlice,flowId,flowStartTs;if(event.bind_id){// Support Flow API v2.
startSlice=opt_slice;flowId=event.bind_id;flowStartTs=this.toModelTimeFromUs_(event.ts+event.dur);}else{// Support Flow API v1.
var ts=this.toModelTimeFromUs_(event.ts);startSlice=thread.sliceGroup.findSliceAtTs(ts);if(startSlice===undefined)return undefined;flowId=event.id;flowStartTs=ts;}var flowEvent=new tr.model.FlowEvent(event.cat,flowId,event.name,getEventColor(event),flowStartTs,that.deepCopyAlways_(event.args));flowEvent.startSlice=startSlice;flowEvent.startStackFrame=that.getStackFrameForEvent_(event);flowEvent.endStackFrame=undefined;startSlice.outFlowEvents.push(flowEvent);return flowEvent;}.bind(this);var finishFlowEventWith=function(flowEvent,thread,event,refGuid,bindToParent,opt_slice){var endSlice;if(event.bind_id){// Support Flow API v2.
endSlice=opt_slice;}else{// Support Flow API v1.
var ts=this.toModelTimeFromUs_(event.ts);if(bindToParent){endSlice=thread.sliceGroup.findSliceAtTs(ts);}else{endSlice=thread.sliceGroup.findNextSliceAfter(ts,refGuid);}if(endSlice===undefined)return false;}endSlice.inFlowEvents.push(flowEvent);flowEvent.endSlice=endSlice;flowEvent.duration=this.toModelTimeFromUs_(event.ts)-flowEvent.start;flowEvent.endStackFrame=that.getStackFrameForEvent_(event);that.mergeArgsInto_(flowEvent.args,event.args,flowEvent.title);return true;}.bind(this);function processFlowConsumer(flowIdToEvent,sliceGuidToEvent,event,slice){var flowEvent=flowIdToEvent[event.bind_id];if(flowEvent===undefined){that.model_.importWarning({type:'flow_slice_ordering_error',message:'Flow consumer '+event.bind_id+' does not have '+'a flow producer'});return false;}else if(flowEvent.endSlice){// One flow producer can have more than one flow consumers.
// In this case, create a new flow event using the flow producer.
var flowProducer=flowEvent.startSlice;flowEvent=createFlowEvent(undefined,sliceGuidToEvent[flowProducer.guid],flowProducer);}var ok=finishFlowEventWith(flowEvent,undefined,event,refGuid,undefined,slice);if(ok){that.model_.flowEvents.push(flowEvent);}else{that.model_.importWarning({type:'flow_slice_end_error',message:'Flow consumer '+event.bind_id+' does not end '+'at an actual slice, so cannot be created.'});return false;}return true;}function processFlowProducer(flowIdToEvent,flowStatus,event,slice){if(flowIdToEvent[event.bind_id]&&flowStatus[event.bind_id]){// Can't open the same flow again while it's still open.
// This is essentially the multi-producer case which we don't support
that.model_.importWarning({type:'flow_slice_start_error',message:'Flow producer '+event.bind_id+' already seen'});return false;}var flowEvent=createFlowEvent(undefined,event,slice);if(!flowEvent){that.model_.importWarning({type:'flow_slice_start_error',message:'Flow producer '+event.bind_id+' does not start'+'a flow'});return false;}flowIdToEvent[event.bind_id]=flowEvent;}// Actual import.
this.allFlowEvents_.sort(function(x,y){var d=x.event.ts-y.event.ts;if(d!=0)return d;return x.sequenceNumber-y.sequenceNumber;});var flowIdToEvent={};var sliceGuidToEvent={};var flowStatus={};// true: open; false: closed.
for(var i=0;i<this.allFlowEvents_.length;++i){var data=this.allFlowEvents_[i];var refGuid=data.refGuid;var event=data.event;var thread=data.thread;if(!validateFlowEvent(event))continue;// Support for Flow API v2.
if(event.bind_id){var slice=data.slice;sliceGuidToEvent[slice.guid]=event;if(event.flowPhase===PRODUCER){if(!processFlowProducer(flowIdToEvent,flowStatus,event,slice))continue;flowStatus[event.bind_id]=true;// open the flow.
}else{if(!processFlowConsumer(flowIdToEvent,sliceGuidToEvent,event,slice))continue;flowStatus[event.bind_id]=false;// close the flow.
if(event.flowPhase===STEP){if(!processFlowProducer(flowIdToEvent,flowStatus,event,slice))continue;flowStatus[event.bind_id]=true;// open the flow again.
}}continue;}// Support for Flow API v1.
var flowEvent;if(event.ph==='s'){if(flowIdToEvent[event.id]){this.model_.importWarning({type:'flow_slice_start_error',message:'event id '+event.id+' already seen when '+'encountering start of flow event.'});continue;}flowEvent=createFlowEvent(thread,event);if(!flowEvent){this.model_.importWarning({type:'flow_slice_start_error',message:'event id '+event.id+' does not start '+'at an actual slice, so cannot be created.'});continue;}flowIdToEvent[event.id]=flowEvent;}else if(event.ph==='t'||event.ph==='f'){flowEvent=flowIdToEvent[event.id];if(flowEvent===undefined){this.model_.importWarning({type:'flow_slice_ordering_error',message:'Found flow phase '+event.ph+' for id: '+event.id+' but no flow start found.'});continue;}var bindToParent=event.ph==='t';if(event.ph==='f'){if(event.bp===undefined){// TODO(yuhaoz): In flow V2, there is no notion of binding point.
// Removal of binding point is tracked in
// https://github.com/google/trace-viewer/issues/991.
if(event.cat.indexOf('input')>-1)bindToParent=true;else if(event.cat.indexOf('ipc.flow')>-1)bindToParent=true;}else{if(event.bp!=='e'){this.model_.importWarning({type:'flow_slice_bind_point_error',message:'Flow event with invalid binding point (event.bp).'});continue;}bindToParent=true;}}var ok=finishFlowEventWith(flowEvent,thread,event,refGuid,bindToParent);if(ok){that.model_.flowEvents.push(flowEvent);}else{this.model_.importWarning({type:'flow_slice_end_error',message:'event id '+event.id+' does not end '+'at an actual slice, so cannot be created.'});}flowIdToEvent[event.id]=undefined;// If this is a step, then create another flow event.
if(ok&&event.ph==='t'){flowEvent=createFlowEvent(thread,event);flowIdToEvent[event.id]=flowEvent;}}}},/**
     * This function creates objects described via the N, D, and O phase
     * events.
     */createExplicitObjects_:function(){if(this.allObjectEvents_.length===0)return;var processEvent=function(objectEventState){var event=objectEventState.event;var scopedId=this.scopedIdForEvent_(event);var thread=objectEventState.thread;if(event.name===undefined){this.model_.importWarning({type:'object_parse_error',message:'While processing '+JSON.stringify(event)+': '+'Object events require an name parameter.'});}if(scopedId.id===undefined){this.model_.importWarning({type:'object_parse_error',message:'While processing '+JSON.stringify(event)+': '+'Object events require an id parameter.'});}var process=thread.parent;var ts=this.toModelTimeFromUs_(event.ts);var instance;if(event.ph==='N'){try{instance=process.objects.idWasCreated(scopedId,event.cat,event.name,ts);}catch(e){this.model_.importWarning({type:'object_parse_error',message:'While processing create of '+scopedId+' at ts='+ts+': '+e});return;}}else if(event.ph==='O'){if(event.args.snapshot===undefined){this.model_.importWarning({type:'object_parse_error',message:'While processing '+scopedId+' at ts='+ts+': '+'Snapshots must have args: {snapshot: ...}'});return;}var snapshot;try{var args=this.deepCopyIfNeeded_(event.args.snapshot);var cat;if(args.cat){cat=args.cat;delete args.cat;}else{cat=event.cat;}var baseTypename;if(args.base_type){baseTypename=args.base_type;delete args.base_type;}else{baseTypename=undefined;}snapshot=process.objects.addSnapshot(scopedId,cat,event.name,ts,args,baseTypename);snapshot.snapshottedOnThread=thread;}catch(e){this.model_.importWarning({type:'object_parse_error',message:'While processing snapshot of '+scopedId+' at ts='+ts+': '+e});return;}instance=snapshot.objectInstance;}else if(event.ph==='D'){try{process.objects.idWasDeleted(scopedId,event.cat,event.name,ts);var instanceMap=process.objects.getOrCreateInstanceMap_(scopedId);instance=instanceMap.lastInstance;}catch(e){this.model_.importWarning({type:'object_parse_error',message:'While processing delete of '+scopedId+' at ts='+ts+': '+e});return;}}if(instance)instance.colorId=getEventColor(event,instance.typeName);}.bind(this);this.allObjectEvents_.sort(function(x,y){var d=x.event.ts-y.event.ts;if(d!=0)return d;return x.sequenceNumber-y.sequenceNumber;});var allObjectEvents=this.allObjectEvents_;for(var i=0;i<allObjectEvents.length;i++){var objectEventState=allObjectEvents[i];try{processEvent.call(this,objectEventState);}catch(e){this.model_.importWarning({type:'object_parse_error',message:e.message});}}},createImplicitObjects_:function(){tr.b.iterItems(this.model_.processes,function(pid,process){this.createImplicitObjectsForProcess_(process);},this);},// Here, we collect all the snapshots that internally contain a
// Javascript-level object inside their args list that has an "id" field,
// and turn that into a snapshot of the instance referred to by id.
createImplicitObjectsForProcess_:function(process){function processField(referencingObject,referencingObjectFieldName,referencingObjectFieldValue,containingSnapshot){if(!referencingObjectFieldValue)return;if(referencingObjectFieldValue instanceof tr.model.ObjectSnapshot)return null;if(referencingObjectFieldValue.id===undefined)return;var implicitSnapshot=referencingObjectFieldValue;var rawId=implicitSnapshot.id;var m=/(.+)\/(.+)/.exec(rawId);if(!m)throw new Error('Implicit snapshots must have names.');delete implicitSnapshot.id;var name=m[1];var id=m[2];var res;var cat;if(implicitSnapshot.cat!==undefined)cat=implicitSnapshot.cat;else cat=containingSnapshot.objectInstance.category;var baseTypename;if(implicitSnapshot.base_type)baseTypename=implicitSnapshot.base_type;else baseTypename=undefined;var scope=containingSnapshot.objectInstance.scopedId.scope;try{res=process.objects.addSnapshot(new tr.model.ScopedId(scope,id),cat,name,containingSnapshot.ts,implicitSnapshot,baseTypename);}catch(e){this.model_.importWarning({type:'object_snapshot_parse_error',message:'While processing implicit snapshot of '+rawId+' at ts='+containingSnapshot.ts+': '+e});return;}res.objectInstance.hasImplicitSnapshots=true;res.containingSnapshot=containingSnapshot;res.snapshottedOnThread=containingSnapshot.snapshottedOnThread;referencingObject[referencingObjectFieldName]=res;if(!(res instanceof tr.model.ObjectSnapshot))throw new Error('Created object must be instanceof snapshot');return res.args;}/**
       * Iterates over the fields in the object, calling func for every
       * field/value found.
       *
       * @return {object} If the function does not want the field's value to be
       * iterated, return null. If iteration of the field value is desired, then
       * return either undefined (if the field value did not change) or the new
       * field value if it was changed.
       */function iterObject(object,func,containingSnapshot,thisArg){if(!(object instanceof Object))return;if(object instanceof Array){for(var i=0;i<object.length;i++){var res=func.call(thisArg,object,i,object[i],containingSnapshot);if(res===null)continue;if(res)iterObject(res,func,containingSnapshot,thisArg);else iterObject(object[i],func,containingSnapshot,thisArg);}return;}for(var key in object){var res=func.call(thisArg,object,key,object[key],containingSnapshot);if(res===null)continue;if(res)iterObject(res,func,containingSnapshot,thisArg);else iterObject(object[key],func,containingSnapshot,thisArg);}}// TODO(nduca): We may need to iterate the instances in sorted order by
// creationTs.
process.objects.iterObjectInstances(function(instance){instance.snapshots.forEach(function(snapshot){if(snapshot.args.id!==undefined)throw new Error('args cannot have an id field inside it');iterObject(snapshot.args,processField,snapshot,this);},this);},this);},createMemoryDumps_:function(){for(var dumpId in this.allMemoryDumpEvents_)this.createGlobalMemoryDump_(this.allMemoryDumpEvents_[dumpId],dumpId);},createGlobalMemoryDump_:function(dumpIdEvents,dumpId){// 1. Create a GlobalMemoryDump for the provided process memory dump
// the events, all of which have the same dump ID.
// Calculate the range of the global memory dump.
var globalRange=new tr.b.Range();for(var pid in dumpIdEvents){var processEvents=dumpIdEvents[pid];for(var i=0;i<processEvents.length;i++)globalRange.addValue(this.toModelTimeFromUs_(processEvents[i].ts));}if(globalRange.isEmpty)throw new Error('Internal error: Global memory dump without events');// Create the global memory dump.
var globalMemoryDump=new tr.model.GlobalMemoryDump(this.model_,globalRange.min);globalMemoryDump.duration=globalRange.range;this.model_.globalMemoryDumps.push(globalMemoryDump);var globalMemoryAllocatorDumpsByFullName={};var levelsOfDetail={};var allMemoryAllocatorDumpsByGuid={};// 2. Create a ProcessMemoryDump for each PID in the provided process
// memory dump events. Everything except for edges between memory
// allocator dumps is parsed from the process memory dump trace events at
// this step.
for(var pid in dumpIdEvents){this.createProcessMemoryDump_(globalMemoryDump,globalMemoryAllocatorDumpsByFullName,levelsOfDetail,allMemoryAllocatorDumpsByGuid,dumpIdEvents[pid],pid,dumpId);}// 3. Set the level of detail and memory allocator dumps of the
// GlobalMemoryDump, which come from the process memory dump trace
// events parsed in the prebvious step.
globalMemoryDump.levelOfDetail=levelsOfDetail.global;// Find the root allocator dumps and establish the parent links of
// the global memory dump.
globalMemoryDump.memoryAllocatorDumps=this.inferMemoryAllocatorDumpTree_(globalMemoryAllocatorDumpsByFullName);// 4. Finally, parse the edges between all memory allocator dumps within
// the GlobalMemoryDump. This can only be done once all memory allocator
// dumps have been parsed (i.e. it is necessary to iterate over the
// process memory dump trace events once more).
this.parseMemoryDumpAllocatorEdges_(allMemoryAllocatorDumpsByGuid,dumpIdEvents,dumpId);},createProcessMemoryDump_:function(globalMemoryDump,globalMemoryAllocatorDumpsByFullName,levelsOfDetail,allMemoryAllocatorDumpsByGuid,processEvents,pid,dumpId){// Calculate the range of the process memory dump.
var processRange=new tr.b.Range();for(var i=0;i<processEvents.length;i++)processRange.addValue(this.toModelTimeFromUs_(processEvents[i].ts));if(processRange.isEmpty)throw new Error('Internal error: Process memory dump without events');// Create the process memory dump.
var process=this.model_.getOrCreateProcess(pid);var processMemoryDump=new tr.model.ProcessMemoryDump(globalMemoryDump,process,processRange.min);processMemoryDump.duration=processRange.range;process.memoryDumps.push(processMemoryDump);globalMemoryDump.processMemoryDumps[pid]=processMemoryDump;var processMemoryAllocatorDumpsByFullName={};// Parse all process memory dump trace events for the newly created
// ProcessMemoryDump.
for(var i=0;i<processEvents.length;i++){var processEvent=processEvents[i];var dumps=processEvent.args.dumps;if(dumps===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'\'dumps\' field not found in a process memory dump'+' event for PID='+pid+' and dump ID='+dumpId+'.'});continue;}// Totals, VM regions, and heap dumps for the newly created
// ProcessMemoryDump should be present in at most one event, so they
// can be added to the ProcessMemoryDump immediately.
this.parseMemoryDumpTotals_(processMemoryDump,dumps,pid,dumpId);this.parseMemoryDumpVmRegions_(processMemoryDump,dumps,pid,dumpId);this.parseMemoryDumpHeapDumps_(processMemoryDump,dumps,pid,dumpId);// All process memory dump trace events for the newly created
// ProcessMemoryDump must be processed before level of detail and
// allocator dumps can be added to it.
this.parseMemoryDumpLevelOfDetail_(levelsOfDetail,dumps,pid,dumpId);this.parseMemoryDumpAllocatorDumps_(processMemoryDump,globalMemoryDump,processMemoryAllocatorDumpsByFullName,globalMemoryAllocatorDumpsByFullName,allMemoryAllocatorDumpsByGuid,dumps,pid,dumpId);}if(levelsOfDetail.process===undefined){// Infer level of detail from the presence of VM regions in legacy
// traces (where raw process memory dump events don't contain the
// level_of_detail field). These traces will not have BACKGROUND mode.
levelsOfDetail.process=processMemoryDump.vmRegions?DETAILED:LIGHT;}if(!this.updateMemoryDumpLevelOfDetail_(levelsOfDetail,'global',levelsOfDetail.process)){this.model_.importWarning({type:'memory_dump_parse_error',message:'diffent levels of detail provided for global memory'+' dump (dump ID='+dumpId+').'});}processMemoryDump.levelOfDetail=levelsOfDetail.process;delete levelsOfDetail.process;// Reused for all process dumps.
// Find the root allocator dumps and establish the parent links of
// the process memory dump.
processMemoryDump.memoryAllocatorDumps=this.inferMemoryAllocatorDumpTree_(processMemoryAllocatorDumpsByFullName);},parseMemoryDumpTotals_:function(processMemoryDump,dumps,pid,dumpId){var rawTotals=dumps.process_totals;if(rawTotals===undefined)return;if(processMemoryDump.totals!==undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Process totals provided multiple times for'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});return;}var totals={};var platformSpecificTotals=undefined;for(var rawTotalName in rawTotals){var rawTotalValue=rawTotals[rawTotalName];if(rawTotalValue===undefined)continue;// Total resident bytes.
if(rawTotalName==='resident_set_bytes'){totals.residentBytes=parseInt(rawTotalValue,16);continue;}// Peak resident bytes.
if(rawTotalName==='peak_resident_set_bytes'){totals.peakResidentBytes=parseInt(rawTotalValue,16);continue;}if(rawTotalName==='is_peak_rss_resetable'){totals.arePeakResidentBytesResettable=!!rawTotalValue;continue;}// OS-specific totals (e.g. private resident on Mac).
if(platformSpecificTotals===undefined){platformSpecificTotals={};totals.platformSpecific=platformSpecificTotals;}platformSpecificTotals[rawTotalName]=parseInt(rawTotalValue,16);}// Either both peak_resident_set_bytes and is_peak_rss_resetable should
// be present in the trace, or neither.
if(totals.peakResidentBytes===undefined&&totals.arePeakResidentBytesResettable!==undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Optional field peak_resident_set_bytes found'+' but is_peak_rss_resetable not found in'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});}if(totals.arePeakResidentBytesResettable!==undefined&&totals.peakResidentBytes===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Optional field is_peak_rss_resetable found'+' but peak_resident_set_bytes not found in'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});}processMemoryDump.totals=totals;},parseMemoryDumpVmRegions_:function(processMemoryDump,dumps,pid,dumpId){var rawProcessMmaps=dumps.process_mmaps;if(rawProcessMmaps===undefined)return;var rawVmRegions=rawProcessMmaps.vm_regions;if(rawVmRegions===undefined)return;if(processMemoryDump.vmRegions!==undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'VM regions provided multiple times for'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});return;}// See //base/trace_event/process_memory_maps.cc in Chromium.
var vmRegions=new Array(rawVmRegions.length);for(var i=0;i<rawVmRegions.length;i++){var rawVmRegion=rawVmRegions[i];var byteStats={};var rawByteStats=rawVmRegion.bs;for(var rawByteStatName in rawByteStats){var rawByteStatValue=rawByteStats[rawByteStatName];if(rawByteStatValue===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Byte stat \''+rawByteStatName+'\' of VM region '+i+' ('+rawVmRegion.mf+') in process memory dump for '+'PID='+pid+' and dump ID='+dumpId+' does not have a value.'});continue;}var byteStatName=BYTE_STAT_NAME_MAP[rawByteStatName];if(byteStatName===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Unknown byte stat name \''+rawByteStatName+'\' ('+rawByteStatValue+') of VM region '+i+' ('+rawVmRegion.mf+') in process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});continue;}byteStats[byteStatName]=parseInt(rawByteStatValue,16);}vmRegions[i]=new tr.model.VMRegion(parseInt(rawVmRegion.sa,16),// startAddress
parseInt(rawVmRegion.sz,16),// sizeInBytes
rawVmRegion.pf,// protectionFlags
rawVmRegion.mf,// mappedFile
byteStats);}processMemoryDump.vmRegions=tr.model.VMRegionClassificationNode.fromRegions(vmRegions);},parseMemoryDumpHeapDumps_:function(processMemoryDump,dumps,pid,dumpId){var rawHeapDumps=dumps.heaps;if(rawHeapDumps===undefined)return;if(processMemoryDump.heapDumps!==undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Heap dumps provided multiple times for'+' process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});return;}var model=this.model_;var idPrefix='p'+pid+':';var heapDumps={};var objectTypeNameMap=this.objectTypeNameMap_[pid];if(objectTypeNameMap===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing mapping from object type IDs to names.'});}for(var allocatorName in rawHeapDumps){var entries=rawHeapDumps[allocatorName].entries;if(entries===undefined||entries.length===0){this.model_.importWarning({type:'memory_dump_parse_error',message:'No heap entries in a '+allocatorName+' heap dump for PID='+pid+' and dump ID='+dumpId+'.'});continue;}// The old format always starts with a {size: <total>} entry.
// See https://goo.gl/WYStil
// TODO(petrcermak): Remove support for the old format once the new
// format has been around long enough.
var isOldFormat=entries[0].bt===undefined;if(!isOldFormat&&objectTypeNameMap===undefined){// Mapping from object type IDs to names must be provided in the new
// format.
continue;}var heapDump=new tr.model.HeapDump(processMemoryDump,allocatorName);for(var i=0;i<entries.length;i++){var entry=entries[i];var leafStackFrameIndex=entry.bt;var leafStackFrame;// There are two possible mappings from leaf stack frame indices
// (provided in the trace) to the corresponding stack frames
// depending on the format.
if(isOldFormat){// Old format:
//   Undefined index        -> / (root)
//   Defined index for /A/B -> /A/B/<self>
if(leafStackFrameIndex===undefined){leafStackFrame=undefined/* root */;}else{// Get the leaf stack frame corresponding to the provided index.
var leafStackFrameId=idPrefix+leafStackFrameIndex;if(leafStackFrameIndex===''){leafStackFrame=undefined/* root */;}else{leafStackFrame=model.stackFrames[leafStackFrameId];if(leafStackFrame===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing leaf stack frame (ID '+leafStackFrameId+') of heap entry '+i+' (size '+size+') in a '+allocatorName+' heap dump for PID='+pid+'.'});continue;}}// Inject an artificial <self> leaf stack frame.
leafStackFrameId+=':self';if(model.stackFrames[leafStackFrameId]!==undefined){// The frame might already exist if there are multiple process
// memory dumps (for the same process) in the trace.
leafStackFrame=model.stackFrames[leafStackFrameId];}else{leafStackFrame=new tr.model.StackFrame(leafStackFrame,leafStackFrameId,'<self>',undefined/* colorId */);model.addStackFrame(leafStackFrame);}}}else{// New format:
//   Undefined index        -> (invalid value)
//   Defined index for /A/B -> /A/B
if(leafStackFrameIndex===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing stack frame ID of heap entry '+i+' (size '+size+') in a '+allocatorName+' heap dump for PID='+pid+'.'});continue;}// Get the leaf stack frame corresponding to the provided index.
var leafStackFrameId=idPrefix+leafStackFrameIndex;if(leafStackFrameIndex===''){leafStackFrame=undefined/* root */;}else{leafStackFrame=model.stackFrames[leafStackFrameId];if(leafStackFrame===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing leaf stack frame (ID '+leafStackFrameId+') of heap entry '+i+' (size '+size+') in a '+allocatorName+' heap dump for PID='+pid+'.'});continue;}}}var objectTypeId=entry.type;var objectTypeName;if(objectTypeId===undefined){objectTypeName=undefined/* total over all types */;}else if(objectTypeNameMap===undefined){// This can only happen when the old format is used.
continue;}else{objectTypeName=objectTypeNameMap[objectTypeId];if(objectTypeName===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Missing object type name (ID '+objectTypeId+') of heap entry '+i+' (size '+size+') in a '+allocatorName+' heap dump for pid='+pid+'.'});continue;}}var size=parseInt(entry.size,16);var count=entry.count===undefined?undefined:parseInt(entry.count,16);heapDump.addEntry(leafStackFrame,objectTypeName,size,count);}// Throw away heap dumps with no entries. This can happen if all raw
// entries in the trace are skipped for some reason (e.g. invalid leaf
// stack frame ID).
if(heapDump.entries.length>0)heapDumps[allocatorName]=heapDump;}if(Object.keys(heapDumps).length>0)processMemoryDump.heapDumps=heapDumps;},parseMemoryDumpLevelOfDetail_:function(levelsOfDetail,dumps,pid,dumpId){var rawLevelOfDetail=dumps.level_of_detail;var level;switch(rawLevelOfDetail){case'background':level=BACKGROUND;break;case'light':level=LIGHT;break;case'detailed':level=DETAILED;break;case undefined:level=undefined;break;default:this.model_.importWarning({type:'memory_dump_parse_error',message:'unknown raw level of detail \''+rawLevelOfDetail+'\' of process memory dump for PID='+pid+' and dump ID='+dumpId+'.'});return;}if(!this.updateMemoryDumpLevelOfDetail_(levelsOfDetail,'process',level)){this.model_.importWarning({type:'memory_dump_parse_error',message:'diffent levels of detail provided for process memory'+' dump for PID='+pid+' (dump ID='+dumpId+').'});}},updateMemoryDumpLevelOfDetail_:function(levelsOfDetail,scope,level){// If all process memory dump events have the same level of detail (for
// the particular 'process' or 'global' scope), return true.
if(!(scope in levelsOfDetail)||level===levelsOfDetail[scope]){levelsOfDetail[scope]=level;return true;}// If the process memory dump events have different levels of detail (for
// the particular 'process' or 'global' scope), use the highest level and
// return false.
if(MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER.indexOf(level)>MEMORY_DUMP_LEVEL_OF_DETAIL_ORDER.indexOf(levelsOfDetail[scope])){levelsOfDetail[scope]=level;}return false;},parseMemoryDumpAllocatorDumps_:function(processMemoryDump,globalMemoryDump,processMemoryAllocatorDumpsByFullName,globalMemoryAllocatorDumpsByFullName,allMemoryAllocatorDumpsByGuid,dumps,pid,dumpId){var rawAllocatorDumps=dumps.allocators;if(rawAllocatorDumps===undefined)return;// Construct the MemoryAllocatorDump objects without parent links
// and add them to the processMemoryAllocatorDumpsByName and
// globalMemoryAllocatorDumpsByName indices appropriately.
for(var fullName in rawAllocatorDumps){var rawAllocatorDump=rawAllocatorDumps[fullName];// Every memory allocator dump should have a GUID. If not, then
// it cannot be associated with any edges.
var guid=rawAllocatorDump.guid;if(guid===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump '+fullName+' for PID='+pid+' and dump ID='+dumpId+' does not have a GUID.'});}// A memory allocator dump can have optional flags.
var flags=rawAllocatorDump.flags||0;var isWeakDump=!!(flags&WEAK_MEMORY_ALLOCATOR_DUMP_FLAG);// Determine if this is a global memory allocator dump (check if
// it's prefixed with 'global/').
var containerMemoryDump;var dstIndex;if(fullName.startsWith(GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX)){// Global memory allocator dump.
fullName=fullName.substring(GLOBAL_MEMORY_ALLOCATOR_DUMP_PREFIX.length);containerMemoryDump=globalMemoryDump;dstIndex=globalMemoryAllocatorDumpsByFullName;}else{// Process memory allocator dump.
containerMemoryDump=processMemoryDump;dstIndex=processMemoryAllocatorDumpsByFullName;}// Construct or retrieve a memory allocator dump with the provided
// GUID.
var allocatorDump=allMemoryAllocatorDumpsByGuid[guid];if(allocatorDump===undefined){if(fullName in dstIndex){this.model_.importWarning({type:'memory_dump_parse_error',message:'Multiple GUIDs provided for'+' memory allocator dump '+fullName+': '+dstIndex[fullName].guid+', '+guid+' (ignored) for'+' PID='+pid+' and dump ID='+dumpId+'.'});continue;}allocatorDump=new tr.model.MemoryAllocatorDump(containerMemoryDump,fullName,guid);allocatorDump.weak=isWeakDump;dstIndex[fullName]=allocatorDump;if(guid!==undefined)allMemoryAllocatorDumpsByGuid[guid]=allocatorDump;}else{// A memory allocator dump with this GUID has already been
// dumped (so we will only add new attributes). Check that it
// belonged to the same process or was also global.
if(allocatorDump.containerMemoryDump!==containerMemoryDump){this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+' dumped in different contexts.'});continue;}// Check that the names of the memory allocator dumps match.
if(allocatorDump.fullName!==fullName){this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump with GUID='+guid+' for PID='+pid+' and dump ID='+dumpId+' has multiple names: '+allocatorDump.fullName+', '+fullName+' (ignored).'});continue;}if(!isWeakDump){// A MemoryAllocatorDump is non-weak if at least one process dumped
// it without WEAK_MEMORY_ALLOCATOR_DUMP_FLAG.
allocatorDump.weak=false;}}// Add all new attributes to the memory allocator dump.
var attributes=rawAllocatorDump.attrs;if(attributes===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+' does not have attributes.'});attributes={};}for(var attrName in attributes){var attrArgs=attributes[attrName];var attrType=attrArgs.type;var attrValue=attrArgs.value;switch(attrType){case'scalar':if(attrName in allocatorDump.numerics){this.model_.importWarning({type:'memory_dump_parse_error',message:'Multiple values provided for scalar attribute '+attrName+' of memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+'.'});break;}var unit=attrArgs.units==='bytes'?tr.b.Unit.byName.sizeInBytes_smallerIsBetter:tr.b.Unit.byName.unitlessNumber_smallerIsBetter;var value=parseInt(attrValue,16);allocatorDump.addNumeric(attrName,new tr.v.ScalarNumeric(unit,value));break;case'string':if(attrName in allocatorDump.diagnostics){this.model_.importWarning({type:'memory_dump_parse_error',message:'Multiple values provided for string attribute '+attrName+' of memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+'.'});break;}allocatorDump.addDiagnostic(attrName,attrValue);break;default:this.model_.importWarning({type:'memory_dump_parse_error',message:'Unknown type provided for attribute '+attrName+' of memory allocator dump '+fullName+' (GUID='+guid+') for PID='+pid+' and dump ID='+dumpId+': '+attrType});break;}}}},inferMemoryAllocatorDumpTree_:function(memoryAllocatorDumpsByFullName){var rootAllocatorDumps=[];var fullNames=Object.keys(memoryAllocatorDumpsByFullName);fullNames.sort();for(var i=0;i<fullNames.length;i++){var fullName=fullNames[i];var allocatorDump=memoryAllocatorDumpsByFullName[fullName];// This is a loop because we might need to build implicit
// ancestors in case they were not present in the trace.
while(true){var lastSlashIndex=fullName.lastIndexOf('/');if(lastSlashIndex===-1){// If the dump is a root, add it to the top-level
// rootAllocatorDumps list.
rootAllocatorDumps.push(allocatorDump);break;}// If the dump is not a root, find its parent.
var parentFullName=fullName.substring(0,lastSlashIndex);var parentAllocatorDump=memoryAllocatorDumpsByFullName[parentFullName];// If the parent dump does not exist yet, we build an implicit
// one and continue up the ancestor chain.
var parentAlreadyExisted=true;if(parentAllocatorDump===undefined){parentAlreadyExisted=false;parentAllocatorDump=new tr.model.MemoryAllocatorDump(allocatorDump.containerMemoryDump,parentFullName);if(allocatorDump.weak!==false){// If we are inferring a parent dump (e.g. 'root/parent') of a
// current dump (e.g. 'root/parent/current') which is weak (or
// was also inferred and we don't know yet whether it's weak or
// not), then we clear the weak flag on the parent dump because
// we don't know yet whether it should be weak or non-weak:
//
//   * We can't mark the parent as non-weak straightaway because
//     the parent might have no non-weak descendants (in which
//     case we want the inferred parent to be weak, so that it
//     would be later removed like the current dump).
//   * We can't mark the parent as weak immediately either. If we
//     did and later encounter a non-weak child of the parent
//     (e.g. 'root/parent/another_child'), then we couldn't
//     retroactively mark the inferred parent dump as non-weak
//     because we couldn't tell whether the parent dump was
//     dumped in the trace as weak (in which case it should stay
//     weak and be subsequently removed) or whether it was
//     inferred as weak (in which case it should be changed to
//     non-weak).
//
// Therefore, we defer marking the inferred parent as
// weak/non-weak. If an inferred parent dump does not have any
// non-weak child, it will be marked as weak at the end of this
// method.
//
// Note that this should not be confused with the recursive
// propagation of the weak flag from parent dumps to their
// children and from owned dumps to their owners, which is
// performed in GlobalMemoryDump.prototype.removeWeakDumps().
parentAllocatorDump.weak=undefined;}memoryAllocatorDumpsByFullName[parentFullName]=parentAllocatorDump;}// Setup the parent <-> children relationships
allocatorDump.parent=parentAllocatorDump;parentAllocatorDump.children.push(allocatorDump);// If the parent already existed, then its ancestors were/will be
// constructed in another iteration of the forEach loop.
if(parentAlreadyExisted){if(!allocatorDump.weak){// If the current dump is non-weak, then we must ensure that all
// its inferred ancestors are also non-weak.
while(parentAllocatorDump!==undefined&&parentAllocatorDump.weak===undefined){parentAllocatorDump.weak=false;parentAllocatorDump=parentAllocatorDump.parent;}}break;}fullName=parentFullName;allocatorDump=parentAllocatorDump;}}// All inferred ancestor dumps that have a non-weak child have already
// been marked as non-weak. We now mark the rest as weak.
for(var fullName in memoryAllocatorDumpsByFullName){var allocatorDump=memoryAllocatorDumpsByFullName[fullName];if(allocatorDump.weak===undefined)allocatorDump.weak=true;}return rootAllocatorDumps;},parseMemoryDumpAllocatorEdges_:function(allMemoryAllocatorDumpsByGuid,dumpIdEvents,dumpId){for(var pid in dumpIdEvents){var processEvents=dumpIdEvents[pid];for(var i=0;i<processEvents.length;i++){var processEvent=processEvents[i];var dumps=processEvent.args.dumps;if(dumps===undefined)continue;var rawEdges=dumps.allocators_graph;if(rawEdges===undefined)continue;for(var j=0;j<rawEdges.length;j++){var rawEdge=rawEdges[j];var sourceGuid=rawEdge.source;var sourceDump=allMemoryAllocatorDumpsByGuid[sourceGuid];if(sourceDump===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Edge for PID='+pid+' and dump ID='+dumpId+' is missing source memory allocator dump (GUID='+sourceGuid+').'});continue;}var targetGuid=rawEdge.target;var targetDump=allMemoryAllocatorDumpsByGuid[targetGuid];if(targetDump===undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Edge for PID='+pid+' and dump ID='+dumpId+' is missing target memory allocator dump (GUID='+targetGuid+').'});continue;}var importance=rawEdge.importance;var edge=new tr.model.MemoryAllocatorDumpLink(sourceDump,targetDump,importance);switch(rawEdge.type){case'ownership':if(sourceDump.owns!==undefined){this.model_.importWarning({type:'memory_dump_parse_error',message:'Memory allocator dump '+sourceDump.fullName+' (GUID='+sourceGuid+') already owns a memory'+' allocator dump ('+sourceDump.owns.target.fullName+').'});}else{sourceDump.owns=edge;targetDump.ownedBy.push(edge);}break;case'retention':sourceDump.retains.push(edge);targetDump.retainedBy.push(edge);break;default:this.model_.importWarning({type:'memory_dump_parse_error',message:'Invalid edge type: '+rawEdge.type+' (PID='+pid+', dump ID='+dumpId+', source='+sourceGuid+', target='+targetGuid+', importance='+importance+').'});}}}}},/**
     * Converts |ts| (in microseconds) to a timestamp in the model clock domain
     * (in milliseconds).
     */toModelTimeFromUs_:function(ts){if(!this.toModelTime_){this.toModelTime_=this.model_.clockSyncManager.getModelTimeTransformer(this.clockDomainId_);}return this.toModelTime_(tr.b.Unit.timestampFromUs(ts));},/**
     * Converts |ts| (in microseconds) to a timestamp in the model clock domain
     * (in milliseconds). If |ts| is undefined, undefined is returned.
     */maybeToModelTimeFromUs_:function(ts){if(ts===undefined)return undefined;return this.toModelTimeFromUs_(ts);}};tr.importer.Importer.register(TraceEventImporter);return{TraceEventImporter:TraceEventImporter};});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/base64.js":29,"../../base/color_scheme.js":32,"../../base/range.js":47,"../../base/unit.js":57,"../../base/utils.js":59,"../../importer/context_processor.js":70,"../../importer/importer.js":76,"../../model/comment_box_annotation.js":106,"../../model/constants.js":108,"../../model/container_memory_dump.js":109,"../../model/counter_series.js":112,"../../model/flow_event.js":121,"../../model/global_memory_dump.js":123,"../../model/heap_dump.js":124,"../../model/instant_event.js":130,"../../model/memory_allocator_dump.js":134,"../../model/model.js":135,"../../model/process_memory_dump.js":145,"../../model/rect_annotation.js":146,"../../model/scoped_id.js":148,"../../model/slice_group.js":152,"../../model/vm_region.js":168,"../../model/x_marker_annotation.js":169,"../../value/numeric.js":190,"./trace_code_entry.js":64,"./trace_code_map.js":65,"./v8/codemap.js":67}],67:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./splaytree.js");

'use strict';

/**
 * @fileoverview Map addresses to dynamically created functions.
 */
global.tr.exportTo('tr.e.importer.v8', function () {
  /**
   * Constructs a mapper that maps addresses into code entries.
   *
   * @constructor
   */
  function CodeMap() {
    /**
     * Dynamic code entries. Used for JIT compiled code.
     */
    this.dynamics_ = new tr.e.importer.v8.SplayTree();

    /**
     * Name generator for entries having duplicate names.
     */
    this.dynamicsNameGen_ = new tr.e.importer.v8.CodeMap.NameGenerator();

    /**
     * Static code entries. Used for statically compiled code.
     */
    this.statics_ = new tr.e.importer.v8.SplayTree();

    /**
     * Libraries entries. Used for the whole static code libraries.
     */
    this.libraries_ = new tr.e.importer.v8.SplayTree();

    /**
     * Map of memory pages occupied with static code.
     */
    this.pages_ = [];
  }

  /**
   * The number of alignment bits in a page address.
   */
  CodeMap.PAGE_ALIGNMENT = 12;

  /**
   * Page size in bytes.
   */
  CodeMap.PAGE_SIZE = 1 << CodeMap.PAGE_ALIGNMENT;

  /**
   * Adds a dynamic (i.e. moveable and discardable) code entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addCode = function (start, codeEntry) {
    this.deleteAllCoveredNodes_(this.dynamics_, start, start + codeEntry.size);
    this.dynamics_.insert(start, codeEntry);
  };

  /**
   * Moves a dynamic code entry. Throws an exception if there is no dynamic
   * code entry with the specified starting address.
   *
   * @param {number} from The starting address of the entry being moved.
   * @param {number} to The destination address.
   */
  CodeMap.prototype.moveCode = function (from, to) {
    var removedNode = this.dynamics_.remove(from);
    this.deleteAllCoveredNodes_(this.dynamics_, to, to + removedNode.value.size);
    this.dynamics_.insert(to, removedNode.value);
  };

  /**
   * Discards a dynamic code entry. Throws an exception if there is no dynamic
   * code entry with the specified starting address.
   *
   * @param {number} start The starting address of the entry being deleted.
   */
  CodeMap.prototype.deleteCode = function (start) {
    var removedNode = this.dynamics_.remove(start);
  };

  /**
   * Adds a library entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addLibrary = function (start, codeEntry) {
    this.markPages_(start, start + codeEntry.size);
    this.libraries_.insert(start, codeEntry);
  };

  /**
   * Adds a static code entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addStaticCode = function (start, codeEntry) {
    this.statics_.insert(start, codeEntry);
  };

  /**
   * @private
   */
  CodeMap.prototype.markPages_ = function (start, end) {
    for (var addr = start; addr <= end; addr += CodeMap.PAGE_SIZE) {
      this.pages_[addr >>> CodeMap.PAGE_ALIGNMENT] = 1;
    }
  };

  /**
   * @private
   */
  CodeMap.prototype.deleteAllCoveredNodes_ = function (tree, start, end) {
    var toDelete = [];
    var addr = end - 1;
    while (addr >= start) {
      var node = tree.findGreatestLessThan(addr);
      if (!node) break;
      var start2 = node.key,
          end2 = start2 + node.value.size;
      if (start2 < end && start < end2) toDelete.push(start2);
      addr = start2 - 1;
    }
    for (var i = 0, l = toDelete.length; i < l; ++i) tree.remove(toDelete[i]);
  };

  /**
   * @private
   */
  CodeMap.prototype.isAddressBelongsTo_ = function (addr, node) {
    return addr >= node.key && addr < node.key + node.value.size;
  };

  /**
   * @private
   */
  CodeMap.prototype.findInTree_ = function (tree, addr) {
    var node = tree.findGreatestLessThan(addr);
    return node && this.isAddressBelongsTo_(addr, node) ? node.value : null;
  };

  /**
   * Finds a code entry that contains the specified address in static libraries.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findEntryInLibraries = function (addr) {
    var pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
    if (pageAddr in this.pages_) return this.findInTree_(this.libraries_, addr);
    return undefined;
  };

  /**
   * Finds a code entry that contains the specified address. Both static and
   * dynamic code entries are considered.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findEntry = function (addr) {
    var pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
    if (pageAddr in this.pages_) {
      // Static code entries can contain "holes" of unnamed code.
      // In this case, the whole library is assigned to this address.
      return this.findInTree_(this.statics_, addr) || this.findInTree_(this.libraries_, addr);
    }
    var min = this.dynamics_.findMin();
    var max = this.dynamics_.findMax();
    if (max != null && addr < max.key + max.value.size && addr >= min.key) {
      var dynaEntry = this.findInTree_(this.dynamics_, addr);
      if (dynaEntry == null) return null;
      // Dedupe entry name.
      if (!dynaEntry.nameUpdated_) {
        dynaEntry.name = this.dynamicsNameGen_.getName(dynaEntry.name);
        dynaEntry.nameUpdated_ = true;
      }
      return dynaEntry;
    }
    return null;
  };

  /**
   * Returns a dynamic code entry using its starting address.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findDynamicEntryByStartAddress = function (addr) {
    var node = this.dynamics_.find(addr);
    return node ? node.value : null;
  };

  /**
   * Returns an array of all dynamic code entries.
   */
  CodeMap.prototype.getAllDynamicEntries = function () {
    return this.dynamics_.exportValues();
  };

  /**
   * Returns an array of pairs of all dynamic code entries and their addresses.
   */
  CodeMap.prototype.getAllDynamicEntriesWithAddresses = function () {
    return this.dynamics_.exportKeysAndValues();
  };

  /**
   * Returns an array of all static code entries.
   */
  CodeMap.prototype.getAllStaticEntries = function () {
    return this.statics_.exportValues();
  };

  /**
   * Returns an array of all libraries entries.
   */
  CodeMap.prototype.getAllLibrariesEntries = function () {
    return this.libraries_.exportValues();
  };

  /**
   * Enum for code state regarding its dynamic optimization.
   *
   * @enum {number}
   */
  CodeMap.CodeState = {
    COMPILED: 0,
    OPTIMIZABLE: 1,
    OPTIMIZED: 2
  };

  /**
   * Creates a code entry object.
   *
   * @param {number} size Code entry size in bytes.
   * @param {string=} opt_name Code entry name.
   * @constructor
   */
  CodeMap.CodeEntry = function (size, opt_name, opt_type) {
    this.id = tr.b.GUID.allocateSimple();
    this.size = size;
    this.name_ = opt_name || '';
    this.type = opt_type || '';
    this.nameUpdated_ = false;
  };

  CodeMap.CodeEntry.prototype = {
    __proto__: Object.prototype,

    get name() {
      return this.name_;
    },

    set name(value) {
      this.name_ = value;
    },

    toString: function () {
      this.name_ + ': ' + this.size.toString(16);
    }
  };

  CodeMap.CodeEntry.TYPE = {
    SHARED_LIB: 'SHARED_LIB',
    CPP: 'CPP'
  };

  /**
   * Creates a dynamic code entry.
   *
   * @param {number} size Code size.
   * @param {string} type Code type.
   * @param {CodeMap.FunctionEntry} func Shared function entry.
   * @param {CodeMap.CodeState} state Code optimization state.
   * @constructor
   */
  CodeMap.DynamicFuncCodeEntry = function (size, type, func, state) {
    CodeMap.CodeEntry.call(this, size, '', type);
    this.func = func;
    this.state = state;
  };

  CodeMap.DynamicFuncCodeEntry.STATE_PREFIX = ['', '~', '*'];

  CodeMap.DynamicFuncCodeEntry.prototype = {
    __proto__: CodeMap.CodeEntry.prototype,

    /**
     * Returns node name.
     */
    get name() {
      return CodeMap.DynamicFuncCodeEntry.STATE_PREFIX[this.state] + this.func.name;
    },

    set name(value) {
      this.name_ = value;
    },

    /**
     * Returns raw node name (without type decoration).
     */
    getRawName: function () {
      return this.func.getName();
    },

    isJSFunction: function () {
      return true;
    },

    toString: function () {
      return this.type + ': ' + this.name + ': ' + this.size.toString(16);
    }
  };

  /**
   * Creates a shared function object entry.
   *
   * @param {string} name Function name.
   * @constructor
   */
  CodeMap.FunctionEntry = function (name) {
    CodeMap.CodeEntry.call(this, 0, name);
  };

  CodeMap.FunctionEntry.prototype = {
    __proto__: CodeMap.CodeEntry.prototype,

    /**
     * Returns node name.
     */
    get name() {
      var name = this.name_;
      if (name.length == 0) {
        name = '<anonymous>';
      } else if (name.charAt(0) == ' ') {
        // An anonymous function with location: " aaa.js:10".
        name = '<anonymous>' + name;
      }
      return name;
    },

    set name(value) {
      this.name_ = value;
    }
  };

  CodeMap.NameGenerator = function () {
    this.knownNames_ = {};
  };

  CodeMap.NameGenerator.prototype.getName = function (name) {
    if (!(name in this.knownNames_)) {
      this.knownNames_[name] = 0;
      return name;
    }
    var count = ++this.knownNames_[name];
    return name + ' {' + count + '}';
  };
  return {
    CodeMap: CodeMap
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./splaytree.js":68}],68:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../../base/base.js");

'use strict';

/**
 * @fileoverview Splay tree used by CodeMap.
 */
global.tr.exportTo('tr.e.importer.v8', function () {
  /**
   * Constructs a Splay tree.  A splay tree is a self-balancing binary
   * search tree with the additional property that recently accessed
   * elements are quick to access again. It performs basic operations
   * such as insertion, look-up and removal in O(log(n)) amortized time.
   *
   * @constructor
   */
  function SplayTree() {};

  /**
   * Pointer to the root node of the tree.
   *
   * @type {SplayTree.Node}
   * @private
   */
  SplayTree.prototype.root_ = null;

  /**
   * @return {boolean} Whether the tree is empty.
   */
  SplayTree.prototype.isEmpty = function () {
    return !this.root_;
  };

  /**
   * Inserts a node into the tree with the specified key and value if
   * the tree does not already contain a node with the specified key. If
   * the value is inserted, it becomes the root of the tree.
   *
   * @param {number} key Key to insert into the tree.
   * @param {*} value Value to insert into the tree.
   */
  SplayTree.prototype.insert = function (key, value) {
    if (this.isEmpty()) {
      this.root_ = new SplayTree.Node(key, value);
      return;
    }
    // Splay on the key to move the last node on the search path for
    // the key to the root of the tree.
    this.splay_(key);
    if (this.root_.key == key) {
      return;
    }
    var node = new SplayTree.Node(key, value);
    if (key > this.root_.key) {
      node.left = this.root_;
      node.right = this.root_.right;
      this.root_.right = null;
    } else {
      node.right = this.root_;
      node.left = this.root_.left;
      this.root_.left = null;
    }
    this.root_ = node;
  };

  /**
   * Removes a node with the specified key from the tree if the tree
   * contains a node with this key. The removed node is returned. If the
   * key is not found, an exception is thrown.
   *
   * @param {number} key Key to find and remove from the tree.
   * @return {SplayTree.Node} The removed node.
   */
  SplayTree.prototype.remove = function (key) {
    if (this.isEmpty()) {
      throw Error('Key not found: ' + key);
    }
    this.splay_(key);
    if (this.root_.key != key) {
      throw Error('Key not found: ' + key);
    }
    var removed = this.root_;
    if (!this.root_.left) {
      this.root_ = this.root_.right;
    } else {
      var right = this.root_.right;
      this.root_ = this.root_.left;
      // Splay to make sure that the new root has an empty right child.
      this.splay_(key);
      // Insert the original right child as the right child of the new
      // root.
      this.root_.right = right;
    }
    return removed;
  };

  /**
   * Returns the node having the specified key or null if the tree doesn't
   * contain a node with the specified key.
   *
   *
   * @param {number} key Key to find in the tree.
   * @return {SplayTree.Node} Node having the specified key.
   */
  SplayTree.prototype.find = function (key) {
    if (this.isEmpty()) {
      return null;
    }
    this.splay_(key);
    return this.root_.key == key ? this.root_ : null;
  };

  /**
   * @return {SplayTree.Node} Node having the minimum key value.
   */
  SplayTree.prototype.findMin = function () {
    if (this.isEmpty()) {
      return null;
    }
    var current = this.root_;
    while (current.left) {
      current = current.left;
    }
    return current;
  };

  /**
   * @return {SplayTree.Node} Node having the maximum key value.
   */
  SplayTree.prototype.findMax = function (opt_startNode) {
    if (this.isEmpty()) {
      return null;
    }
    var current = opt_startNode || this.root_;
    while (current.right) {
      current = current.right;
    }
    return current;
  };

  /**
   * @return {SplayTree.Node} Node having the maximum key value that
   *     is less or equal to the specified key value.
   */
  SplayTree.prototype.findGreatestLessThan = function (key) {
    if (this.isEmpty()) {
      return null;
    }
    // Splay on the key to move the node with the given key or the last
    // node on the search path to the top of the tree.
    this.splay_(key);
    // Now the result is either the root node or the greatest node in
    // the left subtree.
    if (this.root_.key <= key) {
      return this.root_;
    } else if (this.root_.left) {
      return this.findMax(this.root_.left);
    } else {
      return null;
    }
  };

  /**
   * @return {Array<*>} An array containing all the values of tree's nodes
   * paired with keys.
   *
   */
  SplayTree.prototype.exportKeysAndValues = function () {
    var result = [];
    this.traverse_(function (node) {
      result.push([node.key, node.value]);
    });
    return result;
  };

  /**
   * @return {Array<*>} An array containing all the values of tree's nodes.
   */
  SplayTree.prototype.exportValues = function () {
    var result = [];
    this.traverse_(function (node) {
      result.push(node.value);
    });
    return result;
  };

  /**
   * Perform the splay operation for the given key. Moves the node with
   * the given key to the top of the tree.  If no node has the given
   * key, the last node on the search path is moved to the top of the
   * tree. This is the simplified top-down splaying algorithm from:
   * "Self-adjusting Binary Search Trees" by Sleator and Tarjan
   *
   * @param {number} key Key to splay the tree on.
   * @private
   */
  SplayTree.prototype.splay_ = function (key) {
    if (this.isEmpty()) {
      return;
    }
    // Create a dummy node.  The use of the dummy node is a bit
    // counter-intuitive: The right child of the dummy node will hold
    // the L tree of the algorithm.  The left child of the dummy node
    // will hold the R tree of the algorithm.  Using a dummy node, left
    // and right will always be nodes and we avoid special cases.
    var dummy, left, right;
    dummy = left = right = new SplayTree.Node(null, null);
    var current = this.root_;
    while (true) {
      if (key < current.key) {
        if (!current.left) {
          break;
        }
        if (key < current.left.key) {
          // Rotate right.
          var tmp = current.left;
          current.left = tmp.right;
          tmp.right = current;
          current = tmp;
          if (!current.left) {
            break;
          }
        }
        // Link right.
        right.left = current;
        right = current;
        current = current.left;
      } else if (key > current.key) {
        if (!current.right) {
          break;
        }
        if (key > current.right.key) {
          // Rotate left.
          var tmp = current.right;
          current.right = tmp.left;
          tmp.left = current;
          current = tmp;
          if (!current.right) {
            break;
          }
        }
        // Link left.
        left.right = current;
        left = current;
        current = current.right;
      } else {
        break;
      }
    }
    // Assemble.
    left.right = current.left;
    right.left = current.right;
    current.left = dummy.right;
    current.right = dummy.left;
    this.root_ = current;
  };

  /**
   * Performs a preorder traversal of the tree.
   *
   * @param {function(SplayTree.Node)} f Visitor function.
   * @private
   */
  SplayTree.prototype.traverse_ = function (f) {
    var nodesToVisit = [this.root_];
    while (nodesToVisit.length > 0) {
      var node = nodesToVisit.shift();
      if (node == null) {
        continue;
      }
      f(node);
      nodesToVisit.push(node.left);
      nodesToVisit.push(node.right);
    }
  };

  /**
   * Constructs a Splay tree node.
   *
   * @param {number} key Key.
   * @param {*} value Value.
   */
  SplayTree.Node = function (key, value) {
    this.key = key;
    this.value = value;
  };

  /**
   * @type {SplayTree.Node}
   */
  SplayTree.Node.prototype.left = null;

  /**
   * @type {SplayTree.Node}
   */
  SplayTree.Node.prototype.right = null;

  return {
    SplayTree: SplayTree
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../base/base.js":28}],69:[function(require,module,exports){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

/**
The lean config is just enough to import uncompressed, trace-event-formatted
json blobs.
**/

require("./importer/trace_event_importer.js");
require("../model/model.js");
},{"../model/model.js":135,"./importer/trace_event_importer.js":66}],70:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

global.tr.exportTo('tr.importer', function () {
  /**
   * The context processor consumes context events and maintains a set of
   * active contexts for a single thread.
   *
   * @constructor
   */
  function ContextProcessor(model) {
    this.model_ = model;
    this.activeContexts_ = [];
    this.stackPerType_ = {};
    // Cache of unique context objects.
    this.contextCache_ = {};
    // Cache of unique context object sets.
    this.contextSetCache_ = {};
    this.cachedEntryForActiveContexts_ = undefined;
    // All seen context object snapshots.
    this.seenSnapshots_ = {};
  };

  ContextProcessor.prototype = {
    enterContext: function (contextType, scopedId) {
      var newActiveContexts = [this.getOrCreateContext_(contextType, scopedId)];
      for (var oldContext of this.activeContexts_) {
        if (oldContext.type === contextType) {
          // If a previous context of the same type is active, it is removed
          // and pushed onto the stack for this type.
          this.pushContext_(oldContext);
        } else {
          // Otherwise the old context is it is still active.
          newActiveContexts.push(oldContext);
        }
      }
      this.activeContexts_ = newActiveContexts;
      this.cachedEntryForActiveContexts_ = undefined;
    },

    leaveContext: function (contextType, scopedId) {
      this.leaveContextImpl_(context => context.type === contextType && context.snapshot.scope === scopedId.scope && context.snapshot.idRef === scopedId.id);
    },

    destroyContext: function (scopedId) {
      // Remove all matching contexts from stacks.
      tr.b.iterItems(this.stackPerType_, function (contextType, stack) {
        // Perform in-place filtering instead of Array.prototype.filter to
        // prevent creating a new array.
        var newLength = 0;
        for (var i = 0; i < stack.length; ++i) {
          if (stack[i].snapshot.scope !== scopedId.scope || stack[i].snapshot.idRef !== scopedId.id) {
            stack[newLength++] = stack[i];
          }
        }
        stack.length = newLength;
      });

      // Remove all matching contexts from active context set.
      this.leaveContextImpl_(context => context.snapshot.scope === scopedId.scope && context.snapshot.idRef === scopedId.id);
    },

    leaveContextImpl_: function (predicate) {
      var newActiveContexts = [];
      for (var oldContext of this.activeContexts_) {
        if (predicate(oldContext)) {
          // If we left this context, remove it from the active set and
          // restore any previous context of the same type.
          var previousContext = this.popContext_(oldContext.type);
          if (previousContext) newActiveContexts.push(previousContext);
        } else {
          newActiveContexts.push(oldContext);
        }
      }
      this.activeContexts_ = newActiveContexts;
      this.cachedEntryForActiveContexts_ = undefined;
    },

    getOrCreateContext_: function (contextType, scopedId) {
      var context = {
        type: contextType,
        snapshot: {
          scope: scopedId.scope,
          idRef: scopedId.id
        }
      };
      var key = this.getContextKey_(context);
      if (key in this.contextCache_) return this.contextCache_[key];
      this.contextCache_[key] = context;
      var snapshotKey = this.getSnapshotKey_(scopedId);
      this.seenSnapshots_[snapshotKey] = true;
      return context;
    },

    pushContext_: function (context) {
      if (!(context.type in this.stackPerType_)) this.stackPerType_[context.type] = [];
      this.stackPerType_[context.type].push(context);
    },

    popContext_: function (contextType) {
      if (!(contextType in this.stackPerType_)) return undefined;
      return this.stackPerType_[contextType].pop();
    },

    getContextKey_: function (context) {
      return [context.type, context.snapshot.scope, context.snapshot.idRef].join('\x00');
    },

    getSnapshotKey_: function (scopedId) {
      return [scopedId.scope, scopedId.idRef].join('\x00');
    },

    get activeContexts() {
      // Keep a single instance for each unique set of active contexts to
      // reduce memory usage.
      if (this.cachedEntryForActiveContexts_ === undefined) {
        var key = [];
        for (var context of this.activeContexts_) key.push(this.getContextKey_(context));
        key.sort();
        key = key.join('\x00');
        if (key in this.contextSetCache_) {
          this.cachedEntryForActiveContexts_ = this.contextSetCache_[key];
        } else {
          this.activeContexts_.sort(function (a, b) {
            var keyA = this.getContextKey_(a);
            var keyB = this.getContextKey_(b);
            if (keyA < keyB) return -1;
            if (keyA > keyB) return 1;
            return 0;
          }.bind(this));
          this.contextSetCache_[key] = Object.freeze(this.activeContexts_);
          this.cachedEntryForActiveContexts_ = this.contextSetCache_[key];
        }
      }
      return this.cachedEntryForActiveContexts_;
    },

    invalidateContextCacheForSnapshot: function (scopedId) {
      var snapshotKey = this.getSnapshotKey_(scopedId);
      if (!(snapshotKey in this.seenSnapshots_)) return;
      this.contextCache_ = {};
      this.contextSetCache_ = {};
      this.cachedEntryForActiveContexts_ = undefined;
      this.activeContexts_ = this.activeContexts_.map(function (context) {
        // Do not alter unrelated contexts.
        if (context.snapshot.scope !== scopedId.scope || context.snapshot.idRef !== scopedId.id) return context;
        // Replace the invalidated context by a deep copy.
        return {
          type: context.type,
          snapshot: {
            scope: context.snapshot.scope,
            idRef: context.snapshot.idRef
          }
        };
      });
      this.seenSnapshots_ = {};
    }
  };

  return {
    ContextProcessor: ContextProcessor
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],71:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("./importer.js");

'use strict';

/**
 * @fileoverview Base class for trace data importers.
 */
global.tr.exportTo('tr.importer', function () {
  /**
   * Importer for empty strings and arrays.
   * @constructor
   */
  function EmptyImporter(events) {
    this.importPriority = 0;
  };

  EmptyImporter.canImport = function (eventData) {
    if (eventData instanceof Array && eventData.length == 0) return true;
    if (typeof eventData === 'string' || eventData instanceof String) {
      return eventData.length == 0;
    }
    return false;
  };

  EmptyImporter.prototype = {
    __proto__: tr.importer.Importer.prototype,

    get importerName() {
      return 'EmptyImporter';
    }
  };

  tr.importer.Importer.register(EmptyImporter);

  return {
    EmptyImporter: EmptyImporter
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"./importer.js":76}],72:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range_utils.js");
require("../extras/chrome/cc/input_latency_async_slice.js");
require("./proto_expectation.js");

'use strict';

global.tr.exportTo('tr.importer', function () {
  var ProtoExpectation = tr.importer.ProtoExpectation;

  var INPUT_TYPE = tr.e.cc.INPUT_EVENT_TYPE_NAMES;

  var KEYBOARD_TYPE_NAMES = [INPUT_TYPE.CHAR, INPUT_TYPE.KEY_DOWN_RAW, INPUT_TYPE.KEY_DOWN, INPUT_TYPE.KEY_UP];
  var MOUSE_RESPONSE_TYPE_NAMES = [INPUT_TYPE.CLICK, INPUT_TYPE.CONTEXT_MENU];
  var MOUSE_WHEEL_TYPE_NAMES = [INPUT_TYPE.MOUSE_WHEEL];
  var MOUSE_DRAG_TYPE_NAMES = [INPUT_TYPE.MOUSE_DOWN, INPUT_TYPE.MOUSE_MOVE, INPUT_TYPE.MOUSE_UP];
  var TAP_TYPE_NAMES = [INPUT_TYPE.TAP, INPUT_TYPE.TAP_CANCEL, INPUT_TYPE.TAP_DOWN];
  var PINCH_TYPE_NAMES = [INPUT_TYPE.PINCH_BEGIN, INPUT_TYPE.PINCH_END, INPUT_TYPE.PINCH_UPDATE];
  var FLING_TYPE_NAMES = [INPUT_TYPE.FLING_CANCEL, INPUT_TYPE.FLING_START];
  var TOUCH_TYPE_NAMES = [INPUT_TYPE.TOUCH_END, INPUT_TYPE.TOUCH_MOVE, INPUT_TYPE.TOUCH_START];
  var SCROLL_TYPE_NAMES = [INPUT_TYPE.SCROLL_BEGIN, INPUT_TYPE.SCROLL_END, INPUT_TYPE.SCROLL_UPDATE];
  var ALL_HANDLED_TYPE_NAMES = [].concat(KEYBOARD_TYPE_NAMES, MOUSE_RESPONSE_TYPE_NAMES, MOUSE_WHEEL_TYPE_NAMES, MOUSE_DRAG_TYPE_NAMES, PINCH_TYPE_NAMES, TAP_TYPE_NAMES, FLING_TYPE_NAMES, TOUCH_TYPE_NAMES, SCROLL_TYPE_NAMES);

  var RENDERER_FLING_TITLE = 'InputHandlerProxy::HandleGestureFling::started';
  var PLAYBACK_EVENT_TITLE = 'VideoPlayback';

  var CSS_ANIMATION_TITLE = 'Animation';

  /**
   * If there's less than this much time between the end of one event and the
   * start of the next, then they might be merged.
   * There was not enough thought given to this value, so if you have any slight
   * reason to change it, then please do so. It might also be good to split this
   * into multiple values.
   */
  var INPUT_MERGE_THRESHOLD_MS = 200;
  var ANIMATION_MERGE_THRESHOLD_MS = 32; // 2x 60FPS frames

  /**
   * If two MouseWheel events begin this close together, then they're an
   * Animation, not two responses.
   */
  var MOUSE_WHEEL_THRESHOLD_MS = 40;

  /**
   * If two MouseMoves are more than this far apart, then they're two Responses,
   * not Animation.
   */
  var MOUSE_MOVE_THRESHOLD_MS = 40;

  // Strings used to name IRs.
  var KEYBOARD_IR_NAME = 'Keyboard';
  var MOUSE_IR_NAME = 'Mouse';
  var MOUSEWHEEL_IR_NAME = 'MouseWheel';
  var TAP_IR_NAME = 'Tap';
  var PINCH_IR_NAME = 'Pinch';
  var FLING_IR_NAME = 'Fling';
  var TOUCH_IR_NAME = 'Touch';
  var SCROLL_IR_NAME = 'Scroll';
  var CSS_IR_NAME = 'CSS';
  var WEBGL_IR_NAME = 'WebGL';
  var VIDEO_IR_NAME = 'Video';

  // TODO(benjhayden) Find a better home for this.
  function compareEvents(x, y) {
    if (x.start !== y.start) return x.start - y.start;
    if (x.end !== y.end) return x.end - y.end;
    if (x.guid && y.guid) return x.guid - y.guid;
    return 0;
  }

  function forEventTypesIn(events, typeNames, cb, opt_this) {
    events.forEach(function (event) {
      if (typeNames.indexOf(event.typeName) >= 0) {
        cb.call(opt_this, event);
      }
    });
  }

  function causedFrame(event) {
    return event.associatedEvents.some(x => x.title === tr.model.helpers.IMPL_RENDERING_STATS);
  }

  function getSortedFrameEventsByProcess(modelHelper) {
    var frameEventsByPid = {};
    tr.b.iterItems(modelHelper.rendererHelpers, function (pid, rendererHelper) {
      frameEventsByPid[pid] = rendererHelper.getFrameEventsInRange(tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds);
    });
    return frameEventsByPid;
  }

  function getSortedInputEvents(modelHelper) {
    var inputEvents = [];

    var browserProcess = modelHelper.browserHelper.process;
    var mainThread = browserProcess.findAtMostOneThreadNamed('CrBrowserMain');
    for (var slice of mainThread.asyncSliceGroup.getDescendantEvents()) {
      if (!slice.isTopLevel) continue;

      if (!(slice instanceof tr.e.cc.InputLatencyAsyncSlice)) continue;

      // TODO(beaudoin): This should never happen but it does. Investigate
      // the trace linked at in #1567 and remove that when it's fixed.
      if (isNaN(slice.start) || isNaN(slice.duration) || isNaN(slice.end)) continue;

      inputEvents.push(slice);
    }

    return inputEvents.sort(compareEvents);
  }

  function findProtoExpectations(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    // This order is not important. Handlers are independent.
    var handlers = [handleKeyboardEvents, handleMouseResponseEvents, handleMouseWheelEvents, handleMouseDragEvents, handleTapResponseEvents, handlePinchEvents, handleFlingEvents, handleTouchEvents, handleScrollEvents, handleCSSAnimations, handleWebGLAnimations, handleVideoAnimations];
    handlers.forEach(function (handler) {
      protoExpectations.push.apply(protoExpectations, handler(modelHelper, sortedInputEvents));
    });
    protoExpectations.sort(compareEvents);
    return protoExpectations;
  }

  /**
   * Every keyboard event is a Response.
   */
  function handleKeyboardEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    forEventTypesIn(sortedInputEvents, KEYBOARD_TYPE_NAMES, function (event) {
      var pe = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, KEYBOARD_IR_NAME);
      pe.pushEvent(event);
      protoExpectations.push(pe);
    });
    return protoExpectations;
  }

  /**
   * Some mouse events can be translated directly into Responses.
   */
  function handleMouseResponseEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    forEventTypesIn(sortedInputEvents, MOUSE_RESPONSE_TYPE_NAMES, function (event) {
      var pe = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, MOUSE_IR_NAME);
      pe.pushEvent(event);
      protoExpectations.push(pe);
    });
    return protoExpectations;
  }
  /**
   * MouseWheel events are caused either by a physical wheel on a physical
   * mouse, or by a touch-drag gesture on a track-pad. The physical wheel
   * causes MouseWheel events that are much more spaced out, and have no
   * chance of hitting 60fps, so they are each turned into separate Response
   * IRs. The track-pad causes MouseWheel events that are much closer
   * together, and are expected to be 60fps, so the first event in a sequence
   * is turned into a Response, and the rest are merged into an Animation.
   * NB this threshold uses the two events' start times, unlike
   * ProtoExpectation.isNear, which compares the end time of the previous event
   * with the start time of the next.
   */
  function handleMouseWheelEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    var currentPE = undefined;
    var prevEvent_ = undefined;
    forEventTypesIn(sortedInputEvents, MOUSE_WHEEL_TYPE_NAMES, function (event) {
      // Switch prevEvent in one place so that we can early-return later.
      var prevEvent = prevEvent_;
      prevEvent_ = event;

      if (currentPE && prevEvent.start + MOUSE_WHEEL_THRESHOLD_MS >= event.start) {
        if (currentPE.irType === ProtoExpectation.ANIMATION_TYPE) {
          currentPE.pushEvent(event);
        } else {
          currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, MOUSEWHEEL_IR_NAME);
          currentPE.pushEvent(event);
          protoExpectations.push(currentPE);
        }
        return;
      }
      currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, MOUSEWHEEL_IR_NAME);
      currentPE.pushEvent(event);
      protoExpectations.push(currentPE);
    });
    return protoExpectations;
  }

  /**
   * Down events followed closely by Up events are click Responses, but the
   * Response doesn't start until the Up event.
   *
   *     RRR
   * DDD UUU
   *
   * If there are any Move events in between a Down and an Up, then the Down
   * and the first Move are a Response, then the rest of the Moves are an
   * Animation:
   *
   * RRRRRRRAAAAAAAAAAAAAAAAAAAA
   * DDD MMM MMM MMM MMM MMM UUU
   */
  function handleMouseDragEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    var currentPE = undefined;
    var mouseDownEvent = undefined;
    forEventTypesIn(sortedInputEvents, MOUSE_DRAG_TYPE_NAMES, function (event) {
      switch (event.typeName) {
        case INPUT_TYPE.MOUSE_DOWN:
          if (causedFrame(event)) {
            var pe = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, MOUSE_IR_NAME);
            pe.pushEvent(event);
            protoExpectations.push(pe);
          } else {
            // Responses typically don't start until the mouse up event.
            // Add this MouseDown to the Response that starts at the MouseUp.
            mouseDownEvent = event;
          }
          break;

        // There may be more than 100ms between the start of the mouse down
        // and the start of the mouse up. Chrome and the web don't start to
        // respond until the mouse up. ResponseIRs start deducting comfort
        // at 100ms duration. If more than that 100ms duration is burned
        // through while waiting for the user to release the
        // mouse button, then ResponseIR will unfairly start deducting
        // comfort before Chrome even has a mouse up to respond to.
        // It is technically possible for a site to afford one response on
        // mouse down and another on mouse up, but that is an edge case. The
        // vast majority of mouse downs are not responses.

        case INPUT_TYPE.MOUSE_MOVE:
          if (!causedFrame(event)) {
            // Ignore MouseMoves that do not affect the screen. They are not
            // part of an interaction record by definition.
            var pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
          } else if (!currentPE || !currentPE.isNear(event, MOUSE_MOVE_THRESHOLD_MS)) {
            // The first MouseMove after a MouseDown or after a while is a
            // Response.
            currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, MOUSE_IR_NAME);
            currentPE.pushEvent(event);
            if (mouseDownEvent) {
              currentPE.associatedEvents.push(mouseDownEvent);
              mouseDownEvent = undefined;
            }
            protoExpectations.push(currentPE);
          } else {
            // Merge this event into an Animation.
            if (currentPE.irType === ProtoExpectation.ANIMATION_TYPE) {
              currentPE.pushEvent(event);
            } else {
              currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, MOUSE_IR_NAME);
              currentPE.pushEvent(event);
              protoExpectations.push(currentPE);
            }
          }
          break;

        case INPUT_TYPE.MOUSE_UP:
          if (!mouseDownEvent) {
            var pe = new ProtoExpectation(causedFrame(event) ? ProtoExpectation.RESPONSE_TYPE : ProtoExpectation.IGNORED_TYPE, MOUSE_IR_NAME);
            pe.pushEvent(event);
            protoExpectations.push(pe);
            break;
          }

          if (currentPE) {
            currentPE.pushEvent(event);
          } else {
            currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, MOUSE_IR_NAME);
            if (mouseDownEvent) currentPE.associatedEvents.push(mouseDownEvent);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          }
          mouseDownEvent = undefined;
          currentPE = undefined;
          break;
      }
    });
    if (mouseDownEvent) {
      currentPE = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
      currentPE.pushEvent(mouseDownEvent);
      protoExpectations.push(currentPE);
    }
    return protoExpectations;
  }

  /**
   * Solitary Tap events are simple Responses:
   *
   * RRR
   * TTT
   *
   * TapDowns are part of Responses.
   *
   * RRRRRRR
   * DDD TTT
   *
   * TapCancels are part of Responses, which seems strange. They always go
   * with scrolls, so they'll probably be merged with scroll Responses.
   * TapCancels can take a significant amount of time and account for a
   * significant amount of work, which should be grouped with the scroll IRs
   * if possible.
   *
   * RRRRRRR
   * DDD CCC
   **/
  function handleTapResponseEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    var currentPE = undefined;
    forEventTypesIn(sortedInputEvents, TAP_TYPE_NAMES, function (event) {
      switch (event.typeName) {
        case INPUT_TYPE.TAP_DOWN:
          currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, TAP_IR_NAME);
          currentPE.pushEvent(event);
          protoExpectations.push(currentPE);
          break;

        case INPUT_TYPE.TAP:
          if (currentPE) {
            currentPE.pushEvent(event);
          } else {
            // Sometimes we get Tap events with no TapDown, sometimes we get
            // TapDown events. Handle both.
            currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, TAP_IR_NAME);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          }
          currentPE = undefined;
          break;

        case INPUT_TYPE.TAP_CANCEL:
          if (!currentPE) {
            var pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
            break;
          }

          if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            currentPE.pushEvent(event);
          } else {
            currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, TAP_IR_NAME);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          }
          currentPE = undefined;
          break;
      }
    });
    return protoExpectations;
  }

  /**
   * The PinchBegin and the first PinchUpdate comprise a Response, then the
   * rest of the PinchUpdates comprise an Animation.
   *
   * RRRRRRRAAAAAAAAAAAAAAAAAAAA
   * BBB UUU UUU UUU UUU UUU EEE
   */
  function handlePinchEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    var currentPE = undefined;
    var sawFirstUpdate = false;
    var modelBounds = modelHelper.model.bounds;
    forEventTypesIn(sortedInputEvents, PINCH_TYPE_NAMES, function (event) {
      switch (event.typeName) {
        case INPUT_TYPE.PINCH_BEGIN:
          if (currentPE && currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            currentPE.pushEvent(event);
            break;
          }
          currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, PINCH_IR_NAME);
          currentPE.pushEvent(event);
          currentPE.isAnimationBegin = true;
          protoExpectations.push(currentPE);
          sawFirstUpdate = false;
          break;

        case INPUT_TYPE.PINCH_UPDATE:
          // Like ScrollUpdates, the Begin and the first Update constitute a
          // Response, then the rest of the Updates constitute an Animation
          // that begins when the Response ends. If the user pauses in the
          // middle of an extended pinch gesture, then multiple Animations
          // will be created.
          if (!currentPE || currentPE.irType === ProtoExpectation.RESPONSE_TYPE && sawFirstUpdate || !currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, PINCH_IR_NAME);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          } else {
            currentPE.pushEvent(event);
            sawFirstUpdate = true;
          }
          break;

        case INPUT_TYPE.PINCH_END:
          if (currentPE) {
            currentPE.pushEvent(event);
          } else {
            var pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
          }
          currentPE = undefined;
          break;
      }
    });
    return protoExpectations;
  }

  /**
   * Flings are defined by 3 types of events: FlingStart, FlingCancel, and the
   * renderer fling event. Flings do not begin with a Response. Flings end
   * either at the beginning of a FlingCancel, or at the end of the renderer
   * fling event.
   *
   * AAAAAAAAAAAAAAAAAAAAAAAAAA
   * SSS
   *     RRRRRRRRRRRRRRRRRRRRRR
   *
   *
   * AAAAAAAAAAA
   * SSS        CCC
   */
  function handleFlingEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    var currentPE = undefined;

    function isRendererFling(event) {
      return event.title === RENDERER_FLING_TITLE;
    }
    var browserHelper = modelHelper.browserHelper;
    var flingEvents = browserHelper.getAllAsyncSlicesMatching(isRendererFling);

    forEventTypesIn(sortedInputEvents, FLING_TYPE_NAMES, function (event) {
      flingEvents.push(event);
    });
    flingEvents.sort(compareEvents);

    flingEvents.forEach(function (event) {
      if (event.title === RENDERER_FLING_TITLE) {
        if (currentPE) {
          currentPE.pushEvent(event);
        } else {
          currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, FLING_IR_NAME);
          currentPE.pushEvent(event);
          protoExpectations.push(currentPE);
        }
        return;
      }

      switch (event.typeName) {
        case INPUT_TYPE.FLING_START:
          if (currentPE) {
            console.error('Another FlingStart? File a bug with this trace!');
            currentPE.pushEvent(event);
          } else {
            currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, FLING_IR_NAME);
            currentPE.pushEvent(event);
            // Set end to an invalid value so that it can be noticed and fixed
            // later.
            currentPE.end = 0;
            protoExpectations.push(currentPE);
          }
          break;

        case INPUT_TYPE.FLING_CANCEL:
          if (currentPE) {
            currentPE.pushEvent(event);
            // FlingCancel events start when TouchStart events start, which is
            // typically when a Response starts. FlingCancel events end when
            // chrome acknowledges them, not when they update the screen. So
            // there might be one more frame during the FlingCancel, after
            // this Animation ends. That won't affect the scoring algorithms,
            // and it will make the IRs look more correct if they don't
            // overlap unnecessarily.
            currentPE.end = event.start;
            currentPE = undefined;
          } else {
            var pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
          }
          break;
      }
    });
    // If there was neither a FLING_CANCEL nor a renderer fling after the
    // FLING_START, then assume that it ends at the end of the model, so set
    // the end of currentPE to the end of the model.
    if (currentPE && !currentPE.end) currentPE.end = modelHelper.model.bounds.max;
    return protoExpectations;
  }

  /**
   * The TouchStart and the first TouchMove comprise a Response, then the
   * rest of the TouchMoves comprise an Animation.
   *
   * RRRRRRRAAAAAAAAAAAAAAAAAAAA
   * SSS MMM MMM MMM MMM MMM EEE
   *
   * If there are no TouchMove events in between a TouchStart and a TouchEnd,
   * then it's just a Response.
   *
   * RRRRRRR
   * SSS EEE
   */
  function handleTouchEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    var currentPE = undefined;
    var sawFirstMove = false;
    forEventTypesIn(sortedInputEvents, TOUCH_TYPE_NAMES, function (event) {
      switch (event.typeName) {
        case INPUT_TYPE.TOUCH_START:
          if (currentPE) {
            // NB: currentPE will probably be merged with something from
            // handlePinchEvents(). Multiple TouchStart events without an
            // intervening TouchEnd logically implies that multiple fingers
            // are on the screen, so this is probably a pinch gesture.
            currentPE.pushEvent(event);
          } else {
            currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, TOUCH_IR_NAME);
            currentPE.pushEvent(event);
            currentPE.isAnimationBegin = true;
            protoExpectations.push(currentPE);
            sawFirstMove = false;
          }
          break;

        case INPUT_TYPE.TOUCH_MOVE:
          if (!currentPE) {
            currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, TOUCH_IR_NAME);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
            break;
          }

          // Like Scrolls and Pinches, the Response is defined to be the
          // TouchStart plus the first TouchMove, then the rest of the
          // TouchMoves constitute an Animation.
          if (sawFirstMove && currentPE.irType === ProtoExpectation.RESPONSE_TYPE || !currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            // If there's already a touchmove in the currentPE or it's not
            // near event, then finish it and start a new animation.
            var prevEnd = currentPE.end;
            currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, TOUCH_IR_NAME);
            currentPE.pushEvent(event);
            // It's possible for there to be a gap between TouchMoves, but
            // that doesn't mean that there should be an Idle IR there.
            currentPE.start = prevEnd;
            protoExpectations.push(currentPE);
          } else {
            currentPE.pushEvent(event);
            sawFirstMove = true;
          }
          break;

        case INPUT_TYPE.TOUCH_END:
          if (!currentPE) {
            var pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
            break;
          }
          if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS)) {
            currentPE.pushEvent(event);
          } else {
            var pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
          }
          currentPE = undefined;
          break;
      }
    });
    return protoExpectations;
  }

  /**
   * The first ScrollBegin and the first ScrollUpdate comprise a Response,
   * then the rest comprise an Animation.
   *
   * RRRRRRRAAAAAAAAAAAAAAAAAAAA
   * BBB UUU UUU UUU UUU UUU EEE
   */
  function handleScrollEvents(modelHelper, sortedInputEvents) {
    var protoExpectations = [];
    var currentPE = undefined;
    var sawFirstUpdate = false;
    forEventTypesIn(sortedInputEvents, SCROLL_TYPE_NAMES, function (event) {
      switch (event.typeName) {
        case INPUT_TYPE.SCROLL_BEGIN:
          // Always begin a new PE even if there already is one, unlike
          // PinchBegin.
          currentPE = new ProtoExpectation(ProtoExpectation.RESPONSE_TYPE, SCROLL_IR_NAME);
          currentPE.pushEvent(event);
          currentPE.isAnimationBegin = true;
          protoExpectations.push(currentPE);
          sawFirstUpdate = false;
          break;

        case INPUT_TYPE.SCROLL_UPDATE:
          if (currentPE) {
            if (currentPE.isNear(event, INPUT_MERGE_THRESHOLD_MS) && (currentPE.irType === ProtoExpectation.ANIMATION_TYPE || !sawFirstUpdate)) {
              currentPE.pushEvent(event);
              sawFirstUpdate = true;
            } else {
              currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, SCROLL_IR_NAME);
              currentPE.pushEvent(event);
              protoExpectations.push(currentPE);
            }
          } else {
            // ScrollUpdate without ScrollBegin.
            currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, SCROLL_IR_NAME);
            currentPE.pushEvent(event);
            protoExpectations.push(currentPE);
          }
          break;

        case INPUT_TYPE.SCROLL_END:
          if (!currentPE) {
            console.error('ScrollEnd without ScrollUpdate? ' + 'File a bug with this trace!');
            var pe = new ProtoExpectation(ProtoExpectation.IGNORED_TYPE);
            pe.pushEvent(event);
            protoExpectations.push(pe);
            break;
          }
          currentPE.pushEvent(event);
          break;
      }
    });
    return protoExpectations;
  }

  /**
   * Returns proto expectations for video animation events.
   *
   * Video animations represent video playback, and are based on
   * VideoPlayback async events (going from the VideoFrameCompositor::Start
   * to VideoFrameCompositor::Stop calls)
   */
  function handleVideoAnimations(modelHelper, sortedInputEvents) {
    var events = [];
    for (var pid in modelHelper.rendererHelpers) {
      for (var asyncSlice of modelHelper.rendererHelpers[pid].mainThread.asyncSliceGroup.slices) {
        if (asyncSlice.title === PLAYBACK_EVENT_TITLE) events.push(asyncSlice);
      }
    }

    events.sort(tr.importer.compareEvents);

    var protoExpectations = [];
    for (var event of events) {
      var currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, VIDEO_IR_NAME);
      currentPE.start = event.start;
      currentPE.end = event.end;
      currentPE.pushEvent(event);
      protoExpectations.push(currentPE);
    }

    return protoExpectations;
  }

  /**
   * CSS Animations are merged into AnimationExpectations when they intersect.
   */
  function handleCSSAnimations(modelHelper, sortedInputEvents) {
    // First find all the top-level CSS Animation async events.
    var animationEvents = modelHelper.browserHelper.getAllAsyncSlicesMatching(function (event) {
      return event.title === CSS_ANIMATION_TITLE && event.isTopLevel && event.duration > 0;
    });

    // Time ranges where animations are actually running will be collected here.
    // Each element will contain {min, max, animation}.
    var animationRanges = [];

    // This helper function will be called when a time range is found
    // during which the animation is actually running.
    function pushAnimationRange(start, end, animation) {
      var range = tr.b.Range.fromExplicitRange(start, end);
      range.animation = animation;
      animationRanges.push(range);
    }

    animationEvents.forEach(function (animation) {
      if (animation.subSlices.length === 0) {
        pushAnimationRange(animation.start, animation.end, animation);
      } else {
        // Now run a state machine over the animation's subSlices, which
        // indicate the animations running/paused/finished states, in order to
        // find ranges where the animation was actually running.
        var start = undefined;
        animation.subSlices.forEach(function (sub) {
          if (sub.args.data.state === 'running' && start === undefined) {
            // It's possible for the state to alternate between running and
            // pending, but the animation is still running in that case,
            // so only set start if the state is changing from one of the halted
            // states.
            start = sub.start;
          } else if (sub.args.data.state === 'paused' || sub.args.data.state === 'idle' || sub.args.data.state === 'finished') {
            if (start === undefined) {
              // An animation was already running when the trace started.
              // (Actually, it's possible that the animation was in the 'idle'
              // state when tracing started, but that should be rare, and will
              // be fixed when async events are buffered.)
              // http: //crbug.com/565627
              start = modelHelper.model.bounds.min;
            }

            pushAnimationRange(start, sub.start, animation);
            start = undefined;
          }
        });

        // An animation was still running when the
        // top-level animation event ended.
        if (start !== undefined) pushAnimationRange(start, animation.end, animation);
      }
    });

    // Now we have a set of time ranges when css animations were actually
    // running.
    // Leave merging intersecting animations to mergeIntersectingAnimations(),
    // after findFrameEventsForAnimations removes frame-less animations.

    return animationRanges.map(function (range) {
      var protoExpectation = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, CSS_IR_NAME);
      protoExpectation.start = range.min;
      protoExpectation.end = range.max;
      protoExpectation.associatedEvents.push(range.animation);
      return protoExpectation;
    });
  }

  /**
   * Get all the events (prepareMailbox and serviceScriptedAnimations)
   * relevant to WebGL. Note that modelHelper is the helper object containing
   * the model, and mailboxEvents and animationEvents are arrays where the
   * events are being pushed into (DrawingBuffer::prepareMailbox events go
   * into mailboxEvents; PageAnimator::serviceScriptedAnimations events go
   * into animationEvents). The function does not return anything but
   * modifies mailboxEvents and animationEvents.
   */
  function findWebGLEvents(modelHelper, mailboxEvents, animationEvents) {
    for (var event of modelHelper.model.getDescendantEvents()) {
      if (event.title === 'DrawingBuffer::prepareMailbox') mailboxEvents.push(event);else if (event.title === 'PageAnimator::serviceScriptedAnimations') animationEvents.push(event);
    }
  }

  /**
   * Returns a list of events in mailboxEvents that have an event in
   * animationEvents close by (within ANIMATION_MERGE_THRESHOLD_MS).
   */
  function findMailboxEventsNearAnimationEvents(mailboxEvents, animationEvents) {
    if (animationEvents.length === 0) return [];

    mailboxEvents.sort(compareEvents);
    animationEvents.sort(compareEvents);
    var animationIterator = animationEvents[Symbol.iterator]();
    var animationEvent = animationIterator.next().value;

    var filteredEvents = [];

    // We iterate through the mailboxEvents. With each event, we check if
    // there is a animationEvent near it, and if so, add it to the result.
    for (var event of mailboxEvents) {
      // If the current animationEvent is too far before the mailboxEvent,
      // we advance until we get to the next animationEvent that is not too
      // far before the animationEvent.
      while (animationEvent && animationEvent.start < event.start - ANIMATION_MERGE_THRESHOLD_MS) animationEvent = animationIterator.next().value;

      // If there aren't any more animationEvents, then that means all the
      // remaining mailboxEvents are too far after the animationEvents, so
      // we can quit now.
      if (!animationEvent) break;

      // If there's a animationEvent close to the mailboxEvent, then we push
      // the current mailboxEvent onto the stack.
      if (animationEvent.start < event.start + ANIMATION_MERGE_THRESHOLD_MS) filteredEvents.push(event);
    }
    return filteredEvents;
  }

  /**
   * Merge consecutive mailbox events into a ProtoExpectation. Note: Only
   * the drawingBuffer::prepareMailbox events will end up in the
   * associatedEvents. The PageAnimator::serviceScriptedAnimations events
   * will not end up in the associatedEvents.
   */
  function createProtoExpectationsFromMailboxEvents(mailboxEvents) {
    var protoExpectations = [];
    var currentPE = undefined;
    for (var event of mailboxEvents) {
      if (currentPE === undefined || !currentPE.isNear(event, ANIMATION_MERGE_THRESHOLD_MS)) {
        currentPE = new ProtoExpectation(ProtoExpectation.ANIMATION_TYPE, WEBGL_IR_NAME);
        currentPE.pushEvent(event);
        protoExpectations.push(currentPE);
      } else {
        currentPE.pushEvent(event);
      }
    }
    return protoExpectations;
  }

  // WebGL animations are identified by the DrawingBuffer::prepareMailbox
  // and PageAnimator::serviceScriptedAnimations events (one of each per frame)
  // and consecutive frames are merged into the same animation.
  function handleWebGLAnimations(modelHelper, sortedInputEvents) {
    // Get the prepareMailbox and scriptedAnimation events.
    var prepareMailboxEvents = [];
    var scriptedAnimationEvents = [];

    findWebGLEvents(modelHelper, prepareMailboxEvents, scriptedAnimationEvents);
    var webGLMailboxEvents = findMailboxEventsNearAnimationEvents(prepareMailboxEvents, scriptedAnimationEvents);

    return createProtoExpectationsFromMailboxEvents(webGLMailboxEvents);
  }

  function postProcessProtoExpectations(modelHelper, protoExpectations) {
    // protoExpectations is input only. Returns a modified set of
    // ProtoExpectations.  The order is important.
    protoExpectations = findFrameEventsForAnimations(modelHelper, protoExpectations);
    protoExpectations = mergeIntersectingResponses(protoExpectations);
    protoExpectations = mergeIntersectingAnimations(protoExpectations);
    protoExpectations = fixResponseAnimationStarts(protoExpectations);
    protoExpectations = fixTapResponseTouchAnimations(protoExpectations);
    return protoExpectations;
  }

  /**
   * TouchStarts happen at the same time as ScrollBegins.
   * It's easier to let multiple handlers create multiple overlapping
   * Responses and then merge them, rather than make the handlers aware of the
   * other handlers' PEs.
   *
   * For example:
   * RR
   *  RRR  -> RRRRR
   *    RR
   *
   * protoExpectations is input only.
   * Returns a modified set of ProtoExpectations.
   */
  function mergeIntersectingResponses(protoExpectations) {
    var newPEs = [];
    while (protoExpectations.length) {
      var pe = protoExpectations.shift();
      newPEs.push(pe);

      // Only consider Responses for now.
      if (pe.irType !== ProtoExpectation.RESPONSE_TYPE) continue;

      for (var i = 0; i < protoExpectations.length; ++i) {
        var otherPE = protoExpectations[i];

        if (otherPE.irType !== pe.irType) continue;

        if (!otherPE.intersects(pe)) continue;

        // Don't merge together Responses of the same type.
        // If handleTouchEvents wanted two of its Responses to be merged, then
        // it would have made them that way to begin with.
        var typeNames = pe.associatedEvents.map(function (event) {
          return event.typeName;
        });
        if (otherPE.containsTypeNames(typeNames)) continue;

        pe.merge(otherPE);
        protoExpectations.splice(i, 1);

        // Don't skip the next otherPE!
        --i;
      }
    }
    return newPEs;
  }

  /**
   * An animation is simply an expectation of 60fps between start and end.
   * If two animations overlap, then merge them.
   *
   * For example:
   * AA
   *  AAA  -> AAAAA
   *    AA
   *
   * protoExpectations is input only.
   * Returns a modified set of ProtoExpectations.
   */
  function mergeIntersectingAnimations(protoExpectations) {
    var newPEs = [];
    while (protoExpectations.length) {
      var pe = protoExpectations.shift();
      newPEs.push(pe);

      // Only consider Animations for now.
      if (pe.irType !== ProtoExpectation.ANIMATION_TYPE) continue;

      var isCSS = pe.containsSliceTitle(CSS_ANIMATION_TITLE);
      var isFling = pe.containsTypeNames([INPUT_TYPE.FLING_START]);
      var isVideo = pe.containsTypeNames([VIDEO_IR_NAME]);

      for (var i = 0; i < protoExpectations.length; ++i) {
        var otherPE = protoExpectations[i];

        if (otherPE.irType !== pe.irType) continue;

        // Don't merge CSS Animations with any other types.
        if (isCSS != otherPE.containsSliceTitle(CSS_ANIMATION_TITLE)) continue;

        if (isCSS) {
          if (!pe.isNear(otherPE, ANIMATION_MERGE_THRESHOLD_MS)) continue;
        } else if (!otherPE.intersects(pe)) {
          continue;
        }

        // Don't merge Fling Animations with any other types.
        if (isFling !== otherPE.containsTypeNames([INPUT_TYPE.FLING_START])) continue;

        // Don't merge Video Animations with any other types.
        if (isVideo !== otherPE.containsTypeNames([VIDEO_IR_NAME])) continue;

        pe.merge(otherPE);
        protoExpectations.splice(i, 1);
        // Don't skip the next otherPE!
        --i;
      }
    }
    return newPEs;
  }

  /**
   * The ends of responses frequently overlap the starts of animations.
   * Fix the animations to reflect the fact that the user can only start to
   * expect 60fps after the response.
   *
   * For example:
   * RRR   -> RRRAA
   *  AAAA
   *
   * protoExpectations is input only.
   * Returns a modified set of ProtoExpectations.
   */
  function fixResponseAnimationStarts(protoExpectations) {
    protoExpectations.forEach(function (ape) {
      // Only consider animations for now.
      if (ape.irType !== ProtoExpectation.ANIMATION_TYPE) return;

      protoExpectations.forEach(function (rpe) {
        // Only consider responses for now.
        if (rpe.irType !== ProtoExpectation.RESPONSE_TYPE) return;

        // Only consider responses that end during the animation.
        if (!ape.containsTimestampInclusive(rpe.end)) return;

        // Ignore Responses that are entirely contained by the animation.
        if (ape.containsTimestampInclusive(rpe.start)) return;

        // Move the animation start to the response end.
        ape.start = rpe.end;
      });
    });
    return protoExpectations;
  }

  /**
   * Merge Tap Responses that overlap Touch-only Animations.
   * https: *github.com/catapult-project/catapult/issues/1431
   */
  function fixTapResponseTouchAnimations(protoExpectations) {
    function isTapResponse(pe) {
      return pe.irType === ProtoExpectation.RESPONSE_TYPE && pe.containsTypeNames([INPUT_TYPE.TAP]);
    }
    function isTouchAnimation(pe) {
      return pe.irType === ProtoExpectation.ANIMATION_TYPE && pe.containsTypeNames([INPUT_TYPE.TOUCH_MOVE]) && !pe.containsTypeNames([INPUT_TYPE.SCROLL_UPDATE, INPUT_TYPE.PINCH_UPDATE]);
    }
    var newPEs = [];
    while (protoExpectations.length) {
      var pe = protoExpectations.shift();
      newPEs.push(pe);

      // protoExpectations are sorted by start time, and we don't know whether
      // the Tap Response or the Touch Animation will be first
      var peIsTapResponse = isTapResponse(pe);
      var peIsTouchAnimation = isTouchAnimation(pe);
      if (!peIsTapResponse && !peIsTouchAnimation) continue;

      for (var i = 0; i < protoExpectations.length; ++i) {
        var otherPE = protoExpectations[i];

        if (!otherPE.intersects(pe)) continue;

        if (peIsTapResponse && !isTouchAnimation(otherPE)) continue;

        if (peIsTouchAnimation && !isTapResponse(otherPE)) continue;

        // pe might be the Touch Animation, but the merged ProtoExpectation
        // should be a Response.
        pe.irType = ProtoExpectation.RESPONSE_TYPE;

        pe.merge(otherPE);
        protoExpectations.splice(i, 1);
        // Don't skip the next otherPE!
        --i;
      }
    }
    return newPEs;
  }

  function findFrameEventsForAnimations(modelHelper, protoExpectations) {
    var newPEs = [];
    var frameEventsByPid = getSortedFrameEventsByProcess(modelHelper);

    for (var pe of protoExpectations) {
      if (pe.irType !== ProtoExpectation.ANIMATION_TYPE) {
        newPEs.push(pe);
        continue;
      }

      var frameEvents = [];
      // TODO(benjhayden): Use frame blame contexts here.
      for (var pid of Object.keys(modelHelper.rendererHelpers)) {
        var range = tr.b.Range.fromExplicitRange(pe.start, pe.end);
        frameEvents.push.apply(frameEvents, range.filterArray(frameEventsByPid[pid], e => e.start));
      }

      // If a tree falls in a forest...
      // If there were not actually any frames while the animation was
      // running, then it wasn't really an animation, now, was it?
      // Philosophy aside, the system_health Animation metrics fail hard if
      // there are no frames in an AnimationExpectation.
      // Since WebGL animations don't generate this type of frame event,
      // don't remove them if it's a WebGL animation.
      // TODO(alexandermont): Identify what the correct frame event to
      // use here is.
      if (frameEvents.length === 0 && !pe.names.has(WEBGL_IR_NAME)) {
        pe.irType = ProtoExpectation.IGNORED_TYPE;
        newPEs.push(pe);
        continue;
      }

      pe.associatedEvents.addEventSet(frameEvents);
      newPEs.push(pe);
    }

    return newPEs;
  }

  /**
   * Check that none of the handlers accidentally ignored an input event.
   */
  function checkAllInputEventsHandled(sortedInputEvents, protoExpectations) {
    var handledEvents = [];
    protoExpectations.forEach(function (protoExpectation) {
      protoExpectation.associatedEvents.forEach(function (event) {
        // Ignore CSS Animations that might have multiple active ranges.
        if (event.title === CSS_ANIMATION_TITLE && event.subSlices.length > 0) return;

        if (handledEvents.indexOf(event) >= 0 && event.title !== tr.model.helpers.IMPL_RENDERING_STATS) {
          console.error('double-handled event', event.typeName, parseInt(event.start), parseInt(event.end), protoExpectation);
          return;
        }
        handledEvents.push(event);
      });
    });

    sortedInputEvents.forEach(function (event) {
      if (handledEvents.indexOf(event) < 0) {
        console.error('UNHANDLED INPUT EVENT!', event.typeName, parseInt(event.start), parseInt(event.end));
      }
    });
  }

  /**
   * Find ProtoExpectations, post-process them, convert them to real IRs.
   */
  function findInputExpectations(modelHelper) {
    var sortedInputEvents = getSortedInputEvents(modelHelper);
    var protoExpectations = findProtoExpectations(modelHelper, sortedInputEvents);
    protoExpectations = postProcessProtoExpectations(modelHelper, protoExpectations);
    checkAllInputEventsHandled(sortedInputEvents, protoExpectations);

    var irs = [];
    protoExpectations.forEach(function (protoExpectation) {
      var ir = protoExpectation.createInteractionRecord(modelHelper.model);
      if (ir) irs.push(ir);
    });
    return irs;
  }

  return {
    findInputExpectations: findInputExpectations,
    compareEvents: compareEvents,
    CSS_ANIMATION_TITLE: CSS_ANIMATION_TITLE
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range_utils.js":48,"../extras/chrome/cc/input_latency_async_slice.js":62,"./proto_expectation.js":77}],73:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../model/user_model/load_expectation.js");

'use strict';

global.tr.exportTo('tr.importer', function () {
  // This global instant event marks the start of a navigation.
  var NAVIGATION_START = 'NavigationTiming navigationStart';

  // This render-process instant event marks the first contentful paint in a
  // main frame.
  var FIRST_CONTENTFUL_PAINT_TITLE = 'firstContentfulPaint';

  function findLoadExpectations(modelHelper) {
    var events = [];
    for (var event of modelHelper.model.getDescendantEvents()) {
      if (event.title === NAVIGATION_START || event.title === FIRST_CONTENTFUL_PAINT_TITLE) events.push(event);
    }
    events.sort(tr.importer.compareEvents);

    var loads = [];
    var startEvent = undefined;
    // TODO(alexandermont): What's supposed to happen if there are two
    // NAVIGATION_STARTs with no FIRST_CONTENTFUL_PAINT_TITLE between
    // them? Are you supposed to just "lose" the first NAVIGATION_START,
    // like what's happening now?
    for (var event of events) {
      if (event.title === NAVIGATION_START) {
        startEvent = event;
      } else if (event.title === FIRST_CONTENTFUL_PAINT_TITLE) {
        if (startEvent) {
          loads.push(new tr.model.um.LoadExpectation(modelHelper.model, tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL, startEvent.start, event.start - startEvent.start));
          startEvent = undefined;
        }
      }
    }

    // If the trace ended between navigation start and first contentful paint,
    // then make a LoadExpectation that ends at the end of the trace.
    if (startEvent) {
      loads.push(new tr.model.um.LoadExpectation(modelHelper.model, tr.model.um.LOAD_SUBTYPE_NAMES.SUCCESSFUL, startEvent.start, modelHelper.model.bounds.max - startEvent.start));
    }

    return loads;
  }

  return {
    findLoadExpectations: findLoadExpectations
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../model/user_model/load_expectation.js":163}],74:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../model/user_model/startup_expectation.js");

'use strict';

global.tr.exportTo('tr.importer', function () {
  function getAllFrameEvents(modelHelper) {
    var frameEvents = [];
    frameEvents.push.apply(frameEvents, modelHelper.browserHelper.getFrameEventsInRange(tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds));

    tr.b.iterItems(modelHelper.rendererHelpers, function (pid, renderer) {
      frameEvents.push.apply(frameEvents, renderer.getFrameEventsInRange(tr.model.helpers.IMPL_FRAMETIME_TYPE, modelHelper.model.bounds));
    });
    return frameEvents.sort(tr.importer.compareEvents);
  }

  // If a thread contains a typical initialization slice, then the first event
  // on that thread is a startup event.
  function getStartupEvents(modelHelper) {
    function isStartupSlice(slice) {
      return slice.title === 'BrowserMainLoop::CreateThreads';
    }
    var events = modelHelper.browserHelper.getAllAsyncSlicesMatching(isStartupSlice);
    var deduper = new tr.model.EventSet();
    events.forEach(function (event) {
      var sliceGroup = event.parentContainer.sliceGroup;
      var slice = sliceGroup && sliceGroup.findFirstSlice();
      if (slice) deduper.push(slice);
    });
    return deduper.toArray();
  }

  // Match every event in |openingEvents| to the first following event from
  // |closingEvents| and return an array containing a load interaction record
  // for each pair.
  function findStartupExpectations(modelHelper) {
    var openingEvents = getStartupEvents(modelHelper);
    var closingEvents = getAllFrameEvents(modelHelper);
    var startups = [];
    openingEvents.forEach(function (openingEvent) {
      closingEvents.forEach(function (closingEvent) {
        // Ignore opening event that already have a closing event.
        if (openingEvent.closingEvent) return;

        // Ignore closing events that already belong to an opening event.
        if (closingEvent.openingEvent) return;

        // Ignore closing events before |openingEvent|.
        if (closingEvent.start <= openingEvent.start) return;

        // Ignore events from different threads.
        if (openingEvent.parentContainer.parent.pid !== closingEvent.parentContainer.parent.pid) return;

        // This is the first closing event for this opening event, record it.
        openingEvent.closingEvent = closingEvent;
        closingEvent.openingEvent = openingEvent;
        var se = new tr.model.um.StartupExpectation(modelHelper.model, openingEvent.start, closingEvent.end - openingEvent.start);
        se.associatedEvents.push(openingEvent);
        se.associatedEvents.push(closingEvent);
        startups.push(se);
      });
    });
    return startups;
  }

  return {
    findStartupExpectations: findStartupExpectations
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../model/user_model/startup_expectation.js":165}],75:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/timing.js");
require("./empty_importer.js");
require("./importer.js");
require("./user_model_builder.js");
require("../ui/base/overlay.js");

'use strict';

global.tr.exportTo('tr.importer', function () {
  var Timing = tr.b.Timing;

  function ImportOptions() {
    this.shiftWorldToZero = true;
    this.pruneEmptyContainers = true;
    this.showImportWarnings = true;
    this.trackDetailedModelStats = false;

    // Callback called after
    // importers run in which more data can be added to the model, before it is
    // finalized.
    this.customizeModelCallback = undefined;

    var auditorTypes = tr.c.Auditor.getAllRegisteredTypeInfos();
    this.auditorConstructors = auditorTypes.map(function (typeInfo) {
      return typeInfo.constructor;
    });
  }

  function Import(model, opt_options) {
    if (model === undefined) throw new Error('Must provide model to import into.');

    // TODO(dsinclair): Check the model is empty.

    this.importing_ = false;
    this.importOptions_ = opt_options || new ImportOptions();

    this.model_ = model;
    this.model_.importOptions = this.importOptions_;
  }

  Import.prototype = {
    __proto__: Object.prototype,

    /**
     * Imports the provided traces into the model. The eventData type
     * is undefined and will be passed to all the importers registered
     * via Importer.register. The first importer that returns true
     * for canImport(events) will be used to import the events.
     *
     * The primary trace is provided via the eventData variable. If multiple
     * traces are to be imported, specify the first one as events, and the
     * remainder in the opt_additionalEventData array.
     *
     * @param {Array} traces An array of eventData to be imported. Each
     * eventData should correspond to a single trace file and will be handled by
     * a separate importer.
     */
    importTraces: function (traces) {
      var progressMeter = {
        update: function (msg) {}
      };

      tr.b.Task.RunSynchronously(this.createImportTracesTask(progressMeter, traces));
    },

    /**
     * Imports a trace with the usual options from importTraces, but
     * does so using idle callbacks, putting up an import dialog
     * during the import process.
     */
    importTracesWithProgressDialog: function (traces) {
      if (tr.isHeadless) throw new Error('Cannot use this method in headless mode.');

      var overlay = tr.ui.b.Overlay();
      overlay.title = 'Importing...';
      overlay.userCanClose = false;
      overlay.msgEl = document.createElement('div');
      Polymer.dom(overlay).appendChild(overlay.msgEl);
      overlay.msgEl.style.margin = '20px';
      overlay.update = function (msg) {
        Polymer.dom(this.msgEl).textContent = msg;
      };
      overlay.visible = true;

      var promise = tr.b.Task.RunWhenIdle(this.createImportTracesTask(overlay, traces));
      promise.then(function () {
        overlay.visible = false;
      }, function (err) {
        overlay.visible = false;
      });
      return promise;
    },

    /**
     * Creates a task that will import the provided traces into the model,
     * updating the progressMeter as it goes. Parameters are as defined in
     * importTraces.
     */
    createImportTracesTask: function (progressMeter, traces) {
      if (this.importing_) throw new Error('Already importing.');
      this.importing_ = true;

      // Just some simple setup. It is useful to have a no-op first
      // task so that we can set up the lastTask = lastTask.after()
      // pattern that follows.
      var importTask = new tr.b.Task(function prepareImport() {
        progressMeter.update('I will now import your traces for you...');
      }, this);
      var lastTask = importTask;

      var importers = [];

      lastTask = lastTask.timedAfter('TraceImport', function createImports() {
        // Copy the traces array, we may mutate it.
        traces = traces.slice(0);
        progressMeter.update('Creating importers...');
        // Figure out which importers to use.
        for (var i = 0; i < traces.length; ++i) importers.push(this.createImporter_(traces[i]));

        // Some traces have other traces inside them. Before doing the full
        // import, ask the importer if it has any subtraces, and if so, create
        // importers for them, also.
        for (var i = 0; i < importers.length; i++) {
          var subtraces = importers[i].extractSubtraces();
          for (var j = 0; j < subtraces.length; j++) {
            try {
              traces.push(subtraces[j]);
              importers.push(this.createImporter_(subtraces[j]));
            } catch (error) {
              // TODO(kphanee): Log the subtrace file which has failed.
              console.warn(error.name + ': ' + error.message);
              continue;
            }
          }
        }

        if (traces.length && !this.hasEventDataDecoder_(importers)) {
          throw new Error('Could not find an importer for the provided eventData.');
        }

        // Sort them on priority. This ensures importing happens in a
        // predictable order, e.g. ftrace_importer before
        // trace_event_importer.
        importers.sort(function (x, y) {
          return x.importPriority - y.importPriority;
        });
      }, this);

      // We import clock sync markers before all other events. This is necessary
      // because we need the clock sync markers in order to know by how much we
      // need to shift the timestamps of other events.
      lastTask = lastTask.timedAfter('TraceImport', function importClockSyncMarkers(task) {
        importers.forEach(function (importer, index) {
          task.subTask(Timing.wrapNamedFunction('TraceImport', importer.importerName, function runImportClockSyncMarkersOnOneImporter() {
            progressMeter.update('Importing clock sync markers ' + (index + 1) + ' of ' + importers.length);
            importer.importClockSyncMarkers();
          }), this);
        }, this);
      }, this);

      // Run the import.
      lastTask = lastTask.timedAfter('TraceImport', function runImport(task) {
        importers.forEach(function (importer, index) {
          task.subTask(Timing.wrapNamedFunction('TraceImport', importer.importerName, function runImportEventsOnOneImporter() {
            progressMeter.update('Importing ' + (index + 1) + ' of ' + importers.length);
            importer.importEvents();
          }), this);
        }, this);
      }, this);

      // Run the cusomizeModelCallback if needed.
      if (this.importOptions_.customizeModelCallback) {
        lastTask = lastTask.timedAfter('TraceImport', function runCustomizeCallbacks(task) {
          this.importOptions_.customizeModelCallback(this.model_);
        }, this);
      }

      // Import sample data.
      lastTask = lastTask.timedAfter('TraceImport', function importSampleData(task) {
        importers.forEach(function (importer, index) {
          progressMeter.update('Importing sample data ' + (index + 1) + '/' + importers.length);
          importer.importSampleData();
        }, this);
      }, this);

      // Autoclose open slices and create subSlices.
      lastTask = lastTask.timedAfter('TraceImport', function runAutoclosers() {
        progressMeter.update('Autoclosing open slices...');
        this.model_.autoCloseOpenSlices();
        this.model_.createSubSlices();
      }, this);

      // Finalize import.
      lastTask = lastTask.timedAfter('TraceImport', function finalizeImport(task) {
        importers.forEach(function (importer, index) {
          progressMeter.update('Finalizing import ' + (index + 1) + '/' + importers.length);
          importer.finalizeImport();
        }, this);
      }, this);

      // Run preinit.
      lastTask = lastTask.timedAfter('TraceImport', function runPreinits() {
        progressMeter.update('Initializing objects (step 1/2)...');
        this.model_.preInitializeObjects();
      }, this);

      // Prune empty containers.
      if (this.importOptions_.pruneEmptyContainers) {
        lastTask = lastTask.timedAfter('TraceImport', function runPruneEmptyContainers() {
          progressMeter.update('Pruning empty containers...');
          this.model_.pruneEmptyContainers();
        }, this);
      }

      // Merge kernel and userland slices on each thread.
      lastTask = lastTask.timedAfter('TraceImport', function runMergeKernelWithuserland() {
        progressMeter.update('Merging kernel with userland...');
        this.model_.mergeKernelWithUserland();
      }, this);

      // Create auditors
      var auditors = [];
      lastTask = lastTask.timedAfter('TraceImport', function createAuditorsAndRunAnnotate() {
        progressMeter.update('Adding arbitrary data to model...');
        auditors = this.importOptions_.auditorConstructors.map(function (auditorConstructor) {
          return new auditorConstructor(this.model_);
        }, this);
        auditors.forEach(function (auditor) {
          auditor.runAnnotate();
          auditor.installUserFriendlyCategoryDriverIfNeeded();
        });
      }, this);

      lastTask = lastTask.timedAfter('TraceImport', function computeWorldBounds() {
        progressMeter.update('Computing final world bounds...');
        this.model_.computeWorldBounds(this.importOptions_.shiftWorldToZero);
      }, this);

      // Build the flow event interval tree.
      lastTask = lastTask.timedAfter('TraceImport', function buildFlowEventIntervalTree() {
        progressMeter.update('Building flow event map...');
        this.model_.buildFlowEventIntervalTree();
      }, this);

      // Join refs.
      lastTask = lastTask.timedAfter('TraceImport', function joinRefs() {
        progressMeter.update('Joining object refs...');
        this.model_.joinRefs();
      }, this);

      // Delete any undeleted objects.
      lastTask = lastTask.timedAfter('TraceImport', function cleanupUndeletedObjects() {
        progressMeter.update('Cleaning up undeleted objects...');
        this.model_.cleanupUndeletedObjects();
      }, this);

      // Sort global and process memory dumps.
      lastTask = lastTask.timedAfter('TraceImport', function sortMemoryDumps() {
        progressMeter.update('Sorting memory dumps...');
        this.model_.sortMemoryDumps();
      }, this);

      // Finalize memory dump graphs.
      lastTask = lastTask.timedAfter('TraceImport', function finalizeMemoryGraphs() {
        progressMeter.update('Finalizing memory dump graphs...');
        this.model_.finalizeMemoryGraphs();
      }, this);

      // Run initializers.
      lastTask = lastTask.timedAfter('TraceImport', function initializeObjects() {
        progressMeter.update('Initializing objects (step 2/2)...');
        this.model_.initializeObjects();
      }, this);

      // Build event indices mapping from an event id to all flow events.
      lastTask = lastTask.timedAfter('TraceImport', function buildEventIndices() {
        progressMeter.update('Building event indices...');
        this.model_.buildEventIndices();
      }, this);

      // Build the UserModel.
      lastTask = lastTask.timedAfter('TraceImport', function buildUserModel() {
        progressMeter.update('Building UserModel...');
        var userModelBuilder = new tr.importer.UserModelBuilder(this.model_);
        userModelBuilder.buildUserModel();
      }, this);

      // Sort Expectations.
      lastTask = lastTask.timedAfter('TraceImport', function sortExpectations() {
        progressMeter.update('Sorting user expectations...');
        this.model_.userModel.sortExpectations();
      }, this);

      // Run audits.
      lastTask = lastTask.timedAfter('TraceImport', function runAudits() {
        progressMeter.update('Running auditors...');
        auditors.forEach(function (auditor) {
          auditor.runAudit();
        });
      }, this);

      lastTask = lastTask.timedAfter('TraceImport', function sortAlerts() {
        progressMeter.update('Updating alerts...');
        this.model_.sortAlerts();
      }, this);

      lastTask = lastTask.timedAfter('TraceImport', function lastUpdateBounds() {
        progressMeter.update('Update bounds...');
        this.model_.updateBounds();
      }, this);

      lastTask = lastTask.timedAfter('TraceImport', function addModelWarnings() {
        progressMeter.update('Looking for warnings...');
        // Log an import warning if the clock is low resolution.
        if (!this.model_.isTimeHighResolution) {
          this.model_.importWarning({
            type: 'low_resolution_timer',
            message: 'Trace time is low resolution, trace may be unusable.',
            showToUser: true
          });
        }
      }, this);

      // Cleanup.
      lastTask.after(function () {
        this.importing_ = false;
      }, this);
      return importTask;
    },

    createImporter_: function (eventData) {
      var importerConstructor = tr.importer.Importer.findImporterFor(eventData);
      if (!importerConstructor) {
        throw new Error('Couldn\'t create an importer for the provided ' + 'eventData.');
      }
      return new importerConstructor(this.model_, eventData);
    },

    hasEventDataDecoder_: function (importers) {
      for (var i = 0; i < importers.length; ++i) {
        if (!importers[i].isTraceDataContainer()) return true;
      }

      return false;
    }
  };

  return {
    ImportOptions: ImportOptions,
    Import: Import
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/timing.js":56,"../ui/base/overlay.js":174,"./empty_importer.js":71,"./importer.js":76,"./user_model_builder.js":78}],76:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/extension_registry.js");

'use strict';

/**
 * @fileoverview Base class for trace data importers.
 */
global.tr.exportTo('tr.importer', function () {
  function Importer() {}

  Importer.prototype = {
    __proto__: Object.prototype,

    get importerName() {
      return 'Importer';
    },

    /**
     * Called by the Model to check whether the importer type stores the actual
     * trace data or just holds it as container for further extraction.
     */
    isTraceDataContainer: function () {
      return false;
    },

    /**
     * Called by the Model to extract one or more subtraces from the event data.
     */
    extractSubtraces: function () {
      return [];
    },

    /**
     * Called to import clock sync markers into the Model.
     */
    importClockSyncMarkers: function () {},

    /**
     * Called to import events into the Model.
     */
    importEvents: function () {},

    /**
     * Called to import sample data into the Model.
     */
    importSampleData: function () {},

    /**
     * Called by the Model after all other importers have imported their
     * events.
     */
    finalizeImport: function () {}
  };

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Importer;
  tr.b.decorateExtensionRegistry(Importer, options);

  Importer.findImporterFor = function (eventData) {
    var typeInfo = Importer.findTypeInfoMatching(function (ti) {
      return ti.constructor.canImport(eventData);
    });
    if (typeInfo) return typeInfo.constructor;
    return undefined;
  };

  return {
    Importer: Importer
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/extension_registry.js":35}],77:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/range_utils.js");
require("../core/auditor.js");
require("../model/event_info.js");
require("../model/user_model/animation_expectation.js");
require("../model/user_model/response_expectation.js");

'use strict';

global.tr.exportTo('tr.importer', function () {
  // This is an intermediate data format between InputLatencyAsyncSlices and
  // Response and Animation IRs.
  function ProtoExpectation(irType, name) {
    this.irType = irType;
    this.names = new Set(name ? [name] : undefined);
    this.start = Infinity;
    this.end = -Infinity;
    this.associatedEvents = new tr.model.EventSet();
    this.isAnimationBegin = false;
  }

  ProtoExpectation.RESPONSE_TYPE = 'r';
  ProtoExpectation.ANIMATION_TYPE = 'a';

  // Explicitly ignore some input events to allow
  // UserModelBuilder.checkAllInputEventsHandled() to determine which events
  // were unintentionally ignored due to a bug.
  ProtoExpectation.IGNORED_TYPE = 'ignored';

  ProtoExpectation.prototype = {
    get isValid() {
      return this.end > this.start;
    },

    // Return true if any associatedEvent's typeName is in typeNames.
    containsTypeNames: function (typeNames) {
      return this.associatedEvents.some(x => typeNames.indexOf(x.typeName) >= 0);
    },

    containsSliceTitle: function (title) {
      return this.associatedEvents.some(x => title === x.title);
    },

    createInteractionRecord: function (model) {
      if (!this.isValid) {
        console.error('Invalid ProtoExpectation: ' + this.debug() + ' File a bug with this trace!');
        return undefined;
      }

      var initiatorTitles = [];
      this.names.forEach(function (name) {
        initiatorTitles.push(name);
      });
      initiatorTitles = initiatorTitles.sort().join(',');

      var duration = this.end - this.start;

      var ir = undefined;
      switch (this.irType) {
        case ProtoExpectation.RESPONSE_TYPE:
          ir = new tr.model.um.ResponseExpectation(model, initiatorTitles, this.start, duration, this.isAnimationBegin);
          break;
        case ProtoExpectation.ANIMATION_TYPE:
          ir = new tr.model.um.AnimationExpectation(model, initiatorTitles, this.start, duration);
          break;
      }
      if (!ir) return undefined;

      ir.sourceEvents.addEventSet(this.associatedEvents);

      function pushAssociatedEvents(event) {
        ir.associatedEvents.push(event);

        // |event| is either an InputLatencyAsyncSlice (which collects all of
        // its associated events transitively) or a CSS Animation (which doesn't
        // have any associated events). So this does not need to recurse.
        if (event.associatedEvents) ir.associatedEvents.addEventSet(event.associatedEvents);
      }

      this.associatedEvents.forEach(function (event) {
        pushAssociatedEvents(event);

        // Old-style InputLatencyAsyncSlices have subSlices.
        if (event.subSlices) event.subSlices.forEach(pushAssociatedEvents);
      });

      return ir;
    },

    // Merge the other ProtoExpectation into this one.
    // The irTypes need not match: ignored ProtoExpectations might be merged
    // into overlapping ProtoExpectations, and Touch-only Animations are merged
    // into Tap Responses.
    merge: function (other) {
      other.names.forEach(function (name) {
        this.names.add(name);
      }.bind(this));

      // Don't use pushEvent(), which would lose special start, end.
      this.associatedEvents.addEventSet(other.associatedEvents);
      this.start = Math.min(this.start, other.start);
      this.end = Math.max(this.end, other.end);
      if (other.isAnimationBegin) this.isAnimationBegin = true;
    },

    // Include |event| in this ProtoExpectation, expanding start/end to include
    // it.
    pushEvent: function (event) {
      // Usually, this method will be called while iterating over a list of
      // events sorted by start time, so this method won't usually change
      // this.start. However, this will sometimes be called for
      // ProtoExpectations created by previous handlers, in which case
      // event.start could possibly be before this.start.
      this.start = Math.min(this.start, event.start);
      this.end = Math.max(this.end, event.end);
      this.associatedEvents.push(event);
    },

    // Returns true if timestamp is contained in this ProtoExpectation.
    containsTimestampInclusive: function (timestamp) {
      return this.start <= timestamp && timestamp <= this.end;
    },

    // Return true if the other event intersects this ProtoExpectation.
    intersects: function (other) {
      // http://stackoverflow.com/questions/325933
      return other.start < this.end && other.end > this.start;
    },

    isNear: function (event, threshold) {
      return this.end + threshold > event.start;
    },

    // Return a string describing this ProtoExpectation for debugging.
    debug: function () {
      var debugString = this.irType + '(';
      debugString += parseInt(this.start) + ' ';
      debugString += parseInt(this.end);
      this.associatedEvents.forEach(function (event) {
        debugString += ' ' + event.typeName;
      });
      return debugString + ')';
    }
  };

  return {
    ProtoExpectation: ProtoExpectation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/range_utils.js":48,"../core/auditor.js":60,"../model/event_info.js":118,"../model/user_model/animation_expectation.js":161,"../model/user_model/response_expectation.js":164}],78:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/range_utils.js");
require("../core/auditor.js");
require("../extras/chrome/cc/input_latency_async_slice.js");
require("./find_input_expectations.js");
require("./find_load_expectations.js");
require("./find_startup_expectations.js");
require("../model/event_info.js");
require("../model/ir_coverage.js");
require("../model/user_model/idle_expectation.js");

'use strict';

global.tr.exportTo('tr.importer', function () {
  var INSIGNIFICANT_MS = 1;

  function UserModelBuilder(model) {
    this.model = model;
    this.modelHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
  };

  UserModelBuilder.supportsModelHelper = function (modelHelper) {
    return modelHelper.browserHelper !== undefined;
  };

  UserModelBuilder.prototype = {
    buildUserModel: function () {
      if (!this.modelHelper || !this.modelHelper.browserHelper) return;

      var expectations = undefined;
      try {
        expectations = this.findUserExpectations();
        // There are not currently any known cases when this could throw.
      } catch (error) {
        this.model.importWarning({
          type: 'UserModelBuilder',
          message: error,
          showToUser: true
        });
        return;
      }
      expectations.forEach(function (expectation) {
        this.model.userModel.expectations.push(expectation);
      }, this);

      // TODO(benjhayden) Find Gestures here.
    },

    findUserExpectations: function () {
      var expectations = [];
      expectations.push.apply(expectations, tr.importer.findStartupExpectations(this.modelHelper));
      expectations.push.apply(expectations, tr.importer.findLoadExpectations(this.modelHelper));
      expectations.push.apply(expectations, tr.importer.findInputExpectations(this.modelHelper));
      // findIdleExpectations must be called last!
      expectations.push.apply(expectations, this.findIdleExpectations(expectations));
      this.collectUnassociatedEvents_(expectations);
      return expectations;
    },

    // Find all unassociated top-level ThreadSlices. If they start during an
    // Idle or Load IR, then add their entire hierarchy to that IR.
    collectUnassociatedEvents_: function (rirs) {
      var vacuumIRs = [];
      rirs.forEach(function (ir) {
        if (ir instanceof tr.model.um.IdleExpectation || ir instanceof tr.model.um.LoadExpectation || ir instanceof tr.model.um.StartupExpectation) vacuumIRs.push(ir);
      });
      if (vacuumIRs.length === 0) return;

      var allAssociatedEvents = tr.model.getAssociatedEvents(rirs);
      var unassociatedEvents = tr.model.getUnassociatedEvents(this.model, allAssociatedEvents);

      unassociatedEvents.forEach(function (event) {
        if (!(event instanceof tr.model.ThreadSlice)) return;

        if (!event.isTopLevel) return;

        for (var iri = 0; iri < vacuumIRs.length; ++iri) {
          var ir = vacuumIRs[iri];

          if (event.start >= ir.start && event.start < ir.end) {
            ir.associatedEvents.addEventSet(event.entireHierarchy);
            return;
          }
        }
      });
    },

    // Fill in the empty space between IRs with IdleIRs.
    findIdleExpectations: function (otherIRs) {
      if (this.model.bounds.isEmpty) return;
      var emptyRanges = tr.b.findEmptyRangesBetweenRanges(tr.b.convertEventsToRanges(otherIRs), this.model.bounds);
      var irs = [];
      var model = this.model;
      emptyRanges.forEach(function (range) {
        // Ignore insignificantly tiny idle ranges.
        if (range.max < range.min + INSIGNIFICANT_MS) return;
        irs.push(new tr.model.um.IdleExpectation(model, range.min, range.max - range.min));
      });
      return irs;
    }
  };

  function createCustomizeModelLinesFromModel(model) {
    var modelLines = [];
    modelLines.push('      audits.addEvent(model.browserMain,');
    modelLines.push('          {title: \'model start\', start: 0, end: 1});');

    var typeNames = {};
    for (var typeName in tr.e.cc.INPUT_EVENT_TYPE_NAMES) {
      typeNames[tr.e.cc.INPUT_EVENT_TYPE_NAMES[typeName]] = typeName;
    }

    var modelEvents = new tr.model.EventSet();
    model.userModel.expectations.forEach(function (ir, index) {
      modelEvents.addEventSet(ir.sourceEvents);
    });
    modelEvents = modelEvents.toArray();
    modelEvents.sort(tr.importer.compareEvents);

    modelEvents.forEach(function (event) {
      var startAndEnd = 'start: ' + parseInt(event.start) + ', ' + 'end: ' + parseInt(event.end) + '});';
      if (event instanceof tr.e.cc.InputLatencyAsyncSlice) {
        modelLines.push('      audits.addInputEvent(model, INPUT_TYPE.' + typeNames[event.typeName] + ',');
      } else if (event.title === 'RenderFrameImpl::didCommitProvisionalLoad') {
        modelLines.push('      audits.addCommitLoadEvent(model,');
      } else if (event.title === 'InputHandlerProxy::HandleGestureFling::started') {
        modelLines.push('      audits.addFlingAnimationEvent(model,');
      } else if (event.title === tr.model.helpers.IMPL_RENDERING_STATS) {
        modelLines.push('      audits.addFrameEvent(model,');
      } else if (event.title === tr.importer.CSS_ANIMATION_TITLE) {
        modelLines.push('      audits.addEvent(model.rendererMain, {');
        modelLines.push('        title: \'Animation\', ' + startAndEnd);
        return;
      } else {
        throw 'You must extend createCustomizeModelLinesFromModel()' + 'to support this event:\n' + event.title + '\n';
      }
      modelLines.push('          {' + startAndEnd);
    });

    modelLines.push('      audits.addEvent(model.browserMain,');
    modelLines.push('          {' + 'title: \'model end\', ' + 'start: ' + (parseInt(model.bounds.max) - 1) + ', ' + 'end: ' + parseInt(model.bounds.max) + '});');
    return modelLines;
  }

  function createExpectedIRLinesFromModel(model) {
    var expectedLines = [];
    var irCount = model.userModel.expectations.length;
    model.userModel.expectations.forEach(function (ir, index) {
      var irString = '      {';
      irString += 'title: \'' + ir.title + '\', ';
      irString += 'start: ' + parseInt(ir.start) + ', ';
      irString += 'end: ' + parseInt(ir.end) + ', ';
      irString += 'eventCount: ' + ir.sourceEvents.length;
      irString += '}';
      if (index < irCount - 1) irString += ',';
      expectedLines.push(irString);
    });
    return expectedLines;
  }

  function createIRFinderTestCaseStringFromModel(model) {
    var filename = window.location.hash.substr(1);
    var testName = filename.substr(filename.lastIndexOf('/') + 1);
    testName = testName.substr(0, testName.indexOf('.'));

    // createCustomizeModelLinesFromModel() throws an error if there's an
    // unsupported event.
    try {
      var testLines = [];
      testLines.push('  /*');
      testLines.push('    This test was generated from');
      testLines.push('    ' + filename + '');
      testLines.push('   */');
      testLines.push('  test(\'' + testName + '\', function() {');
      testLines.push('    var verifier = new UserExpectationVerifier();');
      testLines.push('    verifier.customizeModelCallback = function(model) {');
      testLines.push.apply(testLines, createCustomizeModelLinesFromModel(model));
      testLines.push('    };');
      testLines.push('    verifier.expectedIRs = [');
      testLines.push.apply(testLines, createExpectedIRLinesFromModel(model));
      testLines.push('    ];');
      testLines.push('    verifier.verify();');
      testLines.push('  });');
      return testLines.join('\n');
    } catch (error) {
      return error;
    }
  }

  return {
    UserModelBuilder: UserModelBuilder,
    createIRFinderTestCaseStringFromModel: createIRFinderTestCaseStringFromModel
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/range_utils.js":48,"../core/auditor.js":60,"../extras/chrome/cc/input_latency_async_slice.js":62,"../model/event_info.js":118,"../model/ir_coverage.js":131,"../model/user_model/idle_expectation.js":162,"./find_input_expectations.js":72,"./find_load_expectations.js":73,"./find_startup_expectations.js":74}],79:[function(require,module,exports){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./importer/import.js");
require("./model/model.js");
require("./extras/lean_config.js");
require("./metrics/all_metrics.js");
},{"./extras/lean_config.js":69,"./importer/import.js":75,"./metrics/all_metrics.js":80,"./model/model.js":135}],80:[function(require,module,exports){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./blink/gc_metric.js");
require("./cpu_process_metric.js");
require("./sample_metric.js");
require("./system_health/clock_sync_latency_metric.js");
require("./system_health/hazard_metric.js");
require("./system_health/loading_metric.js");
require("./system_health/memory_metric.js");
require("./system_health/power_metric.js");
require("./system_health/responsiveness_metric.js");
require("./system_health/system_health_metrics.js");
require("./system_health/webview_startup_metric.js");
require("./tracing_metric.js");
require("./v8/execution_metric.js");
require("./v8/gc_metric.js");
require("./v8/v8_metrics.js");
},{"./blink/gc_metric.js":81,"./cpu_process_metric.js":82,"./sample_metric.js":84,"./system_health/clock_sync_latency_metric.js":85,"./system_health/hazard_metric.js":87,"./system_health/loading_metric.js":88,"./system_health/memory_metric.js":90,"./system_health/power_metric.js":91,"./system_health/responsiveness_metric.js":92,"./system_health/system_health_metrics.js":93,"./system_health/webview_startup_metric.js":95,"./tracing_metric.js":96,"./v8/execution_metric.js":97,"./v8/gc_metric.js":98,"./v8/v8_metrics.js":100}],81:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/range.js");
require("../../base/unit.js");
require("../metric_registry.js");
require("../v8/utils.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.blink', function () {
  // Maps the Blink GC events in timeline to telemetry friendly names.
  var BLINK_GC_EVENTS = {
    'BlinkGCMarking': 'blink-gc-marking',
    'ThreadState::completeSweep': 'blink-gc-complete-sweep',
    'ThreadState::performIdleLazySweep': 'blink-gc-idle-lazy-sweep'
  };

  function isBlinkGarbageCollectionEvent(event) {
    return event.title in BLINK_GC_EVENTS;
  }

  function blinkGarbageCollectionEventName(event) {
    return BLINK_GC_EVENTS[event.title];
  }

  function blinkGcMetric(values, model) {
    addDurationOfTopEvents(values, model);
    addTotalDurationOfTopEvents(values, model);
    addIdleTimesOfTopEvents(values, model);
    addTotalIdleTimesOfTopEvents(values, model);
  }

  tr.metrics.MetricRegistry.register(blinkGcMetric);

  var timeDurationInMs_smallerIsBetter = tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  var percentage_biggerIsBetter = tr.b.Unit.byName.normalizedPercentage_biggerIsBetter;

  // 0.1 steps from 0 to 20 since it is the most common range.
  // Exponentially increasing steps from 20 to 200.
  var CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(0, 20, 200).addExponentialBins(200, 100);

  function createNumericForTopEventTime(name) {
    var n = new tr.v.Histogram(name, timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: true,
      max: true,
      min: false,
      std: true,
      sum: true,
      percentile: [0.90] });
    return n;
  }

  function createNumericForIdleTime(name) {
    var n = new tr.v.Histogram(name, timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: true,
      percentile: []
    });
    return n;
  }

  function createPercentage(name, numerator, denominator) {
    var histogram = new tr.v.Histogram(name, percentage_biggerIsBetter);
    if (denominator === 0) histogram.addSample(0);else histogram.addSample(numerator / denominator);
    return histogram;
  }

  /**
   * Example output:
   * - blink-gc-marking.
   */
  function addDurationOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isBlinkGarbageCollectionEvent, blinkGarbageCollectionEventName, function (name, events) {
      var cpuDuration = createNumericForTopEventTime(name);
      events.forEach(function (event) {
        cpuDuration.addSample(event.cpuDuration);
      });
      values.addHistogram(cpuDuration);
    });
  }

  /**
   * Example output:
   * - blink-gc-total
   */
  function addTotalDurationOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isBlinkGarbageCollectionEvent, event => 'blink-gc-total', function (name, events) {
      var cpuDuration = createNumericForTopEventTime(name);
      events.forEach(function (event) {
        cpuDuration.addSample(event.cpuDuration);
      });
      values.addHistogram(cpuDuration);
    });
  }

  /**
   * Example output:
   * - blink-gc-marking_idle_deadline_overrun,
   * - blink-gc-marking_outside_idle,
   * - blink-gc-marking_percentage_idle.
   */
  function addIdleTimesOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isBlinkGarbageCollectionEvent, blinkGarbageCollectionEventName, function (name, events) {
      addIdleTimes(values, model, name, events);
    });
  }

  /**
   * Example output:
   * - blink-gc-total_idle_deadline_overrun,
   * - blink-gc-total_outside_idle,
   * - blink-gc-total_percentage_idle.
   */
  function addTotalIdleTimesOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isBlinkGarbageCollectionEvent, event => 'blink-gc-total', function (name, events) {
      addIdleTimes(values, model, name, events);
    });
  }

  function addIdleTimes(values, model, name, events) {
    var cpuDuration = createNumericForIdleTime(name + '_cpu');
    var insideIdle = createNumericForIdleTime(name + '_inside_idle');
    var outsideIdle = createNumericForIdleTime(name + '_outside_idle');
    var idleDeadlineOverrun = createNumericForIdleTime(name + '_idle_deadline_overrun');
    events.forEach(function (event) {
      var idleTask = tr.metrics.v8.utils.findParent(event, tr.metrics.v8.utils.isIdleTask);
      var inside = 0;
      var overrun = 0;
      if (idleTask) {
        var allottedTime = idleTask['args']['allotted_time_ms'];
        if (event.duration > allottedTime) {
          overrun = event.duration - allottedTime;
          // Don't count time over the deadline as being inside idle time.
          // Since the deadline should be relative to wall clock we
          // compare allotted_time_ms with wall duration instead of thread
          // duration, and then assume the thread duration was inside idle
          // for the same percentage of time.
          inside = event.cpuDuration * allottedTime / event.duration;
        } else {
          inside = event.cpuDuration;
        }
      }
      cpuDuration.addSample(event.cpuDuration);
      insideIdle.addSample(inside);
      outsideIdle.addSample(event.cpuDuration - inside);
      idleDeadlineOverrun.addSample(overrun);
    });
    values.addHistogram(idleDeadlineOverrun);
    values.addHistogram(outsideIdle);
    var percentage = createPercentage(name + '_percentage_idle', insideIdle.sum, cpuDuration.sum);
    values.addHistogram(percentage);
  }

  return {
    blinkGcMetric: blinkGcMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/range.js":47,"../../base/unit.js":57,"../../value/histogram.js":189,"../metric_registry.js":83,"../v8/utils.js":99}],82:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

require("./metric_registry.js");
require("../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  function getCpuSnapshotsFromModel(model) {
    var snapshots = [];
    for (var pid in model.processes) {
      var snapshotInstances = model.processes[pid].objects.getAllInstancesNamed('CPUSnapshots');
      if (!snapshotInstances) continue;
      for (var object of snapshotInstances[0].snapshots) snapshots.push(object.args.processes);
    }
    return snapshots;
  }

  function getProcessSumsFromSnapshot(snapshot) {
    var processSums = new Map();
    for (var processData of snapshot) {
      var processName = processData.name;
      if (!processSums.has(processName)) processSums.set(processName, { sum: 0.0, paths: new Set() });
      processSums.get(processName).sum += parseFloat(processData.pCpu);
      // The process path may be missing on Windows because of AccessDenied
      // error thrown by psutil package used by CPU tracing agent.
      if (processData.path) processSums.get(processName).paths.add(processData.path);
    }
    return processSums;
  }

  function buildNumericsFromSnapshots(snapshots) {
    var processNumerics = new Map();
    for (var snapshot of snapshots) {
      var processSums = getProcessSumsFromSnapshot(snapshot);
      for (var _ref of processSums.entries()) {
        var _ref2 = _slicedToArray(_ref, 2);

        var processName = _ref2[0];
        var processData = _ref2[1];

        if (!processNumerics.has(processName)) {
          processNumerics.set(processName, {
            numeric: new tr.v.Histogram('cpu:percent:' + processName, tr.b.Unit.byName.normalizedPercentage_smallerIsBetter),
            paths: new Set()
          });
        }
        processNumerics.get(processName).numeric.addSample(processData.sum / 100.0);
        for (var path of processData.paths) processNumerics.get(processName).paths.add(path);
      }
    }
    return processNumerics;
  }

  function cpuProcessMetric(values, model) {
    var snapshots = getCpuSnapshotsFromModel(model);
    var processNumerics = buildNumericsFromSnapshots(snapshots);
    for (var _ref3 of processNumerics) {
      var _ref4 = _slicedToArray(_ref3, 2);

      var processName = _ref4[0];
      var processData = _ref4[1];

      var numeric = processData.numeric;
      // Treat missing snapshots as zeros. A process is missing from a snapshots
      // when its CPU usage was below minimum threshold when the snapshot was
      // taken.
      var missingSnapshotCount = snapshots.length - numeric.numValues;
      for (var i = 0; i < missingSnapshotCount; i++) numeric.addSample(0);
      numeric.diagnostics.set('paths', new tr.v.d.Generic([...processData.paths]));
      values.addHistogram(numeric);
    }
  }

  tr.metrics.MetricRegistry.register(cpuProcessMetric);

  return {
    cpuProcessMetric: cpuProcessMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../value/histogram.js":189,"./metric_registry.js":83}],83:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/extension_registry.js");
require("../base/iteration_helpers.js");

'use strict';

global.tr.exportTo('tr.metrics', function () {

  function MetricRegistry() {}

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  tr.b.decorateExtensionRegistry(MetricRegistry, options);

  MetricRegistry.addEventListener('will-register', function (e) {
    var metric = e.typeInfo.constructor;
    if (!(metric instanceof Function)) throw new Error('Metrics must be functions');

    if (metric.length < 2) {
      throw new Error('Metrics take a ValueSet and a Model and ' + 'optionally an options dictionary');
    }
  });

  return {
    MetricRegistry: MetricRegistry
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/extension_registry.js":35,"../base/iteration_helpers.js":41}],84:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range.js");
require("./metric_registry.js");
require("../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics', function () {
  function sampleMetric(values, model) {
    var hist = new tr.v.Histogram('foo', tr.b.Unit.byName.sizeInBytes_smallerIsBetter);
    hist.addSample(9);
    hist.addSample(91, { bar: new tr.v.d.Generic({ hello: 42 }) });

    for (var expectation of model.userModel.expectations) {
      if (expectation instanceof tr.model.um.ResponseExpectation) {} else if (expectation instanceof tr.model.um.AnimationExpectation) {} else if (expectation instanceof tr.model.um.IdleExpectation) {} else if (expectation instanceof tr.model.um.LoadExpectation) {}
    }

    var chromeHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);

    tr.b.iterItems(model.processes, function (pid, process) {});

    values.addHistogram(hist);
  }

  tr.metrics.MetricRegistry.register(sampleMetric);

  return {
    sampleMetric: sampleMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range.js":47,"../value/histogram.js":189,"./metric_registry.js":83}],85:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../metric_registry.js");
require("./utils.js");
require("../../model/model.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  function syncIsComplete(markers) {
    return markers.length === 2;
  }

  function syncInvolvesTelemetry(markers) {
    for (var marker of markers) if (marker.domainId === tr.model.ClockDomainId.TELEMETRY) return true;

    return false;
  }

  function clockSyncLatencyMetric(values, model) {
    for (var markers of model.clockSyncManager.markersBySyncId.values()) {
      var latency = undefined;
      var targetDomain = undefined;
      if (!syncIsComplete(markers) || !syncInvolvesTelemetry(markers)) continue;

      for (var marker of markers) {
        var domain = marker.domainId;
        if (domain === tr.model.ClockDomainId.TELEMETRY) latency = marker.endTs - marker.startTs;else targetDomain = domain.toLowerCase();
      }

      var hist = new tr.v.Histogram('clock_sync_latency_' + targetDomain, tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, tr.v.HistogramBinBoundaries.createExponential(1e-3, 1e3, 30));
      hist.description = 'Clock sync latency for domain ' + targetDomain;
      hist.addSample(latency);
      values.addHistogram(hist);
    }
  }

  tr.metrics.MetricRegistry.register(clockSyncLatencyMetric);

  return {
    clockSyncLatencyMetric: clockSyncLatencyMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../model/model.js":135,"../../value/histogram.js":189,"../metric_registry.js":83,"./utils.js":94}],86:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../metric_registry.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  // Use a lower bound of 0.01 for the metric boundaries (when no CPU time
  // is consumed) and an upper bound of 50 (fifty cores are all active
  // for the entire time). We can't use zero exactly for the lower bound with an
  // exponential histogram.
  var CPU_TIME_PERCENTAGE_BOUNDARIES = tr.v.HistogramBinBoundaries.createExponential(0.01, 50, 200);

  /**
   * This metric measures total CPU time for Chrome processes, per second of
   *   clock time.
   * This metric requires only the 'toplevel' tracing category.
   *
   * @param {!tr.v.ValueSet} values
   * @param {!tr.model.Model} model
   * @param {!Object=} opt_options
   */
  function cpuTimeMetric(values, model, opt_options) {
    var rangeOfInterest = model.bounds;
    if (opt_options && opt_options.rangeOfInterest) rangeOfInterest = opt_options.rangeOfInterest;
    var allProcessCpuTime = 0;

    for (var pid in model.processes) {
      var process = model.processes[pid];
      var processCpuTime = 0;
      for (var tid in process.threads) {
        var thread = process.threads[tid];
        var threadCpuTime = 0;
        thread.sliceGroup.topLevelSlices.forEach(function (slice) {
          if (slice.duration === 0) return;
          if (!slice.cpuDuration) return;
          var sliceRange = tr.b.Range.fromExplicitRange(slice.start, slice.end);
          var intersection = rangeOfInterest.findIntersection(sliceRange);
          var fractionOfSliceInsideRangeOfInterest = intersection.duration / slice.duration;

          // We assume that if a slice doesn't lie entirely inside the range of
          // interest, then the CPU time is evenly distributed inside of the
          // slice.
          threadCpuTime += slice.cpuDuration * fractionOfSliceInsideRangeOfInterest;
        });
        processCpuTime += threadCpuTime;
      }
      allProcessCpuTime += processCpuTime;
    }

    // Normalize cpu time by clock time.
    var normalizedAllProcessCpuTime = 0;
    if (rangeOfInterest.duration > 0) {
      normalizedAllProcessCpuTime = allProcessCpuTime / rangeOfInterest.duration;
    }

    var unit = tr.b.Unit.byName.normalizedPercentage_smallerIsBetter;
    var cpuTimeHist = new tr.v.Histogram('cpu_time_percentage', unit, CPU_TIME_PERCENTAGE_BOUNDARIES);
    cpuTimeHist.description = 'Percent CPU utilization, normalized against a single core. Can be ' + 'greater than 100% if machine has multiple cores.';
    cpuTimeHist.addSample(normalizedAllProcessCpuTime);
    values.addHistogram(cpuTimeHist);
  }

  tr.metrics.MetricRegistry.register(cpuTimeMetric, {
    supportsRangeOfInterest: true
  });

  return {
    cpuTimeMetric: cpuTimeMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../value/histogram.js":189,"../metric_registry.js":83}],87:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../metric_registry.js");
require("./long_tasks_metric.js");
require("../../value/numeric.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  // The following math is easier if the units are seconds rather than ms,
  // so durations will be converted from ms to s.
  var MS_PER_S = 1000;

  // https://www.desmos.com/calculator/ysabhcc42g
  var RESPONSE_RISK = tr.b.Statistics.LogNormalDistribution.fromMedianAndDiminishingReturns(100 / MS_PER_S, 50 / MS_PER_S);

  /**
   * This helper function computes the risk that a task of the given duration
   * would impact the responsiveness of a speculative input.
   *
   * @param {number} durationMs
   * @return {number} task hazard
   */
  function computeResponsivenessRisk(durationMs) {
    // Returns 0 when the risk of impacting responsiveness is minimal.
    // Returns 1 when it is maximal.
    // durationMs is the duration of a long task.
    // It is at least LONG_TASK_MS.
    // The FAST_RESPONSE_HISTOGRAM was designed to permit both a 50ms task
    // when a Scroll Response begins, plus 16ms latency between the task
    // and the first frame of the scroll, without impacting the responsiveness
    // score.
    // Add 16ms to durationMs to simulate the standard (maximum ideal) scroll
    // response latency, and use the FAST_RESPONSE_HISTOGRAM to punish every ms
    // that the long task exceeds LONG_TASK_MS.

    durationMs += 16;

    // This returns a normalized percentage that
    // represents the fraction of users that would be satisfied with a
    // Scroll Response that takes durationMs to respond.
    // The risk of impacting responsiveness is approximated as the long task's
    // impact on a hypothetical Scroll Response that starts when the long task
    // starts, and then takes the standard 16ms to respond after the long task
    // finishes.
    // We imagine a Scroll Response instead of a Load or another type of
    // Response because the Scroll Response carries the strictest expectation.
    // The risk of impacting responsiveness is framed as the fraction of users
    // that would be *un*satisifed with the responsiveness of that hypothetical
    // Scroll Response. The fraction of users who are unsatisfied with something
    // is equal to 1 - the fraction of users who are satisfied with it.
    return RESPONSE_RISK.computePercentile(durationMs / MS_PER_S);
  }

  /**
   * This weighting function is similar to tr.metrics.sh.perceptualBlend,
   * but this version is appropriate for SmallerIsBetter metrics, whereas
   * that version is for BiggerIsBetter metrics.
   * (This would not be necessary if hazard were reframed as a BiggerIsBetter
   * metric such as "input readiness".)
   * Also, that version assumes that the 'ary' will be UserExpectations, whereas
   * this version assumes that the 'ary' will be scores.
   *
   * @param {number} hazardScore
   * @return {number} weight
   */
  function perceptualBlendSmallerIsBetter(hazardScore) {
    return Math.exp(hazardScore);
  }

  /**
   * Compute and return the normalized score for the risk that a speculative
   * input's responsiveness would have been impacted by long tasks on the given
   * thread in the given range.
   *
   * @param {tr.model.Thread} thread
   * @param {tr.b.Range=} opt_range
   * @return {number} hazard
   */
  function computeHazardForLongTasksInRangeOnThread(thread, opt_range) {
    var taskHazardScores = [];
    tr.metrics.sh.iterateLongTopLevelTasksOnThreadInRange(thread, opt_range, function (task) {
      taskHazardScores.push(computeResponsivenessRisk(task.duration));
    });
    return tr.b.Statistics.weightedMean(taskHazardScores, perceptualBlendSmallerIsBetter);
  }

  /**
   * Compute and return the normalized score for the risk that a speculative
   * input's responsiveness would have been impacted by long tasks.
   *
   * @param {tr.model.Model} model The model.
   * @return {number} hazard
   */
  function computeHazardForLongTasks(model) {
    var threadHazardScores = [];
    tr.metrics.sh.iterateRendererMainThreads(model, function (thread) {
      threadHazardScores.push(computeHazardForLongTasksInRangeOnThread(thread));
    });
    return tr.b.Statistics.weightedMean(threadHazardScores, perceptualBlendSmallerIsBetter);
  }

  /**
   * This EXPERIMENTAL metric computes a scalar normalized score that
   * represents the risk that a speculative input's responsiveness would have
   * been impacted by long tasks.
   * This metric requires only the 'toplevel' tracing category.
   */
  function hazardMetric(values, model) {
    var overallHazard = computeHazardForLongTasks(model);
    if (overallHazard === undefined) overallHazard = 0;

    var hist = new tr.v.Histogram('hazard', tr.b.Unit.byName.normalizedPercentage_smallerIsBetter);
    hist.addSample(overallHazard);
    values.addHistogram(hist);
  }

  tr.metrics.MetricRegistry.register(hazardMetric);

  return {
    hazardMetric: hazardMetric,
    computeHazardForLongTasksInRangeOnThread: computeHazardForLongTasksInRangeOnThread,
    computeHazardForLongTasks: computeHazardForLongTasks,
    computeResponsivenessRisk: computeResponsivenessRisk
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../value/numeric.js":190,"../metric_registry.js":83,"./long_tasks_metric.js":89}],88:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/category_util.js");
require("../../base/statistics.js");
require("../metric_registry.js");
require("./utils.js");
require("../../model/helpers/chrome_model_helper.js");
require("../../model/timed_event.js");
require("../../value/histogram.js");
require("../../value/numeric.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  var RESPONSIVENESS_THRESHOLD = 50;
  var INTERACTIVE_WINDOW_SIZE = 5 * 1000;
  var timeDurationInMs_smallerIsBetter = tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  var RelatedEventSet = tr.v.d.RelatedEventSet;

  // TODO(ksakamoto): This should be a method of tr.model.Event or one of its
  // subclasses.
  function hasCategoryAndName(event, category, title) {
    return event.title === title && event.category && tr.b.getCategoryParts(event.category).indexOf(category) !== -1;
  }

  function findTargetRendererHelper(chromeHelper) {
    var largestPid = -1;
    for (var pid in chromeHelper.rendererHelpers) {
      var rendererHelper = chromeHelper.rendererHelpers[pid];
      if (rendererHelper.isChromeTracingUI) continue;
      if (pid > largestPid) largestPid = pid;
    }

    if (largestPid === -1) return undefined;

    return chromeHelper.rendererHelpers[largestPid];
  }

  function createBreakdownDiagnostic(rendererHelper, start, end) {
    var breakdownDict = rendererHelper.generateTimeBreakdownTree(start, end);

    var breakdownDiagnostic = new tr.v.d.Breakdown();
    breakdownDiagnostic.colorScheme = tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;

    for (var label in breakdownDict) {
      breakdownDiagnostic.set(label, breakdownDict[label].total);
    }
    return breakdownDiagnostic;
  }

  /**
   * A utility class for finding navigationStart event for given frame and
   * timestamp.
   * @constructor
   */
  function NavigationStartFinder(rendererHelper) {
    this.navigationStartsForFrameId_ = {};
    for (var ev of rendererHelper.mainThread.sliceGroup.childEvents()) {
      if (!hasCategoryAndName(ev, 'blink.user_timing', 'navigationStart')) continue;
      var frameIdRef = ev.args['frame'];
      var list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) this.navigationStartsForFrameId_[frameIdRef] = list = [];
      list.unshift(ev);
    }
  }

  NavigationStartFinder.prototype = {
    findNavigationStartEventForFrameBeforeTimestamp: function (frameIdRef, ts) {
      var list = this.navigationStartsForFrameId_[frameIdRef];
      if (list === undefined) {
        console.warn('No navigationStartEvent found for frame id "' + frameIdRef + '"');
        return undefined;
      }
      var eventBeforeTimestamp;
      for (var ev of list) {
        if (ev.start > ts) continue;
        if (eventBeforeTimestamp === undefined) eventBeforeTimestamp = ev;
      }
      if (eventBeforeTimestamp === undefined) {
        console.warn('Failed to find navigationStartEvent.');
        return undefined;
      }
      return eventBeforeTimestamp;
    }
  };

  var FIRST_PAINT_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(0, 1e3, 20) // 50ms step to 1s
  .addLinearBins(3e3, 20) // 100ms step to 3s
  .addExponentialBins(20e3, 20);

  function createHistogram(name) {
    var histogram = new tr.v.Histogram(name, timeDurationInMs_smallerIsBetter, FIRST_PAINT_BOUNDARIES);
    histogram.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: true,
      std: true,
      sum: false,
      percentile: [0.90, 0.95, 0.99]
    });
    return histogram;
  }

  function findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ts) {
    var snapshot;

    var objects = rendererHelper.process.objects;
    var frameLoaderInstances = objects.instancesByTypeName_['FrameLoader'];
    if (frameLoaderInstances === undefined) {
      console.warn('Failed to find FrameLoader for frameId "' + frameIdRef + '" at ts ' + ts + ', the trace maybe incomplete or from an old' + 'Chrome.');
      return undefined;
    }

    var snapshot;
    for (var instance of frameLoaderInstances) {
      if (!instance.isAliveAt(ts)) continue;
      var maybeSnapshot = instance.getSnapshotAt(ts);
      if (frameIdRef !== maybeSnapshot.args['frame']['id_ref']) continue;
      snapshot = maybeSnapshot;
    }

    return snapshot;
  }

  function findAllUserTimingEvents(rendererHelper, title) {
    var targetEvents = [];

    for (var ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, 'blink.user_timing', title)) continue;
      targetEvents.push(ev);
    }

    return targetEvents;
  }

  function findFirstMeaningfulPaintCandidates(rendererHelper) {
    var isTelemetryInternalEvent = prepareTelemetryInternalEventPredicate(rendererHelper);
    var candidatesForFrameId = {};
    for (var ev of rendererHelper.process.getDescendantEvents()) {
      if (!hasCategoryAndName(ev, 'loading', 'firstMeaningfulPaintCandidate')) continue;
      if (isTelemetryInternalEvent(ev)) continue;
      var frameIdRef = ev.args['frame'];
      if (frameIdRef === undefined) continue;
      var list = candidatesForFrameId[frameIdRef];
      if (list === undefined) candidatesForFrameId[frameIdRef] = list = [];
      list.push(ev);
    }
    return candidatesForFrameId;
  }

  function prepareTelemetryInternalEventPredicate(rendererHelper) {
    var ignoreRegions = [];

    var internalRegionStart;
    for (var slice of rendererHelper.mainThread.asyncSliceGroup.getDescendantEvents()) {
      if (!!slice.title.match(/^telemetry\.internal\.[^.]*\.start$/)) internalRegionStart = slice.start;
      if (!!slice.title.match(/^telemetry\.internal\.[^.]*\.end$/)) {
        var timedEvent = new tr.model.TimedEvent(internalRegionStart);
        timedEvent.duration = slice.end - internalRegionStart;
        ignoreRegions.push(timedEvent);
      }
    }

    return function isTelemetryInternalEvent(slice) {
      for (var region of ignoreRegions) if (region.bounds(slice)) return true;
      return false;
    };
  }

  var URL_BLACKLIST = ['about:blank',
  // Chrome on Android creates main frames with the below URL for plugins.
  'data:text/html,pluginplaceholderdata'];
  function shouldIgnoreURL(url) {
    return URL_BLACKLIST.indexOf(url) >= 0;
  }

  var METRICS = [{
    valueName: 'timeToFirstContentfulPaint',
    title: 'firstContentfulPaint',
    description: 'time to first contentful paint'
  }, {
    valueName: 'timeToOnload',
    title: 'loadEventStart',
    description: 'time to onload. ' + 'This is temporary metric used for PCv1/v2 sanity checking'
  }];

  function timeToFirstContentfulPaintMetric(values, model) {
    var chromeHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
    var rendererHelper = findTargetRendererHelper(chromeHelper);
    var isTelemetryInternalEvent = prepareTelemetryInternalEventPredicate(rendererHelper);
    var navigationStartFinder = new NavigationStartFinder(rendererHelper);

    for (var metric of METRICS) {
      var histogram = createHistogram(metric.valueName);
      histogram.description = metric.description;
      var targetEvents = findAllUserTimingEvents(rendererHelper, metric.title);
      for (var ev of targetEvents) {
        if (isTelemetryInternalEvent(ev)) continue;
        var frameIdRef = ev.args['frame'];
        var snapshot = findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, ev.start);
        if (snapshot === undefined || !snapshot.args.isLoadingMainFrame) continue;
        var url = snapshot.args.documentLoaderURL;
        if (shouldIgnoreURL(url)) continue;
        var navigationStartEvent = navigationStartFinder.findNavigationStartEventForFrameBeforeTimestamp(frameIdRef, ev.start);
        // Ignore layout w/o preceding navigationStart, as they are not
        // attributed to any time-to-X metric.
        if (navigationStartEvent === undefined) continue;

        var timeToEvent = ev.start - navigationStartEvent.start;
        histogram.addSample(timeToEvent, { url: new tr.v.d.Generic(url) });
      }
      values.addHistogram(histogram);
    }
  }

  function addTimeToInteractiveSampleToHistogram(histogram, rendererHelper, navigationStart, firstMeaningfulPaint, url) {
    if (shouldIgnoreURL(url)) return;
    var navigationStartTime = navigationStart.start;
    var firstInteractive = Infinity;
    var firstInteractiveCandidate = firstMeaningfulPaint;
    var lastLongTaskEvent = undefined;
    // Find the first interactive point X after firstMeaningfulPaint so that
    // range [X, X + INTERACTIVE_WINDOW_SIZE] contains no
    // 'TaskQueueManager::ProcessTaskFromWorkQueues' slice which takes more than
    // RESPONSIVENESS_THRESHOLD.
    // For more details on why TaskQueueManager::ProcessTaskFromWorkQueue is
    // chosen as a proxy for all un-interruptable task on renderer thread, see
    // https://github.com/GoogleChrome/lighthouse/issues/489
    // TODO(nedn): replace this with just "var ev of rendererHelper..." once
    // canary binary is updated.
    // (https://github.com/catapult-project/catapult/issues/2586)
    for (var ev of [...rendererHelper.mainThread.sliceGroup.childEvents()]) {
      if (ev.start < firstInteractiveCandidate) continue;
      var interactiveDurationSoFar = ev.start - firstInteractiveCandidate;
      if (interactiveDurationSoFar >= INTERACTIVE_WINDOW_SIZE) {
        firstInteractive = firstInteractiveCandidate;
        break;
      }
      if (ev.title === 'TaskQueueManager::ProcessTaskFromWorkQueue' && ev.duration > RESPONSIVENESS_THRESHOLD) {
        firstInteractiveCandidate = ev.end - 50;
        lastLongTaskEvent = ev;
      }
    }
    var breakdownDiagnostic = createBreakdownDiagnostic(rendererHelper, navigationStartTime, firstInteractive);

    var timeToFirstInteractive = firstInteractive - navigationStartTime;
    histogram.addSample(timeToFirstInteractive, {
      "Start": new RelatedEventSet(navigationStart),
      "Last long task": new RelatedEventSet(lastLongTaskEvent),
      "Navigation infos": new tr.v.d.Generic({ url: url, pid: rendererHelper.pid,
        start: navigationStartTime, interactive: firstInteractive }),
      "Breakdown of [navStart, Interactive]": breakdownDiagnostic
    });
  }

  /**
   * Computes Time to first meaningful paint (TTFMP) & time to interactive (TTI)
   * from |model| and add it to |value|.
   *
   * First meaningful paint is the paint following the layout with the highest
   * "Layout Significance". The Layout Significance is computed inside Blink,
   * by FirstMeaningfulPaintDetector class. It logs
   * "firstMeaningfulPaintCandidate" event every time the Layout Significance
   * marks a record. TTFMP is the time between NavigationStart and the last
   * firstMeaningfulPaintCandidate event.
   *
   * Design doc: https://goo.gl/vpaxv6
   *
   * TTI is computed as the starting time of the timed window with size
   * INTERACTIVE_WINDOW_SIZE that happens after FMP in which there is no
   * uninterruptable task on the main thread with size more than
   * RESPONSIVENESS_THRESHOLD.
   *
   * Design doc: https://goo.gl/ISWndc
   */
  function timeToFirstMeaningfulPaintAndTimeToInteractiveMetrics(values, model) {
    var chromeHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
    var rendererHelper = findTargetRendererHelper(chromeHelper);
    var navigationStartFinder = new NavigationStartFinder(rendererHelper);
    var firstMeaningfulPaintHistogram = createHistogram('timeToFirstMeaningfulPaint');
    firstMeaningfulPaintHistogram.description = 'time to first meaningful paint';
    var firstInteractiveHistogram = createHistogram('timeToFirstInteractive');
    firstInteractiveHistogram.description = 'time to first interactive';

    function addFirstMeaningfulPaintSampleToHistogram(frameIdRef, navigationStart, fmpMarkerEvent) {
      var snapshot = findFrameLoaderSnapshotAt(rendererHelper, frameIdRef, fmpMarkerEvent.start);
      if (snapshot === undefined || !snapshot.args.isLoadingMainFrame) return;
      var url = snapshot.args.documentLoaderURL;
      if (shouldIgnoreURL(url)) return;

      var timeToFirstMeaningfulPaint = fmpMarkerEvent.start - navigationStart.start;
      var extraDiagnostic = {
        url: url,
        pid: rendererHelper.pid
      };
      var breakdownDiagnostic = createBreakdownDiagnostic(rendererHelper, navigationStart.start, fmpMarkerEvent.start);
      firstMeaningfulPaintHistogram.addSample(timeToFirstMeaningfulPaint, {
        "Breakdown of [navStart, FMP]": breakdownDiagnostic,
        "Start": new RelatedEventSet(navigationStart),
        "End": new RelatedEventSet(fmpMarkerEvent),
        "Navigation infos": new tr.v.d.Generic({ url: url, pid: rendererHelper.pid,
          start: navigationStart.start, fmp: fmpMarkerEvent.start })
      });
      return { firstMeaningfulPaint: fmpMarkerEvent.start, url: url };
    }

    var candidatesForFrameId = findFirstMeaningfulPaintCandidates(rendererHelper);

    for (var frameIdRef in candidatesForFrameId) {
      var navigationStart;
      var lastCandidate;

      // Iterate over the FMP candidates, remembering the last one.
      for (var ev of candidatesForFrameId[frameIdRef]) {
        var navigationStartForThisCandidate = navigationStartFinder.findNavigationStartEventForFrameBeforeTimestamp(frameIdRef, ev.start);
        // Ignore candidate w/o preceding navigationStart, as they are not
        // attributed to any TTFMP.
        if (navigationStartForThisCandidate === undefined) continue;

        if (navigationStart !== navigationStartForThisCandidate) {
          // New navigation is found. Compute TTFMP for current navigation, and
          // reset the state variables.
          if (navigationStart !== undefined && lastCandidate !== undefined) {
            data = addFirstMeaningfulPaintSampleToHistogram(frameIdRef, navigationStart, lastCandidate);
            if (data !== undefined) addTimeToInteractiveSampleToHistogram(firstInteractiveHistogram, rendererHelper, navigationStart, data.firstMeaningfulPaint, data.url);
          }
          navigationStart = navigationStartForThisCandidate;
        }
        lastCandidate = ev;
      }

      // Emit TTFMP for the last navigation.
      if (lastCandidate !== undefined) {
        var data = addFirstMeaningfulPaintSampleToHistogram(frameIdRef, navigationStart, lastCandidate);

        if (data !== undefined) addTimeToInteractiveSampleToHistogram(firstInteractiveHistogram, rendererHelper, navigationStart, data.firstMeaningfulPaint, data.url);
      }
    }

    values.addHistogram(firstMeaningfulPaintHistogram);
    values.addHistogram(firstInteractiveHistogram);
  }

  function loadingMetric(values, model) {
    timeToFirstContentfulPaintMetric(values, model);
    timeToFirstMeaningfulPaintAndTimeToInteractiveMetrics(values, model);
  }

  tr.metrics.MetricRegistry.register(loadingMetric);

  return {
    loadingMetric: loadingMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/category_util.js":30,"../../base/statistics.js":53,"../../model/helpers/chrome_model_helper.js":127,"../../model/timed_event.js":160,"../../value/histogram.js":189,"../../value/numeric.js":190,"../metric_registry.js":83,"./utils.js":94}],89:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../extras/chrome/chrome_user_friendly_category_driver.js");
require("../metric_registry.js");
require("../../model/helpers/chrome_model_helper.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  var LONG_TASK_MS = 50;

  // Anything longer than this should be so rare that its length beyond this is
  // uninteresting.
  var LONGEST_TASK_MS = 1000;

  /**
   * This helper function calls |cb| for each of the top-level tasks on the
   * given thread in the given range whose duration is longer than LONG_TASK_MS.
   *
   * @param {tr.model.Thread} thread
   * @param {tr.b.Range=} opt_range
   * @param {function()} cb
   * @param {Object=} opt_this
   */
  function iterateLongTopLevelTasksOnThreadInRange(thread, opt_range, cb, opt_this) {
    thread.sliceGroup.topLevelSlices.forEach(function (slice) {
      if (opt_range && !opt_range.intersectsExplicitRangeInclusive(slice.start, slice.end)) return;

      if (slice.duration < LONG_TASK_MS) return;

      cb.call(opt_this, slice);
    });
  }

  /**
   * This helper function calls |cb| for each of the main renderer threads in
   * the model.
   *
   * @param {tr.model.Model} model The model.
   * @param {function()} cb Callback.
   * @param {Object=} opt_this Context object.
   */
  function iterateRendererMainThreads(model, cb, opt_this) {
    var modelHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
    tr.b.dictionaryValues(modelHelper.rendererHelpers).forEach(function (rendererHelper) {
      if (!rendererHelper.mainThread) return;
      cb.call(opt_this, rendererHelper.mainThread);
    });
  }

  /**
   * This metric directly measures long tasks on renderer main threads.
   * This metric requires only the 'toplevel' tracing category.
   *
   * @param {!tr.v.ValueSet} values
   * @param {!tr.model.Model} model
   * @param {!Object=} opt_options
   */
  function longTasksMetric(values, model, opt_options) {
    var rangeOfInterest = opt_options ? opt_options.rangeOfInterest : undefined;
    var longTaskHist = new tr.v.Histogram('long tasks', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, tr.v.HistogramBinBoundaries.createLinear(LONG_TASK_MS, LONGEST_TASK_MS, 40));
    longTaskHist.description = 'durations of long tasks';
    var slices = new tr.model.EventSet();
    iterateRendererMainThreads(model, function (thread) {
      iterateLongTopLevelTasksOnThreadInRange(thread, rangeOfInterest, function (task) {
        longTaskHist.addSample(task.duration, { relatedEvents: new tr.v.d.RelatedEventSet([task]) });
        slices.push(task);
        slices.addEventSet(task.descendentSlices);
      });
    });
    values.addHistogram(longTaskHist);

    var sampleForEvent = undefined;
    var breakdown = tr.v.d.RelatedHistogramBreakdown.buildFromEvents(values, 'long tasks ', slices, e => model.getUserFriendlyCategoryFromEvent(e) || 'unknown', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, sampleForEvent, tr.v.HistogramBinBoundaries.createExponential(1, LONGEST_TASK_MS, 40));
    breakdown.colorScheme = tr.v.d.COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER;
    longTaskHist.diagnostics.set('category', breakdown);
  }

  tr.metrics.MetricRegistry.register(longTasksMetric, {
    supportsRangeOfInterest: true
  });

  return {
    longTasksMetric: longTasksMetric,
    iterateLongTopLevelTasksOnThreadInRange: iterateLongTopLevelTasksOnThreadInRange,
    iterateRendererMainThreads: iterateRendererMainThreads,
    LONG_TASK_MS: LONG_TASK_MS,
    LONGEST_TASK_MS: LONGEST_TASK_MS
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../extras/chrome/chrome_user_friendly_category_driver.js":63,"../../model/helpers/chrome_model_helper.js":127,"../../value/histogram.js":189,"../metric_registry.js":83}],90:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/iteration_helpers.js");
require("../../base/multi_dimensional_view.js");
require("../../base/range.js");
require("../../base/unit.js");
require("../metric_registry.js");
require("../../model/container_memory_dump.js");
require("../../model/helpers/chrome_model_helper.js");
require("../../model/memory_allocator_dump.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  var BACKGROUND = tr.model.ContainerMemoryDump.LevelOfDetail.BACKGROUND;
  var LIGHT = tr.model.ContainerMemoryDump.LevelOfDetail.LIGHT;
  var DETAILED = tr.model.ContainerMemoryDump.LevelOfDetail.DETAILED;
  var sizeInBytes_smallerIsBetter = tr.b.Unit.byName.sizeInBytes_smallerIsBetter;
  var count_smallerIsBetter = tr.b.Unit.byName.count_smallerIsBetter;
  var DISPLAYED_SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME;

  var LEVEL_OF_DETAIL_NAMES = new Map();
  LEVEL_OF_DETAIL_NAMES.set(BACKGROUND, 'background');
  LEVEL_OF_DETAIL_NAMES.set(LIGHT, 'light');
  LEVEL_OF_DETAIL_NAMES.set(DETAILED, 'detailed');

  var BOUNDARIES_FOR_UNIT_MAP = new WeakMap();
  // For unitless numerics (process counts), we use 20 linearly scaled bins
  // from 0 to 20.
  BOUNDARIES_FOR_UNIT_MAP.set(count_smallerIsBetter, tr.v.HistogramBinBoundaries.createLinear(0, 20, 20));
  // For size numerics (subsystem and vm stats), we use 1 bin from 0 B to
  // 1 KiB and 4*24 exponentially scaled bins from 1 KiB to 16 GiB (=2^24 KiB).
  BOUNDARIES_FOR_UNIT_MAP.set(sizeInBytes_smallerIsBetter, new tr.v.HistogramBinBoundaries(0).addBinBoundary(1024 /* 1 KiB */).addExponentialBins(16 * 1024 * 1024 * 1024 /* 16 GiB */, 4 * 24));

  function memoryMetric(values, model, opt_options) {
    var rangeOfInterest = opt_options ? opt_options.rangeOfInterest : undefined;
    var browserNameToGlobalDumps = splitGlobalDumpsByBrowserName(model, rangeOfInterest);
    addGeneralMemoryDumpValues(browserNameToGlobalDumps, values);
    addDetailedMemoryDumpValues(browserNameToGlobalDumps, values);
    addMemoryDumpCountValues(browserNameToGlobalDumps, values);
  }

  /**
   * Splits the global memory dumps in |model| by browser name.
   *
   * @param {!tr.Model} model The trace model from which the global dumps
   *     should be extracted.
   * @param {!tr.b.Range=} opt_rangeOfInterest If proided, global memory dumps
   *     that do not inclusively intersect the range will be skipped.
   * @return {!Map<string, !Array<!tr.model.GlobalMemoryDump>} A map from
   *     browser names to the associated global memory dumps.
   */
  function splitGlobalDumpsByBrowserName(model, opt_rangeOfInterest) {
    var chromeModelHelper = model.getOrCreateHelper(tr.model.helpers.ChromeModelHelper);
    var browserNameToGlobalDumps = new Map();
    var globalDumpToBrowserHelper = new WeakMap();

    // 1. For each browser process in the model, add its global memory dumps to
    // |browserNameToGlobalDumps|. |chromeModelHelper| can be undefined if
    // it fails to find any browser, renderer or GPU process (see
    // tr.model.helpers.ChromeModelHelper.supportsModel).
    if (chromeModelHelper) {
      chromeModelHelper.browserHelpers.forEach(function (helper) {
        // Retrieve the associated global memory dumps and check that they
        // haven't been classified as belonging to another browser process.
        var globalDumps = skipDumpsThatDoNotIntersectRange(helper.process.memoryDumps.map(d => d.globalMemoryDump), opt_rangeOfInterest);
        globalDumps.forEach(function (globalDump) {
          var existingHelper = globalDumpToBrowserHelper.get(globalDump);
          if (existingHelper !== undefined) {
            throw new Error('Memory dump ID clash across multiple browsers ' + 'with PIDs: ' + existingHelper.pid + ' and ' + helper.pid);
          }
          globalDumpToBrowserHelper.set(globalDump, helper);
        });

        makeKeyUniqueAndSet(browserNameToGlobalDumps, canonicalizeName(helper.browserName), globalDumps);
      });
    }

    // 2. If any global memory dump does not have any associated browser
    // process for some reason, associate it with an 'unknown_browser' browser
    // so that we don't lose the data.
    var unclassifiedGlobalDumps = skipDumpsThatDoNotIntersectRange(model.globalMemoryDumps.filter(g => !globalDumpToBrowserHelper.has(g)), opt_rangeOfInterest);
    if (unclassifiedGlobalDumps.length > 0) {
      makeKeyUniqueAndSet(browserNameToGlobalDumps, 'unknown_browser', unclassifiedGlobalDumps);
    }

    return browserNameToGlobalDumps;
  }

  function skipDumpsThatDoNotIntersectRange(dumps, opt_range) {
    if (!opt_range) return dumps;
    return dumps.filter(d => opt_range.intersectsExplicitRangeInclusive(d.start, d.end));
  }

  function canonicalizeName(name) {
    return name.toLowerCase().replace(' ', '_');
  }

  var USER_FRIENDLY_BROWSER_NAMES = {
    'chrome': 'Chrome',
    'webview': 'WebView',
    'unknown_browser': 'an unknown browser'
  };

  /**
   * Convert a canonical browser name used in value names to a user-friendly
   * name used in value descriptions.
   *
   * Examples:
   *
   *   CANONICAL BROWSER NAME -> USER-FRIENDLY NAME
   *   chrome                 -> Chrome
   *   unknown_browser        -> an unknown browser
   *   webview2               -> WebView(2)
   *   unexpected             -> 'unexpected' browser
   */
  function convertBrowserNameToUserFriendlyName(browserName) {
    for (var baseName in USER_FRIENDLY_BROWSER_NAMES) {
      if (!browserName.startsWith(baseName)) continue;
      var userFriendlyBaseName = USER_FRIENDLY_BROWSER_NAMES[baseName];
      var suffix = browserName.substring(baseName.length);
      if (suffix.length === 0) return userFriendlyBaseName;else if (/^\d+$/.test(suffix)) return userFriendlyBaseName + '(' + suffix + ')';
    }
    return '\'' + browserName + '\' browser';
  }

  function canonicalizeProcessName(rawProcessName) {
    if (!rawProcessName) return 'unknown_processes';
    var baseCanonicalName = canonicalizeName(rawProcessName);
    switch (baseCanonicalName) {
      case 'renderer':
        return 'renderer_processes'; // Intentionally plural.
      case 'browser':
        return 'browser_process';
      default:
        return baseCanonicalName;
    }
  }

  /**
   * Convert a canonical process name used in value names to a user-friendly
   * name used in value descriptions.
   */
  function convertProcessNameToUserFriendlyName(processName, opt_requirePlural) {
    switch (processName) {
      case 'browser_process':
        return opt_requirePlural ? 'browser processes' : 'the browser process';
      case 'renderer_processes':
        return 'renderer processes';
      case 'gpu_process':
        return opt_requirePlural ? 'GPU processes' : 'the GPU process';
      case 'ppapi_process':
        return opt_requirePlural ? 'PPAPI processes' : 'the PPAPI process';
      case 'all_processes':
        return 'all processes';
      case 'unknown_processes':
        return 'unknown processes';
      default:
        return '\'' + processName + '\' processes';
    }
  }

  /**
   * Function for adding entries with duplicate keys to a map without
   * overriding existing entries.
   *
   * This is achieved by appending numeric indices (2, 3, 4, ...) to duplicate
   * keys. Example:
   *
   *   var map = new Map();
   *   // map = Map {}.
   *
   *   makeKeyUniqueAndSet(map, 'key', 'a');
   *   // map = Map {"key" => "a"}.
   *
   *   makeKeyUniqueAndSet(map, 'key', 'b');
   *   // map = Map {"key" => "a", "key2" => "b"}.
   *                                ^^^^
   *   makeKeyUniqueAndSet(map, 'key', 'c');
   *   // map = Map {"key" => "a", "key2" => "b", "key3" => "c"}.
   *                                ^^^^           ^^^^
   */
  function makeKeyUniqueAndSet(map, key, value) {
    var uniqueKey = key;
    var nextIndex = 2;
    while (map.has(uniqueKey)) {
      uniqueKey = key + nextIndex;
      nextIndex++;
    }
    map.set(uniqueKey, value);
  }

  /**
   * Add general memory dump values calculated from all global memory dumps to
   * |values|. In particular, this function adds the following values:
   *
   *   * PROCESS COUNTS
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         process_count
   *     type: tr.v.Histogram (over all matching global memory dumps)
   *     unit: count_smallerIsBetter
   *
   *   * MEMORY USAGE REPORTED BY CHROME
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_chrome[:{v8, malloc, ...}]:
   *         {effective_size, allocated_objects_size, locked_size}
   *     type: tr.v.Histogram (over all matching global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   */
  function addGeneralMemoryDumpValues(browserNameToGlobalDumps, values) {
    addMemoryDumpValues(browserNameToGlobalDumps, gmd => true /* process all global memory dumps */
    , function (processDump, addProcessScalar) {
      // Increment memory:<browser-name>:<process-name>:process_count value.
      addProcessScalar({
        source: 'process_count',
        value: 1,
        unit: count_smallerIsBetter,
        descriptionPrefixBuilder: buildProcessCountDescriptionPrefix
      });

      if (processDump.totals !== undefined) {
        tr.b.iterItems(SYSTEM_TOTAL_VALUE_PROPERTIES, function (propertyName, propertySpec) {
          addProcessScalar({
            source: 'reported_by_os',
            property: propertyName,
            component: ['system_memory'],
            value: propertySpec.getPropertyFunction(processDump),
            unit: sizeInBytes_smallerIsBetter,
            descriptionPrefixBuilder: propertySpec.descriptionPrefixBuilder
          });
        });
      }

      // Add memory:<browser-name>:<process-name>:reported_by_chrome:...
      // values.
      if (processDump.memoryAllocatorDumps === undefined) return;
      processDump.memoryAllocatorDumps.forEach(function (rootAllocatorDump) {
        tr.b.iterItems(CHROME_VALUE_PROPERTIES, function (propertyName, descriptionPrefixBuilder) {
          addProcessScalar({
            source: 'reported_by_chrome',
            component: [rootAllocatorDump.name],
            property: propertyName,
            value: rootAllocatorDump.numerics[propertyName],
            descriptionPrefixBuilder: descriptionPrefixBuilder
          });
        });
        // Some dump providers add allocated objects size as
        // "allocated_objects" child dump.
        if (rootAllocatorDump.numerics['allocated_objects_size'] === undefined) {
          var allocatedObjectsDump = rootAllocatorDump.getDescendantDumpByFullName('allocated_objects');
          if (allocatedObjectsDump !== undefined) {
            addProcessScalar({
              source: 'reported_by_chrome',
              component: [rootAllocatorDump.name],
              property: 'allocated_objects_size',
              value: allocatedObjectsDump.numerics['size'],
              descriptionPrefixBuilder: CHROME_VALUE_PROPERTIES['allocated_objects_size']
            });
          }
        }
      });

      // Add memory:<browser-name>:<process-name>:reported_by_chrome:v8:
      //     {heap, allocated_by_malloc}:...
      addV8MemoryDumpValues(processDump, addProcessScalar);
    }, function (componentTree) {
      // Subtract memory:<browser-name>:<process-name>:reported_by_chrome:
      // tracing:<size-property> from memory:<browser-name>:<process-name>:
      // reported_by_chrome:<size-property> if applicable.
      var tracingNode = componentTree.children[1].get('tracing');
      if (tracingNode === undefined) return;
      for (var i = 0; i < componentTree.values.length; i++) componentTree.values[i].total -= tracingNode.values[i].total;
    }, values);
  }

  /**
   * Add memory dump values calculated from V8 components excluding
   * 'heap_spaces/other_spaces'.
   *
   * @param {!tr.model.ProcessMemoryDump} processDump The process memory dump.
   * @param {!function} addProcessScalar The callback for adding a scalar value.
   */
  function addV8MemoryDumpValues(processDump, addProcessScalar) {
    var v8Dump = processDump.getMemoryAllocatorDumpByFullName('v8');
    if (v8Dump === undefined) return;
    v8Dump.children.forEach(function (isolateDump) {
      // v8:allocated_by_malloc:...
      var mallocDump = isolateDump.getDescendantDumpByFullName('malloc');
      if (mallocDump !== undefined) {
        addV8ComponentValues(mallocDump, ['v8', 'allocated_by_malloc'], addProcessScalar);
      }
      // v8:heap:...
      var heapDump = isolateDump.getDescendantDumpByFullName('heap_spaces');
      if (heapDump !== undefined) {
        addV8ComponentValues(heapDump, ['v8', 'heap'], addProcessScalar);
        heapDump.children.forEach(function (spaceDump) {
          if (spaceDump.name === 'other_spaces') return;
          addV8ComponentValues(spaceDump, ['v8', 'heap', spaceDump.name], addProcessScalar);
        });
      }
    });

    // V8 generates bytecode when interpreting and code objects when
    // compiling the javascript. Total code size includes the size
    // of code and bytecode objects.
    addProcessScalar({
      source: 'reported_by_chrome',
      component: ['v8'],
      property: 'code_and_metadata_size',
      value: v8Dump.numerics['code_and_metadata_size'],
      descriptionPrefixBuilder: buildCodeAndMetadataSizeValueDescriptionPrefix
    });
    addProcessScalar({
      source: 'reported_by_chrome',
      component: ['v8'],
      property: 'code_and_metadata_size',
      value: v8Dump.numerics['bytecode_and_metadata_size'],
      descriptionPrefixBuilder: buildCodeAndMetadataSizeValueDescriptionPrefix
    });
  }

  /**
   * Add memory dump values calculated from the specified V8 component.
   *
   * @param {!tr.model.MemoryAllocatorDump} v8Dump The V8 memory dump.
   * @param {!Array<string>} componentPath The component path for reporting.
   * @param {!function} addProcessScalar The callback for adding a scalar value.
   */
  function addV8ComponentValues(componentDump, componentPath, addProcessScalar) {
    tr.b.iterItems(CHROME_VALUE_PROPERTIES, function (propertyName, descriptionPrefixBuilder) {
      addProcessScalar({
        source: 'reported_by_chrome',
        component: componentPath,
        property: propertyName,
        value: componentDump.numerics[propertyName],
        descriptionPrefixBuilder: descriptionPrefixBuilder
      });
    });
  }

  /**
   * Build a description prefix for a memory:<browser-name>:<process-name>:
   * process_count value.
   *
   * @param {!Array<string>} componentPath The underlying component path (must
   *     be empty).
   * @param {string} processName The canonical name of the process.
   * @return {string} Prefix for the value's description (always
   *     'total number of renderer processes').
   */
  function buildProcessCountDescriptionPrefix(componentPath, processName) {
    if (componentPath.length > 0) {
      throw new Error('Unexpected process count non-empty component path: ' + componentPath.join(':'));
    }
    return 'total number of ' + convertProcessNameToUserFriendlyName(processName, true /* opt_requirePlural */);
  }

  /**
   * Build a description prefix for a memory:<browser-name>:<process-name>:
   * reported_by_chrome:... value.
   *
   * @param {{
   *     userFriendlyPropertyName: string,
   *     userFriendlyPropertyNamePrefix: (string|undefined),
   *     totalUserFriendlyPropertyName: (string|undefined),
   *     componentPreposition: (string|undefined) }}
   *     formatSpec Specification of how the property should be formatted.
   * @param {!Array<string>} componentPath The underlying component path (e.g.
   *     ['malloc']).
   * @param {string} processName The canonical name of the process.
   * @return {string} Prefix for the value's description (e.g.
   *     'effective size of malloc in the browser process').
   */
  function buildChromeValueDescriptionPrefix(formatSpec, componentPath, processName) {
    var nameParts = [];
    if (componentPath.length === 0) {
      nameParts.push('total');
      if (formatSpec.totalUserFriendlyPropertyName) {
        nameParts.push(formatSpec.totalUserFriendlyPropertyName);
      } else {
        if (formatSpec.userFriendlyPropertyNamePrefix) nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        nameParts.push(formatSpec.userFriendlyPropertyName);
      }
      nameParts.push('reported by Chrome for');
    } else {
      if (formatSpec.componentPreposition === undefined) {
        // Use component name as an adjective
        // (e.g. 'size of V8 code and metadata').
        if (formatSpec.userFriendlyPropertyNamePrefix) nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        nameParts.push(componentPath.join(':'));
        nameParts.push(formatSpec.userFriendlyPropertyName);
      } else {
        // Use component name as a noun with a preposition
        // (e.g. 'size of all objects allocated BY MALLOC').
        if (formatSpec.userFriendlyPropertyNamePrefix) nameParts.push(formatSpec.userFriendlyPropertyNamePrefix);
        nameParts.push(formatSpec.userFriendlyPropertyName);
        nameParts.push(formatSpec.componentPreposition);
        if (componentPath[componentPath.length - 1] === 'allocated_by_malloc') {
          nameParts.push('objects allocated by malloc for');
          nameParts.push(componentPath.slice(0, componentPath.length - 1).join(':'));
        } else {
          nameParts.push(componentPath.join(':'));
        }
      }
      nameParts.push('in');
    }
    nameParts.push(convertProcessNameToUserFriendlyName(processName));
    return nameParts.join(' ');
  }

  // Specifications of properties reported by Chrome.
  var CHROME_VALUE_PROPERTIES = {
    'effective_size': buildChromeValueDescriptionPrefix.bind(undefined, {
      userFriendlyPropertyName: 'effective size',
      componentPreposition: 'of'
    }),
    'allocated_objects_size': buildChromeValueDescriptionPrefix.bind(undefined, {
      userFriendlyPropertyName: 'size of all objects allocated',
      totalUserFriendlyPropertyName: 'size of all allocated objects',
      componentPreposition: 'by'
    }),
    'locked_size': buildChromeValueDescriptionPrefix.bind(undefined, {
      userFriendlyPropertyName: 'locked (pinned) size',
      componentPreposition: 'of'
    }),
    'peak_size': buildChromeValueDescriptionPrefix.bind(undefined, {
      userFriendlyPropertyName: 'peak size',
      componentPreposition: 'of'
    })
  };

  var SYSTEM_TOTAL_VALUE_PROPERTIES = {
    'resident_size': {
      getPropertyFunction: function (processDump) {
        return processDump.totals.residentBytes;
      },
      descriptionPrefixBuilder: buildOsValueDescriptionPrefix.bind(undefined, 'resident set size (RSS)')
    },
    'peak_resident_size': {
      getPropertyFunction: function (processDump) {
        return processDump.totals.peakResidentBytes;
      },
      descriptionPrefixBuilder: buildOsValueDescriptionPrefix.bind(undefined, 'peak resident set size')
    }
  };

  /**
   * Add heavy memory dump values calculated from heavy global memory dumps to
   * |values|. In particular, this function adds the following values:
   *
   *   * MEMORY USAGE REPORTED BY THE OS
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_os:system_memory:[{ashmem, native_heap, java_heap}:]
   *         {proportional_resident_size, private_dirty_size}
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_os:gpu_memory:[{gl, graphics, ...}:]
   *         proportional_resident_size
   *     type: tr.v.Histogram (over matching heavy global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   *
   *   * MEMORY USAGE REPORTED BY CHROME
   *     memory:{chrome, webview}:
   *         {browser_process, renderer_processes, ..., all_processes}:
   *         reported_by_chrome:v8:code_and_metadata_size
   *     type: tr.v.Histogram (over matching heavy global memory dumps)
   *     unit: sizeInBytes_smallerIsBetter
   */
  function addDetailedMemoryDumpValues(browserNameToGlobalDumps, values) {
    addMemoryDumpValues(browserNameToGlobalDumps, g => g.levelOfDetail === DETAILED, function (processDump, addProcessScalar) {
      // Add memory:<browser-name>:<process-name>:reported_by_os:
      // system_memory:... values.
      tr.b.iterItems(SYSTEM_VALUE_COMPONENTS, function (componentName, componentSpec) {
        tr.b.iterItems(SYSTEM_VALUE_PROPERTIES, function (propertyName, propertySpec) {
          var node = getDescendantVmRegionClassificationNode(processDump.vmRegions, componentSpec.classificationPath);
          var componentPath = ['system_memory'];
          if (componentName) componentPath.push(componentName);
          addProcessScalar({
            source: 'reported_by_os',
            component: componentPath,
            property: propertyName,
            value: node === undefined ? 0 : node.byteStats[propertySpec.byteStat] || 0,
            unit: sizeInBytes_smallerIsBetter,
            descriptionPrefixBuilder: propertySpec.descriptionPrefixBuilder
          });
        });
      });

      // Add memory:<browser-name>:<process-name>:reported_by_os:
      // gpu_memory:... values.
      var memtrackDump = processDump.getMemoryAllocatorDumpByFullName('gpu/android_memtrack');
      if (memtrackDump !== undefined) {
        var descriptionPrefixBuilder = SYSTEM_VALUE_PROPERTIES['proportional_resident_size'].descriptionPrefixBuilder;
        memtrackDump.children.forEach(function (memtrackChildDump) {
          var childName = memtrackChildDump.name;
          addProcessScalar({
            source: 'reported_by_os',
            component: ['gpu_memory', childName],
            property: 'proportional_resident_size',
            value: memtrackChildDump.numerics['memtrack_pss'],
            descriptionPrefixBuilder: descriptionPrefixBuilder
          });
        });
      }
    }, function (componentTree) {}, values);
  }

  // Specifications of components reported by the system.
  var SYSTEM_VALUE_COMPONENTS = {
    '': {
      classificationPath: []
    },
    'java_heap': {
      classificationPath: ['Android', 'Java runtime', 'Spaces'],
      userFriendlyName: 'the Java heap'
    },
    'ashmem': {
      classificationPath: ['Android', 'Ashmem'],
      userFriendlyName: 'ashmem'
    },
    'native_heap': {
      classificationPath: ['Native heap'],
      userFriendlyName: 'the native heap'
    }
  };

  // Specifications of properties reported by the system.
  var SYSTEM_VALUE_PROPERTIES = {
    'proportional_resident_size': {
      byteStat: 'proportionalResident',
      descriptionPrefixBuilder: buildOsValueDescriptionPrefix.bind(undefined, 'proportional resident size (PSS)')
    },
    'private_dirty_size': {
      byteStat: 'privateDirtyResident',
      descriptionPrefixBuilder: buildOsValueDescriptionPrefix.bind(undefined, 'private dirty size')
    }
  };

  /**
   * Build a description prefix for a memory:<browser-name>:<process-name>:
   * reported_by_os:... value.
   *
   * @param {string} userFriendlyPropertyName User-friendly name of the
   *     underlying property (e.g. 'private dirty size').
   * @param {!Array<string>} componentPath The underlying component path (e.g.
   *     ['system', 'java_heap']).
   * @param {string} processName The canonical name of the process.
   * @return {string} Prefix for the value's description (e.g.
   *     'total private dirty size of the Java heal in the GPU process').
   */
  function buildOsValueDescriptionPrefix(userFriendlyPropertyName, componentPath, processName) {
    if (componentPath.length > 2) {
      throw new Error('OS value component path for \'' + userFriendlyPropertyName + '\' too long: ' + componentPath.join(':'));
    }

    var nameParts = [];
    if (componentPath.length < 2) nameParts.push('total');

    nameParts.push(userFriendlyPropertyName);

    if (componentPath.length > 0) {
      switch (componentPath[0]) {
        case 'system_memory':
          if (componentPath.length > 1) {
            var userFriendlyComponentName = SYSTEM_VALUE_COMPONENTS[componentPath[1]].userFriendlyName;
            if (userFriendlyComponentName === undefined) {
              throw new Error('System value sub-component for \'' + userFriendlyPropertyName + '\' unknown: ' + componentPath.join(':'));
            }
            nameParts.push('of', userFriendlyComponentName, 'in');
          } else {
            nameParts.push('of system memory (RAM) used by');
          }
          break;

        case 'gpu_memory':
          if (componentPath.length > 1) {
            nameParts.push('of the', componentPath[1]);
            nameParts.push('Android memtrack component in');
          } else {
            nameParts.push('of GPU memory (Android memtrack) used by');
          }
          break;

        default:
          throw new Error('OS value component for \'' + userFriendlyPropertyName + '\' unknown: ' + componentPath.join(':'));
      }
    } else {
      nameParts.push('reported by the OS for');
    }

    nameParts.push(convertProcessNameToUserFriendlyName(processName));
    return nameParts.join(' ');
  }

  /**
   * Build a description prefix for a memory:<browser-name>:<process-name>:
   * reported_by_chrome:...:code_and_metadata_size value.
   *
   * @param {!Array<string>} componentPath The underlying component path (e.g.
   *     ['v8']).
   * @param {string} processName The canonical name of the process.
   * @return {string} Prefix for the value's description (e.g.
   *     'size of v8 code and metadata in').
   */
  function buildCodeAndMetadataSizeValueDescriptionPrefix(componentPath, processName) {
    return buildChromeValueDescriptionPrefix({
      userFriendlyPropertyNamePrefix: 'size of',
      userFriendlyPropertyName: 'code and metadata'
    }, componentPath, processName);
  }

  /**
   * Get the descendant of a VM region classification |node| specified by the
   * given |path| of child node titles. If |node| is undefined or such a
   * descendant does not exist, this function returns undefined.
   */
  function getDescendantVmRegionClassificationNode(node, path) {
    for (var i = 0; i < path.length; i++) {
      if (node === undefined) break;
      node = tr.b.findFirstInArray(node.children, c => c.title === path[i]);
    }
    return node;
  }

  /**
   * Add global memory dump counts to |values|. In particular, this function
   * adds the following values:
   *
   *   * DUMP COUNTS
   *     memory:{chrome, webview}:all_processes:dump_count[:{light, detailed}]
   *     type: tr.v.Histogram
   *     unit: count_smallerIsBetter
   *
   * Note that unlike all other values generated by the memory metric, the
   * global memory dump counts are NOT instances of tr.v.Histogram
   * because it doesn't make sense to aggregate them (they are already counts
   * over all global dumps associated with the relevant browser).
   */
  function addMemoryDumpCountValues(browserNameToGlobalDumps, values) {
    browserNameToGlobalDumps.forEach(function (globalDumps, browserName) {
      var totalDumpCount = 0;
      var levelOfDetailNameToDumpCount = {};
      LEVEL_OF_DETAIL_NAMES.forEach(function (levelOfDetailName) {
        levelOfDetailNameToDumpCount[levelOfDetailName] = 0;
      });

      globalDumps.forEach(function (globalDump) {
        totalDumpCount++;

        // Increment the level-of-detail-specific dump count (if possible).
        var levelOfDetailName = LEVEL_OF_DETAIL_NAMES.get(globalDump.levelOfDetail);
        if (!(levelOfDetailName in levelOfDetailNameToDumpCount)) return; // Unknown level of detail.
        levelOfDetailNameToDumpCount[levelOfDetailName]++;
      });

      // Add memory:<browser-name>:all_processes:dump_count[:<level>] values.
      reportMemoryDumpCountAsValue(browserName, undefined /* total */
      , totalDumpCount, values);
      tr.b.iterItems(levelOfDetailNameToDumpCount, function (levelOfDetailName, levelOfDetailDumpCount) {
        reportMemoryDumpCountAsValue(browserName, levelOfDetailName, levelOfDetailDumpCount, values);
      });
    });
  }

  /**
   * Add a tr.v.Histogram value to |values| reporting that the number of
   * |levelOfDetailName| memory dumps added by |browserName| was
   * |levelOfDetailCount|.
   */
  function reportMemoryDumpCountAsValue(browserName, levelOfDetailName, levelOfDetailDumpCount, values) {
    // Construct the name of the memory value.
    var nameParts = ['memory', browserName, 'all_processes', 'dump_count'];
    if (levelOfDetailName !== undefined) nameParts.push(levelOfDetailName);
    var name = nameParts.join(':');

    // Build the underlying histogram for the memory value.
    var histogram = new tr.v.Histogram(name, count_smallerIsBetter, BOUNDARIES_FOR_UNIT_MAP.get(count_smallerIsBetter));
    histogram.addSample(levelOfDetailDumpCount);

    // Build the options for the memory value.
    histogram.description = ['total number of', levelOfDetailName || 'all', 'memory dumps added by', convertBrowserNameToUserFriendlyName(browserName), 'to the trace'].join(' ');

    // Report the memory value.
    values.addHistogram(histogram);
  }

  /**
   * Add generic values extracted from process memory dumps and aggregated by
   * process name and component path into |values|.
   *
   * For each browser and set of global dumps in |browserNameToGlobalDumps|,
   * |customProcessDumpValueExtractor| is applied to every process memory dump
   * associated with the global memory dump. The second argument provided to the
   * callback is a function for adding extracted values:
   *
   *   function sampleProcessDumpCallback(processDump, addProcessValue) {
   *     ...
   *     addProcessScalar({
   *       source: 'reported_by_chrome',
   *       component: ['system', 'native_heap'],
   *       property: 'proportional_resident_size',
   *       value: pssExtractedFromProcessDump2,
   *       descriptionPrefixBuilder: function(componentPath) {
   *         return 'PSS of ' + componentPath.join('/') + ' in';
   *       }
   *     });
   *     ...
   *   }
   *
   * For each global memory dump, the extracted values are summed by process
   * name (browser_process, renderer_processes, ..., all_processes) and
   * component path (e.g. gpu is a sum of gpu:gl, gpu:graphics, ...). The sums
   * are then aggregated over all global memory dumps associated with the given
   * browser. For example, assuming that |customProcessDumpValueExtractor|
   * extracts 'proportional_resident_size' values for component paths
   * ['X', 'A'], ['X', 'B'] and ['Y'] under the same 'source' from each process
   * memory dump, the following values will be reported (for Chrome):
   *
   *    memory:chrome:browser_process:source:X:A:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:X:B:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:B in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:B in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:X:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:Y:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of Y in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of Y in all 'browser' process dumps in global dump N
   *        ]
   *
   *    memory:chrome:browser_process:source:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B+Y in all 'browser' process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B+Y in all 'browser' process dumps in global dump N
   *        ]
   *
   *    ...
   *
   *    memory:chrome:all_processes:source:X:A:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A in all process dumps in global dump 1,
   *          ...
   *          sum of X:A in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:X:B:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:B in all process dumps in global dump 1,
   *          ...
   *          sum of X:B in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:X:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B in all process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B in all process dumps in global dump N,
   *    ]
   *
   *    memory:chrome:all_processes:source:Y:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of Y in all process dumps in global dump 1,
   *          ...
   *          sum of Y in all process dumps in global dump N
   *    ]
   *
   *    memory:chrome:all_processes:source:proportional_resident_size :
   *        Histogram aggregated over [
   *          sum of X:A+X:B+Y in all process dumps in global dump 1,
   *          ...
   *          sum of X:A+X:B+Y in all process dumps in global dump N
   *        ]
   *
   * where global dumps 1 to N are the global dumps associated with the given
   * browser.
   *
   * @param {!Map<string, !Array<!tr.model.GlobalMemoryDump>}
   *     browserNameToGlobalDumps Map from browser names to arrays of global
   *     memory dumps. The generic values will be extracted from the associated
   *     process memory dumps.
   * @param {!function(!tr.model.GlobalMemoryDump): boolean}
   *     customGlobalDumpFilter Predicate for filtering global memory dumps.
   * @param {!function(
   *     !tr.model.ProcessMemoryDump,
   *     !function(!{
   *         source: string,
   *         componentPath: (!Array<string>|undefined),
   *         propertyName: (string|undefined),
   *         value: (!tr.v.Histogram|number|undefined),
   *         unit: (!tr.b.Unit|undefined),
   *         descriptionPrefixBuilder: (!function(!Array<string>): string)
   *     }))}
   *     customProcessDumpValueExtractor Callback for extracting values from a
   *     process memory dump.
   * @param {!function(!tr.b.MultiDimensionalViewNode)}
   *     customComponentTreeModifier Callback applied to every component tree
   *     wrt each process name.
   * @param {!tr.v.ValueSet} values List of values to which the
   *     resulting aggregated values are added.
   */
  function addMemoryDumpValues(browserNameToGlobalDumps, customGlobalDumpFilter, customProcessDumpValueExtractor, customComponentTreeModifier, values) {
    browserNameToGlobalDumps.forEach(function (globalDumps, browserName) {
      var filteredGlobalDumps = globalDumps.filter(customGlobalDumpFilter);
      var sourceToPropertyToData = extractDataFromGlobalDumps(filteredGlobalDumps, customProcessDumpValueExtractor);
      reportDataAsValues(sourceToPropertyToData, browserName, customComponentTreeModifier, values);
    });
  }

  /**
   * For each global memory dump in |globalDumps|, calculate per-process-name
   * sums of values extracted by |customProcessDumpValueExtractor| from the
   * associated process memory dumps.
   *
   * This function returns the following nested map structure:
   *
   *  Source name (Map key, e.g. 'reported_by_os')
   *    -> Property name (Map key, e.g. 'proportional_resident_size')
   *      -> {unit, descriptionPrefixBuilder, processAndComponentTreeBuilder}
   *
   *  where |processAndComponentTreeBuilder| is a
   *  tr.b.MultiDimensionalViewBuilder:
   *
   *  Browser name (0th dimension key, e.g. 'webview') x
   *    -> Component path (1st dimension keys, e.g. ['system', 'native_heap'])
   *      -> Sum of value over the processes (number).
   *
   * See addMemoryDumpValues for more details.
   */
  function extractDataFromGlobalDumps(globalDumps, customProcessDumpValueExtractor) {
    var sourceToPropertyToData = new Map();
    var dumpCount = globalDumps.length;
    globalDumps.forEach(function (globalDump, dumpIndex) {
      tr.b.iterItems(globalDump.processMemoryDumps, function (_, processDump) {
        extractDataFromProcessDump(processDump, sourceToPropertyToData, dumpIndex, dumpCount, customProcessDumpValueExtractor);
      });
    });
    return sourceToPropertyToData;
  }

  function extractDataFromProcessDump(processDump, sourceToPropertyToData, dumpIndex, dumpCount, customProcessDumpValueExtractor) {
    // Process name is typically 'browser', 'renderer', etc.
    var rawProcessName = processDump.process.name;
    var processNamePath = [canonicalizeProcessName(rawProcessName)];

    customProcessDumpValueExtractor(processDump, function addProcessScalar(spec) {
      if (spec.value === undefined) return;

      var component = spec.component || [];
      function createDetailsForErrorMessage() {
        var propertyUserFriendlyName = spec.property === undefined ? '(undefined)' : spec.property;
        var componentUserFriendlyName = component.length === 0 ? '(empty)' : component.join(':');
        return ['source=', spec.source, ', property=', propertyUserFriendlyName, ', component=', componentUserFriendlyName, ' in ', processDump.process.userFriendlyName].join('');
      }

      var value, unit;
      if (spec.value instanceof tr.v.ScalarNumeric) {
        value = spec.value.value;
        unit = spec.value.unit;
        if (spec.unit !== undefined) {
          throw new Error('Histogram value for ' + createDetailsForErrorMessage() + ' already specifies a unit');
        }
      } else {
        value = spec.value;
        unit = spec.unit;
      }

      var propertyToData = sourceToPropertyToData.get(spec.source);
      if (propertyToData === undefined) {
        propertyToData = new Map();
        sourceToPropertyToData.set(spec.source, propertyToData);
      }

      var data = propertyToData.get(spec.property);
      if (data === undefined) {
        data = {
          processAndComponentTreeBuilder: new tr.b.MultiDimensionalViewBuilder(2 /* dimensions (process name and component path) */
          , dumpCount /* valueCount */),
          unit: unit,
          descriptionPrefixBuilder: spec.descriptionPrefixBuilder
        };
        propertyToData.set(spec.property, data);
      } else if (data.unit !== unit) {
        throw new Error('Multiple units provided for ' + createDetailsForErrorMessage() + ':' + data.unit.unitName + ' and ' + unit.unitName);
      } else if (data.descriptionPrefixBuilder !== spec.descriptionPrefixBuilder) {
        throw new Error('Multiple description prefix builders provided for' + createDetailsForErrorMessage());
      }

      var values = new Array(dumpCount);
      values[dumpIndex] = value;

      data.processAndComponentTreeBuilder.addPath([processNamePath, component] /* path */, values, tr.b.MultiDimensionalViewBuilder.ValueKind.TOTAL /* valueKind */);
    });
  }

  function reportDataAsValues(sourceToPropertyToData, browserName, customComponentTreeModifier, values) {
    // For each source name (e.g. 'reported_by_os')...
    sourceToPropertyToData.forEach(function (propertyToData, sourceName) {
      // For each property name (e.g. 'effective_size')...
      propertyToData.forEach(function (data, propertyName) {
        var tree = data.processAndComponentTreeBuilder.buildTopDownTreeView();
        var unit = data.unit;
        var descriptionPrefixBuilder = data.descriptionPrefixBuilder;

        // Total over 'all' processes...
        customComponentTreeModifier(tree);
        reportComponentDataAsValues(browserName, sourceName, propertyName, 'all_processes', [] /* componentPath */, tree, unit, descriptionPrefixBuilder, values);

        // For each process name (e.g. 'renderer')...
        tree.children[0].forEach(function (processTree, processName) {
          if (processTree.children[0].size > 0) {
            throw new Error('Multi-dimensional view node for source=' + sourceName + ', property=' + (propertyName === undefined ? '(undefined)' : propertyName) + ', process=' + processName + ' has children wrt the process name dimension');
          }
          customComponentTreeModifier(processTree);
          reportComponentDataAsValues(browserName, sourceName, propertyName, processName, [] /* componentPath */, processTree, unit, descriptionPrefixBuilder, values);
        });
      });
    });
  }

  /**
   * For the given |browserName| (e.g. 'chrome'), |processName|
   * (e.g. 'gpu_process'), |propertyName| (e.g. 'effective_size'),
   * |componentPath| (e.g. ['v8']), add a tr.v.Histogram with |unit| aggregating
   * the total values of the associated |componentNode| across all timestamps
   * (corresponding to global memory dumps associated with the given browser)
   * to |values|.
   *
   * See addMemoryDumpValues for more details.
   */
  function reportComponentDataAsValues(browserName, sourceName, propertyName, processName, componentPath, componentNode, unit, descriptionPrefixBuilder, values) {
    // Construct the name of the memory value.
    var nameParts = ['memory', browserName, processName, sourceName].concat(componentPath);
    if (propertyName !== undefined) nameParts.push(propertyName);
    var name = nameParts.join(':');

    // Build the underlying numeric for the memory value.
    var numeric = buildMemoryNumericFromNode(name, componentNode, unit);

    // Build the options for the memory value.
    numeric.description = [descriptionPrefixBuilder(componentPath, processName), 'in', convertBrowserNameToUserFriendlyName(browserName)].join(' ');

    // Report the memory value.
    values.addHistogram(numeric);

    // Recursively report memory values for sub-components.
    var depth = componentPath.length;
    componentPath.push(undefined);
    componentNode.children[1].forEach(function (childNode, childName) {
      componentPath[depth] = childName;
      reportComponentDataAsValues(browserName, sourceName, propertyName, processName, componentPath, childNode, unit, descriptionPrefixBuilder, values);
    });
    componentPath.pop();
  }

  /**
   * Create a memory tr.v.Histogram with |unit| and add all total values in
   * |node| to it.
   */
  function buildMemoryNumericFromNode(name, node, unit) {
    var histogram = new tr.v.Histogram(name, unit, BOUNDARIES_FOR_UNIT_MAP.get(unit));
    node.values.forEach(v => histogram.addSample(v.total));
    return histogram;
  }

  tr.metrics.MetricRegistry.register(memoryMetric, {
    supportsRangeOfInterest: true
  });

  return {
    memoryMetric: memoryMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/iteration_helpers.js":41,"../../base/multi_dimensional_view.js":43,"../../base/range.js":47,"../../base/unit.js":57,"../../model/container_memory_dump.js":109,"../../model/helpers/chrome_model_helper.js":127,"../../model/memory_allocator_dump.js":134,"../../value/histogram.js":189,"../metric_registry.js":83}],91:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/statistics.js");
require("../metric_registry.js");
require("./loading_metric.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {

  // TODO(alexandermont): Per-frame power metric will be deprecated once
  // newer metrics come online.
  // Frame rate, used to divide power sample interval into frames
  // for purposes of per-frame power metric.
  var FRAMES_PER_SEC = 60;
  var FRAME_MS = tr.b.convertUnit(1.0 / FRAMES_PER_SEC, tr.b.UnitScale.Metric.NONE, tr.b.UnitScale.Metric.MILLI);

  /**
   * Returns power data for the specified interval in the form:
   * {
   *   duration: durationInMs,
   *   energy: energyInJ,
   *   power: powerInW
   * }
   */
  function getPowerData_(model, start, end) {
    var durationInMs = end - start;
    var durationInS = tr.b.convertUnit(durationInMs, tr.b.UnitScale.Metric.MILLI, tr.b.UnitScale.Metric.NONE);
    var energyInJ = model.device.powerSeries.getEnergyConsumedInJ(start, end);
    var powerInW = energyInJ / durationInS;
    return { duration: durationInMs, energy: energyInJ, power: powerInW };
  }

  // TODO(alexandermont): When LoadExpectation v1.0 is released,
  // update this function to use the new LoadExpectation rather
  // than calling loading_metric.html. If we set the end of the loading
  // RAIL stage to be the TTI, then we may not even need to treat the loading
  // events separately; we can just treat them like any other RAIL stage
  // (and the RAIL stage boundaries will be the intervals that we want.)
  /**
   * Returns the intervals of time between navigation event and time to
   * interactive.
   */
  function getNavigationTTIIntervals_(model) {
    var values = new tr.v.ValueSet();
    tr.metrics.sh.loadingMetric(values, model);
    var ttiValues = values.getValuesNamed('timeToFirstInteractive');
    var intervals = [];
    for (var bin of tr.b.getOnlyElement(ttiValues).allBins) {
      for (var diagnostics of bin.diagnosticMaps) {
        var breakdown = diagnostics.get('Navigation infos');
        intervals.push(tr.b.Range.fromExplicitRange(breakdown.value.start, breakdown.value.interactive));
      }
    }
    return intervals.sort((x, y) => x.min - y.min);
  }

  /**
   * Creates a histogram suitable for time data.
   */
  function makeTimeHistogram_(values, title, description) {
    var hist = new tr.v.Histogram(title + ':time', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    hist.customizeSummaryOptions({
      avg: false,
      count: false,
      max: true,
      min: true,
      std: false,
      sum: true
    });
    hist.description = 'Time spent in ' + description;
    values.addHistogram(hist);
    return hist;
  }

  /**
   * Creates a histogram suitable for energy data.
   */
  function makeEnergyHistogram_(values, title, description) {
    var hist = new tr.v.Histogram(title + ':energy', tr.b.Unit.byName.energyInJoules_smallerIsBetter);
    hist.customizeSummaryOptions({
      avg: false,
      count: false,
      max: true,
      min: true,
      std: false,
      sum: true
    });
    hist.description = 'Energy consumed in ' + description;
    values.addHistogram(hist);
    return hist;
  }

  /**
   * Creates a histogram suitable for power data.
   */
  function makePowerHistogram_(values, title, description) {
    var hist = new tr.v.Histogram(title + ':power', tr.b.Unit.byName.powerInWatts_smallerIsBetter);
    hist.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: true,
      std: false,
      sum: false
    });
    hist.description = 'Energy consumption rate in ' + description;
    values.addHistogram(hist);
    return hist;
  }

  /**
   * Stores the power data in data into the given histograms for time, energy,
   * and power. If a histogram is undefined then the corresponding type of
   * data is not stored.
   *
   * @param {!Object} data - Power data (obtained from getPowerData_)
   * @param {tr.v.Histogram} timeHist - Histogram to store time data.
   * @param {tr.v.Histogram} energyHist - Histogram to store energy data.
   * @param {tr.v.Histogram} powerHist - Histogram to store power data.
   */
  function storePowerData_(data, timeHist, energyHist, powerHist) {
    if (timeHist !== undefined) timeHist.addSample(data.duration);
    if (energyHist !== undefined) energyHist.addSample(data.energy);
    if (powerHist !== undefined) powerHist.addSample(data.power);
  }

  function createHistograms_(model, values) {
    var hists = {};

    // "Generic" RAIL stage metrics. These give time, energy, and power
    // for each RAIL stage, indexed by name. For instance, "Tap Animation"
    // is different from "Tap, Touch Animation". There is one histogram
    // for each RAIL stage name; if there are multiple RAIL stages with
    // the same name, these are different samples in the histogram.
    hists.railStageToTimeHist = new Map();
    hists.railStageToEnergyHist = new Map();
    hists.railStageToPowerHist = new Map();

    // Metrics for scrolling. A scroll stage is any stage with the
    // string "Scroll" in its name. For instance, "Scroll Response",
    // "Scroll Animation", and "Scroll, Touch Animation" are all
    // scroll stages. Histograms for scroll metrics contain one
    // sample for each scroll stage.
    hists.scrollTimeHist = makeTimeHistogram_(values, 'scroll', 'scrolling');
    hists.scrollEnergyHist = makeEnergyHistogram_(values, 'scroll', 'scrolling');
    hists.scrollPowerHist = makePowerHistogram_(values, 'scroll', 'scrolling');

    // Metrics for loading. Loading intervals are defined by the intervals
    // between navigation and TTI (time-to-interactive) given by
    // getNavigationTTIIntervals_. We also have a metric for the energy
    // consumed after load.
    hists.loadTimeHist = makeTimeHistogram_(values, 'load', 'page loads');
    hists.loadEnergyHist = makeEnergyHistogram_(values, 'load', 'page loads');
    hists.afterLoadTimeHist = makeTimeHistogram_(values, 'after_load', 'period after load');
    hists.afterLoadPowerHist = makePowerHistogram_(values, 'after_load', 'period after load');

    // Metrics for video. A video stage is any stage with the string "Video"
    // in its name. Histograms for video metrics contain one sample for each
    // video stage. Only power metrics are available for video stages.
    hists.videoPowerHist = makePowerHistogram_(values, 'video', 'video playback');

    // Frame based power metric.
    hists.frameEnergyHist = makeEnergyHistogram_(values, 'per_frame', 'each frame');

    for (var exp of model.userModel.expectations) {
      var currTitle = exp.title.toLowerCase().replace(' ', '_');
      // If we haven't seen a RAIL stage with this title before,
      // we have to create a new set of histograms for the "generic"
      // RAIL stage metrics.
      if (!hists.railStageToTimeHist.has(currTitle)) {
        var timeHist = makeTimeHistogram_(values, currTitle, 'RAIL stage ' + currTitle);

        var energyHist = makeEnergyHistogram_(values, currTitle, 'RAIL stage ' + currTitle);

        var powerHist = makePowerHistogram_(values, currTitle, 'RAIL stage ' + currTitle);

        hists.railStageToTimeHist.set(currTitle, timeHist);
        hists.railStageToEnergyHist.set(currTitle, energyHist);
        hists.railStageToPowerHist.set(currTitle, powerHist);
      }
    }
    return hists;
  }

  /**
   * Process a single interaction record (RAIL stage) for power metric
   * purposes. This function only keeps track of metrics that are based
   * on the start and end time of the RAIL stages.
   */
  function processInteractionRecord_(exp, model, hists) {
    var currTitle = exp.title.toLowerCase().replace(' ', '_');
    var data = getPowerData_(model, exp.start, exp.end);

    // Add the samples for the "generic" RAIL stage metrics.
    storePowerData_(data, hists.railStageToTimeHist.get(currTitle), hists.railStageToEnergyHist.get(currTitle), hists.railStageToPowerHist.get(currTitle));

    // If this is a scroll stage, add the sample for the scroll metrics.
    if (exp.title.indexOf("Scroll") !== -1) {
      storePowerData_(data, hists.scrollTimeHist, hists.scrollEnergyHist, hists.scrollPowerHist);
    }

    // If this is a video stage, add the sample for the video metrics.
    if (exp.title.indexOf("Video") !== -1) storePowerData_(data, undefined, undefined, hists.videoPowerHist);
  }

  /**
   * Compute the loading power metric from the model and put the results
   * in |hists|. Note that this is not in processInteractionRecord_ because
   * the loading metric intervals don't correspond exactly to the RAIL stages.
   */
  function computeLoadingMetric_(model, hists) {
    var intervals = getNavigationTTIIntervals_(model);
    var lastLoadTime = undefined;
    for (var interval of intervals) {
      var loadData = getPowerData_(model, interval.min, interval.max);
      storePowerData_(loadData, hists.loadTimeHist, hists.loadEnergyHist, undefined);
      lastLoadTime = lastLoadTime == undefined ? interval.max : Math.max(lastLoadTime, interval.max);
    }
    if (lastLoadTime !== undefined) {
      var afterLoadData = getPowerData_(model, lastLoadTime, model.bounds.max);
      storePowerData_(afterLoadData, hists.afterLoadTimeHist, undefined, hists.afterLoadPowerHist);
    }
  }

  /**
   * Compute the per-frame power metrics and put the results in |hists|.
   */
  function computeFrameBasedPowerMetric_(model, hists) {
    model.device.powerSeries.updateBounds();
    var currentTime = model.device.powerSeries.bounds.min;
    while (currentTime < model.device.powerSeries.bounds.max) {
      var frameData = getPowerData_(model, currentTime, currentTime + FRAME_MS);
      hists.frameEnergyHist.addSample(frameData.energy);
      currentTime += FRAME_MS;
    }
  }

  function powerMetric(values, model) {
    if (!model.device.powerSeries) return;

    var hists = createHistograms_(model, values);
    for (var exp of model.userModel.expectations) processInteractionRecord_(exp, model, hists);

    // The following two metrics aren't based directly on the IR intervals,
    // and so need to be computed outside the processInteractionRecord_ loop.
    computeLoadingMetric_(model, hists);
    computeFrameBasedPowerMetric_(model, hists);
  }

  tr.metrics.MetricRegistry.register(powerMetric);

  return {
    powerMetric: powerMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/statistics.js":53,"../../value/histogram.js":189,"../metric_registry.js":83,"./loading_metric.js":88}],92:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/statistics.js");
require("../metric_registry.js");
require("./utils.js");
require("../../model/user_model/animation_expectation.js");
require("../../model/user_model/load_expectation.js");
require("../../model/user_model/response_expectation.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  // In the case of Response, Load, and DiscreteAnimation IRs, Responsiveness is
  // derived from the time between when the user thinks they begin an interation
  // (expectedStart) and the time when the screen first changes to reflect the
  // interaction (actualEnd).  There may be a delay between expectedStart and
  // when chrome first starts processing the interaction (actualStart) if the
  // main thread is busy.  The user doesn't know when actualStart is, they only
  // know when expectedStart is. User responsiveness, by definition, considers
  // only what the user experiences, so "duration" is defined as actualEnd -
  // expectedStart.

  function computeAnimationThroughput(animationExpectation) {
    if (animationExpectation.frameEvents === undefined || animationExpectation.frameEvents.length === 0) throw new Error('Animation missing frameEvents ' + animationExpectation.stableId);

    var durationInS = tr.b.convertUnit(animationExpectation.duration, tr.b.UnitScale.Metric.MILLI, tr.b.UnitScale.Metric.NONE);
    return animationExpectation.frameEvents.length / durationInS;
  }

  function computeAnimationframeTimeDiscrepancy(animationExpectation) {
    if (animationExpectation.frameEvents === undefined || animationExpectation.frameEvents.length === 0) throw new Error('Animation missing frameEvents ' + animationExpectation.stableId);

    var frameTimestamps = animationExpectation.frameEvents;
    frameTimestamps = frameTimestamps.toArray().map(function (event) {
      return event.start;
    });

    var absolute = true;
    return tr.b.Statistics.timestampsDiscrepancy(frameTimestamps, absolute);
  }

  /**
   * @param {!tr.v.ValueSet} values
   * @param {!tr.model.Model} model
   * @param {!Object=} opt_options
   */
  function responsivenessMetric(values, model, opt_options) {
    var responseNumeric = new tr.v.Histogram('response latency', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, tr.v.HistogramBinBoundaries.createLinear(100, 1e3, 50));
    var throughputNumeric = new tr.v.Histogram('animation throughput', tr.b.Unit.byName.unitlessNumber_biggerIsBetter, tr.v.HistogramBinBoundaries.createLinear(10, 60, 10));
    var frameTimeDiscrepancyNumeric = new tr.v.Histogram('animation frameTimeDiscrepancy', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, tr.v.HistogramBinBoundaries.createLinear(0, 1e3, 50).addExponentialBins(1e4, 10));
    var latencyNumeric = new tr.v.Histogram('animation latency', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, tr.v.HistogramBinBoundaries.createLinear(0, 300, 60));

    model.userModel.expectations.forEach(function (ue) {
      if (opt_options && opt_options.rangeOfInterest && !opt_options.rangeOfInterest.intersectsExplicitRangeInclusive(ue.start, ue.end)) return;

      var sampleDiagnosticMap = tr.v.d.DiagnosticMap.fromObject({ relatedEvents: new tr.v.d.RelatedEventSet([ue]) });

      // Responsiveness is not defined for Idle or Startup expectations.
      if (ue instanceof tr.model.um.IdleExpectation) {
        return;
      } else if (ue instanceof tr.model.um.StartupExpectation) {
        return;
      } else if (ue instanceof tr.model.um.LoadExpectation) {
        // This is already covered by loadingMetric.
      } else if (ue instanceof tr.model.um.ResponseExpectation) {
        responseNumeric.addSample(ue.duration, sampleDiagnosticMap);
      } else if (ue instanceof tr.model.um.AnimationExpectation) {
        if (ue.frameEvents === undefined || ue.frameEvents.length === 0) {
          // Ignore animation stages that do not have associated frames:
          // https://github.com/catapult-project/catapult/issues/2446
          return;
        }
        var throughput = computeAnimationThroughput(ue);
        if (throughput === undefined) throw new Error('Missing throughput for ' + ue.stableId);

        throughputNumeric.addSample(throughput, sampleDiagnosticMap);

        var frameTimeDiscrepancy = computeAnimationframeTimeDiscrepancy(ue);
        if (frameTimeDiscrepancy === undefined) throw new Error('Missing frameTimeDiscrepancy for ' + ue.stableId);

        frameTimeDiscrepancyNumeric.addSample(frameTimeDiscrepancy, sampleDiagnosticMap);

        ue.associatedEvents.forEach(function (event) {
          if (!(event instanceof tr.e.cc.InputLatencyAsyncSlice)) return;

          latencyNumeric.addSample(event.duration, sampleDiagnosticMap);
        });
      } else {
        throw new Error('Unrecognized stage for ' + ue.stableId);
      }
    });

    [responseNumeric, throughputNumeric, frameTimeDiscrepancyNumeric, latencyNumeric].forEach(function (numeric) {
      numeric.customizeSummaryOptions({
        avg: true,
        max: true,
        min: true,
        std: true
      });
    });

    values.addHistogram(responseNumeric);
    values.addHistogram(throughputNumeric);
    values.addHistogram(frameTimeDiscrepancyNumeric);
    values.addHistogram(latencyNumeric);
  }

  tr.metrics.MetricRegistry.register(responsivenessMetric, {
    supportsRangeOfInterest: true
  });

  return {
    responsivenessMetric: responsivenessMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/statistics.js":53,"../../model/user_model/animation_expectation.js":161,"../../model/user_model/load_expectation.js":163,"../../model/user_model/response_expectation.js":164,"../../value/histogram.js":189,"../metric_registry.js":83,"./utils.js":94}],93:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./cpu_time_metric.js");
require("./hazard_metric.js");
require("./long_tasks_metric.js");
require("./power_metric.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  function systemHealthMetrics(values, model) {
    tr.metrics.sh.responsivenessMetric(values, model);
    tr.metrics.sh.longTasksMetric(values, model);
    tr.metrics.sh.hazardMetric(values, model);
    tr.metrics.sh.powerMetric(values, model);
    tr.metrics.sh.cpuTimeMetric(values, model);
  }

  tr.metrics.MetricRegistry.register(systemHealthMetrics);

  return {
    systemHealthMetrics: systemHealthMetrics
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cpu_time_metric.js":86,"./hazard_metric.js":87,"./long_tasks_metric.js":89,"./power_metric.js":91}],94:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../model/user_model/user_expectation.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  // Returns a weight for this score.
  // score should be a number between 0 and 1 inclusive.
  // This function is expected to be passed to tr.b.Statistics.weightedMean as
  // its weightCallback.
  function perceptualBlend(ir, index, score) {
    // Lower scores are exponentially more important than higher scores
    // due to the Peak-end rule.
    // Other than that general rule, there is no specific reasoning behind this
    // specific formula -- it is fairly arbitrary.
    return Math.exp(1 - score);
  }

  function filterExpectationsByRange(irs, opt_range) {
    var filteredExpectations = [];
    irs.forEach(function (ir) {
      if (!(ir instanceof tr.model.um.UserExpectation)) return;

      if (!opt_range || opt_range.intersectsExplicitRangeInclusive(ir.start, ir.end)) filteredExpectations.push(ir);
    });
    return filteredExpectations;
  }

  return {
    perceptualBlend: perceptualBlend,
    filterExpectationsByRange: filterExpectationsByRange
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../model/user_model/user_expectation.js":166}],95:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../metric_registry.js");
require("./utils.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.sh', function () {
  function webviewStartupMetric(values, model) {
    var startupWallHist = new tr.v.Histogram('webview_startup_wall_time', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    startupWallHist.description = 'WebView startup wall time';
    var startupCPUHist = new tr.v.Histogram('webview_startup_cpu_time', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    startupCPUHist.description = 'WebView startup CPU time';
    var loadWallHist = new tr.v.Histogram('webview_url_load_wall_time', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    loadWallHist.description = 'WebView blank URL load wall time';
    var loadCPUHist = new tr.v.Histogram('webview_url_load_cpu_time', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter);
    loadCPUHist.description = 'WebView blank URL load CPU time';

    // TODO(alexandermont): Only iterate over the processes and threads that
    // could contain these events.
    for (var slice of model.getDescendantEvents()) {
      if (!(slice instanceof tr.model.ThreadSlice)) continue;

      // WebViewStartupInterval is the title of the section of code that is
      // entered (via android.os.Trace.beginSection) when WebView is started
      // up. This value is defined in TelemetryActivity.java.
      if (slice.title === 'WebViewStartupInterval') {
        startupWallHist.addSample(slice.duration);
        startupCPUHist.addSample(slice.cpuDuration);
      }

      // WebViewBlankUrlLoadInterval is the title of the section of code
      // that is entered (via android.os.Trace.beginSection) when WebView
      // is started up. This value is defined in TelemetryActivity.java.
      if (slice.title === 'WebViewBlankUrlLoadInterval') {
        loadWallHist.addSample(slice.duration);
        loadCPUHist.addSample(slice.cpuDuration);
      }
    }

    values.addHistogram(startupWallHist);
    values.addHistogram(startupCPUHist);
    values.addHistogram(loadWallHist);
    values.addHistogram(loadCPUHist);
  }

  tr.metrics.MetricRegistry.register(webviewStartupMetric);

  return {
    webviewStartupMetric: webviewStartupMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../value/histogram.js":189,"../metric_registry.js":83,"./utils.js":94}],96:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/iteration_helpers.js");
require("./metric_registry.js");
require("../value/diagnostics/diagnostic_map.js");
require("../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics', function () {
    var MEMORY_INFRA_TRACING_CATEGORY = 'disabled-by-default-memory-infra';

    var TIME_BOUNDARIES = tr.v.HistogramBinBoundaries.createExponential(1e-3, 1e5, 30);

    var BYTE_BOUNDARIES = tr.v.HistogramBinBoundaries.createExponential(1, 1e9, 30);

    var COUNT_BOUNDARIES = tr.v.HistogramBinBoundaries.createExponential(1, 1e5, 30);

    function addTimeDurationValue(valueName, duration, allValues) {
        var hist = new tr.v.Histogram(valueName, tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, TIME_BOUNDARIES);
        hist.addSample(duration);
        allValues.addHistogram(hist);
    }

    // Adds values specific to memory-infra dumps.
    function addMemoryInfraValues(values, model, categoryNamesToTotalEventSizes) {
        var memoryDumpCount = model.globalMemoryDumps.length;
        if (memoryDumpCount === 0) return;

        var totalOverhead = 0;
        var nonMemoryInfraThreadOverhead = 0;
        var overheadByProvider = {};
        tr.b.iterItems(model.processes, function (pid, process) {
            tr.b.iterItems(process.threads, function (tid, thread) {
                tr.b.iterItems(thread.sliceGroup.slices, (unusedSliceId, slice) => {
                    if (slice.category !== MEMORY_INFRA_TRACING_CATEGORY) return;
                    totalOverhead += slice.duration;
                    if (thread.name !== 'MemoryInfra') nonMemoryInfraThreadOverhead += slice.duration;
                    if (slice.args && slice.args['dump_provider.name']) {
                        var providerName = slice.args['dump_provider.name'];
                        var durationAndCount = overheadByProvider[providerName];
                        if (durationAndCount === undefined) {
                            overheadByProvider[providerName] = durationAndCount = { duration: 0, count: 0 };
                        }
                        durationAndCount.duration += slice.duration;
                        durationAndCount.count++;
                    }
                });
            });
        });

        addTimeDurationValue('Average CPU overhead on all threads per memory-infra dump', totalOverhead / memoryDumpCount, values);
        addTimeDurationValue('Average CPU overhead on non-memory-infra threads per memory-infra ' + 'dump', nonMemoryInfraThreadOverhead / memoryDumpCount, values);
        tr.b.iterItems(overheadByProvider, function (providerName, overhead) {
            addTimeDurationValue('Average CPU overhead of ' + providerName + ' per OnMemoryDump call', overhead.duration / overhead.count, values);
        });

        var memoryInfraEventsSize = categoryNamesToTotalEventSizes.get(MEMORY_INFRA_TRACING_CATEGORY);
        var memoryInfraTraceBytesValue = new tr.v.Histogram('Total trace size of memory-infra dumps in bytes', tr.b.Unit.byName.sizeInBytes_smallerIsBetter, BYTE_BOUNDARIES);
        memoryInfraTraceBytesValue.addSample(memoryInfraEventsSize);
        values.addHistogram(memoryInfraTraceBytesValue);

        var traceBytesPerDumpValue = new tr.v.Histogram('Average trace size of memory-infra dumps in bytes', tr.b.Unit.byName.sizeInBytes_smallerIsBetter, BYTE_BOUNDARIES);
        traceBytesPerDumpValue.addSample(memoryInfraEventsSize / memoryDumpCount);
        values.addHistogram(traceBytesPerDumpValue);
    }

    function tracingMetric(values, model) {
        if (!model.stats.hasEventSizesinBytes) {
            throw new Error('Model stats does not have event size information. ' + 'Please enable ImportOptions.trackDetailedModelStats.');
        }

        var eventStats = model.stats.allTraceEventStatsInTimeIntervals;
        eventStats.sort(function (a, b) {
            return a.timeInterval - b.timeInterval;
        });

        var totalTraceBytes = eventStats.reduce((a, b) => a + b.totalEventSizeinBytes, 0);

        // We maintain a sliding window of records [start ... end-1] where end
        // increments each time through the loop, and we move start just far enough
        // to keep the window less than 1 second wide. Note that we need to compute
        // the number of time intervals (i.e. units that timeInterval is given in)
        // in one second to know how wide the sliding window should be.
        var maxEventCountPerSec = 0;
        var maxEventBytesPerSec = 0;
        var INTERVALS_PER_SEC = Math.floor(1000 / model.stats.TIME_INTERVAL_SIZE_IN_MS);

        var runningEventNumPerSec = 0;
        var runningEventBytesPerSec = 0;
        var start = 0;
        var end = 0;

        while (end < eventStats.length) {
            // Slide the end marker forward. Moving the end marker from N
            // to N+1 adds eventStats[N] to the sliding window.
            runningEventNumPerSec += eventStats[end].numEvents;
            runningEventBytesPerSec += eventStats[end].totalEventSizeinBytes;
            end++;

            // Slide the start marker forward so that the time interval covered
            // by the window is less than 1 second wide.
            while (eventStats[end - 1].timeInterval - eventStats[start].timeInterval >= INTERVALS_PER_SEC) {
                runningEventNumPerSec -= eventStats[start].numEvents;
                runningEventBytesPerSec -= eventStats[start].totalEventSizeinBytes;
                start++;
            }

            // Update maximum values.
            maxEventCountPerSec = Math.max(maxEventCountPerSec, runningEventNumPerSec);
            maxEventBytesPerSec = Math.max(maxEventBytesPerSec, runningEventBytesPerSec);
        }

        var stats = model.stats.allTraceEventStats;
        var categoryNamesToTotalEventSizes = stats.reduce((map, stat) => map.set(stat.category, (map.get(stat.category) || 0) + stat.totalEventSizeinBytes), new Map());

        // Determine the category with the highest total event size.
        var maxCatNameAndBytes = Array.from(categoryNamesToTotalEventSizes.entries()).reduce((a, b) => b[1] >= a[1] ? b : a);
        var maxEventBytesPerCategory = maxCatNameAndBytes[1];
        var categoryWithMaxEventBytes = maxCatNameAndBytes[0];

        var maxEventCountPerSecValue = new tr.v.Histogram('Max number of events per second', tr.b.Unit.byName.count_smallerIsBetter, COUNT_BOUNDARIES);
        maxEventCountPerSecValue.addSample(maxEventCountPerSec);

        var maxEventBytesPerSecValue = new tr.v.Histogram('Max event size in bytes per second', tr.b.Unit.byName.sizeInBytes_smallerIsBetter, BYTE_BOUNDARIES);
        maxEventBytesPerSecValue.addSample(maxEventBytesPerSec);

        var totalTraceBytesValue = new tr.v.Histogram('Total trace size in bytes', tr.b.Unit.byName.sizeInBytes_smallerIsBetter, BYTE_BOUNDARIES);
        totalTraceBytesValue.addSample(totalTraceBytes);

        var biggestCategory = {
            name: categoryWithMaxEventBytes,
            size_in_bytes: maxEventBytesPerCategory
        };

        totalTraceBytesValue.diagnostics.set('category_with_max_event_size', new tr.v.d.Generic(biggestCategory));
        values.addHistogram(totalTraceBytesValue);

        maxEventCountPerSecValue.diagnostics.set('category_with_max_event_size', new tr.v.d.Generic(biggestCategory));
        values.addHistogram(maxEventCountPerSecValue);

        maxEventBytesPerSecValue.diagnostics.set('category_with_max_event_size', new tr.v.d.Generic(biggestCategory));
        values.addHistogram(maxEventBytesPerSecValue);

        addMemoryInfraValues(values, model, categoryNamesToTotalEventSizes);
    }

    tr.metrics.MetricRegistry.register(tracingMetric);

    return {
        tracingMetric: tracingMetric,
        // For testing only:
        MEMORY_INFRA_TRACING_CATEGORY: MEMORY_INFRA_TRACING_CATEGORY
    };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41,"../value/diagnostics/diagnostic_map.js":179,"../value/histogram.js":189,"./metric_registry.js":83}],97:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/range.js");
require("../../base/unit.js");
require("../metric_registry.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.v8', function () {
  var CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(4, 200, 100);

  function computeExecuteMetrics(values, model) {
    var cpuTotalExecution = new tr.v.Histogram('v8_execution_cpu_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalExecution.description = 'cpu total time spent in script execution';
    var wallTotalExecution = new tr.v.Histogram('v8_execution_wall_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalExecution.description = 'wall total time spent in script execution';
    var cpuSelfExecution = new tr.v.Histogram('v8_execution_cpu_self', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuSelfExecution.description = 'cpu self time spent in script execution';
    var wallSelfExecution = new tr.v.Histogram('v8_execution_wall_self', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallSelfExecution.description = 'wall self time spent in script execution';

    for (var e of model.findTopmostSlicesNamed('V8.Execute')) {
      cpuTotalExecution.addSample(e.cpuDuration);
      wallTotalExecution.addSample(e.duration);
      cpuSelfExecution.addSample(e.cpuSelfTime);
      wallSelfExecution.addSample(e.selfTime);
    }

    values.addHistogram(cpuTotalExecution);
    values.addHistogram(wallTotalExecution);
    values.addHistogram(cpuSelfExecution);
    values.addHistogram(wallSelfExecution);
  }

  function computeParseLazyMetrics(values, model) {
    var cpuSelfParseLazy = new tr.v.Histogram('v8_parse_lazy_cpu_self', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuSelfParseLazy.description = 'cpu self time spent performing lazy parsing';
    var wallSelfParseLazy = new tr.v.Histogram('v8_parse_lazy_wall_self', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallSelfParseLazy.description = 'wall self time spent performing lazy parsing';

    for (var e of model.findTopmostSlicesNamed('V8.ParseLazyMicroSeconds')) {
      cpuSelfParseLazy.addSample(e.cpuSelfTime);
      wallSelfParseLazy.addSample(e.selfTime);
    }
    for (var e of model.findTopmostSlicesNamed('V8.ParseLazy')) {
      cpuSelfParseLazy.addSample(e.cpuSelfTime);
      wallSelfParseLazy.addSample(e.selfTime);
    }

    values.addHistogram(cpuSelfParseLazy);
    values.addHistogram(wallSelfParseLazy);
  }

  function computeCompileFullCodeMetrics(values, model) {
    var cpuSelfCompileFullCode = new tr.v.Histogram('v8_compile_full_code_cpu_self', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuSelfCompileFullCode.description = 'cpu self time spent performing compiling full code';
    var wallSelfCompileFullCode = new tr.v.Histogram('v8_compile_full_code_wall_self', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallSelfCompileFullCode.description = 'wall self time spent performing compiling full code';

    for (var e of model.findTopmostSlicesNamed('V8.CompileFullCode')) {
      cpuSelfCompileFullCode.addSample(e.cpuSelfTime);
      wallSelfCompileFullCode.addSample(e.selfTime);
    }

    values.addHistogram(cpuSelfCompileFullCode);
    values.addHistogram(wallSelfCompileFullCode);
  }

  function computeCompileIgnitionMetrics(values, model) {
    var cpuSelfCompileIgnition = new tr.v.Histogram('v8_compile_ignition_cpu_self', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuSelfCompileIgnition.description = 'cpu self time spent in compile ignition';
    var wallSelfCompileIgnition = new tr.v.Histogram('v8_compile_ignition_wall_self', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallSelfCompileIgnition.description = 'wall self time spent in compile ignition';

    for (var e of model.findTopmostSlicesNamed('V8.CompileIgnition')) {
      cpuSelfCompileIgnition.addSample(e.cpuSelfTime);
      wallSelfCompileIgnition.addSample(e.selfTime);
    }

    values.addHistogram(cpuSelfCompileIgnition);
    values.addHistogram(wallSelfCompileIgnition);
  }

  function computeRecompileMetrics(values, model) {
    var cpuTotalRecompileSynchronous = new tr.v.Histogram('v8_recompile_synchronous_cpu_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalRecompileSynchronous.description = 'cpu total time spent in synchronous recompilation';
    var wallTotalRecompileSynchronous = new tr.v.Histogram('v8_recompile_synchronous_wall_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalRecompileSynchronous.description = 'wall total time spent in synchronous recompilation';
    var cpuTotalRecompileConcurrent = new tr.v.Histogram('v8_recompile_concurrent_cpu_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalRecompileConcurrent.description = 'cpu total time spent in concurrent recompilation';
    var wallTotalRecompileConcurrent = new tr.v.Histogram('v8_recompile_concurrent_wall_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalRecompileConcurrent.description = 'wall total time spent in concurrent recompilation';
    // TODO(eakuefner): Stop computing overall values once dash v2 is ready.
    // https://github.com/catapult-project/catapult/issues/2180
    var cpuTotalRecompileOverall = new tr.v.Histogram('v8_recompile_overall_cpu_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalRecompileOverall.description = 'cpu total time spent in synchronous or concurrent recompilation';
    var wallTotalRecompileOverall = new tr.v.Histogram('v8_recompile_overall_wall_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalRecompileOverall.description = 'wall total time spent in synchronous or concurrent recompilation';

    for (var e of model.findTopmostSlicesNamed('V8.RecompileSynchronous')) {
      cpuTotalRecompileSynchronous.addSample(e.cpuDuration);
      wallTotalRecompileSynchronous.addSample(e.duration);
      cpuTotalRecompileOverall.addSample(e.cpuDuration);
      wallTotalRecompileOverall.addSample(e.duration);
    }

    values.addHistogram(cpuTotalRecompileSynchronous);
    values.addHistogram(wallTotalRecompileSynchronous);

    for (var e of model.findTopmostSlicesNamed('V8.RecompileConcurrent')) {
      cpuTotalRecompileConcurrent.addSample(e.cpuDuration);
      wallTotalRecompileConcurrent.addSample(e.duration);
      cpuTotalRecompileOverall.addSample(e.cpuDuration);
      wallTotalRecompileOverall.addSample(e.duration);
    }

    values.addHistogram(cpuTotalRecompileConcurrent);
    values.addHistogram(wallTotalRecompileConcurrent);
    values.addHistogram(cpuTotalRecompileOverall);
    values.addHistogram(wallTotalRecompileOverall);
  }

  function computeOptimizeCodeMetrics(values, model) {
    var cpuTotalOptimizeCode = new tr.v.Histogram('v8_optimize_code_cpu_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalOptimizeCode.description = 'cpu total time spent in code optimization';
    var wallTotalOptimizeCode = new tr.v.Histogram('v8_optimize_code_wall_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalOptimizeCode.description = 'wall total time spent in code optimization';

    for (var e of model.findTopmostSlicesNamed('V8.OptimizeCode')) {
      cpuTotalOptimizeCode.addSample(e.cpuDuration);
      wallTotalOptimizeCode.addSample(e.duration);
    }

    values.addHistogram(cpuTotalOptimizeCode);
    values.addHistogram(wallTotalOptimizeCode);
  }

  function computeDeoptimizeCodeMetrics(values, model) {
    var cpuTotalDeoptimizeCode = new tr.v.Histogram('v8_deoptimize_code_cpu_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    cpuTotalDeoptimizeCode.description = 'cpu total time spent in code deoptimization';
    var wallTotalDeoptimizeCode = new tr.v.Histogram('v8_deoptimize_code_wall_total', tr.b.Unit.byName.timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    wallTotalDeoptimizeCode.description = 'wall total time spent in code deoptimization';

    for (var e of model.findTopmostSlicesNamed('V8.DeoptimizeCode')) {
      cpuTotalDeoptimizeCode.addSample(e.cpuDuration);
      wallTotalDeoptimizeCode.addSample(e.duration);
    }

    values.addHistogram(cpuTotalDeoptimizeCode);
    values.addHistogram(wallTotalDeoptimizeCode);
  }

  function executionMetric(values, model) {
    computeExecuteMetrics(values, model);
    computeParseLazyMetrics(values, model);
    computeCompileIgnitionMetrics(values, model);
    computeCompileFullCodeMetrics(values, model);
    computeRecompileMetrics(values, model);
    computeOptimizeCodeMetrics(values, model);
    computeDeoptimizeCodeMetrics(values, model);
  }

  tr.metrics.MetricRegistry.register(executionMetric);

  return {
    executionMetric: executionMetric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/range.js":47,"../../base/unit.js":57,"../../value/histogram.js":189,"../metric_registry.js":83}],98:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/range.js");
require("../../base/unit.js");
require("../metric_registry.js");
require("./utils.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.v8', function () {
  // The time window size for mutator utilization computation.
  // It is equal to the duration of one frame corresponding to 60 FPS rendering.
  var TARGET_FPS = 60;
  var MS_PER_SECOND = 1000;
  var WINDOW_SIZE_MS = MS_PER_SECOND / TARGET_FPS;

  function gcMetric(values, model) {
    addDurationOfTopEvents(values, model);
    addTotalDurationOfTopEvents(values, model);
    addDurationOfSubEvents(values, model);
    addIdleTimesOfTopEvents(values, model);
    addTotalIdleTimesOfTopEvents(values, model);
    addPercentageInV8ExecuteOfTopEvents(values, model);
    addTotalPercentageInV8Execute(values, model);
    addV8ExecuteMutatorUtilization(values, model);
  }

  tr.metrics.MetricRegistry.register(gcMetric);

  var timeDurationInMs_smallerIsBetter = tr.b.Unit.byName.timeDurationInMs_smallerIsBetter;
  var percentage_biggerIsBetter = tr.b.Unit.byName.normalizedPercentage_biggerIsBetter;
  var percentage_smallerIsBetter = tr.b.Unit.byName.normalizedPercentage_smallerIsBetter;

  // 0.1 steps from 0 to 20 since it is the most common range.
  // Exponentially increasing steps from 20 to 200.
  var CUSTOM_BOUNDARIES = tr.v.HistogramBinBoundaries.createLinear(0, 20, 200).addExponentialBins(200, 100);

  function createNumericForTopEventTime(name) {
    var n = new tr.v.Histogram(name, timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: true,
      max: true,
      min: false,
      std: true,
      sum: true,
      percentile: [0.90] });
    return n;
  }

  function createNumericForSubEventTime(name) {
    var n = new tr.v.Histogram(name, timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: false,
      percentile: [0.90]
    });
    return n;
  }

  function createNumericForIdleTime(name) {
    var n = new tr.v.Histogram(name, timeDurationInMs_smallerIsBetter, CUSTOM_BOUNDARIES);
    n.customizeSummaryOptions({
      avg: true,
      count: false,
      max: true,
      min: false,
      std: false,
      sum: true,
      percentile: []
    });
    return n;
  }

  function createPercentage(name, numerator, denominator, unit) {
    var hist = new tr.v.Histogram(name, unit);
    if (denominator === 0) hist.addSample(0);else hist.addSample(numerator / denominator);
    hist.customizeSummaryOptions({
      avg: true,
      count: false,
      max: false,
      min: false,
      std: false,
      sum: false,
      percentile: []
    });
    return hist;
  }

  function isNotForcedTopGarbageCollectionEvent(event) {
    // We exclude garbage collection events forced by benchmark runner,
    // because they cannot happen in real world.
    return tr.metrics.v8.utils.isTopGarbageCollectionEvent(event) && !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event);
  }

  function isNotForcedSubGarbageCollectionEvent(event) {
    // We exclude garbage collection events forced by benchmark runner,
    // because they cannot happen in real world.
    return tr.metrics.v8.utils.isSubGarbageCollectionEvent(event) && !tr.metrics.v8.utils.isForcedGarbageCollectionEvent(event);
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor.
   */
  function addDurationOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isNotForcedTopGarbageCollectionEvent, tr.metrics.v8.utils.topGarbageCollectionEventName, function (name, events) {
      var cpuDuration = createNumericForTopEventTime(name);
      events.forEach(function (event) {
        cpuDuration.addSample(event.cpuDuration);
      });
      values.addHistogram(cpuDuration);
    });
  }

  /**
   * Example output:
   * - v8-gc-total
   */
  function addTotalDurationOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isNotForcedTopGarbageCollectionEvent, event => 'v8-gc-total', function (name, events) {
      var cpuDuration = createNumericForTopEventTime(name);
      events.forEach(function (event) {
        cpuDuration.addSample(event.cpuDuration);
      });
      values.addHistogram(cpuDuration);
    });
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor-evacuate.
   */
  function addDurationOfSubEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isNotForcedSubGarbageCollectionEvent, tr.metrics.v8.utils.subGarbageCollectionEventName, function (name, events) {
      var cpuDuration = createNumericForSubEventTime(name);
      events.forEach(function (event) {
        cpuDuration.addSample(event.cpuDuration);
      });
      values.addHistogram(cpuDuration);
    });
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor_idle_deadline_overrun,
   * - v8-gc-full-mark-compactor_outside_idle,
   * - v8-gc-full-mark-compactor_percentage_idle.
   */
  function addIdleTimesOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isNotForcedTopGarbageCollectionEvent, tr.metrics.v8.utils.topGarbageCollectionEventName, function (name, events) {
      addIdleTimes(values, model, name, events);
    });
  }

  /**
   * Example output:
   * - v8-gc-total_idle_deadline_overrun,
   * - v8-gc-total_outside_idle,
   * - v8-gc-total_percentage_idle.
   */
  function addTotalIdleTimesOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isNotForcedTopGarbageCollectionEvent, event => 'v8-gc-total', function (name, events) {
      addIdleTimes(values, model, name, events);
    });
  }

  function addIdleTimes(values, model, name, events) {
    var cpuDuration = createNumericForIdleTime();
    var insideIdle = createNumericForIdleTime();
    var outsideIdle = createNumericForIdleTime(name + '_outside_idle');
    var idleDeadlineOverrun = createNumericForIdleTime(name + '_idle_deadline_overrun');
    events.forEach(function (event) {
      var idleTask = tr.metrics.v8.utils.findParent(event, tr.metrics.v8.utils.isIdleTask);
      var inside = 0;
      var overrun = 0;
      if (idleTask) {
        var allottedTime = idleTask['args']['allotted_time_ms'];
        if (event.duration > allottedTime) {
          overrun = event.duration - allottedTime;
          // Don't count time over the deadline as being inside idle time.
          // Since the deadline should be relative to wall clock we
          // compare allotted_time_ms with wall duration instead of thread
          // duration, and then assume the thread duration was inside idle
          // for the same percentage of time.
          inside = event.cpuDuration * allottedTime / event.duration;
        } else {
          inside = event.cpuDuration;
        }
      }
      cpuDuration.addSample(event.cpuDuration);
      insideIdle.addSample(inside);
      outsideIdle.addSample(event.cpuDuration - inside);
      idleDeadlineOverrun.addSample(overrun);
    });
    values.addHistogram(idleDeadlineOverrun);
    values.addHistogram(outsideIdle);
    var percentage = createPercentage(name + '_percentage_idle', insideIdle.sum, cpuDuration.sum, percentage_biggerIsBetter);
    values.addHistogram(percentage);
  }

  /**
   * Example output:
   * - v8-gc-full-mark-compactor_percentage_in_v8_execute.
   */
  function addPercentageInV8ExecuteOfTopEvents(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isNotForcedTopGarbageCollectionEvent, tr.metrics.v8.utils.topGarbageCollectionEventName, function (name, events) {
      addPercentageInV8Execute(values, model, name, events);
    });
  }

  /**
   * Example output:
   * - v8-gc-total_percentage_in_v8_execute.
   */
  function addTotalPercentageInV8Execute(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, isNotForcedTopGarbageCollectionEvent, event => 'v8-gc-total', function (name, events) {
      addPercentageInV8Execute(values, model, name, events);
    });
  }

  function addPercentageInV8Execute(values, model, name, events) {
    var cpuDurationInV8Execute = 0;
    var cpuDurationTotal = 0;
    events.forEach(function (event) {
      var v8Execute = tr.metrics.v8.utils.findParent(event, tr.metrics.v8.utils.isV8ExecuteEvent);
      if (v8Execute) {
        cpuDurationInV8Execute += event.cpuDuration;
      }
      cpuDurationTotal += event.cpuDuration;
    });
    var percentage = createPercentage(name + '_percentage_in_v8_execute', cpuDurationInV8Execute, cpuDurationTotal, percentage_smallerIsBetter);
    values.addHistogram(percentage);
  }

  function addV8ExecuteMutatorUtilization(values, model) {
    tr.metrics.v8.utils.groupAndProcessEvents(model, tr.metrics.v8.utils.isTopV8ExecuteEvent, event => 'v8-execute', function (name, events) {
      events.sort((a, b) => a.start - b.start);
      var time = 0;
      var pauses = [];
      // Glue together the v8.execute events and adjust the GC pause
      // times accordingly.
      for (var topEvent of events) {
        for (var e of topEvent.enumerateAllDescendents()) {
          if (isNotForcedTopGarbageCollectionEvent(e)) {
            pauses.push({ start: e.start - topEvent.start + time,
              end: e.end - topEvent.start + time });
          }
        }
        time += topEvent.duration;
      }
      // Now we have one big v8.execute interval from 0 to |time| and
      // a list of GC pauses.
      var mutatorUtilization = tr.metrics.v8.utils.mutatorUtilization(0, time, WINDOW_SIZE_MS, pauses);
      [0.90, 0.95, 0.99].forEach(function (percent) {
        var hist = new tr.v.Histogram('v8-execute-mutator-utilization_pct_0' + percent * 100, percentage_biggerIsBetter);
        hist.addSample(mutatorUtilization.percentile(1.0 - percent));
        values.addHistogram(hist);
      });
      var hist = new tr.v.Histogram('v8-execute-mutator-utilization_min', percentage_biggerIsBetter);
      hist.addSample(mutatorUtilization.min);
      values.addHistogram(hist);
    });
  }

  return {
    gcMetric: gcMetric,
    WINDOW_SIZE_MS: WINDOW_SIZE_MS // For testing purposes only.
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/range.js":47,"../../base/unit.js":57,"../../value/histogram.js":189,"../metric_registry.js":83,"./utils.js":99}],99:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/piecewise_linear_function.js");
require("../../base/range.js");
require("../../base/range_utils.js");
require("../../base/unit.js");
require("../metric_registry.js");
require("../../value/histogram.js");

'use strict';

global.tr.exportTo('tr.metrics.v8.utils', function () {
  // The title of the idle task event.
  var IDLE_TASK_EVENT = 'SingleThreadIdleTaskRunner::RunTask';

  // V8 execution event.
  var V8_EXECUTE = 'V8.Execute';

  // GC events start with this prefix.
  var GC_EVENT_PREFIX = 'V8.GC';

  // Special handling is required for full GCs inside low memory notification.
  var FULL_GC_EVENT = 'V8.GCCompactor';

  var LOW_MEMORY_EVENT = 'V8.GCLowMemoryNotification';

  var MAJOR_GC_EVENT = 'MajorGC';
  var MINOR_GC_EVENT = 'MinorGC';

  // Maps the top-level GC events in timeline to telemetry friendly names.
  var TOP_GC_EVENTS = {
    'V8.GCCompactor': 'v8-gc-full-mark-compactor',
    'V8.GCFinalizeMC': 'v8-gc-latency-mark-compactor',
    'V8.GCFinalizeMCReduceMemory': 'v8-gc-memory-mark-compactor',
    'V8.GCIncrementalMarking': 'v8-gc-incremental-step',
    'V8.GCIncrementalMarkingFinalize': 'v8-gc-incremental-finalize',
    'V8.GCIncrementalMarkingStart': 'v8-gc-incremental-start',
    'V8.GCPhantomHandleProcessingCallback': 'v8-gc-phantom-handle-callback',
    'V8.GCScavenger': 'v8-gc-scavenger'
  };

  var LOW_MEMORY_MARK_COMPACTOR = 'v8-gc-low-memory-mark-compactor';

  /**
   * Finds the first parent of the |event| for which the |predicate| holds.
   */
  function findParent(event, predicate) {
    var parent = event.parentSlice;
    while (parent) {
      if (predicate(parent)) {
        return parent;
      }
      parent = parent.parentSlice;
    }
    return null;
  }

  function isIdleTask(event) {
    return event.title === IDLE_TASK_EVENT;
  }

  function isLowMemoryEvent(event) {
    return event.title === LOW_MEMORY_EVENT;
  }

  function isV8ExecuteEvent(event) {
    return event.title === V8_EXECUTE;
  }

  function isTopV8ExecuteEvent(event) {
    return isV8ExecuteEvent(event) && findParent(isV8ExecuteEvent) === null;
  }

  function isGarbageCollectionEvent(event) {
    // Low memory notification is handled specially because it contains
    // several full mark compact events.
    return event.title && event.title.startsWith(GC_EVENT_PREFIX) && event.title != LOW_MEMORY_EVENT;
  }

  function isTopGarbageCollectionEvent(event) {
    return event.title in TOP_GC_EVENTS;
  }

  function isForcedGarbageCollectionEvent(event) {
    return findParent(event, isLowMemoryEvent) !== null;
  }

  function isSubGarbageCollectionEvent(event) {
    // To reduce number of results, we return only the first level of GC
    // subevents. Some subevents are nested in MajorGC or MinorGC events, so
    // we have to check for it explicitly.
    return isGarbageCollectionEvent(event) && event.parentSlice && (isTopGarbageCollectionEvent(event.parentSlice) || event.parentSlice.title === MAJOR_GC_EVENT || event.parentSlice.title === MINOR_GC_EVENT);
  }

  function topGarbageCollectionEventName(event) {
    if (event.title === FULL_GC_EVENT) {
      // Full mark compact events inside a low memory notification
      // are counted as low memory mark compacts.
      if (findParent(event, isLowMemoryEvent)) {
        return LOW_MEMORY_MARK_COMPACTOR;
      }
    }
    return TOP_GC_EVENTS[event.title];
  }

  function subGarbageCollectionEventName(event) {
    var topEvent = findParent(event, isTopGarbageCollectionEvent);
    var prefix = topEvent ? topGarbageCollectionEventName(topEvent) : 'unknown';
    // Remove redundant prefixes and convert to lower case.
    var name = event.title.replace('V8.GC_MC_', '').replace('V8.GC_SCAVENGER_', '').replace('V8.GC_', '').replace(/_/g, '-').toLowerCase();
    return prefix + '-' + name;
  }

  /**
   * Filters events using the |filterCallback|, then groups events by the user
   * the name computed using the |nameCallback|, and then invokes
   * the |processCallback| with the grouped events.
   * @param {Function} filterCallback Takes an event and returns a boolean.
   * @param {Function} nameCallback Takes event and returns a string.
   * @param {Function} processCallback Takes a name, and an array of events.
   */
  function groupAndProcessEvents(model, filterCallback, nameCallback, processCallback) {
    // Map: name -> [events].
    var nameToEvents = {};
    for (var event of model.getDescendantEvents()) {
      if (!filterCallback(event)) continue;
      var name = nameCallback(event);
      nameToEvents[name] = nameToEvents[name] || [];
      nameToEvents[name].push(event);
    }
    tr.b.iterItems(nameToEvents, function (name, events) {
      processCallback(name, events);
    });
  }

  /**
  * Given a list of intervals, returns a new list with all overalapping
  * intervals merged into a single interval.
  */
  function unionOfIntervals(intervals) {
    if (intervals.length === 0) return [];
    return tr.b.mergeRanges(intervals.map(x => ({ min: x.start, max: x.end })), 1e-6, function (ranges) {
      return {
        start: ranges.reduce((acc, x) => Math.min(acc, x.min), ranges[0].min),
        end: ranges.reduce((acc, x) => Math.max(acc, x.max), ranges[0].max)
      };
    });
  }

  /**
   * An end-point of a window that is sliding from left to right
   * over |points| starting from time |start|.
   * It is intended to be used only by the |mutatorUtilization| function.
   * @constructor
   */
  function WindowEndpoint(start, points) {
    this.points = points;
    // The index of the last passed point.
    this.lastIndex = -1;
    // The position of the end-point in the time line.
    this.position = start;
    // The distance until the next point.
    this.distanceUntilNextPoint = points[0].position - start;
    // The cumulative duration of GC pauses until this position.
    this.cummulativePause = 0;
    // The number of entered GC intervals.
    this.stackDepth = 0;
  }

  WindowEndpoint.prototype = {
    // Advance the end-point by the given |delta|.
    advance: function (delta) {
      var points = this.points;
      if (delta < this.distanceUntilNextPoint) {
        this.position += delta;
        this.cummulativePause += this.stackDepth > 0 ? delta : 0;
        this.distanceUntilNextPoint = points[this.lastIndex + 1].position - this.position;
      } else {
        this.position += this.distanceUntilNextPoint;
        this.cummulativePause += this.stackDepth > 0 ? this.distanceUntilNextPoint : 0;
        this.distanceUntilNextPoint = 0;
        this.lastIndex++;
        if (this.lastIndex < points.length) {
          this.stackDepth += points[this.lastIndex].delta;
          if (this.lastIndex + 1 < points.length) this.distanceUntilNextPoint = points[this.lastIndex + 1].position - this.position;
        }
      }
    }
  };

  /**
   * Returns mutator utilization as a piecewise linear function.
   * Mutator utilization for a window size w is a function of time mu_w(t)
   * that shows how much time in [t, t+w] is left for the mutator relative
   * to the time window size.
   * More formally:
   * mu_w(t) = (w - total_time_spent_in_gc_in(t, t + w)) / w.
   * The range of mu_w(t) is [0..1].
   * See "A Parallel, Real-Time Garbage Collector" by Cheng et. al. for
   * more info [https://www.cs.cmu.edu/~guyb/papers/gc2001.pdf].
   *
   * All parameters must use the same time unit.
   * @param {number} start The start time of execution.
   * @param {number} end The end time of execution.
   * @param {number} timeWindow The size of the time window.
   * @param {!Array<!{start: number, end: number}>} intervals The list of
   *     GC pauses.
   */
  function mutatorUtilization(start, end, timeWindow, intervals) {
    var mu = new tr.b.PiecewiseLinearFunction();
    // If the interval is smaller than the time window, then the function is
    // empty.
    if (end - start <= timeWindow) return mu;
    // If there are GC pauses then the mutator utilization is 1.0.
    if (intervals.length === 0) {
      mu.push(start, 1.0, end - timeWindow, 1.0);
      return mu;
    }
    intervals = unionOfIntervals(intervals);
    // Create a point for the start and the end of each interval.
    var points = [];
    intervals.forEach(function (interval) {
      points.push({ position: interval.start, delta: 1 });
      points.push({ position: interval.end, delta: -1 });
    });
    points.sort((a, b) => a.position - b.position);
    points.push({ position: end, delta: 0 });
    // The left and the right limit of the sliding window.
    var left = new WindowEndpoint(start, points);
    var right = new WindowEndpoint(start, points);
    // Advance the right end-point until we get the correct window size.
    while (right.position - left.position < timeWindow) right.advance(timeWindow - (right.position - left.position));
    while (right.lastIndex < points.length) {
      // Advance the window end-points by the largest possible amount
      // without jumping over a point.
      var distanceUntilNextPoint = Math.min(left.distanceUntilNextPoint, right.distanceUntilNextPoint);
      var position1 = left.position;
      var value1 = right.cummulativePause - left.cummulativePause;
      left.advance(distanceUntilNextPoint);
      right.advance(distanceUntilNextPoint);
      // Add a new mutator utilization segment only if it is non-trivial.
      if (distanceUntilNextPoint > 0) {
        var position2 = left.position;
        var value2 = right.cummulativePause - left.cummulativePause;
        mu.push(position1, 1.0 - value1 / timeWindow, position2, 1.0 - value2 / timeWindow);
      }
    }
    return mu;
  }

  function hasV8Stats(globalMemoryDump) {
    var v8stats = undefined;
    globalMemoryDump.iterateContainerDumps(function (dump) {
      v8stats = v8stats || dump.getMemoryAllocatorDumpByFullName('v8');
    });
    return !!v8stats;
  }

  function rangeForMemoryDumps(model) {
    var startOfFirstDumpWithV8 = model.globalMemoryDumps.filter(hasV8Stats).reduce((start, dump) => Math.min(start, dump.start), Infinity);
    if (startOfFirstDumpWithV8 === Infinity) return new tr.b.Range(); // Empty range.
    return tr.b.Range.fromExplicitRange(startOfFirstDumpWithV8, Infinity);
  }

  return {
    findParent: findParent,
    groupAndProcessEvents: groupAndProcessEvents,
    isForcedGarbageCollectionEvent: isForcedGarbageCollectionEvent,
    isGarbageCollectionEvent: isGarbageCollectionEvent,
    isIdleTask: isIdleTask,
    isLowMemoryEvent: isLowMemoryEvent,
    isSubGarbageCollectionEvent: isSubGarbageCollectionEvent,
    isTopGarbageCollectionEvent: isTopGarbageCollectionEvent,
    isTopV8ExecuteEvent: isTopV8ExecuteEvent,
    isV8ExecuteEvent: isV8ExecuteEvent,
    mutatorUtilization: mutatorUtilization,
    subGarbageCollectionEventName: subGarbageCollectionEventName,
    topGarbageCollectionEventName: topGarbageCollectionEventName,
    rangeForMemoryDumps: rangeForMemoryDumps,
    unionOfIntervals: unionOfIntervals
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/piecewise_linear_function.js":44,"../../base/range.js":47,"../../base/range_utils.js":48,"../../base/unit.js":57,"../../value/histogram.js":189,"../metric_registry.js":83}],100:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../metric_registry.js");
require("../system_health/memory_metric.js");
require("./execution_metric.js");
require("./gc_metric.js");

'use strict';

global.tr.exportTo('tr.metrics.v8', function () {
  function v8AndMemoryMetrics(values, model) {
    tr.metrics.v8.executionMetric(values, model);
    tr.metrics.v8.gcMetric(values, model);
    tr.metrics.sh.memoryMetric(values, model, { rangeOfInterest: tr.metrics.v8.utils.rangeForMemoryDumps(model) });
  }

  tr.metrics.MetricRegistry.register(v8AndMemoryMetrics);

  return {
    v8AndMemoryMetrics: v8AndMemoryMetrics
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../metric_registry.js":83,"../system_health/memory_metric.js":90,"./execution_metric.js":97,"./gc_metric.js":98}],101:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");
require("./event_info.js");
require("./event_set.js");
require("./timed_event.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  function Alert(info, start, opt_associatedEvents, opt_args) {
    tr.model.TimedEvent.call(this, start);
    this.info = info;
    this.args = opt_args || {};
    this.associatedEvents = new tr.model.EventSet(opt_associatedEvents);
    this.associatedEvents.forEach(function (event) {
      event.addAssociatedAlert(this);
    }, this);
  }

  Alert.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get title() {
      return this.info.title;
    },

    get colorId() {
      return this.info.colorId;
    },

    get userFriendlyName() {
      return 'Alert ' + this.title + ' at ' + tr.b.Unit.byName.timeStampInMs.format(this.start);
    }
  };

  tr.model.EventRegistry.register(Alert, {
    name: 'alert',
    pluralName: 'alerts'
  });

  return {
    Alert: Alert
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57,"./event_info.js":118,"./event_set.js":120,"./timed_event.js":160}],102:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/extension_registry.js");
require("../base/guid.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  /**
   * Annotation is a base class that represents all annotation objects that
   * can be drawn on the timeline.
   *
   * @constructor
   */
  function Annotation() {
    this.guid_ = tr.b.GUID.allocateSimple();
    this.view_ = undefined;
  };

  Annotation.fromDictIfPossible = function (args) {
    if (args.typeName === undefined) throw new Error('Missing typeName argument');

    var typeInfo = Annotation.findTypeInfoMatching(function (typeInfo) {
      return typeInfo.metadata.typeName === args.typeName;
    });

    if (typeInfo === undefined) return undefined;

    return typeInfo.constructor.fromDict(args);
  };

  Annotation.fromDict = function () {
    throw new Error('Not implemented');
  };

  Annotation.prototype = {
    get guid() {
      return this.guid_;
    },

    // Invoked by trace model when this annotation is removed.
    onRemove: function () {},

    toDict: function () {
      throw new Error('Not implemented');
    },

    getOrCreateView: function (viewport) {
      if (!this.view_) this.view_ = this.createView_(viewport);
      return this.view_;
    },

    createView_: function () {
      throw new Error('Not implemented');
    }
  };

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(Annotation, options);

  Annotation.addEventListener('will-register', function (e) {
    if (!e.typeInfo.constructor.hasOwnProperty('fromDict')) throw new Error('Must have fromDict method');

    if (!e.typeInfo.metadata.typeName) throw new Error('Registered Annotations must provide typeName');
  });

  return {
    Annotation: Annotation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/extension_registry.js":35,"../base/guid.js":39}],103:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");
require("./timed_event.js");

'use strict';

/**
 * @fileoverview Provides the AsyncSlice class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * A AsyncSlice represents an interval of time during which an
   * asynchronous operation is in progress. An AsyncSlice consumes no CPU time
   * itself and so is only associated with Threads at its start and end point.
   *
   * @constructor
   */
  function AsyncSlice(category, title, colorId, start, args, duration, opt_isTopLevel, opt_cpuStart, opt_cpuDuration, opt_argsStripped) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    // We keep the original title from the trace file in originalTitle since
    // some sub-classes, e.g. NetAsyncSlice, change the title field.
    this.originalTitle = title;
    this.title = title;
    this.colorId = colorId;
    this.args = args;
    this.startStackFrame = undefined;
    this.endStackFrame = undefined;
    this.didNotFinish = false;
    this.important = false;
    this.subSlices = [];
    this.parentContainer_ = undefined;

    this.id = undefined;
    this.startThread = undefined;
    this.endThread = undefined;
    this.cpuStart = undefined;
    this.cpuDuration = undefined;
    this.argsStripped = false;

    this.startStackFrame = undefined;
    this.endStackFrame = undefined;

    this.duration = duration;

    // isTopLevel is set at import because only NESTABLE_ASYNC events might not
    // be topLevel. All legacy async events are toplevel by definition.
    this.isTopLevel = opt_isTopLevel === true;

    if (opt_cpuStart !== undefined) this.cpuStart = opt_cpuStart;

    if (opt_cpuDuration !== undefined) this.cpuDuration = opt_cpuDuration;

    if (opt_argsStripped !== undefined) this.argsStripped = opt_argsStripped;
  }

  AsyncSlice.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get analysisTypeName() {
      return this.title;
    },

    get parentContainer() {
      return this.parentContainer_;
    },

    set parentContainer(parentContainer) {
      this.parentContainer_ = parentContainer;
      for (var i = 0; i < this.subSlices.length; i++) {
        var subSlice = this.subSlices[i];
        if (subSlice.parentContainer === undefined) subSlice.parentContainer = parentContainer;
      }
    },

    get viewSubGroupTitle() {
      return this.title;
    },

    get userFriendlyName() {
      return 'Async slice ' + this.title + ' at ' + tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get stableId() {
      var parentAsyncSliceGroup = this.parentContainer.asyncSliceGroup;
      return parentAsyncSliceGroup.stableId + '.' + parentAsyncSliceGroup.slices.indexOf(this);
    },

    findTopmostSlicesRelativeToThisSlice: function* (eventPredicate, opt_this) {
      if (eventPredicate(this)) {
        yield this;
        return;
      }
      for (var s of this.subSlices) yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
    },

    findDescendentSlice: function (targetTitle) {
      if (!this.subSlices) return undefined;

      for (var i = 0; i < this.subSlices.length; i++) {
        if (this.subSlices[i].title == targetTitle) return this.subSlices[i];
        var slice = this.subSlices[i].findDescendentSlice(targetTitle);
        if (slice) return slice;
      }
      return undefined;
    },

    enumerateAllDescendents: function* () {
      for (var slice of this.subSlices) yield slice;
      for (var slice of this.subSlices) yield* slice.enumerateAllDescendents();
    },

    compareTo: function (that) {
      return this.title.localeCompare(that.title);
    }
  };

  tr.model.EventRegistry.register(AsyncSlice, {
    name: 'asyncSlice',
    pluralName: 'asyncSlices'
  });

  return {
    AsyncSlice: AsyncSlice
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57,"./timed_event.js":160}],104:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/guid.js");
require("../base/range.js");
require("./async_slice.js");
require("./event_container.js");

'use strict';

/**
 * @fileoverview Provides the AsyncSliceGroup class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * A group of AsyncSlices associated with a thread.
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function AsyncSliceGroup(parentContainer, opt_name) {
    tr.model.EventContainer.call(this);
    this.parentContainer_ = parentContainer;
    this.slices = [];
    this.name_ = opt_name;
    this.viewSubGroups_ = undefined;
  }

  AsyncSliceGroup.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parentContainer() {
      return this.parentContainer_;
    },

    get model() {
      return this.parentContainer_.parent.model;
    },

    get stableId() {
      return this.parentContainer_.stableId + '.AsyncSliceGroup';
    },

    getSettingsKey: function () {
      if (!this.name_) return undefined;
      var parentKey = this.parentContainer_.getSettingsKey();
      if (!parentKey) return undefined;
      return parentKey + '.' + this.name_;
    },

    /**
     * Helper function that pushes the provided slice onto the slices array.
     */
    push: function (slice) {
      slice.parentContainer = this.parentContainer;
      this.slices.push(slice);
      return slice;
    },

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    },

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified, including all nested subSlices if there are any.
     */
    shiftTimestampsForward: function (amount) {
      for (var sI = 0; sI < this.slices.length; sI++) {
        var slice = this.slices[sI];
        slice.start = slice.start + amount;
        // Shift all nested subSlices recursively.
        var shiftSubSlices = function (subSlices) {
          if (subSlices === undefined || subSlices.length === 0) return;
          for (var sJ = 0; sJ < subSlices.length; sJ++) {
            subSlices[sJ].start += amount;
            shiftSubSlices(subSlices[sJ].subSlices);
          }
        };
        shiftSubSlices(slice.subSlices);
      }
    },

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds: function () {
      this.bounds.reset();
      for (var i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    },

    /**
     * Gets the sub-groups in this A-S-G defined by the group titles.
     *
     * @return {Array} An array of AsyncSliceGroups where each group has
     * slices that started on the same thread.
     */
    get viewSubGroups() {
      if (this.viewSubGroups_ === undefined) {
        var prefix = '';
        if (this.name !== undefined) prefix = this.name + '.';else prefix = '';

        var subGroupsByTitle = {};
        for (var i = 0; i < this.slices.length; ++i) {
          var slice = this.slices[i];
          var subGroupTitle = slice.viewSubGroupTitle;
          if (!subGroupsByTitle[subGroupTitle]) {
            subGroupsByTitle[subGroupTitle] = new AsyncSliceGroup(this.parentContainer_, prefix + subGroupTitle);
          }
          subGroupsByTitle[subGroupTitle].push(slice);
        }
        this.viewSubGroups_ = tr.b.dictionaryValues(subGroupsByTitle);
        this.viewSubGroups_.sort(function (a, b) {
          return a.slices[0].compareTo(b.slices[0]);
        });
      }
      return this.viewSubGroups_;
    },

    findTopmostSlicesInThisContainer: function* (eventPredicate, opt_this) {
      for (var slice of this.slices) {
        if (slice.isTopLevel) {
          yield* slice.findTopmostSlicesRelativeToThisSlice(eventPredicate, opt_this);
        }
      }
    },

    childEvents: function* () {
      // Async slices normally don't have sub-slices, and when they do,
      // the sub-slice is specific to the type of async slice. Thus,
      // it is not expected for sub-slices to themselves have sub-sub-slices,
      // which is why we don't recurse into the sub-slices here.
      for (var slice of this.slices) {
        yield slice;
        if (slice.subSlices) yield* slice.subSlices;
      }
    },

    childEventContainers: function* () {}
  };

  return {
    AsyncSliceGroup: AsyncSliceGroup
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/guid.js":39,"../base/range.js":47,"./async_slice.js":103,"./event_container.js":117}],105:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/iteration_helpers.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  var ClockDomainId = {
    BATTOR: 'BATTOR',

    // NOTE: Exists for backwards compatibility with old Chrome traces which
    // didn't explicitly specify the clock being used.
    UNKNOWN_CHROME_LEGACY: 'UNKNOWN_CHROME_LEGACY',

    LINUX_CLOCK_MONOTONIC: 'LINUX_CLOCK_MONOTONIC',
    LINUX_FTRACE_GLOBAL: 'LINUX_FTRACE_GLOBAL',
    MAC_MACH_ABSOLUTE_TIME: 'MAC_MACH_ABSOLUTE_TIME',
    WIN_ROLLOVER_PROTECTED_TIME_GET_TIME: 'WIN_ROLLOVER_PROTECTED_TIME_GET_TIME',
    WIN_QPC: 'WIN_QPC',

    // "Telemetry" isn't really a clock domain because Telemetry actually
    // can use one of several clock domains, just like Chrome. However,
    // because there's a chance that Telemetry is running off of the same
    // clock as Chrome (e.g. LINUX_CLOCK_MONOTONIC) but on a separate device
    // (i.e. on a host computer with Chrome running on an attached phone),
    // there's a chance that Chrome and Telemetry will erroneously get put into
    // the same clock domain. The solution for this is that clock domains should
    // actually be some (unique_device_id, clock_id) tuple. For now, though,
    // we'll hack around this by putting Telemetry into its own clock domain.
    TELEMETRY: 'TELEMETRY'
  };

  var POSSIBLE_CHROME_CLOCK_DOMAINS = new Set([ClockDomainId.UNKNOWN_CHROME_LEGACY, ClockDomainId.LINUX_CLOCK_MONOTONIC, ClockDomainId.MAC_MACH_ABSOLUTE_TIME, ClockDomainId.WIN_ROLLOVER_PROTECTED_TIME_GET_TIME, ClockDomainId.WIN_QPC]);

  // The number of milliseconds above which the BattOr sync is no longer
  // considered "fast", and it's more accurate to use the sync start timestamp
  // instead of the normal sync timestamp due to a bug in the Chrome serial code
  // making serial reads too slow.
  var BATTOR_FAST_SYNC_THRESHOLD_MS = 3;

  /**
   * A ClockSyncManager holds clock sync markers and uses them to shift
   * timestamps from agents' clock domains onto the model's clock domain.
   *
   * In this context, a "clock domain" is a single perspective on the passage
   * of time. A single computer can have multiple clock domains because it
   * can have multiple methods of retrieving a timestamp (e.g.
   * clock_gettime(CLOCK_MONOTONIC) and clock_gettime(CLOCK_REALTIME) on Linux).
   * Another common reason for multiple clock domains within a single trace
   * is that traces can span devices (e.g. a laptop collecting a Chrome trace
   * can have its power consumption recorded by a second device and the two
   * traces can be viewed alongside each other).
   *
   * For more information on how to synchronize multiple time domains using this
   * method, see: http://bit.ly/1OVkqju.
   *
   * @constructor
   */
  function ClockSyncManager() {
    // A set of all domains seen by the ClockSyncManager.
    this.domainsSeen_ = new Set();
    this.markersBySyncId_ = new Map();
    // transformerMapByDomainId_[fromDomainId][toDomainId] returns the function
    // that converts timestamps in the "from" domain to timestamps in the "to"
    // domain.
    this.transformerMapByDomainId_ = {};
  }

  ClockSyncManager.prototype = {
    /**
     * Adds a clock sync marker to the list of known markers.
     *
     * @param {string} domainId The clock domain that the marker is in.
     * @param {string} syncId The identifier shared by both sides of the clock
     *                 sync marker.
     * @param {number} startTs The time (in ms) at which the sync started.
     * @param {number=} opt_endTs The time (in ms) at which the sync ended. If
     *                  unspecified, it's assumed to be the same as the start,
     *                  indicating an instantaneous sync.
     */
    addClockSyncMarker: function (domainId, syncId, startTs, opt_endTs) {
      this.onDomainSeen_(domainId);

      if (tr.b.dictionaryValues(ClockDomainId).indexOf(domainId) < 0) {
        throw new Error('"' + domainId + '" is not in the list of known ' + 'clock domain IDs.');
      }

      if (this.modelDomainId_) {
        throw new Error('Cannot add new clock sync markers after getting ' + 'a model time transformer.');
      }

      var marker = new ClockSyncMarker(domainId, startTs, opt_endTs);

      if (!this.markersBySyncId_.has(syncId)) {
        this.markersBySyncId_.set(syncId, [marker]);
        return;
      }

      var markers = this.markersBySyncId_.get(syncId);

      if (markers.length === 2) {
        throw new Error('Clock sync with ID "' + syncId + '" is already ' + 'complete - cannot add a third clock sync marker to it.');
      }

      if (markers[0].domainId === domainId) throw new Error('A clock domain cannot sync with itself.');

      markers.push(marker);
      this.onSyncCompleted_(markers[0], marker);
    },

    // TODO(charliea): Remove this once the clockSyncMetric is no longer using
    // it.
    get markersBySyncId() {
      return this.markersBySyncId_;
    },

    /** @return {Set<String>} The string IDs of the domains seen so far. */
    get domainsSeen() {
      return this.domainsSeen_;
    },

    /**
     * Returns a function that, given a timestamp in the domain with |domainId|,
     * returns a timestamp in the model's clock domain.
     *
     * NOTE: All clock sync markers should be added before calling this function
     * for the first time. This is because the first time that this function is
     * called, a model clock domain is selected. This clock domain must have
     * syncs connecting it with all other clock domains. If multiple clock
     * domains are viable candidates, the one with the clock domain ID that is
     * the first alphabetically is selected.
     */
    getModelTimeTransformer: function (domainId) {
      return this.getModelTimeTransformerRaw_(domainId).fn;
    },

    /**
     * Returns the error associated with the transformation given by
     * |getModelTimeTransformer(domainId)|.
     */
    getModelTimeTransformerError: function (domainId) {
      return this.getModelTimeTransformerRaw_(domainId).error;
    },

    getModelTimeTransformerRaw_: function (domainId) {
      this.onDomainSeen_(domainId);

      if (!this.modelDomainId_) this.selectModelDomainId_();

      var transformer = this.getTransformerBetween_(domainId, this.modelDomainId_);
      if (!transformer) {
        throw new Error('No clock sync markers exist pairing clock domain "' + domainId + '" ' + 'with model clock domain "' + this.modelDomainId_ + '".');
      }

      return transformer;
    },

    /**
     * Returns a function that, given a timestamp in the "from" domain, returns
     * a timestamp in the "to" domain.
     */
    getTransformerBetween_: function (fromDomainId, toDomainId) {
      // Do a breadth-first search from the "from" domain until we reach the
      // "to" domain.
      var visitedDomainIds = new Set();
      // Keep a queue of nodes to visit, starting with the "from" domain.
      var queue = [{
        domainId: fromDomainId,
        transformer: Transformer.IDENTITY
      }];

      while (queue.length > 0) {
        // NOTE: Using a priority queue here would theoretically be much more
        // efficient, but the actual performance difference is negligible given
        // how few clock domains we have in a trace.
        queue.sort((domain1, domain2) => domain1.transformer.error - domain2.transformer.error);

        var current = queue.shift();

        if (current.domainId === toDomainId) return current.transformer;

        if (visitedDomainIds.has(current.domainId)) continue;
        visitedDomainIds.add(current.domainId);

        var outgoingTransformers = this.transformerMapByDomainId_[current.domainId];

        if (!outgoingTransformers) continue;

        // Add all nodes that are directly connected to this one to the queue.
        for (var outgoingDomainId in outgoingTransformers) {
          // We have two transformers: one to get us from the "from" domain to
          // the current domain, and another to get us from the current domain
          // to the next domain. By composing those two transformers, we can
          // create one that gets us from the "from" domain to the next domain.
          var toNextDomainTransformer = outgoingTransformers[outgoingDomainId];
          var toCurrentDomainTransformer = current.transformer;

          queue.push({
            domainId: outgoingDomainId,
            transformer: Transformer.compose(toNextDomainTransformer, toCurrentDomainTransformer)
          });
        }
      }

      return undefined;
    },

    /**
     * Selects the domain to use as the model domain from among the domains
     * with registered markers.
     *
     * This is necessary because some common domain must be chosen before all
     * timestamps can be shifted onto the same domain.
     *
     * For the time being, preference is given to Chrome clock domains. If no
     * Chrome clock domain is present, the first clock domain alphabetically
     * is selected.
     */
    selectModelDomainId_: function () {
      this.ensureAllDomainsAreConnected_();

      // While we're migrating to the new clock sync system, we have to make
      // sure to prefer the Chrome clock domain because legacy clock sync
      // mechanisms assume that's the case.
      for (var chromeDomainId of POSSIBLE_CHROME_CLOCK_DOMAINS) {
        if (this.domainsSeen_.has(chromeDomainId)) {
          this.modelDomainId_ = chromeDomainId;
          return;
        }
      }

      var domainsSeenArray = Array.from(this.domainsSeen_);
      domainsSeenArray.sort();
      this.modelDomainId_ = domainsSeenArray[0];
    },

    /** Throws an error if all domains are not connected. */
    ensureAllDomainsAreConnected_: function () {
      // NOTE: this is a ridiculously inefficient way to do this. Given how few
      // clock domains we're likely to have, this shouldn't be a problem.
      var firstDomainId = undefined;
      for (var domainId of this.domainsSeen_) {
        if (!firstDomainId) {
          firstDomainId = domainId;
          continue;
        }

        if (!this.getTransformerBetween_(firstDomainId, domainId)) {
          throw new Error('Unable to select a master clock domain because no ' + 'path can be found from "' + firstDomainId + '" to "' + domainId + '".');
        }
      }

      return true;
    },

    /** Observer called each time that a clock domain is seen. */
    onDomainSeen_: function (domainId) {
      if (domainId === ClockDomainId.UNKNOWN_CHROME_LEGACY && !this.domainsSeen_.has(ClockDomainId.UNKNOWN_CHROME_LEGACY)) {
        // UNKNOWN_CHROME_LEGACY was just seen for the first time: collapse it
        // and the other Chrome clock domains into one.
        //
        // This makes sure that we don't have two separate clock sync graphs:
        // one attached to UNKNOWN_CHROME_LEGACY and the other attached to the
        // real Chrome clock domain.
        for (var chromeDomainId of POSSIBLE_CHROME_CLOCK_DOMAINS) {
          if (chromeDomainId === ClockDomainId.UNKNOWN_CHROME_LEGACY) continue;

          this.collapseDomains_(ClockDomainId.UNKNOWN_CHROME_LEGACY, chromeDomainId);
        }
      }

      this.domainsSeen_.add(domainId);
    },

    /**
     * Observer called when a complete sync is made involving |marker1| and
     * |marker2|.
     */
    onSyncCompleted_: function (marker1, marker2) {
      var forwardTransformer = Transformer.fromMarkers(marker1, marker2);
      var backwardTransformer = Transformer.fromMarkers(marker2, marker1);

      var existingTransformer = this.getOrCreateTransformerMap_(marker1.domainId)[marker2.domainId];
      if (!existingTransformer || forwardTransformer.error < existingTransformer.error) {
        this.getOrCreateTransformerMap_(marker1.domainId)[marker2.domainId] = forwardTransformer;
        this.getOrCreateTransformerMap_(marker2.domainId)[marker1.domainId] = backwardTransformer;
      }
    },

    /** Makes timestamps in the two clock domains interchangeable. */
    collapseDomains_: function (domain1Id, domain2Id) {
      this.getOrCreateTransformerMap_(domain1Id)[domain2Id] = this.getOrCreateTransformerMap_(domain2Id)[domain1Id] = Transformer.IDENTITY;
    },

    /**
     * Returns (and creates if it doesn't exist) the transformer map describing
     * how to transform timestamps between directly connected clock domains.
     */
    getOrCreateTransformerMap_: function (domainId) {
      if (!this.transformerMapByDomainId_[domainId]) this.transformerMapByDomainId_[domainId] = {};

      return this.transformerMapByDomainId_[domainId];
    }
  };

  /**
   * A ClockSyncMarker is an internal entity that represents a marker in a
   * trace log indicating that a clock sync happened at a specified time.
   *
   * If no end timestamp argument is specified in the constructor, it's assumed
   * that the end timestamp is the same as the start (i.e. the clock sync
   * was instantaneous).
   */
  function ClockSyncMarker(domainId, startTs, opt_endTs) {
    this.domainId = domainId;
    this.startTs = startTs;
    this.endTs = opt_endTs === undefined ? startTs : opt_endTs;
  }

  ClockSyncMarker.prototype = {
    get duration() {
      return this.endTs - this.startTs;
    },
    get ts() {
      return this.startTs + this.duration / 2;
    }
  };

  /**
   * A Transformer encapsulates information about how to turn timestamps in one
   * clock domain into timestamps in another. It also stores additional data
   * about the maximum error involved in doing so.
   */
  function Transformer(fn, error) {
    this.fn = fn;
    this.error = error;
  }

  Transformer.IDENTITY = new Transformer(tr.b.identity, 0);

  /**
   * Given two transformers, creates a third that's a composition of the two.
   *
   * @param {function(Number): Number} aToB A function capable of converting a
   *     timestamp from domain A to domain B.
   * @param {function(Number): Number} bToC A function capable of converting a
   *     timestamp from domain B to domain C.
   *
   * @return {function(Number): Number} A function capable of converting a
   *     timestamp from domain A to domain C.
   */
  Transformer.compose = function (aToB, bToC) {
    return new Transformer(ts => bToC.fn(aToB.fn(ts)), aToB.error + bToC.error);
  };

  /**
   * Returns a function that, given a timestamp in |fromMarker|'s domain,
   * returns a timestamp in |toMarker|'s domain.
   */
  Transformer.fromMarkers = function (fromMarker, toMarker) {
    var fromTs = fromMarker.ts,
        toTs = toMarker.ts;

    // TODO(charliea): Usually, we estimate that the clock sync marker is
    // issued by the agent exactly in the middle of the controller's start and
    // end timestamps. However, there's currently a bug in the Chrome serial
    // code that's making the clock sync ack for BattOr take much longer to
    // read than it should (by about 8ms). This is causing the above estimate
    // of the controller's sync timestamp to be off by a substantial enough
    // amount that it makes traces hard to read. For now, make an exception
    // for BattOr and just use the controller's start timestamp as the sync
    // time. In the medium term, we should fix the Chrome serial code in order
    // to remove this special logic and get an even more accurate estimate.
    if (fromMarker.domainId === ClockDomainId.BATTOR && toMarker.duration > BATTOR_FAST_SYNC_THRESHOLD_MS) {
      toTs = toMarker.startTs;
    } else if (toMarker.domainId === ClockDomainId.BATTOR && fromMarker.duration > BATTOR_FAST_SYNC_THRESHOLD_MS) {
      fromTs = fromMarker.startTs;
    }

    var tsShift = toTs - fromTs;
    return new Transformer(ts => ts + tsShift, fromMarker.duration + toMarker.duration);
  };

  return {
    ClockDomainId: ClockDomainId,
    ClockSyncManager: ClockSyncManager
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41}],106:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./location.js");
require("./annotation.js");
require("./rect_annotation.js");
require("../ui/annotations/comment_box_annotation_view.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  function CommentBoxAnnotation(location, text) {
    tr.model.Annotation.apply(this, arguments);

    this.location = location;
    this.text = text;
  }

  CommentBoxAnnotation.fromDict = function (dict) {
    var args = dict.args;
    var location = new tr.model.Location(args.location.xWorld, args.location.yComponents);
    return new tr.model.CommentBoxAnnotation(location, args.text);
  };

  CommentBoxAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    onRemove: function () {
      this.view_.removeTextArea();
    },

    toDict: function () {
      return {
        typeName: 'comment_box',
        args: {
          text: this.text,
          location: this.location.toDict()
        }
      };
    },

    createView_: function (viewport) {
      return new tr.ui.annotations.CommentBoxAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(CommentBoxAnnotation, { typeName: 'comment_box' });

  return {
    CommentBoxAnnotation: CommentBoxAnnotation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../ui/annotations/comment_box_annotation_view.js":171,"./annotation.js":102,"./location.js":133,"./rect_annotation.js":146}],107:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  /**
   * Indicates how much of a compound-event is selected [if any].
   *
   * The CompoundEventSelectionState enum is used with events that are
   * directly selectable, but also have associated events, too, that can be
   * selected. In this situation, there are a variety of different
   * selected states other than just "yes, no". This enum encodes those
   * various possible states.
   */
  var CompoundEventSelectionState = {
    // Basic bit states.
    NOT_SELECTED: 0,
    EVENT_SELECTED: 0x1,
    SOME_ASSOCIATED_EVENTS_SELECTED: 0x2,
    ALL_ASSOCIATED_EVENTS_SELECTED: 0x4,

    // Common combinations.
    EVENT_AND_SOME_ASSOCIATED_SELECTED: 0x1 | 0x2,
    EVENT_AND_ALL_ASSOCIATED_SELECTED: 0x1 | 0x4
  };

  return {
    CompoundEventSelectionState: CompoundEventSelectionState
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],108:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  return {
    // Since the PID of the browser process is not known to the child processes,
    // we let them use "pid_ref = -1" to reference an object created in the
    // browser process.
    BROWSER_PROCESS_PID_REF: -1,

    // The default scope of object events, when not explicitly specified.
    OBJECT_DEFAULT_SCOPE: 'ptr'
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],109:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./timed_event.js");

'use strict';

/**
 * @fileoverview Provides the ContainerMemoryDump class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * The ContainerMemoryDump represents an abstract container memory dump.
   * @constructor
   */
  function ContainerMemoryDump(start) {
    tr.model.TimedEvent.call(this, start);

    this.levelOfDetail = undefined;

    this.memoryAllocatorDumps_ = undefined;
    this.memoryAllocatorDumpsByFullName_ = undefined;
  };

  /**
   * Memory dump level of detail. See base::trace_event::MemoryDumpLevelOfDetail
   * in the Chromium repository.
   *
   * @enum
   */
  ContainerMemoryDump.LevelOfDetail = {
    BACKGROUND: 0,
    LIGHT: 1,
    DETAILED: 2
  };

  ContainerMemoryDump.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    shiftTimestampsForward: function (amount) {
      this.start += amount;
    },

    get memoryAllocatorDumps() {
      return this.memoryAllocatorDumps_;
    },

    set memoryAllocatorDumps(memoryAllocatorDumps) {
      this.memoryAllocatorDumps_ = memoryAllocatorDumps;
      this.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
    },

    getMemoryAllocatorDumpByFullName: function (fullName) {
      if (this.memoryAllocatorDumps_ === undefined) return undefined;

      // Lazily generate the index if necessary.
      if (this.memoryAllocatorDumpsByFullName_ === undefined) {
        var index = {};
        function addDumpsToIndex(dumps) {
          dumps.forEach(function (dump) {
            index[dump.fullName] = dump;
            addDumpsToIndex(dump.children);
          });
        };
        addDumpsToIndex(this.memoryAllocatorDumps_);
        this.memoryAllocatorDumpsByFullName_ = index;
      }

      return this.memoryAllocatorDumpsByFullName_[fullName];
    },

    forceRebuildingMemoryAllocatorDumpByFullNameIndex: function () {
      // Clear the index and generate it lazily.
      this.memoryAllocatorDumpsByFullName_ = undefined;
    },

    iterateRootAllocatorDumps: function (fn, opt_this) {
      if (this.memoryAllocatorDumps === undefined) return;
      this.memoryAllocatorDumps.forEach(fn, opt_this || this);
    }
  };

  return {
    ContainerMemoryDump: ContainerMemoryDump
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./timed_event.js":160}],110:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/guid.js");
require("../base/range.js");
require("./counter_series.js");
require("./event_container.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  /**
   * A container holding all series of a given type of measurement.
   *
   * As an example, if we're measuring the throughput of data sent over several
   * USB connections, the throughput of each cable might be added as a separate
   * series to a single counter.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function Counter(parent, id, category, name) {
    tr.model.EventContainer.call(this);

    this.parent_ = parent;
    this.id_ = id;
    this.category_ = category || '';
    this.name_ = name;

    this.series_ = [];
    this.totals = [];
  }

  Counter.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parent() {
      return this.parent_;
    },

    get id() {
      return this.id_;
    },

    get category() {
      return this.category_;
    },

    get name() {
      return this.name_;
    },

    childEvents: function* () {},

    childEventContainers: function* () {
      yield* this.series;
    },

    set timestamps(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set seriesNames(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set seriesColors(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    set samples(arg) {
      throw new Error('Bad counter API. No cookie.');
    },

    addSeries: function (series) {
      series.counter = this;
      series.seriesIndex = this.series_.length;
      this.series_.push(series);
      return series;
    },

    getSeries: function (idx) {
      return this.series_[idx];
    },

    get series() {
      return this.series_;
    },

    get numSeries() {
      return this.series_.length;
    },

    get numSamples() {
      if (this.series_.length === 0) return 0;
      return this.series_[0].length;
    },

    get timestamps() {
      if (this.series_.length === 0) return [];
      return this.series_[0].timestamps;
    },

    /**
     * Obtains min, max, avg, values, start, and end for different series for
     * a given counter
     *     getSampleStatistics([0,1])
     * The statistics objects that this returns are an array of objects, one
     * object for each series for the counter in the form:
     * {min: minVal, max: maxVal, avg: avgVal, start: startVal, end: endVal}
     *
     * @param {Array.<Number>} Indices to summarize.
     * @return {Object} An array of statistics. Each element in the array
     * has data for one of the series in the selected counter.
     */
    getSampleStatistics: function (sampleIndices) {
      sampleIndices.sort();

      var ret = [];
      this.series_.forEach(function (series) {
        ret.push(series.getStatistics(sampleIndices));
      });
      return ret;
    },

    /**
     * Shifts all the timestamps inside this counter forward by the amount
     * specified.
     */
    shiftTimestampsForward: function (amount) {
      for (var i = 0; i < this.series_.length; ++i) this.series_[i].shiftTimestampsForward(amount);
    },

    /**
     * Updates the bounds for this counter based on the samples it contains.
     */
    updateBounds: function () {
      this.totals = [];
      this.maxTotal = 0;
      this.bounds.reset();

      if (this.series_.length === 0) return;

      var firstSeries = this.series_[0];
      var lastSeries = this.series_[this.series_.length - 1];

      this.bounds.addValue(firstSeries.getTimestamp(0));
      this.bounds.addValue(lastSeries.getTimestamp(lastSeries.length - 1));

      var numSeries = this.numSeries;
      this.maxTotal = -Infinity;

      // Sum the samples at each timestamp.
      // Note, this assumes that all series have all timestamps.
      for (var i = 0; i < firstSeries.length; ++i) {
        var total = 0;
        this.series_.forEach(function (series) {
          total += series.getSample(i).value;
          this.totals.push(total);
        }.bind(this));

        this.maxTotal = Math.max(total, this.maxTotal);
      }
    }
  };

  /**
   * Comparison between counters that orders by parent.compareTo, then name.
   */
  Counter.compare = function (x, y) {
    var tmp = x.parent.compareTo(y);
    if (tmp != 0) return tmp;
    var tmp = x.name.localeCompare(y.name);
    if (tmp == 0) return x.tid - y.tid;
    return tmp;
  };

  return {
    Counter: Counter
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/guid.js":39,"../base/range.js":47,"./counter_series.js":112,"./event_container.js":117}],111:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/iteration_helpers.js");
require("../base/sorted_array_utils.js");
require("../base/unit.js");
require("./event.js");
require("./event_registry.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  /**
   * The value of a given measurement at a given time.
   *
   * As an example, if we're measuring the throughput of data sent over a USB
   * connection, each counter sample might represent the instantaneous
   * throughput of the connection at a given time.
   *
   * @constructor
   * @extends {Event}
   */
  function CounterSample(series, timestamp, value) {
    tr.model.Event.call(this);
    this.series_ = series;
    this.timestamp_ = timestamp;
    this.value_ = value;
  }

  CounterSample.groupByTimestamp = function (samples) {
    var samplesByTimestamp = tr.b.group(samples, function (sample) {
      return sample.timestamp;
    });

    var timestamps = tr.b.dictionaryKeys(samplesByTimestamp);
    timestamps.sort();
    var groups = [];
    for (var i = 0; i < timestamps.length; i++) {
      var ts = timestamps[i];
      var group = samplesByTimestamp[ts];
      group.sort(function (x, y) {
        return x.series.seriesIndex - y.series.seriesIndex;
      });
      groups.push(group);
    }
    return groups;
  };

  CounterSample.prototype = {
    __proto__: tr.model.Event.prototype,

    get series() {
      return this.series_;
    },

    get timestamp() {
      return this.timestamp_;
    },

    get value() {
      return this.value_;
    },

    set timestamp(timestamp) {
      this.timestamp_ = timestamp;
    },

    addBoundsToRange: function (range) {
      range.addValue(this.timestamp);
    },

    getSampleIndex: function () {
      return tr.b.findLowIndexInSortedArray(this.series.timestamps, function (x) {
        return x;
      }, this.timestamp_);
    },

    get userFriendlyName() {
      return 'Counter sample from ' + this.series_.title + ' at ' + tr.b.Unit.byName.timeStampInMs.format(this.timestamp);
    }
  };

  tr.model.EventRegistry.register(CounterSample, {
    name: 'counterSample',
    pluralName: 'counterSamples'
  });

  return {
    CounterSample: CounterSample
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41,"../base/sorted_array_utils.js":52,"../base/unit.js":57,"./event.js":116,"./event_registry.js":119}],112:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./counter_sample.js");
require("./event_container.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  var CounterSample = tr.model.CounterSample;

  /**
   * A container holding all samples of a given measurement over time.
   *
   * As an example, a counter series might measure the throughput of data sent
   * over a USB connection, with each sample representing the instantaneous
   * throughput of the connection.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function CounterSeries(name, color) {
    tr.model.EventContainer.call(this);

    this.name_ = name;
    this.color_ = color;

    this.timestamps_ = [];
    this.samples_ = [];

    // Set by counter.addSeries
    this.counter = undefined;
    this.seriesIndex = undefined;
  }

  CounterSeries.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get length() {
      return this.timestamps_.length;
    },

    get name() {
      return this.name_;
    },

    get color() {
      return this.color_;
    },

    get samples() {
      return this.samples_;
    },

    get timestamps() {
      return this.timestamps_;
    },

    getSample: function (idx) {
      return this.samples_[idx];
    },

    getTimestamp: function (idx) {
      return this.timestamps_[idx];
    },

    addCounterSample: function (ts, val) {
      var sample = new CounterSample(this, ts, val);
      this.addSample(sample);
      return sample;
    },

    addSample: function (sample) {
      this.timestamps_.push(sample.timestamp);
      this.samples_.push(sample);
    },

    getStatistics: function (sampleIndices) {
      var sum = 0;
      var min = Number.MAX_VALUE;
      var max = -Number.MAX_VALUE;

      for (var i = 0; i < sampleIndices.length; ++i) {
        var sample = this.getSample(sampleIndices[i]).value;

        sum += sample;
        min = Math.min(sample, min);
        max = Math.max(sample, max);
      }

      return {
        min: min,
        max: max,
        avg: sum / sampleIndices.length,
        start: this.getSample(sampleIndices[0]).value,
        end: this.getSample(sampleIndices.length - 1).value
      };
    },

    shiftTimestampsForward: function (amount) {
      for (var i = 0; i < this.timestamps_.length; ++i) {
        this.timestamps_[i] += amount;
        this.samples_[i].timestamp = this.timestamps_[i];
      }
    },

    childEvents: function* () {
      yield* this.samples_;
    },

    childEventContainers: function* () {}
  };

  return {
    CounterSeries: CounterSeries
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./counter_sample.js":111,"./event_container.js":117}],113:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range.js");
require("./counter.js");
require("./cpu_slice.js");
require("./process_base.js");
require("./thread_time_slice.js");

'use strict';

/**
 * @fileoverview Provides the Cpu class.
 */
global.tr.exportTo('tr.model', function () {

  var ColorScheme = tr.b.ColorScheme;
  var Counter = tr.model.Counter;
  var CpuSlice = tr.model.CpuSlice;

  /**
   * The Cpu represents a Cpu from the kernel's point of view.
   * @constructor
   */
  function Cpu(kernel, number) {
    if (kernel === undefined || number === undefined) throw new Error('Missing arguments');
    this.kernel = kernel;
    this.cpuNumber = number;
    this.slices = [];
    this.counters = {};
    this.bounds_ = new tr.b.Range();
    this.samples_ = undefined; // Set during createSubSlices

    // Start timestamp of the last active thread.
    this.lastActiveTimestamp_ = undefined;

    // Identifier of the last active thread. On Linux, it's a pid while on
    // Windows it's a thread id.
    this.lastActiveThread_ = undefined;

    // Name and arguments of the last active thread.
    this.lastActiveName_ = undefined;
    this.lastActiveArgs_ = undefined;
  }

  Cpu.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get samples() {
      return this.samples_;
    },

    get userFriendlyName() {
      return 'CPU ' + this.cpuNumber;
    },

    findTopmostSlicesInThisContainer: function* (eventPredicate, opt_this) {
      // All CpuSlices are toplevel since CpuSlices do not nest.
      for (var s of this.slices) {
        yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate, opt_this);
      }
    },

    childEvents: function* () {
      yield* this.slices;

      if (this.samples_) yield* this.samples_;
    },

    childEventContainers: function* () {
      yield* tr.b.dictionaryValues(this.counters);
    },

    /**
     * @return {Counter} The counter on this CPU with the given category/name
     * combination, creating it if it doesn't exist.
     */
    getOrCreateCounter: function (cat, name) {
      var id = cat + '.' + name;
      if (!this.counters[id]) this.counters[id] = new Counter(this, id, cat, name);
      return this.counters[id];
    },

    /**
     * @return {Counter} the counter on this CPU with the given category/name
     * combination, or undefined if it doesn't exist.
     */
    getCounter: function (cat, name) {
      var id = cat + '.' + name;
      if (!this.counters[id]) return undefined;
      return this.counters[id];
    },

    /**
     * Shifts all the timestamps inside this CPU forward by the amount
     * specified.
     */
    shiftTimestampsForward: function (amount) {
      for (var sI = 0; sI < this.slices.length; sI++) this.slices[sI].start = this.slices[sI].start + amount;
      for (var id in this.counters) this.counters[id].shiftTimestampsForward(amount);
    },

    /**
     * Updates the range based on the current slices attached to the cpu.
     */
    updateBounds: function () {
      this.bounds_.reset();
      if (this.slices.length) {
        this.bounds_.addValue(this.slices[0].start);
        this.bounds_.addValue(this.slices[this.slices.length - 1].end);
      }
      for (var id in this.counters) {
        this.counters[id].updateBounds();
        this.bounds_.addRange(this.counters[id].bounds);
      }
      if (this.samples_ && this.samples_.length) {
        this.bounds_.addValue(this.samples_[0].start);
        this.bounds_.addValue(this.samples_[this.samples_.length - 1].end);
      }
    },

    createSubSlices: function () {
      this.samples_ = this.kernel.model.samples.filter(function (sample) {
        return sample.cpu == this;
      }, this);
    },

    addCategoriesToDict: function (categoriesDict) {
      for (var i = 0; i < this.slices.length; i++) categoriesDict[this.slices[i].category] = true;
      for (var id in this.counters) categoriesDict[this.counters[id].category] = true;
      for (var i = 0; i < this.samples_.length; i++) categoriesDict[this.samples_[i].category] = true;
    },

    /*
     * Returns the index of the slice in the CPU's slices, or undefined.
     */
    indexOf: function (cpuSlice) {
      var i = tr.b.findLowIndexInSortedArray(this.slices, function (slice) {
        return slice.start;
      }, cpuSlice.start);
      if (this.slices[i] !== cpuSlice) return undefined;
      return i;
    },

    /**
     * Closes the thread running on the CPU. |endTimestamp| is the timestamp
     * at which the thread was unscheduled. |args| is merged with the arguments
     * specified when the thread was initially scheduled.
     */
    closeActiveThread: function (endTimestamp, args) {
      // Don't generate a slice if the last active thread is the idle task.
      if (this.lastActiveThread_ == undefined || this.lastActiveThread_ == 0) return;

      if (endTimestamp < this.lastActiveTimestamp_) {
        throw new Error('The end timestamp of a thread running on CPU ' + this.cpuNumber + ' is before its start timestamp.');
      }

      // Merge |args| with |this.lastActiveArgs_|. If a key is in both
      // dictionaries, the value from |args| is used.
      for (var key in args) {
        this.lastActiveArgs_[key] = args[key];
      }

      var duration = endTimestamp - this.lastActiveTimestamp_;
      var slice = new tr.model.CpuSlice('', this.lastActiveName_, ColorScheme.getColorIdForGeneralPurposeString(this.lastActiveName_), this.lastActiveTimestamp_, this.lastActiveArgs_, duration);
      slice.cpu = this;
      this.slices.push(slice);

      // Clear the last state.
      this.lastActiveTimestamp_ = undefined;
      this.lastActiveThread_ = undefined;
      this.lastActiveName_ = undefined;
      this.lastActiveArgs_ = undefined;
    },

    switchActiveThread: function (timestamp, oldThreadArgs, newThreadId, newThreadName, newThreadArgs) {
      // Close the previous active thread and generate a slice.
      this.closeActiveThread(timestamp, oldThreadArgs);

      // Keep track of the new thread.
      this.lastActiveTimestamp_ = timestamp;
      this.lastActiveThread_ = newThreadId;
      this.lastActiveName_ = newThreadName;
      this.lastActiveArgs_ = newThreadArgs;
    },

    /**
     * Returns the frequency statistics for this CPU;
     * the returned object contains the frequencies as keys,
     * and the duration at this frequency in milliseconds as the value,
     * for the range that was specified.
     */
    getFreqStatsForRange: function (range) {
      var stats = {};

      function addStatsForFreq(freqSample, index) {
        // Counters don't have an explicit end or duration;
        // calculate the end by looking at the starting point
        // of the next value in the series, or if that doesn't
        // exist, assume this frequency is held until the end.
        var freqEnd = index < freqSample.series_.length - 1 ? freqSample.series_.samples_[index + 1].timestamp : range.max;

        var freqRange = tr.b.Range.fromExplicitRange(freqSample.timestamp, freqEnd);
        var intersection = freqRange.findIntersection(range);
        if (!(freqSample.value in stats)) stats[freqSample.value] = 0;
        stats[freqSample.value] += intersection.duration;
      }

      var freqCounter = this.getCounter('', 'Clock Frequency');
      if (freqCounter !== undefined) {
        var freqSeries = freqCounter.getSeries(0);
        if (!freqSeries) return;

        tr.b.iterateOverIntersectingIntervals(freqSeries.samples_, function (x) {
          return x.timestamp;
        }, function (x, index) {
          return index < freqSeries.length - 1 ? freqSeries.samples_[index + 1].timestamp : range.max;
        }, range.min, range.max, addStatsForFreq);
      }

      return stats;
    }
  };

  /**
   * Comparison between processes that orders by cpuNumber.
   */
  Cpu.compare = function (x, y) {
    return x.cpuNumber - y.cpuNumber;
  };

  return {
    Cpu: Cpu
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range.js":47,"./counter.js":110,"./cpu_slice.js":114,"./process_base.js":144,"./thread_time_slice.js":158}],114:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range.js");
require("./thread_time_slice.js");

'use strict';

/**
 * @fileoverview Provides the CpuSlice class.
 */
global.tr.exportTo('tr.model', function () {

  var Slice = tr.model.Slice;

  /**
   * A CpuSlice represents a slice of time on a CPU.
   *
   * @constructor
   */
  function CpuSlice(cat, title, colorId, start, args, opt_duration) {
    Slice.apply(this, arguments);
    this.threadThatWasRunning = undefined;
    this.cpu = undefined;
  }

  CpuSlice.prototype = {
    __proto__: Slice.prototype,

    get analysisTypeName() {
      return 'tr.ui.analysis.CpuSlice';
    },

    getAssociatedTimeslice: function () {
      if (!this.threadThatWasRunning) return undefined;
      var timeSlices = this.threadThatWasRunning.timeSlices;
      for (var i = 0; i < timeSlices.length; i++) {
        var timeSlice = timeSlices[i];
        if (timeSlice.start !== this.start) continue;
        if (timeSlice.duration !== this.duration) continue;
        return timeSlice;
      }
      return undefined;
    }
  };

  tr.model.EventRegistry.register(CpuSlice, {
    name: 'cpuSlice',
    pluralName: 'cpuSlices'
  });

  return {
    CpuSlice: CpuSlice
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range.js":47,"./thread_time_slice.js":158}],115:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/guid.js");
require("../base/range.js");
require("./event_container.js");
require("./power_series.js");

'use strict';

/**
 * @fileoverview Provides the Device class.
 */
global.tr.exportTo('tr.model', function () {

  /**
   * Device represents the device-level objects in the model.
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function Device(model) {
    if (!model) throw new Error('Must provide a model.');

    tr.model.EventContainer.call(this);

    this.powerSeries_ = undefined;
    this.vSyncTimestamps_ = [];
  };

  Device.compare = function (x, y) {
    return x.guid - y.guid;
  };

  Device.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    compareTo: function (that) {
      return Device.compare(this, that);
    },

    get userFriendlyName() {
      return 'Device';
    },

    get userFriendlyDetails() {
      return 'Device';
    },

    get stableId() {
      return 'Device';
    },

    getSettingsKey: function () {
      return 'device';
    },

    get powerSeries() {
      return this.powerSeries_;
    },

    set powerSeries(powerSeries) {
      this.powerSeries_ = powerSeries;
    },

    get vSyncTimestamps() {
      return this.vSyncTimestamps_;
    },

    set vSyncTimestamps(value) {
      this.vSyncTimestamps_ = value;
    },

    updateBounds: function () {
      this.bounds.reset();
      for (var child of this.childEventContainers()) {
        child.updateBounds();
        this.bounds.addRange(child.bounds);
      }
    },

    shiftTimestampsForward: function (amount) {
      for (var child of this.childEventContainers()) {
        child.shiftTimestampsForward(amount);
      }

      for (var i = 0; i < this.vSyncTimestamps_.length; i++) this.vSyncTimestamps_[i] += amount;
    },

    addCategoriesToDict: function (categoriesDict) {},

    childEventContainers: function* () {
      if (this.powerSeries_) yield this.powerSeries_;
    }
  };

  return {
    Device: Device
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/guid.js":39,"../base/range.js":47,"./event_container.js":117,"./power_series.js":142}],116:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/guid.js");
require("../base/range.js");
require("./event_set.js");
require("./selectable_item.js");
require("./selection_state.js");

'use strict';

/**
 * @fileoverview Provides the Event class.
 */
global.tr.exportTo('tr.model', function () {
  var SelectableItem = tr.model.SelectableItem;
  var SelectionState = tr.model.SelectionState;
  var IMMUTABLE_EMPTY_SET = tr.model.EventSet.IMMUTABLE_EMPTY_SET;

  /**
   * An Event is the base type for any non-container, selectable piece
   * of data in the trace model.
   *
   * @constructor
   * @extends {SelectableItem}
   */
  function Event() {
    SelectableItem.call(this, this /* modelItem */);
    this.guid_ = tr.b.GUID.allocateSimple();
    this.selectionState = SelectionState.NONE;
    this.info = undefined;
  }

  Event.prototype = {
    __proto__: SelectableItem.prototype,

    get guid() {
      return this.guid_;
    },

    get stableId() {
      return undefined;
    },

    get range() {
      var range = new tr.b.Range();
      this.addBoundsToRange(range);
      return range;
    },

    // Empty by default. Lazily initialized on an instance in
    // addAssociatedAlert(). See #1930.
    associatedAlerts: IMMUTABLE_EMPTY_SET,

    addAssociatedAlert: function (alert) {
      if (this.associatedAlerts === IMMUTABLE_EMPTY_SET) this.associatedAlerts = new tr.model.EventSet();
      this.associatedAlerts.push(alert);
    },

    // Adds the range of timestamps for this event to the specified range.
    // If this is not overridden in subclass, it means that type of event
    // doesn't have timestamps.
    addBoundsToRange: function (range) {}
  };

  return {
    Event: Event
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/guid.js":39,"../base/range.js":47,"./event_set.js":120,"./selectable_item.js":149,"./selection_state.js":150}],117:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/guid.js");
require("../base/range.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  /**
   * EventContainer is a base class for any class in the trace model that
   * contains child events or child EventContainers.
   *
   * For all EventContainers, updateBounds() must be called after modifying the
   * container's events if an up-to-date bounds is expected.
   *
   * @constructor
   */
  function EventContainer() {
    this.guid_ = tr.b.GUID.allocateSimple();
    this.important = true;
    this.bounds_ = new tr.b.Range();
  }

  EventContainer.prototype = {
    get guid() {
      return this.guid_;
    },

    /**
     * @return {String} A stable and unique identifier that describes this
     * container's position in the event tree relative to the root. If an event
     * container 'B' is a child to another event container 'A', then container
     * B's stable ID would be 'A.B'.
     */
    get stableId() {
      throw new Error('Not implemented');
    },

    /**
     * Returns the bounds of the event container, which describe the range
     * of timestamps for all ancestor events.
     */
    get bounds() {
      return this.bounds_;
    },

    // TODO(charliea): A default implementation of this method could likely be
    // provided that iterates throuch getDescendantEvents.
    /**
     * Updates the bounds of the event container. After updating, this.bounds
     * will describe the range of timestamps of all ancestor events.
     */
    updateBounds: function () {
      throw new Error('Not implemented');
    },

    // TODO(charliea): A default implementation of this method could likely be
    // provided that iterates through getDescendantEvents.
    /**
     * Shifts the timestamps for ancestor events by 'amount' milliseconds.
     */
    shiftTimestampsForward: function (amount) {
      throw new Error('Not implemented');
    },

    /**
    * Returns an iterable of all child events.
    */
    childEvents: function* () {},

    /**
     * Returns an iterable of all events in this and descendant
     * event containers.
     */
    getDescendantEvents: function* () {
      yield* this.childEvents();
      for (var container of this.childEventContainers()) yield* container.getDescendantEvents();
    },

    /**
     * Returns an iterable of all child event containers.
     */
    childEventContainers: function* () {},

    /**
    * Returns an iterable containing this and all descendant event containers.
    */
    getDescendantEventContainers: function* () {
      yield this;
      for (var container of this.childEventContainers()) yield* container.getDescendantEventContainers();
    },

    /**
     * Finds topmost slices in this container (see docstring for
     * findTopmostSlices).
     */
    findTopmostSlicesInThisContainer: function* (eventPredicate, opt_this) {},

    /**
     * The findTopmostSlices* series of helpers find all topmost slices
     * satisfying the given predicates.
     *
     * As an example, suppose we are trying to find slices named 'C', with the
     * following thread:
     *
     *  -> |---C---| |-----D-----|
     *       |-C-|      |---C---| <-
     *
     * findTopmostSlices would locate the pointed-to Cs, because the bottom C on
     * the  left is not the topmost C, and the right one is, even though it is
     * not itself a top-level slice.
     */
    findTopmostSlices: function* (eventPredicate) {
      for (var ec of this.getDescendantEventContainers()) yield* ec.findTopmostSlicesInThisContainer(eventPredicate);
    },

    findTopmostSlicesNamed: function* (name) {
      yield* this.findTopmostSlices(e => e.title === name);
    }
  };

  return {
    EventContainer: EventContainer
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/guid.js":39,"../base/range.js":47}],118:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/color_scheme.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  var ColorScheme = tr.b.ColorScheme;

  /**
   * EventInfo is an annotation added to Events in order to document
   * what they represent, and override their title/colorId values.
   *
   * TODO(ccraik): eventually support more complex structure/paragraphs.
   *
   * @param {string} title A user-visible title for the event.
   * @param {string} description A user-visible description of the event.
   * @param {Array} docLinks A list of Objects, each of the form
   * {label: str, textContent: str, href: str}
   *
   * @constructor
   */
  function EventInfo(title, description, docLinks) {
    this.title = title;
    this.description = description;
    this.docLinks = docLinks;
    this.colorId = ColorScheme.getColorIdForGeneralPurposeString(title);
  }

  return {
    EventInfo: EventInfo
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/color_scheme.js":32}],119:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/extension_registry.js");

'use strict';

/**
 * @fileoverview Provides the EventRegistry class.
 */
global.tr.exportTo('tr.model', function () {
  // Create the type registry.
  function EventRegistry() {}

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(EventRegistry, options);

  // Enforce all options objects have the right fields.
  EventRegistry.addEventListener('will-register', function (e) {
    var metadata = e.typeInfo.metadata;
    if (metadata.name === undefined) throw new Error('Registered events must provide name metadata');
    if (metadata.pluralName === undefined) throw new Error('Registered events must provide pluralName metadata');

    // Add a subtype registry to every event so that all events can be
    // extended
    if (metadata.subTypes === undefined) {
      metadata.subTypes = {};
      var options = new tr.b.ExtensionRegistryOptions(tr.b.TYPE_BASED_REGISTRY_MODE);
      options.mandatoryBaseClass = e.typeInfo.constructor;
      options.defaultConstructor = e.typeInfo.constructor;
      tr.b.decorateExtensionRegistry(metadata.subTypes, options);
    } else {
      if (!metadata.subTypes.register) throw new Error('metadata.subTypes must be an extension registry.');
    }

    e.typeInfo.constructor.subTypes = metadata.subTypes;
  });

  // Helper: lookup Events indexed by type name.
  var eventsByTypeName = undefined;
  EventRegistry.getEventTypeInfoByTypeName = function (typeName) {
    if (eventsByTypeName === undefined) {
      eventsByTypeName = {};
      EventRegistry.getAllRegisteredTypeInfos().forEach(function (typeInfo) {
        eventsByTypeName[typeInfo.metadata.name] = typeInfo;
      });
    }
    return eventsByTypeName[typeName];
  };

  // Ensure eventsByTypeName stays current.
  EventRegistry.addEventListener('registry-changed', function () {
    eventsByTypeName = undefined;
  });

  function convertCamelCaseToTitleCase(name) {
    var result = name.replace(/[A-Z]/g, ' $&');
    result = result.charAt(0).toUpperCase() + result.slice(1);
    return result;
  }

  EventRegistry.getUserFriendlySingularName = function (typeName) {
    var typeInfo = EventRegistry.getEventTypeInfoByTypeName(typeName);
    var str = typeInfo.metadata.name;
    return convertCamelCaseToTitleCase(str);
  };

  EventRegistry.getUserFriendlyPluralName = function (typeName) {
    var typeInfo = EventRegistry.getEventTypeInfoByTypeName(typeName);
    var str = typeInfo.metadata.pluralName;
    return convertCamelCaseToTitleCase(str);
  };

  return {
    EventRegistry: EventRegistry
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/extension_registry.js":35}],120:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/event.js");
require("../base/guid.js");
require("../base/iteration_helpers.js");
require("../base/range.js");
require("./event_registry.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  var EventRegistry = tr.model.EventRegistry;

  var RequestSelectionChangeEvent = tr.b.Event.bind(undefined, 'requestSelectionChange', true, false);

  /**
   * Represents a event set within a  and its associated set of tracks.
   * @constructor
   */
  function EventSet(opt_events) {
    this.bounds_ = new tr.b.Range();
    this.events_ = new Set();

    if (opt_events) {
      if (opt_events instanceof Array) {
        for (var event of opt_events) this.push(event);
      } else if (opt_events instanceof EventSet) {
        this.addEventSet(opt_events);
      } else {
        this.push(opt_events);
      }
    }
  }

  EventSet.prototype = {
    __proto__: Object.prototype,

    get bounds() {
      return this.bounds_;
    },

    get duration() {
      if (this.bounds_.isEmpty) return 0;
      return this.bounds_.max - this.bounds_.min;
    },

    get length() {
      return this.events_.size;
    },

    get guid() {
      return this.guid_;
    },

    *[Symbol.iterator]() {
      for (var event of this.events_) yield event;
    },

    clear: function () {
      this.bounds_ = new tr.b.Range();
      this.events_.clear();
    },

    // push pushes only unique events.
    // If an event has been already pushed, do nothing.
    push: function (event) {
      if (event.guid == undefined) throw new Error('Event must have a GUID');

      if (!this.events_.has(event)) {
        this.events_.add(event);
        // Some uses of eventSet, particularly in tests, have Events as objects
        // that don't have addBoundsToRange as a function. Thus we need to
        // handle this case.
        if (event.addBoundsToRange) if (this.bounds_ !== undefined) event.addBoundsToRange(this.bounds_);
      }

      return event;
    },

    contains: function (event) {
      if (this.events_.has(event)) return event;else return undefined;
    },

    addEventSet: function (eventSet) {
      for (var event of eventSet) this.push(event);
    },

    intersectionIsEmpty: function (otherEventSet) {
      return !this.some(event => otherEventSet.contains(event));
    },

    equals: function (that) {
      if (this.length !== that.length) return false;
      return this.every(event => that.contains(event));
    },

    sortEvents: function (compare) {
      // Convert to array, then sort, then convert back
      var ary = this.toArray();
      ary.sort(compare);

      this.clear();
      for (var event of ary) this.push(event);
    },

    getEventsOrganizedByBaseType: function (opt_pruneEmpty) {
      var allTypeInfos = EventRegistry.getAllRegisteredTypeInfos();

      var events = this.getEventsOrganizedByCallback(function (event) {
        var maxEventIndex = -1;
        var maxEventTypeInfo = undefined;

        allTypeInfos.forEach(function (eventTypeInfo, eventIndex) {
          if (!(event instanceof eventTypeInfo.constructor)) return;
          if (eventIndex > maxEventIndex) {
            maxEventIndex = eventIndex;
            maxEventTypeInfo = eventTypeInfo;
          }
        });

        if (maxEventIndex == -1) {
          console.log(event);
          throw new Error('Unrecognized event type');
        }

        return maxEventTypeInfo.metadata.name;
      });

      if (!opt_pruneEmpty) {
        allTypeInfos.forEach(function (eventTypeInfo) {
          if (events[eventTypeInfo.metadata.name] === undefined) events[eventTypeInfo.metadata.name] = new EventSet();
        });
      }

      return events;
    },

    getEventsOrganizedByTitle: function () {
      return this.getEventsOrganizedByCallback(function (event) {
        if (event.title === undefined) throw new Error('An event didn\'t have a title!');
        return event.title;
      });
    },

    /**
     * @param {!function(!tr.model.Event):string} cb
     * @param {*=} opt_this
     * @return {!Object}
     */
    getEventsOrganizedByCallback: function (cb, opt_this) {
      var groupedEvents = tr.b.group(this, cb, opt_this || this);
      return tr.b.mapItems(groupedEvents, (_, events) => new EventSet(events));
    },

    enumEventsOfType: function (type, func) {
      for (var event of this) if (event instanceof type) func(event);
    },

    get userFriendlyName() {
      if (this.length === 0) {
        throw new Error('Empty event set');
      }

      var eventsByBaseType = this.getEventsOrganizedByBaseType(true);
      var eventTypeName = tr.b.dictionaryKeys(eventsByBaseType)[0];

      if (this.length === 1) {
        var tmp = EventRegistry.getUserFriendlySingularName(eventTypeName);
        return tr.b.getOnlyElement(this.events_).userFriendlyName;
      }

      var numEventTypes = tr.b.dictionaryLength(eventsByBaseType);
      if (numEventTypes !== 1) {
        return this.length + ' events of various types';
      }

      var tmp = EventRegistry.getUserFriendlyPluralName(eventTypeName);
      return this.length + ' ' + tmp;
    },

    filter: function (fn, opt_this) {
      var res = new EventSet();
      for (var event of this) if (fn.call(opt_this, event)) res.push(event);

      return res;
    },

    toArray: function () {
      var ary = [];
      for (var event of this) ary.push(event);
      return ary;
    },

    forEach: function (fn, opt_this) {
      for (var event of this) fn.call(opt_this, event);
    },

    map: function (fn, opt_this) {
      var res = [];
      for (var event of this) res.push(fn.call(opt_this, event));
      return res;
    },

    every: function (fn, opt_this) {
      for (var event of this) if (!fn.call(opt_this, event)) return false;
      return true;
    },

    some: function (fn, opt_this) {
      for (var event of this) if (fn.call(opt_this, event)) return true;
      return false;
    },

    asDict: function () {
      var stableIds = [];
      for (var event of this) stableIds.push(event.stableId);
      return { 'events': stableIds };
    },

    asSet: function () {
      return this.events_;
    }
  };

  EventSet.IMMUTABLE_EMPTY_SET = function () {
    var s = new EventSet();
    s.push = function () {
      throw new Error('Cannot push to an immutable event set');
    };
    s.addEventSet = function () {
      throw new Error('Cannot add to an immutable event set');
    };
    Object.freeze(s);
    return s;
  }();

  return {
    EventSet: EventSet,
    RequestSelectionChangeEvent: RequestSelectionChangeEvent
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/event.js":33,"../base/guid.js":39,"../base/iteration_helpers.js":41,"../base/range.js":47,"./event_registry.js":119}],121:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");
require("./timed_event.js");

'use strict';

/**
 * @fileoverview Provides the Flow class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * A Flow represents an interval of time plus parameters associated
   * with that interval.
   *
   * @constructor
   */
  function FlowEvent(category, id, title, colorId, start, args, opt_duration) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.start = start;
    this.args = args;

    this.id = id;

    this.startSlice = undefined;
    this.endSlice = undefined;

    this.startStackFrame = undefined;
    this.endStackFrame = undefined;

    if (opt_duration !== undefined) this.duration = opt_duration;
  }

  FlowEvent.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get userFriendlyName() {
      return 'Flow event named ' + this.title + ' at ' + tr.b.Unit.byName.timeStampInMs.format(this.timestamp);
    }
  };

  tr.model.EventRegistry.register(FlowEvent, {
    name: 'flowEvent',
    pluralName: 'flowEvents'
  });

  return {
    FlowEvent: FlowEvent
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57,"./timed_event.js":160}],122:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/color_scheme.js");
require("../base/statistics.js");
require("./event.js");
require("./event_set.js");

'use strict';

/**
 * @fileoverview Class describing rendered frames.
 *
 * Because a frame is produced by multiple threads, it does not inherit from
 * TimedEvent, and has no duration.
 */
global.tr.exportTo('tr.model', function () {
  var ColorScheme = tr.b.ColorScheme;
  var Statistics = tr.b.Statistics;

  var FRAME_PERF_CLASS = {
    GOOD: 'good',
    BAD: 'bad',
    TERRIBLE: 'terrible',
    NEUTRAL: 'generic_work'
  };

  /**
   * @constructor
   * @param {Array} associatedEvents Selection of events composing the frame.
   * @param {Array} threadTimeRanges Array of {thread, start, end}
   * for each thread, describing the critical path of the frame.
   */
  function Frame(associatedEvents, threadTimeRanges, opt_args) {
    tr.model.Event.call(this);

    this.threadTimeRanges = threadTimeRanges;
    this.associatedEvents = new tr.model.EventSet(associatedEvents);
    this.args = opt_args || {};

    this.title = 'Frame';
    this.start = Statistics.min(threadTimeRanges, function (x) {
      return x.start;
    });
    this.end = Statistics.max(threadTimeRanges, function (x) {
      return x.end;
    });
    this.totalDuration = Statistics.sum(threadTimeRanges, function (x) {
      return x.end - x.start;
    });

    this.perfClass = FRAME_PERF_CLASS.NEUTRAL;
  };

  Frame.prototype = {
    __proto__: tr.model.Event.prototype,

    set perfClass(perfClass) {
      this.colorId = ColorScheme.getColorIdForReservedName(perfClass);
      this.perfClass_ = perfClass;
    },

    get perfClass() {
      return this.perfClass_;
    },

    shiftTimestampsForward: function (amount) {
      this.start += amount;
      this.end += amount;

      for (var i = 0; i < this.threadTimeRanges.length; i++) {
        this.threadTimeRanges[i].start += amount;
        this.threadTimeRanges[i].end += amount;
      }
    },

    addBoundsToRange: function (range) {
      range.addValue(this.start);
      range.addValue(this.end);
    }
  };

  tr.model.EventRegistry.register(Frame, {
    name: 'frame',
    pluralName: 'frames'
  });

  return {
    Frame: Frame,
    FRAME_PERF_CLASS: FRAME_PERF_CLASS
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/color_scheme.js":32,"../base/statistics.js":53,"./event.js":116,"./event_set.js":120}],123:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/iteration_helpers.js");
require("../base/unit.js");
require("./container_memory_dump.js");
require("./event_registry.js");
require("./memory_allocator_dump.js");
require("../value/numeric.js");

'use strict';

/**
 * @fileoverview Provides the GlobalMemoryDump class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * The GlobalMemoryDump represents a simultaneous memory dump of all
   * processes.
   * @constructor
   */
  function GlobalMemoryDump(model, start) {
    tr.model.ContainerMemoryDump.call(this, start);
    this.model = model;
    this.processMemoryDumps = {};
  }

  // Size numeric names.
  var SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.SIZE_NUMERIC_NAME;
  var EFFECTIVE_SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME;

  // Size numeric info types.
  var MemoryAllocatorDumpInfoType = tr.model.MemoryAllocatorDumpInfoType;
  var PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN = MemoryAllocatorDumpInfoType.PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN;
  var PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER = MemoryAllocatorDumpInfoType.PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER;

  // TODO(petrcermak): Move this to tracing/base/iteration_helpers.html.
  function inPlaceFilter(array, predicate, opt_this) {
    opt_this = opt_this || this;
    var nextPosition = 0;
    for (var i = 0; i < array.length; i++) {
      if (!predicate.call(opt_this, array[i], i)) continue;
      if (nextPosition < i) array[nextPosition] = array[i]; // Move elements only if necessary.
      nextPosition++;
    }

    if (nextPosition < array.length) array.length = nextPosition; // Truncate the array only if necessary.
  }

  function getSize(dump) {
    var numeric = dump.numerics[SIZE_NUMERIC_NAME];
    if (numeric === undefined) return 0;
    return numeric.value;
  }

  function hasSize(dump) {
    return dump.numerics[SIZE_NUMERIC_NAME] !== undefined;
  }

  function optional(value, defaultValue) {
    if (value === undefined) return defaultValue;
    return value;
  }

  GlobalMemoryDump.prototype = {
    __proto__: tr.model.ContainerMemoryDump.prototype,

    get userFriendlyName() {
      return 'Global memory dump at ' + tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get containerName() {
      return 'global space';
    },

    finalizeGraph: function () {
      // 1. Transitively remove weak memory allocator dumps and all their
      // owners and descendants from the model. This must be performed before
      // any other steps.
      this.removeWeakDumps();

      // 2. Add ownership links from tracing MADs to descendants of malloc or
      // winheap MADs so that tracing would be automatically discounted from
      // them later (step 3).
      this.setUpTracingOverheadOwnership();

      // 3. Aggregate all other numerics of all MADs (*excluding* sizes and
      // effective sizes) and propagate numerics from global MADs to their
      // owners (*including* sizes and effective sizes). This step must be
      // carried out before the sizes of all MADs are calculated (step 3).
      // Otherwise, the propagated sizes of all MADs would not be aggregated.
      this.aggregateNumerics();

      // 4. Calculate the sizes of all memory allocator dumps (MADs). This step
      // requires that the memory allocator dump graph has been finalized (step
      // 1) and numerics were propagated from global MADs (step 2). Subsequent
      // modifications of the graph will most likely break the calculation
      // invariants.
      this.calculateSizes();

      // 5. Calculate the effective sizes of all MADs. This step requires that
      // the sizes of all MADs have already been calculated (step 3).
      this.calculateEffectiveSizes();

      // 6. Discount tracing from VM regions stats. This steps requires that
      // resident sizes (step 2) and sizes (step 3) of the tracing MADs have
      // already been calculated.
      this.discountTracingOverheadFromVmRegions();

      // 7. The above steps (especially steps 1 and 3) can create new memory
      // allocator dumps, so we force rebuilding the memory allocator dump
      // indices of all container memory dumps.
      this.forceRebuildingMemoryAllocatorDumpByFullNameIndices();
    },

    removeWeakDumps: function () {
      // Mark all transitive owners and children of weak memory allocator dumps
      // as weak.
      this.traverseAllocatorDumpsInDepthFirstPreOrder(function (dump) {
        if (dump.weak) return;
        if (dump.owns !== undefined && dump.owns.target.weak || dump.parent !== undefined && dump.parent.weak) {
          dump.weak = true;
        }
      });

      function removeWeakDumpsFromListRecursively(dumps) {
        inPlaceFilter(dumps, function (dump) {
          if (dump.weak) {
            // The dump is weak, so remove it. This will implicitly remove all
            // its descendants, which are also weak due to the initial marking
            // step.
            return false;
          }

          // This dump is non-weak, so keep it. Recursively remove its weak
          // descendants and ownership links from weak dumps instead.
          removeWeakDumpsFromListRecursively(dump.children);
          inPlaceFilter(dump.ownedBy, function (ownershipLink) {
            return !ownershipLink.source.weak;
          });

          return true;
        });
      }

      this.iterateContainerDumps(function (containerDump) {
        var memoryAllocatorDumps = containerDump.memoryAllocatorDumps;
        if (memoryAllocatorDumps !== undefined) removeWeakDumpsFromListRecursively(memoryAllocatorDumps);
      });
    },

    /**
     * Calculate the size of all memory allocator dumps in the dump graph.
     *
     * The size refers to the allocated size of a (sub)component. It is a
     * natural extension of the optional size numeric provided by
     * MemoryAllocatorDump(s):
     *
     *   - If a MAD provides a size numeric, then its size is assumed to be
     *     equal to it.
     *   - If a MAD does not provide a size numeric, then its size is assumed
     *     to be the maximum of (1) the size of the largest owner of the MAD
     *     and (2) the aggregated size of the MAD's children.
     *
     * Metric motivation: "How big is a (sub)system?"
     *
     * Please refer to the Memory Dump Graph Metric Calculation design document
     * for more details (https://goo.gl/fKg0dt).
     */
    calculateSizes: function () {
      this.traverseAllocatorDumpsInDepthFirstPostOrder(this.calculateMemoryAllocatorDumpSize_.bind(this));
    },

    /**
     * Calculate the size of the given MemoryAllocatorDump. This method assumes
     * that the size of both the children and owners of the dump has already
     * been calculated.
     */
    calculateMemoryAllocatorDumpSize_: function (dump) {
      // This flag becomes true if the size numeric of the current dump should
      // be defined, i.e. if (1) the current dump's size numeric is defined,
      // (2) the size of at least one of its children is defined or (3) the
      // size of at least one of its owners is defined.
      var shouldDefineSize = false;

      // This helper function returns the value of the size numeric of the
      // given dependent memory allocator dump. If the numeric is defined, the
      // shouldDefineSize flag above is also set to true (because condition
      // (2) or (3) is satisfied). Otherwise, zero is returned (and the flag is
      // left unchanged).
      function getDependencySize(dependencyDump) {
        var numeric = dependencyDump.numerics[SIZE_NUMERIC_NAME];
        if (numeric === undefined) return 0;
        shouldDefineSize = true;
        return numeric.value;
      }

      // 1. Get the size provided by the dump. If present, define a function
      // for checking dependent size consistency (a dump must always be bigger
      // than all its children aggregated together and/or its largest owner).
      var sizeNumeric = dump.numerics[SIZE_NUMERIC_NAME];
      var size = 0;
      var checkDependencySizeIsConsistent = function () {/* no-op */};
      if (sizeNumeric !== undefined) {
        size = sizeNumeric.value;
        shouldDefineSize = true;
        if (sizeNumeric.unit !== tr.b.Unit.byName.sizeInBytes_smallerIsBetter) {
          this.model.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Invalid unit of \'size\' numeric of memory allocator ' + 'dump ' + dump.quantifiedName + ': ' + sizeNumeric.unit.unitName + '.'
          });
        }
        checkDependencySizeIsConsistent = function (dependencySize, dependencyInfoType, dependencyName) {
          if (size >= dependencySize) return;
          this.model.importWarning({
            type: 'memory_dump_parse_error',
            message: 'Size provided by memory allocator dump \'' + dump.fullName + '\'' + tr.b.Unit.byName.sizeInBytes.format(size) + ') is less than ' + dependencyName + ' (' + tr.b.Unit.byName.sizeInBytes.format(dependencySize) + ').'
          });
          dump.infos.push({
            type: dependencyInfoType,
            providedSize: size,
            dependencySize: dependencySize
          });
        }.bind(this);
      }

      // 2. Aggregate size of children. The recursive function traverses all
      // descendants and ensures that double-counting due to ownership within a
      // subsystem is avoided.
      var aggregatedChildrenSize = 0;
      // Owned child dump name -> (Owner child dump name -> overlapping size).
      var allOverlaps = {};
      dump.children.forEach(function (childDump) {
        function aggregateDescendantDump(descendantDump) {
          // Don't count this descendant dump if it owns another descendant of
          // the current dump (would cause double-counting).
          var ownedDumpLink = descendantDump.owns;
          if (ownedDumpLink !== undefined && ownedDumpLink.target.isDescendantOf(dump)) {
            // If the target owned dump is a descendant of a *different* child
            // of the the current dump (i.e. not childDump), then we remember
            // the ownership so that we could explain why the size of the
            // current dump is not equal to the sum of its children.
            var ownedChildDump = ownedDumpLink.target;
            while (ownedChildDump.parent !== dump) ownedChildDump = ownedChildDump.parent;
            if (childDump !== ownedChildDump) {
              var ownedBySiblingSize = getDependencySize(descendantDump);
              if (ownedBySiblingSize > 0) {
                var previousTotalOwnedBySiblingSize = ownedChildDump.ownedBySiblingSizes.get(childDump) || 0;
                var updatedTotalOwnedBySiblingSize = previousTotalOwnedBySiblingSize + ownedBySiblingSize;
                ownedChildDump.ownedBySiblingSizes.set(childDump, updatedTotalOwnedBySiblingSize);
              }
            }
            return;
          }

          // If this descendant dump is a leaf node, add its size to the
          // aggregated size.
          if (descendantDump.children.length === 0) {
            aggregatedChildrenSize += getDependencySize(descendantDump);
            return;
          }

          // If this descendant dump is an intermediate node, recurse down into
          // its children. Note that the dump's size is NOT added because it is
          // an aggregate of its children (would cause double-counting).
          descendantDump.children.forEach(aggregateDescendantDump);
        }
        aggregateDescendantDump(childDump);
      });
      checkDependencySizeIsConsistent(aggregatedChildrenSize, PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN, 'the aggregated size of its children');

      // 3. Calculate the largest owner size.
      var largestOwnerSize = 0;
      dump.ownedBy.forEach(function (ownershipLink) {
        var owner = ownershipLink.source;
        var ownerSize = getDependencySize(owner);
        largestOwnerSize = Math.max(largestOwnerSize, ownerSize);
      });
      checkDependencySizeIsConsistent(largestOwnerSize, PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER, 'the size of its largest owner');

      // If neither the dump nor any of its dependencies (children and owners)
      // provide a size, do NOT add a zero size numeric.
      if (!shouldDefineSize) {
        // The rest of the pipeline relies on size being either a valid
        // ScalarNumeric, or undefined.
        delete dump.numerics[SIZE_NUMERIC_NAME];
        return;
      }

      // A dump must always be bigger than all its children aggregated
      // together and/or its largest owner.
      size = Math.max(size, aggregatedChildrenSize, largestOwnerSize);

      dump.numerics[SIZE_NUMERIC_NAME] = new tr.v.ScalarNumeric(tr.b.Unit.byName.sizeInBytes_smallerIsBetter, size);

      // Add a virtual child to make up for extra size of the dump with
      // respect to its children (if applicable).
      if (aggregatedChildrenSize < size && dump.children !== undefined && dump.children.length > 0) {
        var virtualChild = new tr.model.MemoryAllocatorDump(dump.containerMemoryDump, dump.fullName + '/<unspecified>');
        virtualChild.parent = dump;
        dump.children.unshift(virtualChild);
        virtualChild.numerics[SIZE_NUMERIC_NAME] = new tr.v.ScalarNumeric(tr.b.Unit.byName.sizeInBytes_smallerIsBetter, size - aggregatedChildrenSize);
      }
    },

    /**
     * Calculate the effective size of all memory allocator dumps in the dump
     * graph.
     *
     * The effective size refers to the amount of memory a particular component
     * is using/consuming. In other words, every (reported) byte of used memory
     * is uniquely attributed to exactly one component. Consequently, unlike
     * size, effective size is cumulative, i.e. the sum of the effective sizes
     * of (top-level) components is equal to the total amount of (reported)
     * used memory.
     *
     * Metric motivation: "How much memory does a (sub)system use?" or "For how
     * much memory should a (sub)system be 'charged'?"
     *
     * Please refer to the Memory Dump Graph Metric Calculation design document
     * for more details (https://goo.gl/fKg0dt).
     *
     * This method assumes that the size of all contained memory allocator
     * dumps has already been calculated [see calculateSizes()].
     */
    calculateEffectiveSizes: function () {
      // 1. Calculate not-owned and not-owning sub-sizes of all MADs
      // (depth-first post-order traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(this.calculateDumpSubSizes_.bind(this));

      // 2. Calculate owned and owning coefficients of owned and owner MADs
      // respectively (arbitrary traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(this.calculateDumpOwnershipCoefficient_.bind(this));

      // 3. Calculate cumulative owned and owning coefficients of all MADs
      // (depth-first pre-order traversal).
      this.traverseAllocatorDumpsInDepthFirstPreOrder(this.calculateDumpCumulativeOwnershipCoefficient_.bind(this));

      // 4. Calculate the effective sizes of all MADs (depth-first post-order
      // traversal).
      this.traverseAllocatorDumpsInDepthFirstPostOrder(this.calculateDumpEffectiveSize_.bind(this));
    },

    /**
     * Calculate not-owned and not-owning sub-sizes of a memory allocator dump
     * from its children's (sub-)sizes.
     *
     * Not-owned sub-size refers to the aggregated memory of all children which
     * is not owned by other MADs. Conversely, not-owning sub-size is the
     * aggregated memory of all children which do not own another MAD. The
     * diagram below illustrates these two concepts:
     *
     *     ROOT 1                         ROOT 2
     *     size: 4                        size: 5
     *     not-owned sub-size: 4          not-owned sub-size: 1 (!)
     *     not-owning sub-size: 0 (!)     not-owning sub-size: 5
     *
     *      ^                              ^
     *      |                              |
     *
     *     PARENT 1   ===== owns =====>   PARENT 2
     *     size: 4                        size: 5
     *     not-owned sub-size: 4          not-owned sub-size: 5
     *     not-owning sub-size: 4         not-owning sub-size: 5
     *
     *      ^                              ^
     *      |                              |
     *
     *     CHILD 1                        CHILD 2
     *     size [given]: 4                size [given]: 5
     *     not-owned sub-size: 4          not-owned sub-size: 5
     *     not-owning sub-size: 4         not-owning sub-size: 5
     *
     * This method assumes that (1) the size of the dump, its children, and its
     * owners [see calculateSizes()] and (2) the not-owned and not-owning
     * sub-sizes of both the children and owners of the dump have already been
     * calculated [depth-first post-order traversal].
     */
    calculateDumpSubSizes_: function (dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump)) return;

      // If the dump is a leaf node, then both sub-sizes are equal to the size.
      if (dump.children === undefined || dump.children.length === 0) {
        var size = getSize(dump);
        dump.notOwningSubSize_ = size;
        dump.notOwnedSubSize_ = size;
        return;
      }

      // Calculate this dump's not-owning sub-size by summing up the not-owning
      // sub-sizes of children MADs which do not own another MAD.
      var notOwningSubSize = 0;
      dump.children.forEach(function (childDump) {
        if (childDump.owns !== undefined) return;
        notOwningSubSize += optional(childDump.notOwningSubSize_, 0);
      });
      dump.notOwningSubSize_ = notOwningSubSize;

      // Calculate this dump's not-owned sub-size.
      var notOwnedSubSize = 0;
      dump.children.forEach(function (childDump) {
        // If the child dump is not owned, then add its not-owned sub-size.
        if (childDump.ownedBy.length === 0) {
          notOwnedSubSize += optional(childDump.notOwnedSubSize_, 0);
          return;
        }
        // If the child dump is owned, then add the difference between its size
        // and the largest owner.
        var largestChildOwnerSize = 0;
        childDump.ownedBy.forEach(function (ownershipLink) {
          largestChildOwnerSize = Math.max(largestChildOwnerSize, getSize(ownershipLink.source));
        });
        notOwnedSubSize += getSize(childDump) - largestChildOwnerSize;
      });
      dump.notOwnedSubSize_ = notOwnedSubSize;
    },

    /**
     * Calculate owned and owning coefficients of a memory allocator dump and
     * its owners.
     *
     * The owning coefficient refers to the proportion of a dump's not-owning
     * sub-size which is attributed to the dump (only relevant to owning MADs).
     * Conversely, the owned coefficient is the proportion of a dump's
     * not-owned sub-size, which is attributed to it (only relevant to owned
     * MADs).
     *
     * The not-owned size of the owned dump is split among its owners in the
     * order of the ownership importance as demonstrated by the following
     * example:
     *
     *                                          memory allocator dumps
     *                                   OWNED  OWNER1  OWNER2  OWNER3  OWNER4
     *       not-owned sub-size [given]     10       -       -       -       -
     *      not-owning sub-size [given]      -       6       7       5       8
     *               importance [given]      -       2       2       1       0
     *    attributed not-owned sub-size      2       -       -       -       -
     *   attributed not-owning sub-size      -       3       4       0       1
     *                owned coefficient   2/10       -       -       -       -
     *               owning coefficient      -     3/6     4/7     0/5     1/8
     *
     * Explanation: Firstly, 6 bytes are split equally among OWNER1 and OWNER2
     * (highest importance). OWNER2 owns one more byte, so its attributed
     * not-owning sub-size is 6/2 + 1 = 4 bytes. OWNER3 is attributed no size
     * because it is smaller than the owners with higher priority. However,
     * OWNER4 is larger, so it's attributed the difference 8 - 7 = 1 byte.
     * Finally, 2 bytes remain unattributed and are hence kept in the OWNED
     * dump as attributed not-owned sub-size. The coefficients are then
     * directly calculated as fractions of the sub-sizes and corresponding
     * attributed sub-sizes.
     *
     * Note that we always assume that all ownerships of a dump overlap (e.g.
     * OWNER3 is subsumed by both OWNER1 and OWNER2). Hence, the table could
     * be alternatively represented as follows:
     *
     *                                 owned memory range
     *              0   1   2    3    4    5    6        7        8   9  10
     *   Priority 2 |  OWNER1 + OWNER2 (split)  | OWNER2 |
     *   Priority 1 | (already attributed) |
     *   Priority 0 | - - -  (already attributed)  - - - | OWNER4 |
     *    Remainder | - - - - - (already attributed) - - - - - -  | OWNED |
     *
     * This method assumes that (1) the size of the dump [see calculateSizes()]
     * and (2) the not-owned size of the dump and not-owning sub-sizes of its
     * owners [see the first step of calculateEffectiveSizes()] have already
     * been calculated. Note that the method doesn't make any assumptions about
     * the order in which dumps are visited.
     */
    calculateDumpOwnershipCoefficient_: function (dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump)) return;

      // We only need to consider owned dumps.
      if (dump.ownedBy.length === 0) return;

      // Sort the owners in decreasing order of ownership importance and
      // increasing order of not-owning sub-size (in case of equal importance).
      var owners = dump.ownedBy.map(function (ownershipLink) {
        return {
          dump: ownershipLink.source,
          importance: optional(ownershipLink.importance, 0),
          notOwningSubSize: optional(ownershipLink.source.notOwningSubSize_, 0)
        };
      });
      owners.sort(function (a, b) {
        if (a.importance === b.importance) return a.notOwningSubSize - b.notOwningSubSize;
        return b.importance - a.importance;
      });

      // Loop over the list of owners and distribute the owned dump's not-owned
      // sub-size among them according to their ownership importance and
      // not-owning sub-size.
      var currentImportanceStartPos = 0;
      var alreadyAttributedSubSize = 0;
      while (currentImportanceStartPos < owners.length) {
        var currentImportance = owners[currentImportanceStartPos].importance;

        // Find the position of the first owner with lower priority.
        var nextImportanceStartPos = currentImportanceStartPos + 1;
        while (nextImportanceStartPos < owners.length && owners[nextImportanceStartPos].importance === currentImportance) {
          nextImportanceStartPos++;
        }

        // Visit the owners with the same importance in increasing order of
        // not-owned sub-size, split the owned memory among them appropriately,
        // and calculate their owning coefficients.
        var attributedNotOwningSubSize = 0;
        for (var pos = currentImportanceStartPos; pos < nextImportanceStartPos; pos++) {
          var owner = owners[pos];
          var notOwningSubSize = owner.notOwningSubSize;
          if (notOwningSubSize > alreadyAttributedSubSize) {
            attributedNotOwningSubSize += (notOwningSubSize - alreadyAttributedSubSize) / (nextImportanceStartPos - pos);
            alreadyAttributedSubSize = notOwningSubSize;
          }

          var owningCoefficient = 0;
          if (notOwningSubSize !== 0) owningCoefficient = attributedNotOwningSubSize / notOwningSubSize;
          owner.dump.owningCoefficient_ = owningCoefficient;
        }

        currentImportanceStartPos = nextImportanceStartPos;
      }

      // Attribute the remainder of the owned dump's not-owned sub-size to
      // the dump itself and calculate its owned coefficient.
      var notOwnedSubSize = optional(dump.notOwnedSubSize_, 0);
      var remainderSubSize = notOwnedSubSize - alreadyAttributedSubSize;
      var ownedCoefficient = 0;
      if (notOwnedSubSize !== 0) ownedCoefficient = remainderSubSize / notOwnedSubSize;
      dump.ownedCoefficient_ = ownedCoefficient;
    },

    /**
     * Calculate cumulative owned and owning coefficients of a memory allocator
     * dump from its (non-cumulative) owned and owning coefficients and the
     * cumulative coefficients of its parent and/or owned dump.
     *
     * The cumulative coefficients represent the total effect of all
     * (non-strict) ancestor ownerships on a memory allocator dump. The
     * cumulative owned coefficient of a MAD can be calculated simply as:
     *
     *   cumulativeOwnedC(M) = ownedC(M) * cumulativeOwnedC(parent(M))
     *
     * This reflects the assumption that if a parent of a child MAD is
     * (partially) owned, then the parent's owner also indirectly owns (a part
     * of) the child MAD.
     *
     * The cumulative owning coefficient of a MAD depends on whether the MAD
     * owns another dump:
     *
     *                           [if M doesn't own another MAD]
     *                         / cumulativeOwningC(parent(M))
     *   cumulativeOwningC(M) =
     *                         \ [if M owns another MAD]
     *                           owningC(M) * cumulativeOwningC(owned(M))
     *
     * The reasoning behind the first case is similar to the one for cumulative
     * owned coefficient above. The only difference is that we don't need to
     * include the dump's (non-cumulative) owning coefficient because it is
     * implicitly 1.
     *
     * The formula for the second case is derived as follows: Since the MAD
     * owns another dump, its memory is not included in its parent's not-owning
     * sub-size and hence shouldn't be affected by the parent's corresponding
     * cumulative coefficient. Instead, the MAD indirectly owns everything
     * owned by its owned dump (and so it should be affected by the
     * corresponding coefficient).
     *
     * Note that undefined coefficients (and coefficients of non-existent
     * dumps) are implicitly assumed to be 1.
     *
     * This method assumes that (1) the size of the dump [see calculateSizes()],
     * (2) the (non-cumulative) owned and owning coefficients of the dump [see
     * the second step of calculateEffectiveSizes()], and (3) the cumulative
     * coefficients of the dump's parent and owned MADs (if present)
     * [depth-first pre-order traversal] have already been calculated.
     */
    calculateDumpCumulativeOwnershipCoefficient_: function (dump) {
      // Completely skip dumps with undefined size.
      if (!hasSize(dump)) return;

      var cumulativeOwnedCoefficient = optional(dump.ownedCoefficient_, 1);
      var parent = dump.parent;
      if (dump.parent !== undefined) cumulativeOwnedCoefficient *= dump.parent.cumulativeOwnedCoefficient_;
      dump.cumulativeOwnedCoefficient_ = cumulativeOwnedCoefficient;

      var cumulativeOwningCoefficient;
      if (dump.owns !== undefined) {
        cumulativeOwningCoefficient = dump.owningCoefficient_ * dump.owns.target.cumulativeOwningCoefficient_;
      } else if (dump.parent !== undefined) {
        cumulativeOwningCoefficient = dump.parent.cumulativeOwningCoefficient_;
      } else {
        cumulativeOwningCoefficient = 1;
      }
      dump.cumulativeOwningCoefficient_ = cumulativeOwningCoefficient;
    },

    /**
     * Calculate the effective size of a memory allocator dump.
     *
     * In order to simplify the (already complex) calculation, we use the fact
     * that effective size is cumulative (unlike regular size), i.e. the
     * effective size of a non-leaf node is equal to the sum of effective sizes
     * of its children. The effective size of a leaf MAD is calculated as:
     *
     *   effectiveSize(M) = size(M) * cumulativeOwningC(M) * cumulativeOwnedC(M)
     *
     * This method assumes that (1) the size of the dump and its children [see
     * calculateSizes()] and (2) the cumulative owning and owned coefficients
     * of the dump (if it's a leaf node) [see the third step of
     * calculateEffectiveSizes()] or the effective sizes of its children (if
     * it's a non-leaf node) [depth-first post-order traversal] have already
     * been calculated.
     */
    calculateDumpEffectiveSize_: function (dump) {
      // Completely skip dumps with undefined size. As a result, each dump will
      // have defined effective size if and only if it has defined size.
      if (!hasSize(dump)) {
        // The rest of the pipeline relies on effective size being either a
        // valid ScalarNumeric, or undefined.
        delete dump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME];
        return;
      }

      var effectiveSize;
      if (dump.children === undefined || dump.children.length === 0) {
        // Leaf dump.
        effectiveSize = getSize(dump) * dump.cumulativeOwningCoefficient_ * dump.cumulativeOwnedCoefficient_;
      } else {
        // Non-leaf dump.
        effectiveSize = 0;
        dump.children.forEach(function (childDump) {
          if (!hasSize(childDump)) return;
          effectiveSize += childDump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME].value;
        });
      }
      dump.numerics[EFFECTIVE_SIZE_NUMERIC_NAME] = new tr.v.ScalarNumeric(tr.b.Unit.byName.sizeInBytes_smallerIsBetter, effectiveSize);
    },

    aggregateNumerics: function () {
      // 1. Aggregate numerics in this global memory dump.
      this.iterateRootAllocatorDumps(function (dump) {
        dump.aggregateNumericsRecursively(this.model);
      });

      // 2. Propagate numerics and diagnostics from global memory allocator
      // dumps to their owners.
      this.iterateRootAllocatorDumps(this.propagateNumericsAndDiagnosticsRecursively);

      // 3. Aggregate numerics in the associated process memory dumps.
      tr.b.iterItems(this.processMemoryDumps, function (pid, processMemoryDump) {
        processMemoryDump.iterateRootAllocatorDumps(function (dump) {
          dump.aggregateNumericsRecursively(this.model);
        }, this);
      }, this);
    },

    propagateNumericsAndDiagnosticsRecursively: function (globalAllocatorDump) {
      ['numerics', 'diagnostics'].forEach(function (field) {
        tr.b.iterItems(globalAllocatorDump[field], function (name, value) {
          globalAllocatorDump.ownedBy.forEach(function (ownershipLink) {
            var processAllocatorDump = ownershipLink.source;
            if (processAllocatorDump[field][name] !== undefined) {
              // Numerics and diagnostics provided by process memory allocator
              // dumps themselves have precedence over numerics and diagnostics
              // propagated from global memory allocator dumps.
              return;
            }
            processAllocatorDump[field][name] = value;
          });
        });
      });

      // Recursively propagate numerics from all child memory allocator dumps.
      globalAllocatorDump.children.forEach(this.propagateNumericsAndDiagnosticsRecursively, this);
    },

    setUpTracingOverheadOwnership: function () {
      tr.b.iterItems(this.processMemoryDumps, function (pid, dump) {
        dump.setUpTracingOverheadOwnership(this.model);
      }, this);
    },

    discountTracingOverheadFromVmRegions: function () {
      // TODO(petrcermak): Consider factoring out all the finalization code and
      // constants to a single file.
      tr.b.iterItems(this.processMemoryDumps, function (pid, dump) {
        dump.discountTracingOverheadFromVmRegions(this.model);
      }, this);
    },

    forceRebuildingMemoryAllocatorDumpByFullNameIndices: function () {
      this.iterateContainerDumps(function (containerDump) {
        containerDump.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
      });
    },

    iterateContainerDumps: function (fn) {
      fn.call(this, this);
      tr.b.iterItems(this.processMemoryDumps, function (pid, processDump) {
        fn.call(this, processDump);
      }, this);
    },

    iterateAllRootAllocatorDumps: function (fn) {
      this.iterateContainerDumps(function (containerDump) {
        containerDump.iterateRootAllocatorDumps(fn, this);
      });
    },

    /**
     * Traverse the memory dump graph in a depth first post-order, i.e.
     * children and owners of a memory allocator dump are visited before the
     * dump itself. This method will throw an exception if the graph contains
     * a cycle.
     */
    traverseAllocatorDumpsInDepthFirstPostOrder: function (fn) {
      var visitedDumps = new WeakSet();
      var openDumps = new WeakSet();

      function visit(dump) {
        if (visitedDumps.has(dump)) return;

        if (openDumps.has(dump)) throw new Error(dump.userFriendlyName + ' contains a cycle');
        openDumps.add(dump);

        // Visit owners before the dumps they own.
        dump.ownedBy.forEach(function (ownershipLink) {
          visit.call(this, ownershipLink.source);
        }, this);

        // Visit children before parents.
        dump.children.forEach(visit, this);

        // Actually visit the current memory allocator dump.
        fn.call(this, dump);
        visitedDumps.add(dump);

        openDumps.delete(dump);
      }

      this.iterateAllRootAllocatorDumps(visit);
    },

    /**
     * Traverse the memory dump graph in a depth first pre-order, i.e.
     * children and owners of a memory allocator dump are visited after the
     * dump itself. This method will not visit some dumps if the graph contains
     * a cycle.
     */
    traverseAllocatorDumpsInDepthFirstPreOrder: function (fn) {
      var visitedDumps = new WeakSet();

      function visit(dump) {
        if (visitedDumps.has(dump)) return;

        // If this dumps owns another dump which hasn't been visited yet, then
        // wait for this dump to be visited later.
        if (dump.owns !== undefined && !visitedDumps.has(dump.owns.target)) return;

        // If this dump's parent hasn't been visited yet, then wait for this
        // dump to be visited later.
        if (dump.parent !== undefined && !visitedDumps.has(dump.parent)) return;

        // Actually visit the current memory allocator dump.
        fn.call(this, dump);
        visitedDumps.add(dump);

        // Visit owners after the dumps they own.
        dump.ownedBy.forEach(function (ownershipLink) {
          visit.call(this, ownershipLink.source);
        }, this);

        // Visit children after parents.
        dump.children.forEach(visit, this);
      }

      this.iterateAllRootAllocatorDumps(visit);
    }
  };

  tr.model.EventRegistry.register(GlobalMemoryDump, {
    name: 'globalMemoryDump',
    pluralName: 'globalMemoryDumps'
  });

  return {
    GlobalMemoryDump: GlobalMemoryDump
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41,"../base/unit.js":57,"../value/numeric.js":190,"./container_memory_dump.js":109,"./event_registry.js":119,"./memory_allocator_dump.js":134}],124:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  /**
   * HeapEntry represents a single value describing the state of the heap of an
   * allocator in a single process.
   *
   * An entry specifies how much space (e.g. 19 MiB) was allocated in a
   * particular context, which consists of a codepath (e.g. drawQuad <- draw <-
   * MessageLoop::RunTask) and an object type (e.g. HTMLImportLoader).
   *
   * @{constructor}
   */
  function HeapEntry(heapDump, leafStackFrame, objectTypeName, size, count) {
    this.heapDump = heapDump;

    // The leaf stack frame of the associated backtrace (e.g. drawQuad for the
    // drawQuad <- draw <- MessageLoop::RunTask backtrace). If undefined, the
    // backtrace is empty.
    this.leafStackFrame = leafStackFrame;

    // The name of the allocated object type (e.g. 'HTMLImportLoader'). If
    // undefined, the entry represents the sum over all object types.
    this.objectTypeName = objectTypeName;

    this.size = size;
    this.count = count;
  }

  /**
   * HeapDump represents a dump of the heap of an allocator in a single process
   * at a particular timestamp.
   *
   * @{constructor}
   */
  function HeapDump(processMemoryDump, allocatorName) {
    this.processMemoryDump = processMemoryDump;
    this.allocatorName = allocatorName;
    this.entries = [];
  }

  HeapDump.prototype = {
    addEntry: function (leafStackFrame, objectTypeName, size, count) {
      var entry = new HeapEntry(this, leafStackFrame, objectTypeName, size, count);
      this.entries.push(entry);
      return entry;
    }
  };

  return {
    HeapEntry: HeapEntry,
    HeapDump: HeapDump
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],125:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/iteration_helpers.js");
require("./chrome_process_helper.js");

'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
global.tr.exportTo('tr.model.helpers', function () {
  function ChromeBrowserHelper(modelHelper, process) {
    tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
    this.mainThread_ = process.findAtMostOneThreadNamed('CrBrowserMain');
    if (!process.name) process.name = ChromeBrowserHelper.PROCESS_NAME;
  }

  ChromeBrowserHelper.PROCESS_NAME = 'Browser';

  ChromeBrowserHelper.isBrowserProcess = function (process) {
    return !!process.findAtMostOneThreadNamed('CrBrowserMain');
  };

  ChromeBrowserHelper.prototype = {
    __proto__: tr.model.helpers.ChromeProcessHelper.prototype,

    // TODO(petrcermak): Pass browser name in a metadata event (see
    // crbug.com/605088).
    get browserName() {
      var hasInProcessRendererThread = this.process.findAllThreadsNamed('Chrome_InProcRendererThread').length > 0;
      return hasInProcessRendererThread ? 'webview' : 'chrome';
    },

    get rendererHelpers() {
      return this.modelHelper.rendererHelpers;
    },

    getLoadingEventsInRange: function (rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function (slice) {
        return slice.title.indexOf('WebContentsImpl Loading') === 0 && rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end);
      });
    },

    getCommitProvisionalLoadEventsInRange: function (rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function (slice) {
        return slice.title === 'RenderFrameImpl::didCommitProvisionalLoad' && rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end);
      });
    },

    get hasLatencyEvents() {
      var hasLatency = false;
      for (var thread of this.modelHelper.model.getAllThreads()) for (var event of thread.getDescendantEvents()) {
        if (!event.isTopLevel) continue;
        if (!(event instanceof tr.e.cc.InputLatencyAsyncSlice)) continue;
        hasLatency = true;
      }
      return hasLatency;
    },

    getLatencyEventsInRange: function (rangeOfInterest) {
      return this.getAllAsyncSlicesMatching(function (slice) {
        return slice.title.indexOf('InputLatency') === 0 && rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end);
      });
    },

    getAllAsyncSlicesMatching: function (pred, opt_this) {
      var events = [];
      this.iterAllThreads(function (thread) {
        for (var slice of thread.getDescendantEvents()) if (pred.call(opt_this, slice)) events.push(slice);
      });
      return events;
    },

    getAllNetworkEventsInRange: function (rangeOfInterest) {
      var networkEvents = [];
      this.modelHelper.model.getAllThreads().forEach(function (thread) {
        thread.asyncSliceGroup.slices.forEach(function (slice) {
          var match = false;
          if (slice.category == 'net' || // old-style URLRequest/Resource
          slice.category == 'disabled-by-default-netlog' || slice.category == 'netlog') {
            match = true;
          }

          if (!match) return;

          if (rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end)) networkEvents.push(slice);
        });
      });
      return networkEvents;
    },

    iterAllThreads: function (func, opt_this) {
      tr.b.iterItems(this.process.threads, function (tid, thread) {
        func.call(opt_this, thread);
      });

      tr.b.iterItems(this.rendererHelpers, function (pid, rendererHelper) {
        var rendererProcess = rendererHelper.process;
        tr.b.iterItems(rendererProcess.threads, function (tid, thread) {
          func.call(opt_this, thread);
        });
      }, this);
    }
  };

  return {
    ChromeBrowserHelper: ChromeBrowserHelper
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/iteration_helpers.js":41,"./chrome_process_helper.js":128}],126:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./chrome_process_helper.js");

'use strict';

/**
 * @fileoverview Utilities for accessing the Chrome GPU Process.
 */
global.tr.exportTo('tr.model.helpers', function () {
  function ChromeGpuHelper(modelHelper, process) {
    tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
    this.mainThread_ = process.findAtMostOneThreadNamed('CrGpuMain');
    if (!process.name) process.name = ChromeGpuHelper.PROCESS_NAME;
  };

  ChromeGpuHelper.PROCESS_NAME = 'GPU Process';

  ChromeGpuHelper.isGpuProcess = function (process) {
    // In some android builds the GPU thread is not in a separate process.
    if (process.findAtMostOneThreadNamed('CrBrowserMain') || process.findAtMostOneThreadNamed('CrRendererMain')) return false;
    return process.findAtMostOneThreadNamed('CrGpuMain');
  };

  ChromeGpuHelper.prototype = {
    __proto__: tr.model.helpers.ChromeProcessHelper.prototype,

    get mainThread() {
      return this.mainThread_;
    }
  };

  return {
    ChromeGpuHelper: ChromeGpuHelper
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chrome_process_helper.js":128}],127:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/guid.js");
require("../../base/iteration_helpers.js");
require("./chrome_browser_helper.js");
require("./chrome_gpu_helper.js");
require("./chrome_renderer_helper.js");

'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
global.tr.exportTo('tr.model.helpers', function () {
  function findChromeBrowserProcesses(model) {
    return model.getAllProcesses(tr.model.helpers.ChromeBrowserHelper.isBrowserProcess);
  }

  function findChromeRenderProcesses(model) {
    return model.getAllProcesses(tr.model.helpers.ChromeRendererHelper.isRenderProcess);
  }

  function findChromeGpuProcess(model) {
    var gpuProcesses = model.getAllProcesses(tr.model.helpers.ChromeGpuHelper.isGpuProcess);
    if (gpuProcesses.length !== 1) return undefined;
    return gpuProcesses[0];
  }

  /**
   * @constructor
   */
  function ChromeModelHelper(model) {
    this.model_ = model;

    // Find browserHelpers.
    var browserProcesses = findChromeBrowserProcesses(model);
    this.browserHelpers_ = browserProcesses.map(p => new tr.model.helpers.ChromeBrowserHelper(this, p));

    // Find gpuHelper.
    var gpuProcess = findChromeGpuProcess(model);
    if (gpuProcess) {
      this.gpuHelper_ = new tr.model.helpers.ChromeGpuHelper(this, gpuProcess);
    } else {
      this.gpuHelper_ = undefined;
    }

    // Find rendererHelpers.
    var rendererProcesses_ = findChromeRenderProcesses(model);

    this.rendererHelpers_ = {};
    rendererProcesses_.forEach(function (renderProcess) {
      var rendererHelper = new tr.model.helpers.ChromeRendererHelper(this, renderProcess);
      this.rendererHelpers_[rendererHelper.pid] = rendererHelper;
    }, this);
  }

  ChromeModelHelper.guid = tr.b.GUID.allocateSimple();

  ChromeModelHelper.supportsModel = function (model) {
    if (findChromeBrowserProcesses(model).length) return true;
    if (findChromeRenderProcesses(model).length) return true;
    return false;
  };

  ChromeModelHelper.prototype = {
    get pid() {
      throw new Error('woah');
    },

    get process() {
      throw new Error('woah');
    },

    get model() {
      return this.model_;
    },

    // TODO: Make all users of ChromeModelHelper support multiple browsers and
    // remove this getter (see #2119).
    get browserProcess() {
      if (this.browserHelper === undefined) return undefined;
      return this.browserHelper.process;
    },

    // TODO: Make all users of ChromeModelHelper support multiple browsers and
    // remove this getter (see #2119).
    get browserHelper() {
      return this.browserHelpers_[0];
    },

    get browserHelpers() {
      return this.browserHelpers_;
    },

    get gpuHelper() {
      return this.gpuHelper_;
    },

    get rendererHelpers() {
      return this.rendererHelpers_;
    }
  };

  return {
    ChromeModelHelper: ChromeModelHelper
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/guid.js":39,"../../base/iteration_helpers.js":41,"./chrome_browser_helper.js":125,"./chrome_gpu_helper.js":126,"./chrome_renderer_helper.js":129}],128:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/base.js");

'use strict';

/**
 * @fileoverview Utilities for accessing trace data about the Chrome browser.
 */
global.tr.exportTo('tr.model.helpers', function () {
  var MAIN_FRAMETIME_TYPE = 'main_frametime_type';
  var IMPL_FRAMETIME_TYPE = 'impl_frametime_type';

  var MAIN_RENDERING_STATS = 'BenchmarkInstrumentation::MainThreadRenderingStats';
  var IMPL_RENDERING_STATS = 'BenchmarkInstrumentation::ImplThreadRenderingStats';

  function getSlicesIntersectingRange(rangeOfInterest, slices) {
    var slicesInFilterRange = [];
    for (var i = 0; i < slices.length; i++) {
      var slice = slices[i];
      if (rangeOfInterest.intersectsExplicitRangeInclusive(slice.start, slice.end)) slicesInFilterRange.push(slice);
    }
    return slicesInFilterRange;
  }

  function ChromeProcessHelper(modelHelper, process) {
    this.modelHelper = modelHelper;
    this.process = process;
  }

  ChromeProcessHelper.prototype = {
    get pid() {
      return this.process.pid;
    },

    getFrameEventsInRange: function (frametimeType, range) {
      var titleToGet = frametimeType === MAIN_FRAMETIME_TYPE ? MAIN_RENDERING_STATS : IMPL_RENDERING_STATS;

      var frameEvents = [];
      for (var event of this.process.getDescendantEvents()) if (event.title === titleToGet) if (range.intersectsExplicitRangeInclusive(event.start, event.end)) frameEvents.push(event);

      frameEvents.sort(function (a, b) {
        return a.start - b.start;
      });
      return frameEvents;
    }
  };

  function getFrametimeDataFromEvents(frameEvents) {
    var frametimeData = [];
    for (var i = 1; i < frameEvents.length; i++) {
      var diff = frameEvents[i].start - frameEvents[i - 1].start;
      frametimeData.push({
        'x': frameEvents[i].start,
        'frametime': diff
      });
    }
    return frametimeData;
  }

  return {
    ChromeProcessHelper: ChromeProcessHelper,

    MAIN_FRAMETIME_TYPE: MAIN_FRAMETIME_TYPE,
    IMPL_FRAMETIME_TYPE: IMPL_FRAMETIME_TYPE,
    MAIN_RENDERING_STATS: MAIN_RENDERING_STATS,
    IMPL_RENDERING_STATS: IMPL_RENDERING_STATS,

    getSlicesIntersectingRange: getSlicesIntersectingRange,
    getFrametimeDataFromEvents: getFrametimeDataFromEvents
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/base.js":28}],129:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/range.js");
require("../../extras/chrome/chrome_user_friendly_category_driver.js");
require("./chrome_process_helper.js");

'use strict';

global.tr.exportTo('tr.model.helpers', function () {
  function ChromeRendererHelper(modelHelper, process) {
    tr.model.helpers.ChromeProcessHelper.call(this, modelHelper, process);
    this.mainThread_ = process.findAtMostOneThreadNamed('CrRendererMain');
    this.compositorThread_ = process.findAtMostOneThreadNamed('Compositor');
    this.rasterWorkerThreads_ = process.findAllThreadsMatching(function (t) {
      if (t.name === undefined) return false;
      if (t.name.indexOf('CompositorTileWorker') === 0) return true;
      if (t.name.indexOf('CompositorRasterWorker') === 0) return true;
      return false;
    });

    this.isChromeTracingUI_ = process.labels !== undefined && process.labels.length === 1 && process.labels[0] === 'chrome://tracing';
    if (!process.name) process.name = ChromeRendererHelper.PROCESS_NAME;
  }

  ChromeRendererHelper.PROCESS_NAME = 'Renderer';

  // Returns true if there is either a main thread or a compositor thread.
  ChromeRendererHelper.isRenderProcess = function (process) {
    if (process.findAtMostOneThreadNamed('CrRendererMain')) return true;
    if (process.findAtMostOneThreadNamed('Compositor')) return true;
    return false;
  };

  ChromeRendererHelper.prototype = {
    __proto__: tr.model.helpers.ChromeProcessHelper.prototype,

    // May be undefined.
    get mainThread() {
      return this.mainThread_;
    },

    // May be undefined.
    get compositorThread() {
      return this.compositorThread_;
    },

    // May be empty.
    get rasterWorkerThreads() {
      return this.rasterWorkerThreads_;
    },

    get isChromeTracingUI() {
      return this.isChromeTracingUI_;
    },

    /**
    * Generate a breakdown that attributes where time goes between |start| &
    * |end| on renderer thread.
    *
    * @param {number} start
    * @param {number} end
    * @return {Object} A time breakdown object whose every key is a chrome
    * userfriendly title & values are an object that show the total spent
    * between |start| & |end|, and the list of event labels of the group and
    * their total time between |start| & |end|.
    *
    * Example:
    *   {layout: {
    *        total: 100,
    *        events: {'FrameView::performPreLayoutTasks': 20,..}},
    *    v8_runtime: {
    *        total: 500,
    *        events: {'String::NewExternalTwoByte': 0.5,..}},
    *    ...
    *    }
    *
    *
    */
    generateTimeBreakdownTree: function (start, end) {
      if (this.mainThread === null) return;
      var breakdownMap = {};
      var range = tr.b.Range.fromExplicitRange(start, end);
      for (var title of tr.e.chrome.ChromeUserFriendlyCategoryDriver.ALL_TITLES) {
        breakdownMap[title] = { total: 0, events: {} };
      }
      breakdownMap['idle'] = { total: 0, events: {} };
      var totalIdleTime = end - start;
      for (var event of this.mainThread.getDescendantEvents()) {
        if (!range.intersectsExplicitRangeExclusive(event.start, event.end)) continue;
        if (event.selfTime === undefined) continue;
        var title = tr.e.chrome.ChromeUserFriendlyCategoryDriver.fromEvent(event);
        var wallTimeIntersectionRatio = 0;
        if (event.duration > 0) {
          wallTimeIntersectionRatio = range.findExplicitIntersectionDuration(event.start, event.end) / event.duration;
        }
        var v8Runtime = event.args['runtime-call-stat'];
        if (v8Runtime !== undefined) {
          try {
            var v8RuntimeObject = JSON.parse(v8Runtime);
            for (var runtimeCall in v8RuntimeObject) {
              if (v8RuntimeObject[runtimeCall].length == 2) {
                if (breakdownMap['v8_runtime'].events[runtimeCall] === undefined) {
                  breakdownMap['v8_runtime'].events[runtimeCall] = 0;
                }
                // V8 Runtime Call Stats data is in us, while the
                // breakdown tree timing is in ms.
                var runtimeTime = v8RuntimeObject[runtimeCall][1] * wallTimeIntersectionRatio / 1000;
                breakdownMap['v8_runtime'].total += runtimeTime;
                breakdownMap['v8_runtime'].events[runtimeCall] += runtimeTime;
              }
            }
          } catch (e) {
            console.warn(e);
          }
        }
        //        [     Slice 1       ]   [      Slice  2   ]   [    Slice 3   ]
        //            [  Slice 4    ]                             [ Slice 5 ]
        //              [ Slice 6 ]                                  |
        //                 |                                         |
        //                 |                                         |
        //                 v                                         v
        //                start                                     end
        //
        // For the case where the |start| or |end| overlapped with some existing
        // slice (see above diagram), we approximate the overlapped self-time
        // by multiplying the ratio of overlapped wall time to the self-time.
        // There should be way to compute the exact number, but in practice,
        // this should rarely happen, and when it does, the overlapped range
        // is relative small so that using approximation here should be good
        // enough.
        var approximatedSelfTimeContribution = event.selfTime * wallTimeIntersectionRatio;
        breakdownMap[title].total += approximatedSelfTimeContribution;
        if (breakdownMap[title].events[event.title] === undefined) breakdownMap[title].events[event.title] = 0;
        breakdownMap[title].events[event.title] += approximatedSelfTimeContribution;
        totalIdleTime -= approximatedSelfTimeContribution;
      }
      breakdownMap['idle'].total = totalIdleTime;
      return breakdownMap;
    }

  };

  return {
    ChromeRendererHelper: ChromeRendererHelper
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/range.js":47,"../../extras/chrome/chrome_user_friendly_category_driver.js":63,"./chrome_process_helper.js":128}],130:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");
require("./timed_event.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  var InstantEventType = {
    GLOBAL: 1,
    PROCESS: 2
  };

  /**
   * An InstantEvent is a zero-duration event.
   *
   * @constructor
   */
  function InstantEvent(category, title, colorId, start, args) {
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.args = args;

    this.type = undefined;
  }

  InstantEvent.prototype = {
    __proto__: tr.model.TimedEvent.prototype
  };

  /**
   * A GlobalInstantEvent is a zero-duration event that's not tied to any
   * particular process.
   *
   * An example is a trace event that's issued when a new USB device is plugged
   * into the machine.
   *
   * @constructor
   */
  function GlobalInstantEvent(category, title, colorId, start, args) {
    InstantEvent.apply(this, arguments);
    this.type = InstantEventType.GLOBAL;
  }

  GlobalInstantEvent.prototype = {
    __proto__: InstantEvent.prototype,
    get userFriendlyName() {
      return 'Global instant event ' + this.title + ' @ ' + tr.b.Unit.byName.timeStampInMs.format(start);
    }
  };

  /**
   * A ProcessInstantEvent is a zero-duration event that's tied to a
   * particular process.
   *
   * An example is a trace event that's issued when a kill signal is received.
   *
   * @constructor
   */
  function ProcessInstantEvent(category, title, colorId, start, args) {
    InstantEvent.apply(this, arguments);
    this.type = InstantEventType.PROCESS;
  }

  ProcessInstantEvent.prototype = {
    __proto__: InstantEvent.prototype,

    get userFriendlyName() {
      return 'Process-level instant event ' + this.title + ' @ ' + tr.b.Unit.byName.timeStampInMs.format(start);
    }
  };

  tr.model.EventRegistry.register(InstantEvent, {
    name: 'instantEvent',
    pluralName: 'instantEvents'
  });

  return {
    GlobalInstantEvent: GlobalInstantEvent,
    ProcessInstantEvent: ProcessInstantEvent,

    InstantEventType: InstantEventType,
    InstantEvent: InstantEvent
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57,"./timed_event.js":160}],131:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/iteration_helpers.js");
require("./event_set.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  function getAssociatedEvents(irs) {
    var allAssociatedEvents = new tr.model.EventSet();
    irs.forEach(function (ir) {
      ir.associatedEvents.forEach(function (event) {
        // FlowEvents don't have parentContainers or cpuDurations, and it's
        // annoying to highlight them.
        if (event instanceof tr.model.FlowEvent) return;
        allAssociatedEvents.push(event);
      });
    });
    return allAssociatedEvents;
  }

  function getUnassociatedEvents(model, associatedEvents) {
    var unassociatedEvents = new tr.model.EventSet();
    // The set of unassociated events contains only events that are not in
    // the set of associated events.
    // Only add event to the set of unassociated events if it is not in
    // the set of associated events.
    for (var proc of model.getAllProcesses()) for (var thread of tr.b.dictionaryValues(proc.threads)) for (var event of thread.sliceGroup.getDescendantEvents()) if (!associatedEvents.contains(event)) unassociatedEvents.push(event);
    return unassociatedEvents;
  }

  function getTotalCpuDuration(events) {
    var cpuMs = 0;
    events.forEach(function (event) {
      // Add up events' cpu self time if they have any.
      if (event.cpuSelfTime) cpuMs += event.cpuSelfTime;
    });
    return cpuMs;
  }

  function getIRCoverageFromModel(model) {
    var associatedEvents = getAssociatedEvents(model.userModel.expectations);

    if (!associatedEvents.length) return undefined;

    var unassociatedEvents = getUnassociatedEvents(model, associatedEvents);

    var associatedCpuMs = getTotalCpuDuration(associatedEvents);
    var unassociatedCpuMs = getTotalCpuDuration(unassociatedEvents);

    var totalEventCount = associatedEvents.length + unassociatedEvents.length;
    var totalCpuMs = associatedCpuMs + unassociatedCpuMs;
    var coveredEventsCpuTimeRatio = undefined;
    if (totalCpuMs !== 0) coveredEventsCpuTimeRatio = associatedCpuMs / totalCpuMs;

    return {
      associatedEventsCount: associatedEvents.length,
      unassociatedEventsCount: unassociatedEvents.length,
      associatedEventsCpuTimeMs: associatedCpuMs,
      unassociatedEventsCpuTimeMs: unassociatedCpuMs,
      coveredEventsCountRatio: associatedEvents.length / totalEventCount,
      coveredEventsCpuTimeRatio: coveredEventsCpuTimeRatio
    };
  }

  return {
    getIRCoverageFromModel: getIRCoverageFromModel,
    getAssociatedEvents: getAssociatedEvents,
    getUnassociatedEvents: getUnassociatedEvents
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41,"./event_set.js":120}],132:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/iteration_helpers.js");
require("./cpu.js");
require("./process_base.js");

'use strict';

/**
 * @fileoverview Provides the Process class.
 */
global.tr.exportTo('tr.model', function () {
  var Cpu = tr.model.Cpu;
  var ProcessBase = tr.model.ProcessBase;

  /**
   * The Kernel represents kernel-level objects in the model.
   * @constructor
   */
  function Kernel(model) {
    ProcessBase.call(this, model);

    this.cpus = {};
    this.softwareMeasuredCpuCount_ = undefined;
  };

  /**
   * Comparison between kernels is pretty meaningless.
   */
  Kernel.compare = function (x, y) {
    return 0;
  };

  Kernel.prototype = {
    __proto__: ProcessBase.prototype,

    compareTo: function (that) {
      return Kernel.compare(this, that);
    },

    get userFriendlyName() {
      return 'Kernel';
    },

    get userFriendlyDetails() {
      return 'Kernel';
    },

    get stableId() {
      return 'Kernel';
    },

    /**
     * @return {Cpu} Gets a specific Cpu or creates one if
     * it does not exist.
     */
    getOrCreateCpu: function (cpuNumber) {
      if (!this.cpus[cpuNumber]) this.cpus[cpuNumber] = new Cpu(this, cpuNumber);
      return this.cpus[cpuNumber];
    },

    get softwareMeasuredCpuCount() {
      return this.softwareMeasuredCpuCount_;
    },

    set softwareMeasuredCpuCount(softwareMeasuredCpuCount) {
      if (this.softwareMeasuredCpuCount_ !== undefined && this.softwareMeasuredCpuCount_ !== softwareMeasuredCpuCount) {
        throw new Error('Cannot change the softwareMeasuredCpuCount once it is set');
      }

      this.softwareMeasuredCpuCount_ = softwareMeasuredCpuCount;
    },

    /**
     * Estimates how many cpus are in the system, for use in system load
     * estimation.
     *
     * If kernel trace was provided, uses that data. Otherwise, uses the
     * software measured cpu count.
     */
    get bestGuessAtCpuCount() {
      var realCpuCount = tr.b.dictionaryLength(this.cpus);
      if (realCpuCount !== 0) return realCpuCount;
      return this.softwareMeasuredCpuCount;
    },

    updateBounds: function () {
      ProcessBase.prototype.updateBounds.call(this);
      for (var cpuNumber in this.cpus) {
        var cpu = this.cpus[cpuNumber];
        cpu.updateBounds();
        this.bounds.addRange(cpu.bounds);
      }
    },

    createSubSlices: function () {
      ProcessBase.prototype.createSubSlices.call(this);
      for (var cpuNumber in this.cpus) {
        var cpu = this.cpus[cpuNumber];
        cpu.createSubSlices();
      }
    },

    addCategoriesToDict: function (categoriesDict) {
      ProcessBase.prototype.addCategoriesToDict.call(this, categoriesDict);
      for (var cpuNumber in this.cpus) this.cpus[cpuNumber].addCategoriesToDict(categoriesDict);
    },

    getSettingsKey: function () {
      return 'kernel';
    },

    childEventContainers: function* () {
      yield* ProcessBase.prototype.childEventContainers.call(this);
      yield* tr.b.dictionaryValues(this.cpus);
    }
  };

  return {
    Kernel: Kernel
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41,"./cpu.js":113,"./process_base.js":144}],133:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  /**
   * YComponent is a class that handles storing the stableId and the percentage
   * offset in the y direction of all tracks within a specific viewX and viewY
   * coordinate.
   * @constructor
   */
  function YComponent(stableId, yPercentOffset) {
    this.stableId = stableId;
    this.yPercentOffset = yPercentOffset;
  }

  YComponent.prototype = {
    toDict: function () {
      return {
        stableId: this.stableId,
        yPercentOffset: this.yPercentOffset
      };
    }
  };

  /**
   * Location is a class that represents a spatial location on the timeline
   * that is specified by percent offsets within tracks rather than specific
   * points.
   *
   * @constructor
   */
  function Location(xWorld, yComponents) {
    this.xWorld_ = xWorld;
    this.yComponents_ = yComponents;
  };

  /**
   * Returns a new Location given by x and y coordinates with respect to
   * the timeline's drawing canvas.
   */
  Location.fromViewCoordinates = function (viewport, viewX, viewY) {
    var dt = viewport.currentDisplayTransform;
    var xWorld = dt.xViewToWorld(viewX);
    var yComponents = [];

    // Since we're given coordinates within the timeline canvas, we need to
    // convert them to document coordinates to get the element.
    var elem = document.elementFromPoint(viewX + viewport.modelTrackContainer.canvas.offsetLeft, viewY + viewport.modelTrackContainer.canvas.offsetTop);
    // Build yComponents by calculating percentage offset with respect to
    // each parent track.
    while (elem instanceof tr.ui.tracks.Track) {
      if (elem.eventContainer) {
        var boundRect = elem.getBoundingClientRect();
        var yPercentOffset = (viewY - boundRect.top) / boundRect.height;
        yComponents.push(new YComponent(elem.eventContainer.stableId, yPercentOffset));
      }
      elem = elem.parentElement;
    }

    if (yComponents.length == 0) return;
    return new Location(xWorld, yComponents);
  };

  Location.fromStableIdAndTimestamp = function (viewport, stableId, ts) {
    var xWorld = ts;
    var yComponents = [];

    // The y components' percentage offsets will be calculated with respect to
    // the boundingRect's top of containing track.
    var containerToTrack = viewport.containerToTrackMap;
    var elem = containerToTrack.getTrackByStableId(stableId);
    if (!elem) return;

    var firstY = elem.getBoundingClientRect().top;
    while (elem instanceof tr.ui.tracks.Track) {
      if (elem.eventContainer) {
        var boundRect = elem.getBoundingClientRect();
        var yPercentOffset = (firstY - boundRect.top) / boundRect.height;
        yComponents.push(new YComponent(elem.eventContainer.stableId, yPercentOffset));
      }
      elem = elem.parentElement;
    }

    if (yComponents.length == 0) return;
    return new Location(xWorld, yComponents);
  };

  Location.prototype = {

    get xWorld() {
      return this.xWorld_;
    },

    /**
     * Returns the first valid containing track based on the
     * internal yComponents.
     */
    getContainingTrack: function (viewport) {
      var containerToTrack = viewport.containerToTrackMap;
      for (var i in this.yComponents_) {
        var yComponent = this.yComponents_[i];
        var track = containerToTrack.getTrackByStableId(yComponent.stableId);
        if (track !== undefined) return track;
      }
    },

    /**
     * Calculates and returns x and y coordinates of the current location with
     * respect to the timeline's canvas.
     */
    toViewCoordinates: function (viewport) {
      var dt = viewport.currentDisplayTransform;
      var containerToTrack = viewport.containerToTrackMap;
      var viewX = dt.xWorldToView(this.xWorld_);

      var viewY = -1;
      for (var index in this.yComponents_) {
        var yComponent = this.yComponents_[index];
        var track = containerToTrack.getTrackByStableId(yComponent.stableId);
        if (track !== undefined) {
          var boundRect = track.getBoundingClientRect();
          viewY = yComponent.yPercentOffset * boundRect.height + boundRect.top;
          break;
        }
      }

      return {
        viewX: viewX,
        viewY: viewY
      };
    },

    toDict: function () {
      return {
        xWorld: this.xWorld_,
        yComponents: this.yComponents_
      };
    }
  };

  return {
    Location: Location
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],134:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/iteration_helpers.js");
require("../base/unit.js");
require("../value/numeric.js");

'use strict';

/**
 * @fileoverview Provides the MemoryAllocatorDump class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * @constructor
   */
  function MemoryAllocatorDump(containerMemoryDump, fullName, opt_guid) {
    this.fullName = fullName;
    this.parent = undefined;
    this.children = [];

    // String -> ScalarNumeric.
    this.numerics = {};

    // String -> string.
    this.diagnostics = {};

    // The associated container memory dump.
    this.containerMemoryDump = containerMemoryDump;

    // Ownership relationship between memory allocator dumps.
    this.owns = undefined;
    this.ownedBy = [];

    // Map from sibling dumps (other children of this dump's parent) to the
    // proportion of this dump's size which they (or their descendants) own.
    this.ownedBySiblingSizes = new Map();

    // Retention relationship between memory allocator dumps.
    this.retains = [];
    this.retainedBy = [];

    // Weak memory allocator dumps are removed from the model after import in
    // tr.model.GlobalMemoryDump.removeWeakDumps(). See
    // base::trace_event::MemoryAllocatorDump::Flags::WEAK in the Chromium
    // codebase.
    this.weak = false;

    // A list of information about the memory allocator dump (e.g. about how
    // its fields were calculated). Each item should be an object with
    // a mandatory 'type' property and type-specific extra arguments (see
    // MemoryAllocatorDumpInfoType).
    this.infos = [];

    // For debugging purposes.
    this.guid = opt_guid;
  }

  /**
   * Size numeric names. Please refer to the Memory Dump Graph Metric
   * Calculation design document for more details (https://goo.gl/fKg0dt).
   */
  MemoryAllocatorDump.SIZE_NUMERIC_NAME = 'size';
  MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME = 'effective_size';
  MemoryAllocatorDump.RESIDENT_SIZE_NUMERIC_NAME = 'resident_size';
  MemoryAllocatorDump.DISPLAYED_SIZE_NUMERIC_NAME = MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME;

  MemoryAllocatorDump.prototype = {
    get name() {
      return this.fullName.substring(this.fullName.lastIndexOf('/') + 1);
    },

    get quantifiedName() {
      return '\'' + this.fullName + '\' in ' + this.containerMemoryDump.containerName;
    },

    getDescendantDumpByFullName: function (fullName) {
      return this.containerMemoryDump.getMemoryAllocatorDumpByFullName(this.fullName + '/' + fullName);
    },

    isDescendantOf: function (otherDump) {
      var dump = this;
      while (dump !== undefined) {
        if (dump === otherDump) return true;
        dump = dump.parent;
      }
      return false;
    },

    addNumeric: function (name, numeric) {
      if (!(numeric instanceof tr.v.ScalarNumeric)) throw new Error('Numeric value must be an instance of ScalarNumeric.');
      if (name in this.numerics) throw new Error('Duplicate numeric name: ' + name + '.');
      this.numerics[name] = numeric;
    },

    addDiagnostic: function (name, text) {
      if (typeof text !== 'string') throw new Error('Diagnostic text must be a string.');
      if (name in this.diagnostics) throw new Error('Duplicate diagnostic name: ' + name + '.');
      this.diagnostics[name] = text;
    },

    aggregateNumericsRecursively: function (opt_model) {
      var numericNames = new Set();

      // Aggregate descendants's numerics recursively and gather children's
      // numeric names.
      this.children.forEach(function (child) {
        child.aggregateNumericsRecursively(opt_model);
        tr.b.iterItems(child.numerics, numericNames.add, numericNames);
      }, this);

      // Aggregate children's numerics.
      numericNames.forEach(function (numericName) {
        if (numericName === MemoryAllocatorDump.SIZE_NUMERIC_NAME || numericName === MemoryAllocatorDump.EFFECTIVE_SIZE_NUMERIC_NAME || this.numerics[numericName] !== undefined) {
          // Don't aggregate size and effective size numerics. These are
          // calculated in GlobalMemoryDump.prototype.calculateSizes() and
          // GlobalMemoryDump.prototype.calculateEffectiveSizes respectively.
          // Also don't aggregate numerics that the parent already has.
          return;
        }

        this.numerics[numericName] = MemoryAllocatorDump.aggregateNumerics(this.children.map(function (child) {
          return child.numerics[numericName];
        }), opt_model);
      }, this);
    }
  };

  // TODO(petrcermak): Consider moving this to tr.v.Histogram.
  MemoryAllocatorDump.aggregateNumerics = function (numerics, opt_model) {
    var shouldLogWarning = !!opt_model;
    var aggregatedUnit = undefined;
    var aggregatedValue = 0;

    // Aggregate the units and sum up the values of the numerics.
    numerics.forEach(function (numeric) {
      if (numeric === undefined) return;

      var unit = numeric.unit;
      if (aggregatedUnit === undefined) {
        aggregatedUnit = unit;
      } else if (aggregatedUnit !== unit) {
        if (shouldLogWarning) {
          opt_model.importWarning({
            type: 'numeric_parse_error',
            message: 'Multiple units provided for numeric: \'' + aggregatedUnit.unitName + '\' and \'' + unit.unitName + '\'.'
          });
          shouldLogWarning = false; // Don't log multiple warnings.
        }
        // Use the most generic unit when the numerics don't agree (best
        // effort).
        aggregatedUnit = tr.b.Unit.byName.unitlessNumber_smallerIsBetter;
      }

      aggregatedValue += numeric.value;
    }, this);

    if (aggregatedUnit === undefined) return undefined;

    return new tr.v.ScalarNumeric(aggregatedUnit, aggregatedValue);
  };

  /**
   * @constructor
   */
  function MemoryAllocatorDumpLink(source, target, opt_importance) {
    this.source = source;
    this.target = target;
    this.importance = opt_importance;
    this.size = undefined;
  }

  /**
   * Types of size numeric information.
   *
   * @enum
   */
  var MemoryAllocatorDumpInfoType = {
    // The provided size of a MemoryAllocatorDump was less than the aggregated
    // size of its children.
    //
    // Mandatory extra args:
    //   * providedSize: The inconsistent provided size.
    //   * dependencySize: The aggregated size of the children.
    PROVIDED_SIZE_LESS_THAN_AGGREGATED_CHILDREN: 0,

    // The provided size of a MemoryAllocatorDump was less than the size of its
    // largest owner.
    //
    // Mandatory extra args:
    //   * providedSize: The inconsistent provided size.
    //   * dependencySize: The size of the largest owner.
    PROVIDED_SIZE_LESS_THAN_LARGEST_OWNER: 1
  };

  return {
    MemoryAllocatorDump: MemoryAllocatorDump,
    MemoryAllocatorDumpLink: MemoryAllocatorDumpLink,
    MemoryAllocatorDumpInfoType: MemoryAllocatorDumpInfoType
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41,"../base/unit.js":57,"../value/numeric.js":190}],135:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2012 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/event.js");
require("../base/interval_tree.js");
require("../base/quad.js");
require("../base/range.js");
require("../base/task.js");
require("../base/time_display_modes.js");
require("../base/unit.js");
require("../core/auditor.js");
require("../core/filter.js");
require("./alert.js");
require("./clock_sync_manager.js");
require("./constants.js");
require("./device.js");
require("./flow_event.js");
require("./frame.js");
require("./global_memory_dump.js");
require("./instant_event.js");
require("./kernel.js");
require("./model_indices.js");
require("./model_stats.js");
require("./object_snapshot.js");
require("./process.js");
require("./process_memory_dump.js");
require("./sample.js");
require("./stack_frame.js");
require("./user_model/user_expectation.js");
require("./user_model/user_model.js");

'use strict';

/**
 * @fileoverview Model is a parsed representation of the
 * TraceEvents obtained from base/trace_event in which the begin-end
 * tokens are converted into a hierarchy of processes, threads,
 * subrows, and slices.
 *
 * The building block of the model is a slice. A slice is roughly
 * equivalent to function call executing on a specific thread. As a
 * result, slices may have one or more subslices.
 *
 * A thread contains one or more subrows of slices. Row 0 corresponds to
 * the "root" slices, e.g. the topmost slices. Row 1 contains slices that
 * are nested 1 deep in the stack, and so on. We use these subrows to draw
 * nesting tasks.
 *
 */
global.tr.exportTo('tr', function () {
  var Process = tr.model.Process;
  var Device = tr.model.Device;
  var Kernel = tr.model.Kernel;
  var GlobalMemoryDump = tr.model.GlobalMemoryDump;
  var GlobalInstantEvent = tr.model.GlobalInstantEvent;
  var FlowEvent = tr.model.FlowEvent;
  var Alert = tr.model.Alert;
  var Sample = tr.model.Sample;

  /**
   * @constructor
   */
  function Model() {
    tr.model.EventContainer.call(this);
    tr.b.EventTarget.decorate(this);

    this.timestampShiftToZeroAmount_ = 0;

    this.faviconHue = 'blue'; // Should be a key from favicons.html

    this.device = new Device(this);
    this.kernel = new Kernel(this);
    this.processes = {};
    this.metadata = [];
    this.categories = [];
    this.instantEvents = [];
    this.flowEvents = [];
    this.clockSyncManager = new tr.model.ClockSyncManager();
    this.intrinsicTimeUnit_ = undefined;

    this.stackFrames = {};
    this.samples = [];

    this.alerts = [];
    this.userModel = new tr.model.um.UserModel(this);

    this.flowIntervalTree = new tr.b.IntervalTree(f => f.start, f => f.end);
    this.globalMemoryDumps = [];

    this.userFriendlyCategoryDrivers_ = [];

    this.annotationsByGuid_ = {};
    this.modelIndices = undefined;

    this.stats = new tr.model.ModelStats();

    this.importWarnings_ = [];
    this.reportedImportWarnings_ = {};

    this.isTimeHighResolution_ = true;

    this.patchupsToApply_ = [];

    this.doesHelperGUIDSupportThisModel_ = {};
    this.helpersByConstructorGUID_ = {};
    this.eventsByStableId_ = undefined;
  }

  Model.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    getEventByStableId: function (stableId) {
      if (this.eventsByStableId_ === undefined) {
        this.eventsByStableId_ = {};
        for (var event of this.getDescendantEvents()) {
          this.eventsByStableId_[event.stableId] = event;
        }
      }
      return this.eventsByStableId_[stableId];
    },

    getOrCreateHelper: function (constructor) {
      if (!constructor.guid) throw new Error('Helper constructors must have GUIDs');

      if (this.helpersByConstructorGUID_[constructor.guid] === undefined) {
        if (this.doesHelperGUIDSupportThisModel_[constructor.guid] === undefined) {
          this.doesHelperGUIDSupportThisModel_[constructor.guid] = constructor.supportsModel(this);
        }

        if (!this.doesHelperGUIDSupportThisModel_[constructor.guid]) return undefined;

        this.helpersByConstructorGUID_[constructor.guid] = new constructor(this);
      }
      return this.helpersByConstructorGUID_[constructor.guid];
    },

    childEvents: function* () {
      yield* this.globalMemoryDumps;
      yield* this.instantEvents;
      yield* this.flowEvents;
      yield* this.alerts;
      yield* this.samples;
    },

    childEventContainers: function* () {
      yield this.userModel;
      yield this.device;
      yield this.kernel;
      yield* tr.b.dictionaryValues(this.processes);
    },

    /**
     * Some objects in the model can persist their state in ModelSettings.
     *
     * This iterates through them.
     */
    iterateAllPersistableObjects: function (callback) {
      this.kernel.iterateAllPersistableObjects(callback);
      for (var pid in this.processes) this.processes[pid].iterateAllPersistableObjects(callback);
    },

    updateBounds: function () {
      this.bounds.reset();
      var bounds = this.bounds;
      for (var ec of this.childEventContainers()) {
        ec.updateBounds();
        bounds.addRange(ec.bounds);
      }
      for (var event of this.childEvents()) event.addBoundsToRange(bounds);
    },

    shiftWorldToZero: function () {
      var shiftAmount = -this.bounds.min;
      this.timestampShiftToZeroAmount_ = shiftAmount;
      for (var ec of this.childEventContainers()) ec.shiftTimestampsForward(shiftAmount);

      for (var event of this.childEvents()) event.start += shiftAmount;
      this.updateBounds();
    },

    convertTimestampToModelTime: function (sourceClockDomainName, ts) {
      if (sourceClockDomainName !== 'traceEventClock') throw new Error('Only traceEventClock is supported.');
      return tr.b.Unit.timestampFromUs(ts) + this.timestampShiftToZeroAmount_;
    },

    get numProcesses() {
      var n = 0;
      for (var p in this.processes) n++;
      return n;
    },

    /**
     * @return {Process} Gets a TimelineProcess for a specified pid. Returns
     * undefined if the process doesn't exist.
     */
    getProcess: function (pid) {
      return this.processes[pid];
    },

    /**
     * @return {Process} Gets a TimelineProcess for a specified pid or
     * creates one if it does not exist.
     */
    getOrCreateProcess: function (pid) {
      if (!this.processes[pid]) this.processes[pid] = new Process(this, pid);
      return this.processes[pid];
    },

    addStackFrame: function (stackFrame) {
      if (this.stackFrames[stackFrame.id]) throw new Error('Stack frame already exists');
      this.stackFrames[stackFrame.id] = stackFrame;
      return stackFrame;
    },

    /**
     * Generates the set of categories from the slices and counters.
     */
    updateCategories_: function () {
      var categoriesDict = {};
      this.userModel.addCategoriesToDict(categoriesDict);
      this.device.addCategoriesToDict(categoriesDict);
      this.kernel.addCategoriesToDict(categoriesDict);
      for (var pid in this.processes) this.processes[pid].addCategoriesToDict(categoriesDict);

      this.categories = [];
      for (var category in categoriesDict) if (category != '') this.categories.push(category);
    },

    getAllThreads: function () {
      var threads = [];
      for (var tid in this.kernel.threads) {
        threads.push(process.threads[tid]);
      }
      for (var pid in this.processes) {
        var process = this.processes[pid];
        for (var tid in process.threads) {
          threads.push(process.threads[tid]);
        }
      }
      return threads;
    },

    /**
     * @param {(!function(!tr.model.Process): boolean)=} opt_predicate Optional
     *     predicate for filtering the returned processes. If undefined, all
     *     process in the model will be returned.
     * @return {!Array<!tr.model.Process>} An array of processes in the model.
     */
    getAllProcesses: function (opt_predicate) {
      var processes = [];
      for (var pid in this.processes) {
        var process = this.processes[pid];
        if (opt_predicate === undefined || opt_predicate(process)) processes.push(process);
      }
      return processes;
    },

    /**
     * @return {Array} An array of all the counters in the model.
     */
    getAllCounters: function () {
      var counters = [];
      counters.push.apply(counters, tr.b.dictionaryValues(this.device.counters));
      counters.push.apply(counters, tr.b.dictionaryValues(this.kernel.counters));
      for (var pid in this.processes) {
        var process = this.processes[pid];
        for (var tid in process.counters) {
          counters.push(process.counters[tid]);
        }
      }
      return counters;
    },

    getAnnotationByGUID: function (guid) {
      return this.annotationsByGuid_[guid];
    },

    addAnnotation: function (annotation) {
      if (!annotation.guid) throw new Error('Annotation with undefined guid given');

      this.annotationsByGuid_[annotation.guid] = annotation;
      tr.b.dispatchSimpleEvent(this, 'annotationChange');
    },

    removeAnnotation: function (annotation) {
      this.annotationsByGuid_[annotation.guid].onRemove();
      delete this.annotationsByGuid_[annotation.guid];
      tr.b.dispatchSimpleEvent(this, 'annotationChange');
    },

    getAllAnnotations: function () {
      return tr.b.dictionaryValues(this.annotationsByGuid_);
    },

    addUserFriendlyCategoryDriver: function (ufcd) {
      this.userFriendlyCategoryDrivers_.push(ufcd);
    },

    /**
     * Gets the user friendly category string from an event.
     *
     * Returns undefined if none is known.
     */
    getUserFriendlyCategoryFromEvent: function (event) {
      for (var i = 0; i < this.userFriendlyCategoryDrivers_.length; i++) {
        var ufc = this.userFriendlyCategoryDrivers_[i].fromEvent(event);
        if (ufc !== undefined) return ufc;
      }
      return undefined;
    },

    /**
     * @param {String} The name of the thread to find.
     * @return {Array} An array of all the matched threads.
     */
    findAllThreadsNamed: function (name) {
      var namedThreads = [];
      namedThreads.push.apply(namedThreads, this.kernel.findAllThreadsNamed(name));
      for (var pid in this.processes) {
        namedThreads.push.apply(namedThreads, this.processes[pid].findAllThreadsNamed(name));
      }
      return namedThreads;
    },

    get importOptions() {
      return this.importOptions_;
    },

    set importOptions(options) {
      this.importOptions_ = options;
    },

    /**
     * Returns a time unit that is used to format values and determines the
     * precision of the timestamp values.
     */
    get intrinsicTimeUnit() {
      if (this.intrinsicTimeUnit_ === undefined) return tr.b.TimeDisplayModes.ms;
      return this.intrinsicTimeUnit_;
    },

    set intrinsicTimeUnit(value) {
      if (this.intrinsicTimeUnit_ === value) return;
      if (this.intrinsicTimeUnit_ !== undefined) throw new Error('Intrinsic time unit already set');
      this.intrinsicTimeUnit_ = value;
    },

    get isTimeHighResolution() {
      return this.isTimeHighResolution_;
    },

    set isTimeHighResolution(value) {
      this.isTimeHighResolution_ = value;
    },

    /**
     * Returns a link to a trace data file that this model was imported from.
     * This is NOT the URL of a site being traced, but instead an indicator of
     * where the data is stored.
     */
    get canonicalUrl() {
      return this.canonicalUrl_;
    },

    set canonicalUrl(value) {
      if (this.canonicalUrl_ === value) return;
      if (this.canonicalUrl_ !== undefined) throw new Error('canonicalUrl already set');
      this.canonicalUrl_ = value;
    },

    /**
     * Saves a warning that happened during import.
     *
     * Warnings are typically logged to the console, and optionally, the
     * more critical ones are shown to the user.
     *
     * @param {Object} data The import warning data. Data must provide two
     *    accessors: type, message. The types are used to determine if we
     *    should output the message, we'll only output one message of each type.
     *    The message is the actual warning content.
     */
    importWarning: function (data) {
      data.showToUser = !!data.showToUser;

      this.importWarnings_.push(data);

      // Only log each warning type once. We may want to add some kind of
      // flag to allow reporting all importer warnings.
      if (this.reportedImportWarnings_[data.type] === true) return;

      if (this.importOptions_.showImportWarnings) console.warn(data.message);

      this.reportedImportWarnings_[data.type] = true;
    },

    get hasImportWarnings() {
      return this.importWarnings_.length > 0;
    },

    get importWarnings() {
      return this.importWarnings_;
    },

    get importWarningsThatShouldBeShownToUser() {
      return this.importWarnings_.filter(function (warning) {
        return warning.showToUser;
      });
    },

    autoCloseOpenSlices: function () {
      // Sort the samples.
      this.samples.sort(function (x, y) {
        return x.start - y.start;
      });

      this.updateBounds();
      this.kernel.autoCloseOpenSlices();
      for (var pid in this.processes) this.processes[pid].autoCloseOpenSlices();
    },

    createSubSlices: function () {
      this.kernel.createSubSlices();
      for (var pid in this.processes) this.processes[pid].createSubSlices();
    },

    preInitializeObjects: function () {
      for (var pid in this.processes) this.processes[pid].preInitializeObjects();
    },

    initializeObjects: function () {
      for (var pid in this.processes) this.processes[pid].initializeObjects();
    },

    pruneEmptyContainers: function () {
      this.kernel.pruneEmptyContainers();
      for (var pid in this.processes) this.processes[pid].pruneEmptyContainers();
    },

    mergeKernelWithUserland: function () {
      for (var pid in this.processes) this.processes[pid].mergeKernelWithUserland();
    },

    computeWorldBounds: function (shiftWorldToZero) {
      this.updateBounds();
      this.updateCategories_();

      if (shiftWorldToZero) this.shiftWorldToZero();
    },

    buildFlowEventIntervalTree: function () {
      for (var i = 0; i < this.flowEvents.length; ++i) {
        var flowEvent = this.flowEvents[i];
        this.flowIntervalTree.insert(flowEvent);
      }
      this.flowIntervalTree.updateHighValues();
    },

    cleanupUndeletedObjects: function () {
      for (var pid in this.processes) this.processes[pid].autoDeleteObjects(this.bounds.max);
    },

    sortMemoryDumps: function () {
      this.globalMemoryDumps.sort(function (x, y) {
        return x.start - y.start;
      });

      for (var pid in this.processes) this.processes[pid].sortMemoryDumps();
    },

    finalizeMemoryGraphs: function () {
      this.globalMemoryDumps.forEach(function (dump) {
        dump.finalizeGraph();
      });
    },

    buildEventIndices: function () {
      this.modelIndices = new tr.model.ModelIndices(this);
    },

    sortAlerts: function () {
      this.alerts.sort(function (x, y) {
        return x.start - y.start;
      });
    },

    applyObjectRefPatchups: function () {
      // Change all the fields pointing at id_refs to their real values.
      var unresolved = [];
      this.patchupsToApply_.forEach(function (patchup) {
        if (patchup.pidRef in this.processes) {
          var snapshot = this.processes[patchup.pidRef].objects.getSnapshotAt(patchup.scopedId, patchup.ts);
          if (snapshot) {
            patchup.object[patchup.field] = snapshot;
            snapshot.referencedAt(patchup.item, patchup.object, patchup.field);
            return;
          }
        }
        unresolved.push(patchup);
      }, this);
      this.patchupsToApply_ = unresolved;
    },

    replacePIDRefsInPatchups: function (oldPidRef, newPidRef) {
      this.patchupsToApply_.forEach(function (patchup) {
        if (patchup.pidRef === oldPidRef) {
          patchup.pidRef = newPidRef;
        }
      });
    },

    /**
     * Called by the model to join references between objects, after final model
     * bounds have been computed.
     */
    joinRefs: function () {
      this.joinObjectRefs_();
      this.applyObjectRefPatchups();
    },

    joinObjectRefs_: function () {
      tr.b.iterItems(this.processes, function (pid, process) {
        this.joinObjectRefsForProcess_(pid, process);
      }, this);
    },

    joinObjectRefsForProcess_: function (pid, process) {
      // Iterate the world, looking for id_refs
      tr.b.iterItems(process.threads, function (tid, thread) {
        thread.asyncSliceGroup.slices.forEach(function (item) {
          this.searchItemForIDRefs_(pid, 'start', item);
        }, this);
        thread.sliceGroup.slices.forEach(function (item) {
          this.searchItemForIDRefs_(pid, 'start', item);
        }, this);
      }, this);
      process.objects.iterObjectInstances(function (instance) {
        instance.snapshots.forEach(function (item) {
          this.searchItemForIDRefs_(pid, 'ts', item);
        }, this);
      }, this);
    },

    searchItemForIDRefs_: function (pid, itemTimestampField, item) {
      if (!item.args && !item.contexts) return;
      var patchupsToApply = this.patchupsToApply_;

      function handleField(object, fieldName, fieldValue) {
        if (!fieldValue || !fieldValue.id_ref && !fieldValue.idRef) return;

        var scope = fieldValue.scope || tr.model.OBJECT_DEFAULT_SCOPE;
        var idRef = fieldValue.id_ref || fieldValue.idRef;
        var scopedId = new tr.model.ScopedId(scope, idRef);
        var pidRef = fieldValue.pid_ref || fieldValue.pidRef || pid;
        var ts = item[itemTimestampField];
        // We have to delay the actual change to the new value until after all
        // refs have been located. Otherwise, we could end up recursing in
        // ways we definitely didn't intend.
        patchupsToApply.push({
          item: item,
          object: object,
          field: fieldName,
          pidRef: pidRef,
          scopedId: scopedId,
          ts: ts });
      }
      function iterObjectFieldsRecursively(object) {
        if (!(object instanceof Object)) return;

        if (object instanceof tr.model.ObjectSnapshot || object instanceof Float32Array || object instanceof tr.b.Quad) return;

        if (object instanceof Array) {
          for (var i = 0; i < object.length; i++) {
            handleField(object, i, object[i]);
            iterObjectFieldsRecursively(object[i]);
          }
          return;
        }

        for (var key in object) {
          var value = object[key];
          handleField(object, key, value);
          iterObjectFieldsRecursively(value);
        }
      }

      iterObjectFieldsRecursively(item.args);
      iterObjectFieldsRecursively(item.contexts);
    }
  };

  return {
    Model: Model
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/event.js":33,"../base/interval_tree.js":40,"../base/quad.js":45,"../base/range.js":47,"../base/task.js":54,"../base/time_display_modes.js":55,"../base/unit.js":57,"../core/auditor.js":60,"../core/filter.js":61,"./alert.js":101,"./clock_sync_manager.js":105,"./constants.js":108,"./device.js":115,"./flow_event.js":121,"./frame.js":122,"./global_memory_dump.js":123,"./instant_event.js":130,"./kernel.js":132,"./model_indices.js":136,"./model_stats.js":137,"./object_snapshot.js":140,"./process.js":143,"./process_memory_dump.js":145,"./sample.js":147,"./stack_frame.js":155,"./user_model/user_expectation.js":166,"./user_model/user_model.js":167}],136:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

/**
 * @fileoverview Provides the Event Index class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * A Event Index maps an id to all the events that have that particular id
   *
   * @constructor
   */
  function ModelIndices(model) {
    // For now the only indices we construct are for flowEvents
    this.flowEventsById_ = {};
    model.flowEvents.forEach(function (fe) {
      if (fe.id !== undefined) {
        if (!this.flowEventsById_.hasOwnProperty(fe.id)) {
          this.flowEventsById_[fe.id] = new Array();
        }
        this.flowEventsById_[fe.id].push(fe);
      }
    }, this);
  }

  ModelIndices.prototype = {
    addEventWithId: function (id, event) {
      if (!this.flowEventsById_.hasOwnProperty(id)) {
        this.flowEventsById_[id] = new Array();
      }
      this.flowEventsById_[id].push(event);
    },

    getFlowEventsWithId: function (id) {
      if (!this.flowEventsById_.hasOwnProperty(id)) return [];
      return this.flowEventsById_[id];
    }
  };

  return {
    ModelIndices: ModelIndices
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],137:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  /**
   * @constructor
   */
  function ModelStats() {
    this.traceEventCountsByKey_ = new Map();
    this.allTraceEventStats_ = [];

    this.traceEventStatsInTimeIntervals_ = new Map();
    this.allTraceEventStatsInTimeIntervals_ = [];

    this.hasEventSizesinBytes_ = false;
  }

  ModelStats.prototype = {
    TIME_INTERVAL_SIZE_IN_MS: 100,

    willProcessBasicTraceEvent: function (phase, category, title, ts, opt_eventSizeinBytes) {
      var key = phase + '/' + category + '/' + title;
      var eventStats = this.traceEventCountsByKey_.get(key);
      if (eventStats === undefined) {
        eventStats = {
          phase: phase,
          category: category,
          title: title,
          numEvents: 0,
          totalEventSizeinBytes: 0
        };
        this.traceEventCountsByKey_.set(key, eventStats);
        this.allTraceEventStats_.push(eventStats);
      }
      eventStats.numEvents++;

      var timeIntervalKey = Math.floor(tr.b.Unit.timestampFromUs(ts) / this.TIME_INTERVAL_SIZE_IN_MS);
      var eventStatsByTimeInverval = this.traceEventStatsInTimeIntervals_.get(timeIntervalKey);
      if (eventStatsByTimeInverval === undefined) {
        eventStatsByTimeInverval = {
          timeInterval: timeIntervalKey,
          numEvents: 0,
          totalEventSizeinBytes: 0
        };
        this.traceEventStatsInTimeIntervals_.set(timeIntervalKey, eventStatsByTimeInverval);
        this.allTraceEventStatsInTimeIntervals_.push(eventStatsByTimeInverval);
      }
      eventStatsByTimeInverval.numEvents++;

      if (opt_eventSizeinBytes !== undefined) {
        this.hasEventSizesinBytes_ = true;
        eventStats.totalEventSizeinBytes += opt_eventSizeinBytes;
        eventStatsByTimeInverval.totalEventSizeinBytes += opt_eventSizeinBytes;
      }
    },

    get allTraceEventStats() {
      return this.allTraceEventStats_;
    },

    get allTraceEventStatsInTimeIntervals() {
      return this.allTraceEventStatsInTimeIntervals_;
    },

    get hasEventSizesinBytes() {
      return this.hasEventSizesinBytes_;
    }
  };

  return {
    ModelStats: ModelStats
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57}],138:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range.js");
require("../base/sorted_array_utils.js");
require("../base/utils.js");
require("./event_container.js");
require("./object_instance.js");
require("./time_to_object_instance_map.js");

'use strict';

/**
 * @fileoverview Provides the ObjectCollection class.
 */
global.tr.exportTo('tr.model', function () {
  var ObjectInstance = tr.model.ObjectInstance;
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * A collection of object instances and their snapshots, accessible by id and
   * time, or by object name.
   *
   * @constructor
   */
  function ObjectCollection(parent) {
    tr.model.EventContainer.call(this);
    this.parent = parent;
    // scope -> {id -> TimeToObjectInstanceMap}
    this.instanceMapsByScopedId_ = {};
    this.instancesByTypeName_ = {};
    this.createObjectInstance_ = this.createObjectInstance_.bind(this);
  }

  ObjectCollection.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    childEvents: function* () {
      for (var instance of this.getAllObjectInstances()) {
        yield instance;
        yield* instance.snapshots;
      }
    },

    createObjectInstance_: function (parent, scopedId, category, name, creationTs, opt_baseTypeName) {
      var constructor = tr.model.ObjectInstance.subTypes.getConstructor(category, name);
      var instance = new constructor(parent, scopedId, category, name, creationTs, opt_baseTypeName);
      var typeName = instance.typeName;
      var instancesOfTypeName = this.instancesByTypeName_[typeName];
      if (!instancesOfTypeName) {
        instancesOfTypeName = [];
        this.instancesByTypeName_[typeName] = instancesOfTypeName;
      }
      instancesOfTypeName.push(instance);
      return instance;
    },

    getOrCreateInstanceMap_: function (scopedId) {
      var dict;
      if (scopedId.scope in this.instanceMapsByScopedId_) {
        dict = this.instanceMapsByScopedId_[scopedId.scope];
      } else {
        dict = {};
        this.instanceMapsByScopedId_[scopedId.scope] = dict;
      }
      var instanceMap = dict[scopedId.id];
      if (instanceMap) return instanceMap;
      instanceMap = new tr.model.TimeToObjectInstanceMap(this.createObjectInstance_, this.parent, scopedId);
      dict[scopedId.id] = instanceMap;
      return instanceMap;
    },

    idWasCreated: function (scopedId, category, name, ts) {
      var instanceMap = this.getOrCreateInstanceMap_(scopedId);
      return instanceMap.idWasCreated(category, name, ts);
    },

    addSnapshot: function (scopedId, category, name, ts, args, opt_baseTypeName) {
      var instanceMap = this.getOrCreateInstanceMap_(scopedId);
      var snapshot = instanceMap.addSnapshot(category, name, ts, args, opt_baseTypeName);
      if (snapshot.objectInstance.category != category) {
        var msg = 'Added snapshot name=' + name + ' with cat=' + category + ' impossible. It instance was created/snapshotted with cat=' + snapshot.objectInstance.category + ' name=' + snapshot.objectInstance.name;
        throw new Error(msg);
      }
      if (opt_baseTypeName && snapshot.objectInstance.baseTypeName != opt_baseTypeName) {
        throw new Error('Could not add snapshot with baseTypeName=' + opt_baseTypeName + '. It ' + 'was previously created with name=' + snapshot.objectInstance.baseTypeName);
      }
      if (snapshot.objectInstance.name != name) {
        throw new Error('Could not add snapshot with name=' + name + '. It ' + 'was previously created with name=' + snapshot.objectInstance.name);
      }
      return snapshot;
    },

    idWasDeleted: function (scopedId, category, name, ts) {
      var instanceMap = this.getOrCreateInstanceMap_(scopedId);
      var deletedInstance = instanceMap.idWasDeleted(category, name, ts);
      if (!deletedInstance) return;
      if (deletedInstance.category != category) {
        var msg = 'Deleting object ' + deletedInstance.name + ' with a different category ' + 'than when it was created. It previous had cat=' + deletedInstance.category + ' but the delete command ' + 'had cat=' + category;
        throw new Error(msg);
      }
      if (deletedInstance.baseTypeName != name) {
        throw new Error('Deletion requested for name=' + name + ' could not proceed: ' + 'An existing object with baseTypeName=' + deletedInstance.baseTypeName + ' existed.');
      }
    },

    autoDeleteObjects: function (maxTimestamp) {
      tr.b.iterItems(this.instanceMapsByScopedId_, function (scope, imapById) {
        tr.b.iterItems(imapById, function (id, i2imap) {
          var lastInstance = i2imap.lastInstance;
          if (lastInstance.deletionTs != Number.MAX_VALUE) return;
          i2imap.idWasDeleted(lastInstance.category, lastInstance.name, maxTimestamp);
          // idWasDeleted will cause lastInstance.deletionTsWasExplicit to be
          // set to true. Unset it here.
          lastInstance.deletionTsWasExplicit = false;
        });
      });
    },

    getObjectInstanceAt: function (scopedId, ts) {
      var instanceMap;
      if (scopedId.scope in this.instanceMapsByScopedId_) instanceMap = this.instanceMapsByScopedId_[scopedId.scope][scopedId.id];
      if (!instanceMap) return undefined;
      return instanceMap.getInstanceAt(ts);
    },

    getSnapshotAt: function (scopedId, ts) {
      var instance = this.getObjectInstanceAt(scopedId, ts);
      if (!instance) return undefined;
      return instance.getSnapshotAt(ts);
    },

    iterObjectInstances: function (iter, opt_this) {
      opt_this = opt_this || this;
      tr.b.iterItems(this.instanceMapsByScopedId_, function (scope, imapById) {
        tr.b.iterItems(imapById, function (id, i2imap) {
          i2imap.instances.forEach(iter, opt_this);
        });
      });
    },

    getAllObjectInstances: function () {
      var instances = [];
      this.iterObjectInstances(function (i) {
        instances.push(i);
      });
      return instances;
    },

    getAllInstancesNamed: function (name) {
      return this.instancesByTypeName_[name];
    },

    getAllInstancesByTypeName: function () {
      return this.instancesByTypeName_;
    },

    preInitializeAllObjects: function () {
      this.iterObjectInstances(function (instance) {
        instance.preInitialize();
      });
    },

    initializeAllObjects: function () {
      this.iterObjectInstances(function (instance) {
        instance.initialize();
      });
    },

    initializeInstances: function () {
      this.iterObjectInstances(function (instance) {
        instance.initialize();
      });
    },

    updateBounds: function () {
      this.bounds.reset();
      this.iterObjectInstances(function (instance) {
        instance.updateBounds();
        this.bounds.addRange(instance.bounds);
      }, this);
    },

    shiftTimestampsForward: function (amount) {
      this.iterObjectInstances(function (instance) {
        instance.shiftTimestampsForward(amount);
      });
    },

    addCategoriesToDict: function (categoriesDict) {
      this.iterObjectInstances(function (instance) {
        categoriesDict[instance.category] = true;
      });
    }
  };

  return {
    ObjectCollection: ObjectCollection
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range.js":47,"../base/sorted_array_utils.js":52,"../base/utils.js":59,"./event_container.js":117,"./object_instance.js":139,"./time_to_object_instance_map.js":159}],139:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range.js");
require("../base/sorted_array_utils.js");
require("./event.js");
require("./object_snapshot.js");

'use strict';

/**
 * @fileoverview Provides the ObjectSnapshot and ObjectHistory classes.
 */
global.tr.exportTo('tr.model', function () {
  var ObjectSnapshot = tr.model.ObjectSnapshot;

  /**
   * An object with a specific id, whose state has been snapshotted several
   * times.
   *
   * @constructor
   */
  function ObjectInstance(parent, scopedId, category, name, creationTs, opt_baseTypeName) {
    tr.model.Event.call(this);
    this.parent = parent;
    this.scopedId = scopedId;
    this.category = category;
    this.baseTypeName = opt_baseTypeName ? opt_baseTypeName : name;
    this.name = name;
    this.creationTs = creationTs;
    this.creationTsWasExplicit = false;
    this.deletionTs = Number.MAX_VALUE;
    this.deletionTsWasExplicit = false;
    this.colorId = 0;
    this.bounds = new tr.b.Range();
    this.snapshots = [];
    this.hasImplicitSnapshots = false;
  }

  ObjectInstance.prototype = {
    __proto__: tr.model.Event.prototype,

    get typeName() {
      return this.name;
    },

    addBoundsToRange: function (range) {
      range.addRange(this.bounds);
    },

    addSnapshot: function (ts, args, opt_name, opt_baseTypeName) {
      if (ts < this.creationTs) throw new Error('Snapshots must be >= instance.creationTs');
      if (ts >= this.deletionTs) throw new Error('Snapshots cannot be added after ' + 'an objects deletion timestamp.');

      var lastSnapshot;
      if (this.snapshots.length > 0) {
        lastSnapshot = this.snapshots[this.snapshots.length - 1];
        if (lastSnapshot.ts == ts) throw new Error('Snapshots already exists at this time!');
        if (ts < lastSnapshot.ts) {
          throw new Error('Snapshots must be added in increasing timestamp order');
        }
      }

      // Update baseTypeName if needed.
      if (opt_name && this.name != opt_name) {
        if (!opt_baseTypeName) throw new Error('Must provide base type name for name update');
        if (this.baseTypeName != opt_baseTypeName) throw new Error('Cannot update type name: base types dont match');
        this.name = opt_name;
      }

      var snapshotConstructor = tr.model.ObjectSnapshot.subTypes.getConstructor(this.category, this.name);
      var snapshot = new snapshotConstructor(this, ts, args);
      this.snapshots.push(snapshot);
      return snapshot;
    },

    wasDeleted: function (ts) {
      var lastSnapshot;
      if (this.snapshots.length > 0) {
        lastSnapshot = this.snapshots[this.snapshots.length - 1];
        if (lastSnapshot.ts > ts) throw new Error('Instance cannot be deleted at ts=' + ts + '. A snapshot exists that is older.');
      }
      this.deletionTs = ts;
      this.deletionTsWasExplicit = true;
    },

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    preInitialize: function () {
      for (var i = 0; i < this.snapshots.length; i++) this.snapshots[i].preInitialize();
    },

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    initialize: function () {
      for (var i = 0; i < this.snapshots.length; i++) this.snapshots[i].initialize();
    },

    isAliveAt: function (ts) {
      if (ts < this.creationTs && this.creationTsWasExplicit) return false;
      if (ts > this.deletionTs) return false;

      return true;
    },

    getSnapshotAt: function (ts) {
      if (ts < this.creationTs) {
        if (this.creationTsWasExplicit) throw new Error('ts must be within lifetime of this instance');
        return this.snapshots[0];
      }
      if (ts > this.deletionTs) throw new Error('ts must be within lifetime of this instance');

      var snapshots = this.snapshots;
      var i = tr.b.findIndexInSortedIntervals(snapshots, function (snapshot) {
        return snapshot.ts;
      }, function (snapshot, i) {
        if (i == snapshots.length - 1) return snapshots[i].objectInstance.deletionTs;
        return snapshots[i + 1].ts - snapshots[i].ts;
      }, ts);
      if (i < 0) {
        // Note, this is a little bit sketchy: this lets early ts point at the
        // first snapshot, even before it is taken. We do this because raster
        // tasks usually post before their tile snapshots are dumped. This may
        // be a good line of code to re-visit if we start seeing strange and
        // confusing object references showing up in the traces.
        return this.snapshots[0];
      }
      if (i >= this.snapshots.length) return this.snapshots[this.snapshots.length - 1];
      return this.snapshots[i];
    },

    updateBounds: function () {
      this.bounds.reset();
      this.bounds.addValue(this.creationTs);
      if (this.deletionTs != Number.MAX_VALUE) this.bounds.addValue(this.deletionTs);else if (this.snapshots.length > 0) this.bounds.addValue(this.snapshots[this.snapshots.length - 1].ts);
    },

    shiftTimestampsForward: function (amount) {
      this.creationTs += amount;
      if (this.deletionTs != Number.MAX_VALUE) this.deletionTs += amount;
      this.snapshots.forEach(function (snapshot) {
        snapshot.ts += amount;
      });
    },

    get userFriendlyName() {
      return this.typeName + ' object ' + this.scopedId;
    }
  };

  tr.model.EventRegistry.register(ObjectInstance, {
    name: 'objectInstance',
    pluralName: 'objectInstances'
  });

  return {
    ObjectInstance: ObjectInstance
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range.js":47,"../base/sorted_array_utils.js":52,"./event.js":116,"./object_snapshot.js":140}],140:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");
require("./event.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  /**
   * A snapshot of an object instance, at a given moment in time.
   *
   * Initialization of snapshots and instances is three phased:
   *
   * 1. Instances and snapshots are constructed. This happens during event
   *    importing. Little should be done here, because the object's data
   *    are still being used by the importer to reconstruct object references.
   *
   * 2. Instances and snapshtos are preinitialized. This happens after implicit
   *    objects have been found, but before any references have been found and
   *    switched to direct references. Thus, every snapshot stands on its own.
   *    This is a good time to do global field renaming and type conversion,
   *    e.g. recognizing domain-specific types and converting from C++ naming
   *    convention to JS.
   *
   * 3. Instances and snapshtos are initialized. At this point, {id_ref:
   *    '0x1000'} fields have been converted to snapshot references. This is a
   *    good time to generic initialization steps and argument verification.
   *
   * @constructor
   */
  function ObjectSnapshot(objectInstance, ts, args) {
    tr.model.Event.call(this);
    this.objectInstance = objectInstance;
    this.ts = ts;
    this.args = args;
  }

  ObjectSnapshot.prototype = {
    __proto__: tr.model.Event.prototype,

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    preInitialize: function () {},

    /**
     * See ObjectSnapshot constructor notes on object initialization.
     */
    initialize: function () {},

    /**
     * Called when an object reference is resolved as this ObjectSnapshot.
     * @param {Object} item The event (async slice, slice or object) containing
     *     the resolved reference.
     * @param {Object} object The object directly containing the reference.
     * @param {String} field The field name of the reference in |object|.
     */
    referencedAt: function (item, object, field) {},

    addBoundsToRange: function (range) {
      range.addValue(this.ts);
    },

    get userFriendlyName() {
      return 'Snapshot of ' + this.objectInstance.typeName + ' ' + this.objectInstance.id + ' @ ' + tr.b.Unit.byName.timeStampInMs.format(this.ts);
    }
  };

  tr.model.EventRegistry.register(ObjectSnapshot, {
    name: 'objectSnapshot',
    pluralName: 'objectSnapshots'
  });

  return {
    ObjectSnapshot: ObjectSnapshot
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57,"./event.js":116}],141:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./event.js");
require("./event_registry.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  var Event = tr.model.Event;
  var EventRegistry = tr.model.EventRegistry;

  /**
   * A sample that contains a power measurement (in W).
   *
   * @constructor
   * @extends {Event}
   */
  function PowerSample(series, start, powerInW) {
    Event.call(this);

    this.series_ = series;
    this.start_ = start;
    this.powerInW_ = powerInW;
  }

  PowerSample.prototype = {
    __proto__: Event.prototype,

    get series() {
      return this.series_;
    },

    get start() {
      return this.start_;
    },

    set start(value) {
      this.start_ = value;
    },

    get powerInW() {
      return this.powerInW_;
    },

    set powerInW(value) {
      this.powerInW_ = value;
    },

    addBoundsToRange: function (range) {
      range.addValue(this.start);
    }
  };

  EventRegistry.register(PowerSample, {
    name: 'powerSample',
    pluralName: 'powerSamples'
  });

  return {
    PowerSample: PowerSample
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./event.js":116,"./event_registry.js":119}],142:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range.js");
require("../base/sorted_array_utils.js");
require("../base/unit_scale.js");
require("./event_container.js");
require("./power_sample.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  var PowerSample = tr.model.PowerSample;

  /**
   * A container holding a time series of power samples.
   *
   * @constructor
   * @extends {EventContainer}
   */
  function PowerSeries(device) {
    tr.model.EventContainer.call(this);

    this.device_ = device;
    this.samples_ = [];
  }

  PowerSeries.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get device() {
      return this.device_;
    },

    get samples() {
      return this.samples_;
    },

    get stableId() {
      return this.device_.stableId + '.PowerSeries';
    },

    /**
     * Adds a power sample to the series and returns it.
     *
     * Note: Samples must be added in chronological order.
     */
    addPowerSample: function (ts, val) {
      var sample = new PowerSample(this, ts, val);
      this.samples_.push(sample);
      return sample;
    },

    /**
     * Returns the total energy (in Joules) consumed between the specified
     * start and end timestamps (in milliseconds).
     */
    getEnergyConsumedInJ: function (start, end) {
      var measurementRange = tr.b.Range.fromExplicitRange(start, end);

      var energyConsumedInJ = 0;
      var startIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, start) - 1;
      var endIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, end);

      if (startIndex < 0) startIndex = 0;

      for (var i = startIndex; i < endIndex; i++) {
        var sample = this.samples[i];
        var nextSample = this.samples[i + 1];

        var sampleRange = new tr.b.Range();
        sampleRange.addValue(sample.start);
        sampleRange.addValue(nextSample ? nextSample.start : sample.start);

        var intersectionRangeInMs = measurementRange.findIntersection(sampleRange);

        var durationInS = tr.b.convertUnit(intersectionRangeInMs.duration, tr.b.UnitScale.Metric.MILLI, tr.b.UnitScale.Metric.NONE);

        energyConsumedInJ += durationInS * sample.powerInW;
      }

      return energyConsumedInJ;
    },

    getSamplesWithinRange: function (start, end) {
      var startIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, start);
      var endIndex = tr.b.findLowIndexInSortedArray(this.samples, x => x.start, end);
      return this.samples.slice(startIndex, endIndex);
    },

    shiftTimestampsForward: function (amount) {
      for (var i = 0; i < this.samples_.length; ++i) this.samples_[i].start += amount;
    },

    updateBounds: function () {
      this.bounds.reset();

      if (this.samples_.length === 0) return;

      this.bounds.addValue(this.samples_[0].start);
      this.bounds.addValue(this.samples_[this.samples_.length - 1].start);
    },

    childEvents: function* () {
      yield* this.samples_;
    }
  };

  return {
    PowerSeries: PowerSeries
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range.js":47,"../base/sorted_array_utils.js":52,"../base/unit_scale.js":58,"./event_container.js":117,"./power_sample.js":141}],143:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./process_base.js");
require("./process_memory_dump.js");

'use strict';

/**
 * @fileoverview Provides the Process class.
 */
global.tr.exportTo('tr.model', function () {
  var ProcessBase = tr.model.ProcessBase;
  var ProcessInstantEvent = tr.model.ProcessInstantEvent;
  var Frame = tr.model.Frame;
  var ProcessMemoryDump = tr.model.ProcessMemoryDump;

  /**
   * The Process represents a single userland process in the
   * trace.
   * @constructor
   */
  function Process(model, pid) {
    if (model === undefined) throw new Error('model must be provided');
    if (pid === undefined) throw new Error('pid must be provided');
    tr.model.ProcessBase.call(this, model);
    this.pid = pid;
    this.name = undefined;
    this.labels = [];
    this.instantEvents = [];
    this.memoryDumps = [];
    this.frames = [];
    this.activities = [];
  };

  /**
   * Comparison between processes that orders by pid.
   */
  Process.compare = function (x, y) {
    var tmp = tr.model.ProcessBase.compare(x, y);
    if (tmp) return tmp;

    tmp = tr.b.comparePossiblyUndefinedValues(x.name, y.name, function (x, y) {
      return x.localeCompare(y);
    });
    if (tmp) return tmp;

    tmp = tr.b.compareArrays(x.labels, y.labels, function (x, y) {
      return x.localeCompare(y);
    });
    if (tmp) return tmp;

    return x.pid - y.pid;
  };

  Process.prototype = {
    __proto__: tr.model.ProcessBase.prototype,

    get stableId() {
      return this.pid;
    },

    compareTo: function (that) {
      return Process.compare(this, that);
    },

    childEvents: function* () {
      yield* ProcessBase.prototype.childEvents.call(this);
      yield* this.instantEvents;
      yield* this.frames;
      yield* this.memoryDumps;
    },

    addLabelIfNeeded: function (labelName) {
      for (var i = 0; i < this.labels.length; i++) {
        if (this.labels[i] === labelName) return;
      }
      this.labels.push(labelName);
    },

    get userFriendlyName() {
      var res;
      if (this.name) res = this.name + ' (pid ' + this.pid + ')';else res = 'Process ' + this.pid;
      if (this.labels.length) res += ': ' + this.labels.join(', ');
      return res;
    },

    get userFriendlyDetails() {
      if (this.name) return this.name + ' (pid ' + this.pid + ')';
      return 'pid: ' + this.pid;
    },

    getSettingsKey: function () {
      if (!this.name) return undefined;
      if (!this.labels.length) return 'processes.' + this.name;
      return 'processes.' + this.name + '.' + this.labels.join('.');
    },

    shiftTimestampsForward: function (amount) {
      for (var i = 0; i < this.instantEvents.length; i++) this.instantEvents[i].start += amount;

      for (var i = 0; i < this.frames.length; i++) this.frames[i].shiftTimestampsForward(amount);

      for (var i = 0; i < this.memoryDumps.length; i++) this.memoryDumps[i].shiftTimestampsForward(amount);

      for (var i = 0; i < this.activities.length; i++) this.activities[i].shiftTimestampsForward(amount);

      tr.model.ProcessBase.prototype.shiftTimestampsForward.apply(this, arguments);
    },

    updateBounds: function () {
      tr.model.ProcessBase.prototype.updateBounds.apply(this);

      for (var i = 0; i < this.frames.length; i++) this.frames[i].addBoundsToRange(this.bounds);

      for (var i = 0; i < this.memoryDumps.length; i++) this.memoryDumps[i].addBoundsToRange(this.bounds);

      for (var i = 0; i < this.activities.length; i++) this.activities[i].addBoundsToRange(this.bounds);
    },

    sortMemoryDumps: function () {
      this.memoryDumps.sort(function (x, y) {
        return x.start - y.start;
      });
      tr.model.ProcessMemoryDump.hookUpMostRecentVmRegionsLinks(this.memoryDumps);
    }
  };

  return {
    Process: Process
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./process_base.js":144,"./process_memory_dump.js":145}],144:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/guid.js");
require("../base/range.js");
require("./counter.js");
require("./event_container.js");
require("./object_collection.js");
require("./thread.js");

'use strict';

/**
 * @fileoverview Provides the ProcessBase class.
 */
global.tr.exportTo('tr.model', function () {

  var Thread = tr.model.Thread;
  var Counter = tr.model.Counter;

  /**
   * The ProcessBase is a partial base class, upon which Kernel
   * and Process are built.
   *
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function ProcessBase(model) {
    if (!model) throw new Error('Must provide a model');
    tr.model.EventContainer.call(this);
    this.model = model;
    this.threads = {};
    this.counters = {};
    this.objects = new tr.model.ObjectCollection(this);
    this.sortIndex = 0;
  };

  ProcessBase.compare = function (x, y) {
    return x.sortIndex - y.sortIndex;
  };

  ProcessBase.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get stableId() {
      throw new Error('Not implemented');
    },

    childEventContainers: function* () {
      yield* tr.b.dictionaryValues(this.threads);
      yield* tr.b.dictionaryValues(this.counters);
      yield this.objects;
    },

    iterateAllPersistableObjects: function (cb) {
      cb(this);
      for (var tid in this.threads) this.threads[tid].iterateAllPersistableObjects(cb);
    },

    /**
     * Gets the number of threads in this process.
     */
    get numThreads() {
      var n = 0;
      for (var p in this.threads) {
        n++;
      }
      return n;
    },

    /**
     * Shifts all the timestamps inside this process forward by the amount
     * specified.
     */
    shiftTimestampsForward: function (amount) {
      for (var child of this.childEventContainers()) child.shiftTimestampsForward(amount);
    },

    /**
     * Closes any open slices.
     */
    autoCloseOpenSlices: function () {
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        thread.autoCloseOpenSlices();
      }
    },

    autoDeleteObjects: function (maxTimestamp) {
      this.objects.autoDeleteObjects(maxTimestamp);
    },

    /**
     * Called by the model after finalizing imports,
     * but before joining refs.
     */
    preInitializeObjects: function () {
      this.objects.preInitializeAllObjects();
    },

    /**
     * Called by the model after joining refs.
     */
    initializeObjects: function () {
      this.objects.initializeAllObjects();
    },

    /**
     * Merge slices from the kernel with those from userland for each thread.
     */
    mergeKernelWithUserland: function () {
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        thread.mergeKernelWithUserland();
      }
    },

    updateBounds: function () {
      this.bounds.reset();
      for (var tid in this.threads) {
        this.threads[tid].updateBounds();
        this.bounds.addRange(this.threads[tid].bounds);
      }
      for (var id in this.counters) {
        this.counters[id].updateBounds();
        this.bounds.addRange(this.counters[id].bounds);
      }
      this.objects.updateBounds();
      this.bounds.addRange(this.objects.bounds);
    },

    addCategoriesToDict: function (categoriesDict) {
      for (var tid in this.threads) this.threads[tid].addCategoriesToDict(categoriesDict);
      for (var id in this.counters) categoriesDict[this.counters[id].category] = true;
      this.objects.addCategoriesToDict(categoriesDict);
    },

    findAllThreadsMatching: function (predicate, opt_this) {
      var threads = [];
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        if (predicate.call(opt_this, thread)) threads.push(thread);
      }
      return threads;
    },

    /**
     * @param {String} The name of the thread to find.
     * @return {Array} An array of all the matched threads.
     */
    findAllThreadsNamed: function (name) {
      var threads = this.findAllThreadsMatching(function (thread) {
        if (!thread.name) return false;
        return thread.name === name;
      });
      return threads;
    },

    findAtMostOneThreadNamed: function (name) {
      var threads = this.findAllThreadsNamed(name);
      if (threads.length === 0) return undefined;
      if (threads.length > 1) throw new Error('Expected no more than one ' + name);
      return threads[0];
    },

    /**
     * Removes threads from the process that are fully empty.
     */
    pruneEmptyContainers: function () {
      var threadsToKeep = {};
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        if (!thread.isEmpty) threadsToKeep[tid] = thread;
      }
      this.threads = threadsToKeep;
    },

    /**
     * @return {TimelineThread} The thread identified by tid on this process,
     * or undefined if it doesn't exist.
     */
    getThread: function (tid) {
      return this.threads[tid];
    },

    /**
     * @return {TimelineThread} The thread identified by tid on this process,
     * creating it if it doesn't exist.
     */
    getOrCreateThread: function (tid) {
      if (!this.threads[tid]) this.threads[tid] = new Thread(this, tid);
      return this.threads[tid];
    },

    /**
     * @return {Counter} The counter on this process with the given
     * category/name combination, creating it if it doesn't exist.
     */
    getOrCreateCounter: function (cat, name) {
      var id = cat + '.' + name;
      if (!this.counters[id]) this.counters[id] = new Counter(this, id, cat, name);
      return this.counters[id];
    },

    getSettingsKey: function () {
      throw new Error('Not implemented');
    },

    createSubSlices: function () {
      for (var tid in this.threads) this.threads[tid].createSubSlices();
    }
  };

  return {
    ProcessBase: ProcessBase
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/guid.js":39,"../base/range.js":47,"./counter.js":110,"./event_container.js":117,"./object_collection.js":138,"./thread.js":156}],145:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");
require("./container_memory_dump.js");
require("./memory_allocator_dump.js");
require("./vm_region.js");

'use strict';

/**
 * @fileoverview Provides the ProcessMemoryDump class.
 */
global.tr.exportTo('tr.model', function () {

  // Names of MemoryAllocatorDump(s) from which tracing overhead should be
  // discounted.
  var DISCOUNTED_ALLOCATOR_NAMES = ['winheap', 'malloc'];

  // The path to where the tracing overhead dump should be added to the
  // winheap/malloc allocator dump tree.
  var TRACING_OVERHEAD_PATH = ['allocated_objects', 'tracing_overhead'];

  var SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.SIZE_NUMERIC_NAME;
  var RESIDENT_SIZE_NUMERIC_NAME = tr.model.MemoryAllocatorDump.RESIDENT_SIZE_NUMERIC_NAME;

  function getSizeNumericValue(dump, sizeNumericName) {
    var sizeNumeric = dump.numerics[sizeNumericName];
    if (sizeNumeric === undefined) return 0;
    return sizeNumeric.value;
  }

  /**
   * The ProcessMemoryDump represents a memory dump of a single process.
   * @constructor
   */
  function ProcessMemoryDump(globalMemoryDump, process, start) {
    tr.model.ContainerMemoryDump.call(this, start);
    this.process = process;
    this.globalMemoryDump = globalMemoryDump;

    // Process memory totals (optional object) with the following fields (also
    // optional):
    //   - residentBytes: Total resident bytes (number)
    //   - peakResidentBytes: Peak resident bytes (number)
    //   - arePeakResidentBytesResettable: Flag whether peak resident bytes are
    //     resettable (boolean)
    //   - platformSpecific: Map from OS-specific total names (string) to sizes
    //     (number)
    this.totals = undefined;

    this.vmRegions = undefined;

    // Map from allocator names to heap dumps.
    this.heapDumps = undefined;

    this.tracingOverheadOwnershipSetUp_ = false;
    this.tracingOverheadDiscountedFromVmRegions_ = false;
  }

  ProcessMemoryDump.prototype = {
    __proto__: tr.model.ContainerMemoryDump.prototype,

    get userFriendlyName() {
      return 'Process memory dump at ' + tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get containerName() {
      return this.process.userFriendlyName;
    },

    get processMemoryDumps() {
      var dumps = {};
      dumps[this.process.pid] = this;
      return dumps;
    },

    get hasOwnVmRegions() {
      return this.vmRegions !== undefined;
    },

    setUpTracingOverheadOwnership: function (opt_model) {
      // Make sure that calling this method twice won't lead to
      // 'double-discounting'.
      if (this.tracingOverheadOwnershipSetUp_) return;
      this.tracingOverheadOwnershipSetUp_ = true;

      var tracingDump = this.getMemoryAllocatorDumpByFullName('tracing');
      if (tracingDump === undefined || tracingDump.owns !== undefined) {
        // The tracing dump either doesn't exist, or it already owns another
        // dump.
        return;
      }

      if (tracingDump.owns !== undefined) return;

      // Add an ownership link from tracing to
      // malloc/allocated_objects/tracing_overhead or
      // winheap/allocated_objects/tracing_overhead.
      var hasDiscountedFromAllocatorDumps = DISCOUNTED_ALLOCATOR_NAMES.some(function (allocatorName) {
        // First check if the allocator root exists.
        var allocatorDump = this.getMemoryAllocatorDumpByFullName(allocatorName);
        if (allocatorDump === undefined) return false; // Allocator doesn't exist, try another one.

        var nextPathIndex = 0;
        var currentDump = allocatorDump;
        var currentFullName = allocatorName;

        // Descend from the root towards tracing_overhead as long as the dumps
        // on the path exist.
        for (; nextPathIndex < TRACING_OVERHEAD_PATH.length; nextPathIndex++) {
          var childFullName = currentFullName + '/' + TRACING_OVERHEAD_PATH[nextPathIndex];
          var childDump = this.getMemoryAllocatorDumpByFullName(childFullName);
          if (childDump === undefined) break;

          currentDump = childDump;
          currentFullName = childFullName;
        }

        // Create the missing descendant dumps on the path from the root
        // towards tracing_overhead.
        for (; nextPathIndex < TRACING_OVERHEAD_PATH.length; nextPathIndex++) {
          var childFullName = currentFullName + '/' + TRACING_OVERHEAD_PATH[nextPathIndex];
          var childDump = new tr.model.MemoryAllocatorDump(currentDump.containerMemoryDump, childFullName);
          childDump.parent = currentDump;
          currentDump.children.push(childDump);

          currentFullName = childFullName;
          currentDump = childDump;
        }

        // Add the ownership link.
        var ownershipLink = new tr.model.MemoryAllocatorDumpLink(tracingDump, currentDump);
        tracingDump.owns = ownershipLink;
        currentDump.ownedBy.push(ownershipLink);
        return true;
      }, this);

      // Force rebuilding the memory allocator dump index (if we've just added
      // a new memory allocator dump).
      if (hasDiscountedFromAllocatorDumps) this.forceRebuildingMemoryAllocatorDumpByFullNameIndex();
    },

    discountTracingOverheadFromVmRegions: function (opt_model) {
      // Make sure that calling this method twice won't lead to
      // 'double-discounting'.
      if (this.tracingOverheadDiscountedFromVmRegions_) return;
      this.tracingOverheadDiscountedFromVmRegions_ = true;

      var tracingDump = this.getMemoryAllocatorDumpByFullName('tracing');
      if (tracingDump === undefined) return;

      var discountedSize = getSizeNumericValue(tracingDump, SIZE_NUMERIC_NAME);
      var discountedResidentSize = getSizeNumericValue(tracingDump, RESIDENT_SIZE_NUMERIC_NAME);

      if (discountedSize <= 0 && discountedResidentSize <= 0) return;

      // Subtract the tracing size from the totals.
      if (this.totals !== undefined) {
        if (this.totals.residentBytes !== undefined) this.totals.residentBytes -= discountedResidentSize;
        if (this.totals.peakResidentBytes !== undefined) this.totals.peakResidentBytes -= discountedResidentSize;
      }

      // Subtract the tracing size from VM regions. More precisely, subtract
      // tracing resident_size from byte stats (private dirty and PSS) and
      // tracing size from virtual size by injecting a fake VM region with
      // negative values.
      if (this.vmRegions !== undefined) {
        var hasSizeInBytes = this.vmRegions.sizeInBytes !== undefined;
        var hasPrivateDirtyResident = this.vmRegions.byteStats.privateDirtyResident !== undefined;
        var hasProportionalResident = this.vmRegions.byteStats.proportionalResident !== undefined;

        if (hasSizeInBytes && discountedSize > 0 || (hasPrivateDirtyResident || hasProportionalResident) && discountedResidentSize > 0) {
          var byteStats = {};
          if (hasPrivateDirtyResident) byteStats.privateDirtyResident = -discountedResidentSize;
          if (hasProportionalResident) byteStats.proportionalResident = -discountedResidentSize;
          this.vmRegions.addRegion(tr.model.VMRegion.fromDict({
            mappedFile: '[discounted tracing overhead]',
            sizeInBytes: hasSizeInBytes ? -discountedSize : undefined,
            byteStats: byteStats
          }));
        }
      }
    }
  };

  ProcessMemoryDump.hookUpMostRecentVmRegionsLinks = function (processDumps) {
    var mostRecentVmRegions = undefined;

    processDumps.forEach(function (processDump) {
      // Update the most recent VM regions from the current dump.
      if (processDump.vmRegions !== undefined) mostRecentVmRegions = processDump.vmRegions;

      // Set the most recent VM regions of the current dump.
      processDump.mostRecentVmRegions = mostRecentVmRegions;
    });
  };

  tr.model.EventRegistry.register(ProcessMemoryDump, {
    name: 'processMemoryDump',
    pluralName: 'processMemoryDumps'
  });

  return {
    ProcessMemoryDump: ProcessMemoryDump
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57,"./container_memory_dump.js":109,"./memory_allocator_dump.js":134,"./vm_region.js":168}],146:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./location.js");
require("./annotation.js");
require("../ui/annotations/rect_annotation_view.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  function RectAnnotation(start, end) {
    tr.model.Annotation.apply(this, arguments);

    this.startLocation_ = start; // Location of top-left corner.
    this.endLocation_ = end; // Location of bottom-right corner.
    this.fillStyle = 'rgba(255, 180, 0, 0.3)';
  }

  RectAnnotation.fromDict = function (dict) {
    var args = dict.args;
    var startLoc = new tr.model.Location(args.start.xWorld, args.start.yComponents);
    var endLoc = new tr.model.Location(args.end.xWorld, args.end.yComponents);
    return new tr.model.RectAnnotation(startLoc, endLoc);
  };

  RectAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    get startLocation() {
      return this.startLocation_;
    },

    get endLocation() {
      return this.endLocation_;
    },

    toDict: function () {
      return {
        typeName: 'rect',
        args: {
          start: this.startLocation.toDict(),
          end: this.endLocation.toDict()
        }
      };
    },

    createView_: function (viewport) {
      return new tr.ui.annotations.RectAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(RectAnnotation, { typeName: 'rect' });

  return {
    RectAnnotation: RectAnnotation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../ui/annotations/rect_annotation_view.js":172,"./annotation.js":102,"./location.js":133}],147:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");
require("./timed_event.js");

'use strict';

/**
 * @fileoverview Provides the Sample class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * A Sample represents a sample taken at an instant in time, plus its stack
   * frame and parameters associated with that sample.
   *
   * @constructor
   */
  function Sample(cpu, thread, title, start, leafStackFrame, opt_weight, opt_args) {
    tr.model.TimedEvent.call(this, start);

    this.title = title;
    this.cpu = cpu;
    this.thread = thread;
    this.leafStackFrame = leafStackFrame;
    this.weight = opt_weight;
    this.args = opt_args || {};
  }

  Sample.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get colorId() {
      return this.leafStackFrame.colorId;
    },

    get stackTrace() {
      return this.leafStackFrame.stackTrace;
    },

    getUserFriendlyStackTrace: function () {
      return this.leafStackFrame.getUserFriendlyStackTrace();
    },

    get userFriendlyName() {
      return 'Sample at ' + tr.b.Unit.byName.timeStampInMs.format(this.start);
    }
  };

  tr.model.EventRegistry.register(Sample, {
    name: 'sample',
    pluralName: 'samples'
  });

  return {
    Sample: Sample
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57,"./timed_event.js":160}],148:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("./constants.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  function ScopedId(scope, id) {
    if (scope === undefined) {
      throw new Error('Scope should be defined. Use \'' + tr.model.OBJECT_DEFAULT_SCOPE + '\' as the default scope.');
    }
    this.scope = scope;
    this.id = id;
  }

  ScopedId.prototype = {
    toString: function () {
      return '{scope: ' + this.scope + ', id: ' + this.id + '}';
    }
  };

  return {
    ScopedId: ScopedId
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"./constants.js":108}],149:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./selection_state.js");

'use strict';

/**
 * @fileoverview Provides the SelectableItem class.
 */
global.tr.exportTo('tr.model', function () {
  var SelectionState = tr.model.SelectionState;

  /**
   * A SelectableItem is the abstract base class for any non-container data that
   * has an associated model item in the trace model (possibly itself).
   *
   * Subclasses must provide a selectionState property (or getter).
   *
   * @constructor
   */
  function SelectableItem(modelItem) {
    this.modelItem_ = modelItem;
  }

  SelectableItem.prototype = {
    get modelItem() {
      return this.modelItem_;
    },

    get selected() {
      return this.selectionState === SelectionState.SELECTED;
    },

    addToSelection: function (selection) {
      var modelItem = this.modelItem_;
      if (!modelItem) return;
      selection.push(modelItem);
    },

    addToTrackMap: function (eventToTrackMap, track) {
      var modelItem = this.modelItem_;
      if (!modelItem) return;
      eventToTrackMap.addEvent(modelItem, track);
    }
  };

  return {
    SelectableItem: SelectableItem
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./selection_state.js":150}],150:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");
require("../base/color_scheme.js");

'use strict';

/**
 * @fileoverview Provides the SelectionState class.
 */
global.tr.exportTo('tr.model', function () {
  var ColorScheme = tr.b.ColorScheme;

  /**
   * Describes the level of visual highlighting to apply to an event when shown.
   *
   * color_scheme.html defines N variations off of a base color palette,
   * one for each selection state, all concatenated into one flat array. To
   * pick the final colorId for a given variations, the SelectionState is
   * multiplied by the number of base colors.
   *
   * Thus, the values here must be kept in sync with color_scheme's palette
   * layout.
   */
  var SelectionState = {
    NONE: 0,

    // Legacy names.
    SELECTED: ColorScheme.properties.brightenedOffsets[0],
    HIGHLIGHTED: ColorScheme.properties.brightenedOffsets[1],
    DIMMED: ColorScheme.properties.dimmedOffsets[0],

    // Modern names.
    BRIGHTENED0: ColorScheme.properties.brightenedOffsets[0],
    BRIGHTENED1: ColorScheme.properties.brightenedOffsets[1],
    BRIGHTENED2: ColorScheme.properties.brightenedOffsets[2],

    DIMMED0: ColorScheme.properties.dimmedOffsets[0],
    DIMMED1: ColorScheme.properties.dimmedOffsets[1],
    DIMMED2: ColorScheme.properties.dimmedOffsets[2]
  };

  var brighteningLevels = [SelectionState.NONE, SelectionState.BRIGHTENED0, SelectionState.BRIGHTENED1, SelectionState.BRIGHTENED2];
  SelectionState.getFromBrighteningLevel = function (level) {
    return brighteningLevels[level];
  };

  var dimmingLevels = [SelectionState.DIMMED0, SelectionState.DIMMED1, SelectionState.DIMMED2];
  SelectionState.getFromDimmingLevel = function (level) {
    return dimmingLevels[level];
  };

  return {
    SelectionState: SelectionState
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28,"../base/color_scheme.js":32}],151:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/unit.js");
require("./timed_event.js");

'use strict';

/**
 * @fileoverview Provides the Slice class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * A Slice represents an interval of time plus parameters associated
   * with that interval.
   *
   * @constructor
   */
  function Slice(category, title, colorId, start, args, opt_duration, opt_cpuStart, opt_cpuDuration, opt_argsStripped, opt_bindId) {
    if (!(this instanceof Slice)) {
      throw new Error("Can't instantiate pure virtual class Slice");
    }
    tr.model.TimedEvent.call(this, start);

    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.args = args;
    this.startStackFrame = undefined;
    this.endStackFrame = undefined;
    this.didNotFinish = false;
    this.inFlowEvents = [];
    this.outFlowEvents = [];
    this.subSlices = [];
    this.selfTime = undefined;
    this.cpuSelfTime = undefined;
    this.important = false;
    this.parentContainer = undefined;
    this.argsStripped = false;

    this.bind_id_ = opt_bindId;

    // parentSlice and isTopLevel will be set by SliceGroup.
    this.parentSlice = undefined;
    this.isTopLevel = false;
    // After SliceGroup processes Slices, isTopLevel should be equivalent to
    // !parentSlice.

    if (opt_duration !== undefined) this.duration = opt_duration;

    if (opt_cpuStart !== undefined) this.cpuStart = opt_cpuStart;

    if (opt_cpuDuration !== undefined) this.cpuDuration = opt_cpuDuration;

    if (opt_argsStripped !== undefined) this.argsStripped = true;
  }

  Slice.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    get analysisTypeName() {
      return this.title;
    },

    get userFriendlyName() {
      return 'Slice ' + this.title + ' at ' + tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get stableId() {
      var parentSliceGroup = this.parentContainer.sliceGroup;
      return parentSliceGroup.stableId + '.' + parentSliceGroup.slices.indexOf(this);
    },

    findDescendentSlice: function (targetTitle) {
      if (!this.subSlices) return undefined;

      for (var i = 0; i < this.subSlices.length; i++) {
        if (this.subSlices[i].title == targetTitle) return this.subSlices[i];
        var slice = this.subSlices[i].findDescendentSlice(targetTitle);
        if (slice) return slice;
      }
      return undefined;
    },

    get mostTopLevelSlice() {
      var curSlice = this;
      while (curSlice.parentSlice) curSlice = curSlice.parentSlice;

      return curSlice;
    },

    getProcess: function () {
      var thread = this.parentContainer;
      if (thread && thread.getProcess) return thread.getProcess();
      return undefined;
    },

    get model() {
      var process = this.getProcess();
      if (process !== undefined) return this.getProcess().model;
      return undefined;
    },

    /**
     * Finds all topmost slices relative to this slice.
     *
     * Slices may have multiple direct descendants which satisfy
     * |eventPredicate|, and in this case, all of them are topmost as long as
     * this slice does not satisfy the predicate.
     *
     * For instance, suppose we are passing a predicate that checks whether
     * events titles begin with 'C'.
     *  C1.findTopmostSlicesRelativeToThisSlice() returns C1 in this example:
     * [   C1  ]
     *   [ C2 ]
     *
     * and D.findTopmostSlicesRelativeToThisSlice() returns C1 and C2 in this
     * example:
     * [      D     ]
     *   [C1]  [C2]
     */
    findTopmostSlicesRelativeToThisSlice: function* (eventPredicate) {
      if (eventPredicate(this)) {
        yield this;
        return;
      }
      for (var s of this.subSlices) yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
    },

    /**
     * Obtains all subsequent slices of this slice.
     *
     * Subsequent slices are slices that get executed after a particular
     * slice, i.e., all the functions that are called after the current one.
     *
     * For instance, E.iterateAllSubsequentSlices() in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will pass F, G, then H to the provided callback.
     *
     * The reason we need subsequent slices of a particular slice is that
     * when there is flow event goes into, e.g., E, we only want to highlight
     * E's subsequent slices to indicate the execution order.
     *
     * The idea to calculate the subsequent slices of slice E is to view
     * the slice group as a tree where the top-level slice A is the root node.
     * The preorder depth-first-search (DFS) order is naturally equivalent
     * to the function call order. We just need to perform a DFS, and start
     * recording the slices after we see the occurance of E.
     */
    iterateAllSubsequentSlices: function (callback, opt_this) {
      var parentStack = [];
      var started = false;

      // get the root node and push it to the DFS stack
      var topmostSlice = this.mostTopLevelSlice;
      parentStack.push(topmostSlice);

      // Using the stack to perform DFS
      while (parentStack.length !== 0) {
        var curSlice = parentStack.pop();

        if (started) callback.call(opt_this, curSlice);else started = curSlice.guid === this.guid;

        for (var i = curSlice.subSlices.length - 1; i >= 0; i--) {
          parentStack.push(curSlice.subSlices[i]);
        }
      }
    },

    get subsequentSlices() {
      var res = [];

      this.iterateAllSubsequentSlices(function (subseqSlice) {
        res.push(subseqSlice);
      });

      return res;
    },

    /**
     * Obtains the parents of a slice, from the most immediate to the root.
     *
     * For instance, E.enumerateAllAncestors() in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will yield D, then A, in the order from the leaves to the root.
     */
    enumerateAllAncestors: function* () {
      var curSlice = this;

      while (curSlice.parentSlice) {
        curSlice = curSlice.parentSlice;
        yield curSlice;
      }
    },

    get ancestorSlices() {
      var res = [];
      for (var slice of this.enumerateAllAncestors()) res.push(slice);
      return res;
    },

    iterateEntireHierarchy: function (callback, opt_this) {
      var mostTopLevelSlice = this.mostTopLevelSlice;
      callback.call(opt_this, mostTopLevelSlice);
      mostTopLevelSlice.iterateAllSubsequentSlices(callback, opt_this);
    },

    get entireHierarchy() {
      var res = [];

      this.iterateEntireHierarchy(function (slice) {
        res.push(slice);
      });

      return res;
    },

    /**
     * Returns this slice, and its ancestor and subsequent slices.
     *
     * For instance, E.ancestorAndSubsequentSlices in the following example:
     * [     A          ]
     * [ B][  D   ][ G  ]
     *  [C] [E][F]  [H]
     * will return E, D, A, F, G, and H, where E is itself, D and A are
     * E's ancestors, and F, G, and H are subsequent slices of E
     */
    get ancestorAndSubsequentSlices() {
      var res = [];

      res.push(this);

      for (var aSlice of this.enumerateAllAncestors()) res.push(aSlice);

      this.iterateAllSubsequentSlices(function (sSlice) {
        res.push(sSlice);
      });

      return res;
    },

    enumerateAllDescendents: function* () {
      for (var slice of this.subSlices) yield slice;
      for (var slice of this.subSlices) yield* slice.enumerateAllDescendents();
    },

    get descendentSlices() {
      var res = [];
      for (var slice of this.enumerateAllDescendents()) res.push(slice);
      return res;
    }

  };

  return {
    Slice: Slice
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/unit.js":57,"./timed_event.js":160}],152:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/color_scheme.js");
require("../base/guid.js");
require("../base/sorted_array_utils.js");
require("../core/filter.js");
require("./event_container.js");
require("./thread_slice.js");

'use strict';

/**
 * @fileoverview Provides the SliceGroup class.
 */
global.tr.exportTo('tr.model', function () {
  var ColorScheme = tr.b.ColorScheme;
  var ThreadSlice = tr.model.ThreadSlice;

  function getSliceLo(s) {
    return s.start;
  }

  function getSliceHi(s) {
    return s.end;
  }

  /**
   * A group of Slices, plus code to create them from B/E events, as
   * well as arrange them into subRows.
   *
   * Do not mutate the slices array directly. Modify it only by
   * SliceGroup mutation methods.
   *
   * @constructor
   * @param {function(new:Slice, category, title, colorId, start, args)=}
   *     opt_sliceConstructor The constructor to use when creating slices.
   * @extends {tr.model.EventContainer}
   */
  function SliceGroup(parentContainer, opt_sliceConstructor, opt_name) {
    tr.model.EventContainer.call(this);

    this.parentContainer_ = parentContainer;

    var sliceConstructor = opt_sliceConstructor || ThreadSlice;
    this.sliceConstructor = sliceConstructor;
    this.sliceConstructorSubTypes = this.sliceConstructor.subTypes;
    if (!this.sliceConstructorSubTypes) throw new Error('opt_sliceConstructor must have a subtype registry.');

    this.openPartialSlices_ = [];

    this.slices = [];
    this.topLevelSlices = [];
    this.haveTopLevelSlicesBeenBuilt = false;
    this.name_ = opt_name;

    if (this.model === undefined) throw new Error('SliceGroup must have model defined.');
  }

  SliceGroup.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get parentContainer() {
      return this.parentContainer_;
    },

    get model() {
      return this.parentContainer_.model;
    },

    get stableId() {
      return this.parentContainer_.stableId + '.SliceGroup';
    },

    getSettingsKey: function () {
      if (!this.name_) return undefined;
      var parentKey = this.parentContainer_.getSettingsKey();
      if (!parentKey) return undefined;
      return parentKey + '.' + this.name;
    },

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    },

    /**
     * Helper function that pushes the provided slice onto the slices array.
     * @param {Slice} slice The slice to be added to the slices array.
     */
    pushSlice: function (slice) {
      this.haveTopLevelSlicesBeenBuilt = false;
      slice.parentContainer = this.parentContainer_;
      this.slices.push(slice);
      return slice;
    },

    /**
     * Helper function that pushes the provided slices onto the slices array.
     * @param {Array.<Slice>} slices An array of slices to be added.
     */
    pushSlices: function (slices) {
      this.haveTopLevelSlicesBeenBuilt = false;
      slices.forEach(function (slice) {
        slice.parentContainer = this.parentContainer_;
        this.slices.push(slice);
      }, this);
    },

    /**
     * Opens a new slice in the group's slices.
     *
     * Calls to beginSlice and
     * endSlice must be made with non-monotonically-decreasing timestamps.
     *
     * @param {String} category Category name of the slice to add.
     * @param {String} title Title of the slice to add.
     * @param {Number} ts The timetsamp of the slice, in milliseconds.
     * @param {Object.<string, Object>=} opt_args Arguments associated with
     * the slice.
     * @param {Number=} opt_colorId The color of the slice, defined by
     * its palette id (see base/color_scheme.html).
     */
    beginSlice: function (category, title, ts, opt_args, opt_tts, opt_argsStripped, opt_colorId) {
      if (this.openPartialSlices_.length) {
        var prevSlice = this.openPartialSlices_[this.openPartialSlices_.length - 1];
        if (ts < prevSlice.start) throw new Error('Slices must be added in increasing timestamp order');
      }

      var colorId = opt_colorId || ColorScheme.getColorIdForGeneralPurposeString(title);
      var sliceConstructorSubTypes = this.sliceConstructorSubTypes;
      var sliceType = sliceConstructorSubTypes.getConstructor(category, title);
      var slice = new sliceType(category, title, colorId, ts, opt_args ? opt_args : {}, null, opt_tts, undefined, opt_argsStripped);
      this.openPartialSlices_.push(slice);
      slice.didNotFinish = true;
      this.pushSlice(slice);

      return slice;
    },

    isTimestampValidForBeginOrEnd: function (ts) {
      if (!this.openPartialSlices_.length) return true;
      var top = this.openPartialSlices_[this.openPartialSlices_.length - 1];
      return ts >= top.start;
    },

    /**
     * @return {Number} The number of beginSlices for which an endSlice has not
     * been issued.
     */
    get openSliceCount() {
      return this.openPartialSlices_.length;
    },

    get mostRecentlyOpenedPartialSlice() {
      if (!this.openPartialSlices_.length) return undefined;
      return this.openPartialSlices_[this.openPartialSlices_.length - 1];
    },

    /**
     * Ends the last begun slice in this group and pushes it onto the slice
     * array.
     *
     * @param {Number} ts Timestamp when the slice ended
     * @param {Number=} opt_colorId The color of the slice, defined by
     * its palette id (see base/color_scheme.html).
     * @return {Slice} slice.
     */
    endSlice: function (ts, opt_tts, opt_colorId) {
      if (!this.openSliceCount) throw new Error('endSlice called without an open slice');

      var slice = this.openPartialSlices_[this.openSliceCount - 1];
      this.openPartialSlices_.splice(this.openSliceCount - 1, 1);
      if (ts < slice.start) throw new Error('Slice ' + slice.title + ' end time is before its start.');

      slice.duration = ts - slice.start;
      slice.didNotFinish = false;
      slice.colorId = opt_colorId || slice.colorId;

      if (opt_tts && slice.cpuStart !== undefined) slice.cpuDuration = opt_tts - slice.cpuStart;

      return slice;
    },

    /**
     * Push a complete event as a Slice into the slice list.
     * The timestamp can be in any order.
     *
     * @param {String} category Category name of the slice to add.
     * @param {String} title Title of the slice to add.
     * @param {Number} ts The timetsamp of the slice, in milliseconds.
     * @param {Number} duration The duration of the slice, in milliseconds.
     * @param {Object.<string, Object>=} opt_args Arguments associated with
     * the slice.
     * @param {Number=} opt_colorId The color of the slice, as defined by
     * its palette id (see base/color_scheme.html).
     */
    pushCompleteSlice: function (category, title, ts, duration, tts, cpuDuration, opt_args, opt_argsStripped, opt_colorId, opt_bindId) {
      var colorId = opt_colorId || ColorScheme.getColorIdForGeneralPurposeString(title);
      var sliceConstructorSubTypes = this.sliceConstructorSubTypes;
      var sliceType = sliceConstructorSubTypes.getConstructor(category, title);
      var slice = new sliceType(category, title, colorId, ts, opt_args ? opt_args : {}, duration, tts, cpuDuration, opt_argsStripped, opt_bindId);
      if (duration === undefined) slice.didNotFinish = true;
      this.pushSlice(slice);
      return slice;
    },

    /**
     * Closes any open slices.
     * @param {Number=} opt_maxTimestamp The end time to use for the closed
     * slices. If not provided,
     * the max timestamp for this slice is provided.
     */
    autoCloseOpenSlices: function () {
      this.updateBounds();
      var maxTimestamp = this.bounds.max;
      for (var sI = 0; sI < this.slices.length; sI++) {
        var slice = this.slices[sI];
        if (slice.didNotFinish) slice.duration = maxTimestamp - slice.start;
      }
      this.openPartialSlices_ = [];
    },

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified.
     */
    shiftTimestampsForward: function (amount) {
      for (var sI = 0; sI < this.slices.length; sI++) {
        var slice = this.slices[sI];
        slice.start = slice.start + amount;
      }
    },

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds: function () {
      this.bounds.reset();
      for (var i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    },

    copySlice: function (slice) {
      var sliceConstructorSubTypes = this.sliceConstructorSubTypes;
      var sliceType = sliceConstructorSubTypes.getConstructor(slice.category, slice.title);
      var newSlice = new sliceType(slice.category, slice.title, slice.colorId, slice.start, slice.args, slice.duration, slice.cpuStart, slice.cpuDuration);
      newSlice.didNotFinish = slice.didNotFinish;
      return newSlice;
    },

    findTopmostSlicesInThisContainer: function* (eventPredicate, opt_this) {
      if (!this.haveTopLevelSlicesBeenBuilt) throw new Error('Nope');

      for (var s of this.topLevelSlices) yield* s.findTopmostSlicesRelativeToThisSlice(eventPredicate);
    },

    childEvents: function* () {
      yield* this.slices;
    },

    childEventContainers: function* () {},

    getSlicesOfName: function (title) {
      var slices = [];
      for (var i = 0; i < this.slices.length; i++) {
        if (this.slices[i].title == title) {
          slices.push(this.slices[i]);
        }
      }
      return slices;
    },

    iterSlicesInTimeRange: function (callback, start, end) {
      var ret = [];
      tr.b.iterateOverIntersectingIntervals(this.topLevelSlices, function (s) {
        return s.start;
      }, function (s) {
        return s.duration;
      }, start, end, function (topLevelSlice) {
        callback(topLevelSlice);
        for (var slice of topLevelSlice.enumerateAllDescendents()) callback(slice);
      });
      return ret;
    },

    findFirstSlice: function () {
      if (!this.haveTopLevelSlicesBeenBuilt) throw new Error('Nope');
      if (0 === this.slices.length) return undefined;
      return this.slices[0];
    },

    findSliceAtTs: function (ts) {
      if (!this.haveTopLevelSlicesBeenBuilt) throw new Error('Nope');
      var i = tr.b.findIndexInSortedClosedIntervals(this.topLevelSlices, getSliceLo, getSliceHi, ts);
      if (i == -1 || i == this.topLevelSlices.length) return undefined;

      var curSlice = this.topLevelSlices[i];

      // Now recurse on slice looking for subSlice of given ts.
      while (true) {
        var i = tr.b.findIndexInSortedClosedIntervals(curSlice.subSlices, getSliceLo, getSliceHi, ts);
        if (i == -1 || i == curSlice.subSlices.length) return curSlice;
        curSlice = curSlice.subSlices[i];
      }
    },

    findNextSliceAfter: function (ts, refGuid) {
      var i = tr.b.findLowIndexInSortedArray(this.slices, getSliceLo, ts);
      if (i === this.slices.length) return undefined;
      for (; i < this.slices.length; i++) {
        var slice = this.slices[i];
        if (slice.start > ts) return slice;
        if (slice.guid <= refGuid) continue;
        return slice;
      }
      return undefined;
    },

    /**
     * Construct subSlices for this group.
     * Populate the group topLevelSlices, parent slices get a subSlices[],
     * a selfThreadTime and a selfTime, child slices get a parentSlice
     * reference.
     */
    createSubSlices: function () {
      this.haveTopLevelSlicesBeenBuilt = true;
      this.createSubSlicesImpl_();
      if (this.parentContainer.timeSlices) this.addCpuTimeToSubslices_(this.parentContainer.timeSlices);
      this.slices.forEach(function (slice) {
        var selfTime = slice.duration;
        for (var i = 0; i < slice.subSlices.length; i++) selfTime -= slice.subSlices[i].duration;
        slice.selfTime = selfTime;

        if (slice.cpuDuration === undefined) return;

        var cpuSelfTime = slice.cpuDuration;
        for (var i = 0; i < slice.subSlices.length; i++) {
          if (slice.subSlices[i].cpuDuration !== undefined) cpuSelfTime -= slice.subSlices[i].cpuDuration;
        }
        slice.cpuSelfTime = cpuSelfTime;
      });
    },
    createSubSlicesImpl_: function () {
      var precisionUnit = this.model.intrinsicTimeUnit;

      // Note that this doesn't check whether |child| should be added to
      // |parent|'s descendant slices instead of |parent| directly.
      function addSliceIfBounds(parent, child) {
        if (parent.bounds(child, precisionUnit)) {
          child.parentSlice = parent;
          if (parent.subSlices === undefined) parent.subSlices = [];
          parent.subSlices.push(child);
          return true;
        }
        return false;
      }

      if (!this.slices.length) return;

      var ops = [];
      for (var i = 0; i < this.slices.length; i++) {
        if (this.slices[i].subSlices) this.slices[i].subSlices.splice(0, this.slices[i].subSlices.length);
        ops.push(i);
      }

      var originalSlices = this.slices;
      ops.sort(function (ix, iy) {
        var x = originalSlices[ix];
        var y = originalSlices[iy];
        if (x.start != y.start) return x.start - y.start;

        // Elements get inserted into the slices array in order of when the
        // slices start. Because slices must be properly nested, we break
        // start-time ties by assuming that the elements appearing earlier
        // in the slices array (and thus ending earlier) start earlier.
        return ix - iy;
      });

      var slices = new Array(this.slices.length);
      for (var i = 0; i < ops.length; i++) {
        slices[i] = originalSlices[ops[i]];
      }

      // Actually build the subrows.
      var rootSlice = slices[0];
      this.topLevelSlices = [];
      this.topLevelSlices.push(rootSlice);
      rootSlice.isTopLevel = true;
      for (var i = 1; i < slices.length; i++) {
        var slice = slices[i];
        while (rootSlice !== undefined && !addSliceIfBounds(rootSlice, slice)) {
          rootSlice = rootSlice.parentSlice;
        }
        if (rootSlice === undefined) {
          this.topLevelSlices.push(slice);
          slice.isTopLevel = true;
        }
        rootSlice = slice;
      }

      // Keep the slices in sorted form.
      this.slices = slices;
    },
    addCpuTimeToSubslices_: function (timeSlices) {
      var SCHEDULING_STATE = tr.model.SCHEDULING_STATE;
      var sliceIdx = 0;
      timeSlices.forEach(function (timeSlice) {
        if (timeSlice.schedulingState == SCHEDULING_STATE.RUNNING) {
          while (sliceIdx < this.topLevelSlices.length) {
            if (this.addCpuTimeToSubslice_(this.topLevelSlices[sliceIdx], timeSlice)) {
              // The current top-level slice and children are fully
              // accounted for, proceed to next top-level slice.
              sliceIdx++;
            } else {
              // The current top-level runs beyond the time slice, break out
              // so we can potentially add more time slices to it
              break;
            }
          }
        }
      }, this);
    },
    /* Add run-time of this timeSlice to the passed in slice
     * and all of it's children (recursively).
     * Returns whether the slice ends before or at the end of the
     * time slice, signaling we are done with this slice.
     */
    addCpuTimeToSubslice_: function (slice, timeSlice) {
      // Make sure they overlap
      if (slice.start > timeSlice.end || slice.end < timeSlice.start) return slice.end <= timeSlice.end;

      // Compute actual overlap
      var duration = timeSlice.duration;
      if (slice.start > timeSlice.start) duration -= slice.start - timeSlice.start;
      if (timeSlice.end > slice.end) duration -= timeSlice.end - slice.end;

      if (slice.cpuDuration) {
        slice.cpuDuration += duration;
      } else {
        slice.cpuDuration = duration;
      }

      for (var i = 0; i < slice.subSlices.length; i++) {
        this.addCpuTimeToSubslice_(slice.subSlices[i], timeSlice);
      }

      return slice.end <= timeSlice.end;
    }
  };

  /**
   * Merge two slice groups.
   *
   * If the two groups do not nest properly some of the slices of groupB will
   * be split to accomodate the improper nesting.  This is done to accomodate
   * combined kernel and userland call stacks on Android.  Because userland
   * tracing is done by writing to the trace_marker file, the kernel calls
   * that get invoked as part of that write may not be properly nested with
   * the userland call trace.  For example the following sequence may occur:
   *
   *     kernel enter sys_write        (the write to trace_marker)
   *     user   enter some_function
   *     kernel exit  sys_write
   *     ...
   *     kernel enter sys_write        (the write to trace_marker)
   *     user   exit  some_function
   *     kernel exit  sys_write
   *
   * This is handled by splitting the sys_write call into two slices as
   * follows:
   *
   *     | sys_write |            some_function            | sys_write (cont.) |
   *                 | sys_write (cont.) |     | sys_write |
   *
   * The colorId of both parts of the split slices are kept the same, and the
   * " (cont.)" suffix is appended to the later parts of a split slice.
   *
   * The two input SliceGroups are not modified by this, and the merged
   * SliceGroup will contain a copy of each of the input groups' slices (those
   * copies may be split).
   */
  SliceGroup.merge = function (groupA, groupB) {
    // This is implemented by traversing the two slice groups in reverse
    // order.  The slices in each group are sorted by ascending end-time, so
    // we must do the traversal from back to front in order to maintain the
    // sorting.
    //
    // We traverse the two groups simultaneously, merging as we go.  At each
    // iteration we choose the group from which to take the next slice based
    // on which group's next slice has the greater end-time.  During this
    // traversal we maintain a stack of currently "open" slices for each input
    // group.  A slice is considered "open" from the time it gets reached in
    // our input group traversal to the time we reach an slice in this
    // traversal with an end-time before the start time of the "open" slice.
    //
    // Each time a slice from groupA is opened or closed (events corresponding
    // to the end-time and start-time of the input slice, respectively) we
    // split all of the currently open slices from groupB.

    if (groupA.openPartialSlices_.length > 0) throw new Error('groupA has open partial slices');

    if (groupB.openPartialSlices_.length > 0) throw new Error('groupB has open partial slices');

    if (groupA.parentContainer != groupB.parentContainer) throw new Error('Different parent threads. Cannot merge');

    if (groupA.sliceConstructor != groupB.sliceConstructor) throw new Error('Different slice constructors. Cannot merge');

    var result = new SliceGroup(groupA.parentContainer, groupA.sliceConstructor, groupA.name_);

    var slicesA = groupA.slices;
    var slicesB = groupB.slices;
    var idxA = 0;
    var idxB = 0;
    var openA = [];
    var openB = [];

    var splitOpenSlices = function (when) {
      for (var i = 0; i < openB.length; i++) {
        var oldSlice = openB[i];
        var oldEnd = oldSlice.end;
        if (when < oldSlice.start || oldEnd < when) {
          throw new Error('slice should not be split');
        }

        var newSlice = result.copySlice(oldSlice);
        newSlice.start = when;
        newSlice.duration = oldEnd - when;
        if (newSlice.title.indexOf(' (cont.)') == -1) newSlice.title += ' (cont.)';
        oldSlice.duration = when - oldSlice.start;
        openB[i] = newSlice;
        result.pushSlice(newSlice);
      }
    };

    var closeOpenSlices = function (upTo) {
      while (openA.length > 0 || openB.length > 0) {
        var nextA = openA[openA.length - 1];
        var nextB = openB[openB.length - 1];
        var endA = nextA && nextA.end;
        var endB = nextB && nextB.end;

        if ((endA === undefined || endA > upTo) && (endB === undefined || endB > upTo)) {
          return;
        }

        if (endB === undefined || endA < endB) {
          splitOpenSlices(endA);
          openA.pop();
        } else {
          openB.pop();
        }
      }
    };

    while (idxA < slicesA.length || idxB < slicesB.length) {
      var sA = slicesA[idxA];
      var sB = slicesB[idxB];
      var nextSlice, isFromB;

      if (sA === undefined || sB !== undefined && sA.start > sB.start) {
        nextSlice = result.copySlice(sB);
        isFromB = true;
        idxB++;
      } else {
        nextSlice = result.copySlice(sA);
        isFromB = false;
        idxA++;
      }

      closeOpenSlices(nextSlice.start);

      result.pushSlice(nextSlice);

      if (isFromB) {
        openB.push(nextSlice);
      } else {
        splitOpenSlices(nextSlice.start);
        openA.push(nextSlice);
      }
    }

    closeOpenSlices();

    return result;
  };

  return {
    SliceGroup: SliceGroup
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/color_scheme.js":32,"../base/guid.js":39,"../base/sorted_array_utils.js":52,"../core/filter.js":61,"./event_container.js":117,"./thread_slice.js":157}],153:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./source_info.js");

'use strict';

global.tr.exportTo('tr.model.source_info', function () {
  function JSSourceInfo(file, line, column, isNative, scriptId, state) {
    tr.model.source_info.SourceInfo.call(this, file, line, column);

    this.isNative_ = isNative;
    this.scriptId_ = scriptId;
    this.state_ = state;
  }

  JSSourceInfo.prototype = {
    __proto__: tr.model.source_info.SourceInfo.prototype,

    get state() {
      return this.state_;
    },

    get isNative() {
      return this.isNative_;
    },

    get scriptId() {
      return this.scriptId_;
    },

    toString: function () {
      var str = this.isNative_ ? '[native v8] ' : '';
      return str + tr.model.source_info.SourceInfo.prototype.toString.call(this);
    }
  };

  return {
    JSSourceInfo: JSSourceInfo,
    JSSourceState: {
      COMPILED: 'compiled',
      OPTIMIZABLE: 'optimizable',
      OPTIMIZED: 'optimized',
      UNKNOWN: 'unknown'
    }
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./source_info.js":154}],154:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/base.js");

'use strict';

global.tr.exportTo('tr.model.source_info', function () {
  function SourceInfo(file, opt_line, opt_column) {
    this.file_ = file;
    this.line_ = opt_line || -1;
    this.column_ = opt_column || -1;
  }

  SourceInfo.prototype = {
    get file() {
      return this.file_;
    },

    get line() {
      return this.line_;
    },

    get column() {
      return this.column_;
    },

    get domain() {
      if (!this.file_) return undefined;
      var domain = this.file_.match(/(.*:\/\/[^:\/]*)/i);
      return domain ? domain[1] : undefined;
    },

    toString: function () {
      var str = '';

      if (this.file_) str += this.file_;
      if (this.line_ > 0) str += ':' + this.line_;
      if (this.column_ > 0) str += ':' + this.column_;
      return str;
    }
  };

  return {
    SourceInfo: SourceInfo
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/base.js":28}],155:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  function StackFrame(parentFrame, id, title, colorId, opt_sourceInfo) {
    if (id === undefined) throw new Error('id must be given');
    this.parentFrame_ = parentFrame;
    this.id = id;
    this.title_ = title;
    this.colorId = colorId;
    this.children = [];
    this.sourceInfo_ = opt_sourceInfo;

    if (this.parentFrame_) this.parentFrame_.addChild(this);
  }

  StackFrame.prototype = {
    get parentFrame() {
      return this.parentFrame_;
    },

    get title() {
      if (this.sourceInfo_) {
        var src = this.sourceInfo_.toString();
        return this.title_ + (src === '' ? '' : ' ' + src);
      }
      return this.title_;
    },

    /**
     * Attempts to find the domain of the origin of the script either from this
     * stack trace or from its ancestors.
     */
    get domain() {
      var result = 'unknown';
      if (this.sourceInfo_ && this.sourceInfo_.domain) result = this.sourceInfo_.domain;
      if (result === 'unknown' && this.parentFrame) result = this.parentFrame.domain;
      return result;
    },

    get sourceInfo() {
      return this.sourceInfo_;
    },

    set parentFrame(parentFrame) {
      if (this.parentFrame_) Polymer.dom(this.parentFrame_).removeChild(this);
      this.parentFrame_ = parentFrame;
      if (this.parentFrame_) this.parentFrame_.addChild(this);
    },

    addChild: function (child) {
      this.children.push(child);
    },

    removeChild: function (child) {
      var i = this.children.indexOf(child.id);
      if (i == -1) throw new Error('omg');
      this.children.splice(i, 1);
    },

    removeAllChildren: function () {
      for (var i = 0; i < this.children.length; i++) this.children[i].parentFrame_ = undefined;
      this.children.splice(0, this.children.length);
    },

    /**
     * Returns stackFrames where the most specific frame is first.
     */
    get stackTrace() {
      var stack = [];
      var cur = this;
      while (cur) {
        stack.push(cur);
        cur = cur.parentFrame;
      }
      return stack;
    },

    getUserFriendlyStackTrace: function () {
      return this.stackTrace.map(function (x) {
        return x.title;
      });
    }
  };

  return {
    StackFrame: StackFrame
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],156:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/guid.js");
require("../base/range.js");
require("./async_slice_group.js");
require("./event_container.js");
require("./slice_group.js");
require("./thread_slice.js");

'use strict';

/**
 * @fileoverview Provides the Thread class.
 */
global.tr.exportTo('tr.model', function () {
  var AsyncSlice = tr.model.AsyncSlice;
  var AsyncSliceGroup = tr.model.AsyncSliceGroup;
  var SliceGroup = tr.model.SliceGroup;
  var ThreadSlice = tr.model.ThreadSlice;
  var ThreadTimeSlice = tr.model.ThreadTimeSlice;

  /**
   * A Thread stores all the trace events collected for a particular
   * thread. We organize the synchronous slices on a thread by "subrows," where
   * subrow 0 has all the root slices, subrow 1 those nested 1 deep, and so on.
   * The asynchronous slices are stored in an AsyncSliceGroup object.
   *
   * The slices stored on a Thread should be instances of
   * ThreadSlice.
   *
   * @constructor
   * @extends {tr.model.EventContainer}
   */
  function Thread(parent, tid) {
    if (!parent) throw new Error('Parent must be provided.');

    tr.model.EventContainer.call(this);
    this.parent = parent;
    this.sortIndex = 0;
    this.tid = tid;
    this.name = undefined;
    this.samples_ = undefined; // Set during createSubSlices

    var that = this;

    this.sliceGroup = new SliceGroup(this, ThreadSlice, 'slices');
    this.timeSlices = undefined;
    this.kernelSliceGroup = new SliceGroup(this, ThreadSlice, 'kernel-slices');
    this.asyncSliceGroup = new AsyncSliceGroup(this, 'async-slices');
  }

  Thread.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get model() {
      return this.parent.model;
    },

    get stableId() {
      return this.parent.stableId + '.' + this.tid;
    },

    compareTo: function (that) {
      return Thread.compare(this, that);
    },

    childEventContainers: function* () {
      if (this.sliceGroup.length) yield this.sliceGroup;
      if (this.kernelSliceGroup.length) yield this.kernelSliceGroup;
      if (this.asyncSliceGroup.length) yield this.asyncSliceGroup;
    },

    childEvents: function* () {
      if (this.timeSlices) yield* this.timeSlices;
    },

    iterateAllPersistableObjects: function (cb) {
      cb(this);
      if (this.sliceGroup.length) cb(this.sliceGroup);
      this.asyncSliceGroup.viewSubGroups.forEach(cb);
    },

    /**
     * Shifts all the timestamps inside this thread forward by the amount
     * specified.
     */
    shiftTimestampsForward: function (amount) {
      this.sliceGroup.shiftTimestampsForward(amount);

      if (this.timeSlices) {
        for (var i = 0; i < this.timeSlices.length; i++) {
          var slice = this.timeSlices[i];
          slice.start += amount;
        }
      }

      this.kernelSliceGroup.shiftTimestampsForward(amount);
      this.asyncSliceGroup.shiftTimestampsForward(amount);
    },

    /**
     * Determines whether this thread is empty. If true, it usually implies
     * that it should be pruned from the model.
     */
    get isEmpty() {
      if (this.sliceGroup.length) return false;
      if (this.sliceGroup.openSliceCount) return false;
      if (this.timeSlices && this.timeSlices.length) return false;
      if (this.kernelSliceGroup.length) return false;
      if (this.asyncSliceGroup.length) return false;
      if (this.samples_.length) return false;
      return true;
    },

    /**
     * Updates the bounds based on the
     * current objects associated with the thread.
     */
    updateBounds: function () {
      this.bounds.reset();

      this.sliceGroup.updateBounds();
      this.bounds.addRange(this.sliceGroup.bounds);

      this.kernelSliceGroup.updateBounds();
      this.bounds.addRange(this.kernelSliceGroup.bounds);

      this.asyncSliceGroup.updateBounds();
      this.bounds.addRange(this.asyncSliceGroup.bounds);

      if (this.timeSlices && this.timeSlices.length) {
        this.bounds.addValue(this.timeSlices[0].start);
        this.bounds.addValue(this.timeSlices[this.timeSlices.length - 1].end);
      }

      if (this.samples_ && this.samples_.length) {
        this.bounds.addValue(this.samples_[0].start);
        this.bounds.addValue(this.samples_[this.samples_.length - 1].end);
      }
    },

    addCategoriesToDict: function (categoriesDict) {
      for (var i = 0; i < this.sliceGroup.length; i++) categoriesDict[this.sliceGroup.slices[i].category] = true;
      for (var i = 0; i < this.kernelSliceGroup.length; i++) categoriesDict[this.kernelSliceGroup.slices[i].category] = true;
      for (var i = 0; i < this.asyncSliceGroup.length; i++) categoriesDict[this.asyncSliceGroup.slices[i].category] = true;
      if (this.samples_) {
        for (var i = 0; i < this.samples_.length; i++) categoriesDict[this.samples_[i].category] = true;
      }
    },

    autoCloseOpenSlices: function () {
      this.sliceGroup.autoCloseOpenSlices();
      this.kernelSliceGroup.autoCloseOpenSlices();
    },

    mergeKernelWithUserland: function () {
      if (this.kernelSliceGroup.length > 0) {
        var newSlices = SliceGroup.merge(this.sliceGroup, this.kernelSliceGroup);
        this.sliceGroup.slices = newSlices.slices;
        this.kernelSliceGroup = new SliceGroup(this);
        this.updateBounds();
      }
    },

    createSubSlices: function () {
      this.sliceGroup.createSubSlices();
      this.samples_ = this.parent.model.samples.filter(function (sample) {
        return sample.thread == this;
      }, this);
    },

    /**
     * @return {String} A user-friendly name for this thread.
     */
    get userFriendlyName() {
      return this.name || this.tid;
    },

    /**
     * @return {String} User friendly details about this thread.
     */
    get userFriendlyDetails() {
      return 'tid: ' + this.tid + (this.name ? ', name: ' + this.name : '');
    },

    getSettingsKey: function () {
      if (!this.name) return undefined;
      var parentKey = this.parent.getSettingsKey();
      if (!parentKey) return undefined;
      return parentKey + '.' + this.name;
    },

    getProcess: function () {
      return this.parent;
    },

    /*
     * Returns the index of the slice in the timeSlices array, or undefined.
     */
    indexOfTimeSlice: function (timeSlice) {
      var i = tr.b.findLowIndexInSortedArray(this.timeSlices, function (slice) {
        return slice.start;
      }, timeSlice.start);
      if (this.timeSlices[i] !== timeSlice) return undefined;
      return i;
    },

    /*
     * Returns an object with the CPU number used as keys,
     * and the value of each key object is the amount of milliseconds spent
     * running on this CPU.
     * Additionally, stats.total contains the total time
     * spent running on all CPUs.
     */
    getCpuStatsForRange: function (range) {
      var stats = {};
      stats.total = 0;

      if (!this.timeSlices) return stats;

      function addStatsForSlice(threadTimeSlice) {
        var freqRange = tr.b.Range.fromExplicitRange(threadTimeSlice.start, threadTimeSlice.end);
        var intersection = freqRange.findIntersection(range);

        if (threadTimeSlice.schedulingState == tr.model.SCHEDULING_STATE.RUNNING) {
          var cpu = threadTimeSlice.cpuOnWhichThreadWasRunning;
          if (!(cpu.cpuNumber in stats)) stats[cpu.cpuNumber] = 0;

          stats[cpu.cpuNumber] += intersection.duration;
          stats.total += intersection.duration;
        }
      }

      tr.b.iterateOverIntersectingIntervals(this.timeSlices, function (x) {
        return x.start;
      }, function (x) {
        return x.end;
      }, range.min, range.max, addStatsForSlice);
      return stats;
    },

    getSchedulingStatsForRange: function (start, end) {
      var stats = {};

      if (!this.timeSlices) return stats;

      function addStatsForSlice(threadTimeSlice) {
        var overlapStart = Math.max(threadTimeSlice.start, start);
        var overlapEnd = Math.min(threadTimeSlice.end, end);
        var schedulingState = threadTimeSlice.schedulingState;

        if (!(schedulingState in stats)) stats[schedulingState] = 0;
        stats[schedulingState] += overlapEnd - overlapStart;
      }

      tr.b.iterateOverIntersectingIntervals(this.timeSlices, function (x) {
        return x.start;
      }, function (x) {
        return x.end;
      }, start, end, addStatsForSlice);
      return stats;
    },

    get samples() {
      return this.samples_;
    }
  };

  /**
   * Comparison between threads that orders first by parent.compareTo,
   * then by names, then by tid.
   */
  Thread.compare = function (x, y) {
    var tmp = x.parent.compareTo(y.parent);
    if (tmp) return tmp;

    tmp = x.sortIndex - y.sortIndex;
    if (tmp) return tmp;

    tmp = tr.b.comparePossiblyUndefinedValues(x.name, y.name, function (x, y) {
      return x.localeCompare(y);
    });
    if (tmp) return tmp;

    return x.tid - y.tid;
  };

  return {
    Thread: Thread
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/guid.js":39,"../base/range.js":47,"./async_slice_group.js":104,"./event_container.js":117,"./slice_group.js":152,"./thread_slice.js":157}],157:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./slice.js");

'use strict';

/**
 * @fileoverview Provides the Thread class.
 */
global.tr.exportTo('tr.model', function () {
  var Slice = tr.model.Slice;

  /**
   * A ThreadSlice represents an interval of time on a thread resource
   * with associated nesting slice information.
   *
   * ThreadSlices are typically associated with a specific trace event pair on a
   * specific thread.
   * For example,
   *   TRACE_EVENT_BEGIN1("x","myArg", 7) at time=0.1ms
   *   TRACE_EVENT_END0()                 at time=0.3ms
   * This results in a single slice from 0.1 with duration 0.2 on a
   * specific thread.
   *
   * @constructor
   */
  function ThreadSlice(cat, title, colorId, start, args, opt_duration, opt_cpuStart, opt_cpuDuration, opt_argsStripped, opt_bindId) {
    Slice.call(this, cat, title, colorId, start, args, opt_duration, opt_cpuStart, opt_cpuDuration, opt_argsStripped, opt_bindId);
    // Do not modify this directly.
    // subSlices is configured by SliceGroup.rebuildSubRows_.
    this.subSlices = [];
  }

  ThreadSlice.prototype = {
    __proto__: Slice.prototype,

    get overlappingSamples() {
      var samples = new tr.model.EventSet();
      if (!this.parentContainer || !this.parentContainer.samples) return samples;
      this.parentContainer.samples.forEach(function (sample) {
        if (this.start <= sample.start && sample.start <= this.end) samples.push(sample);
      }, this);
      return samples;
    }
  };

  tr.model.EventRegistry.register(ThreadSlice, {
    name: 'slice',
    pluralName: 'slices'
  });

  return {
    ThreadSlice: ThreadSlice
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./slice.js":151}],158:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range.js");
require("./slice.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  var Slice = tr.model.Slice;

  var SCHEDULING_STATE = {
    DEBUG: 'Debug',
    EXIT_DEAD: 'Exit Dead',
    RUNNABLE: 'Runnable',
    RUNNING: 'Running',
    SLEEPING: 'Sleeping',
    STOPPED: 'Stopped',
    TASK_DEAD: 'Task Dead',
    UNINTR_SLEEP: 'Uninterruptible Sleep',
    UNINTR_SLEEP_WAKE_KILL: 'Uninterruptible Sleep | WakeKill',
    UNINTR_SLEEP_WAKING: 'Uninterruptible Sleep | Waking',
    UNINTR_SLEEP_IO: 'Uninterruptible Sleep - Block I/O',
    UNINTR_SLEEP_WAKE_KILL_IO: 'Uninterruptible Sleep | WakeKill - Block I/O',
    UNINTR_SLEEP_WAKING_IO: 'Uninterruptible Sleep | Waking - Block I/O',
    UNKNOWN: 'UNKNOWN',
    WAKE_KILL: 'Wakekill',
    WAKING: 'Waking',
    ZOMBIE: 'Zombie'
  };

  /**
   * A ThreadTimeSlice is a slice of time on a specific thread where that thread
   * was running on a specific CPU, or in a specific sleep state.
   *
   * As a thread switches moves through its life, it sometimes goes to sleep and
   * can't run. Other times, its runnable but isn't actually assigned to a CPU.
   * Finally, sometimes it gets put on a CPU to actually execute. Each of these
   * states is represented by a ThreadTimeSlice:
   *
   *   Sleeping or runnable: cpuOnWhichThreadWasRunning is undefined
   *   Running:  cpuOnWhichThreadWasRunning is set.
   *
   * @constructor
   */
  function ThreadTimeSlice(thread, schedulingState, cat, start, args, opt_duration) {
    Slice.call(this, cat, schedulingState, this.getColorForState_(schedulingState), start, args, opt_duration);
    this.thread = thread;
    this.schedulingState = schedulingState;
    this.cpuOnWhichThreadWasRunning = undefined;
  }

  ThreadTimeSlice.prototype = {
    __proto__: Slice.prototype,

    getColorForState_: function (state) {
      var getColorIdForReservedName = tr.b.ColorScheme.getColorIdForReservedName;

      switch (state) {
        case SCHEDULING_STATE.RUNNABLE:
          return getColorIdForReservedName('thread_state_runnable');
        case SCHEDULING_STATE.RUNNING:
          return getColorIdForReservedName('thread_state_running');
        case SCHEDULING_STATE.SLEEPING:
          return getColorIdForReservedName('thread_state_sleeping');
        case SCHEDULING_STATE.DEBUG:
        case SCHEDULING_STATE.EXIT_DEAD:
        case SCHEDULING_STATE.STOPPED:
        case SCHEDULING_STATE.TASK_DEAD:
        case SCHEDULING_STATE.UNINTR_SLEEP:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKING:
        case SCHEDULING_STATE.UNKNOWN:
        case SCHEDULING_STATE.WAKE_KILL:
        case SCHEDULING_STATE.WAKING:
        case SCHEDULING_STATE.ZOMBIE:
          return getColorIdForReservedName('thread_state_uninterruptible');
        case SCHEDULING_STATE.UNINTR_SLEEP_IO:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKE_KILL_IO:
        case SCHEDULING_STATE.UNINTR_SLEEP_WAKING_IO:
          return getColorIdForReservedName('thread_state_iowait');
        default:
          return getColorIdForReservedName('thread_state_unknown');
      }
    },

    get analysisTypeName() {
      return 'tr.ui.analysis.ThreadTimeSlice';
    },

    getAssociatedCpuSlice: function () {
      if (!this.cpuOnWhichThreadWasRunning) return undefined;
      var cpuSlices = this.cpuOnWhichThreadWasRunning.slices;
      for (var i = 0; i < cpuSlices.length; i++) {
        var cpuSlice = cpuSlices[i];
        if (cpuSlice.start !== this.start) continue;
        if (cpuSlice.duration !== this.duration) continue;
        return cpuSlice;
      }
      return undefined;
    },

    getCpuSliceThatTookCpu: function () {
      if (this.cpuOnWhichThreadWasRunning) return undefined;
      var curIndex = this.thread.indexOfTimeSlice(this);
      var cpuSliceWhenLastRunning;
      while (curIndex >= 0) {
        var curSlice = this.thread.timeSlices[curIndex];
        if (!curSlice.cpuOnWhichThreadWasRunning) {
          curIndex--;
          continue;
        }
        cpuSliceWhenLastRunning = curSlice.getAssociatedCpuSlice();
        break;
      }
      if (!cpuSliceWhenLastRunning) return undefined;

      var cpu = cpuSliceWhenLastRunning.cpu;
      var indexOfSliceOnCpuWhenLastRunning = cpu.indexOf(cpuSliceWhenLastRunning);
      var nextRunningSlice = cpu.slices[indexOfSliceOnCpuWhenLastRunning + 1];
      if (!nextRunningSlice) return undefined;
      if (Math.abs(nextRunningSlice.start - cpuSliceWhenLastRunning.end) < 0.00001) return nextRunningSlice;
      return undefined;
    }
  };

  tr.model.EventRegistry.register(ThreadTimeSlice, {
    name: 'threadTimeSlice',
    pluralName: 'threadTimeSlices'
  });

  return {
    ThreadTimeSlice: ThreadTimeSlice,
    SCHEDULING_STATE: SCHEDULING_STATE
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range.js":47,"./slice.js":151}],159:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/range.js");
require("../base/sorted_array_utils.js");

'use strict';

/**
 * @fileoverview Provides the TimeToObjectInstanceMap class.
 */
global.tr.exportTo('tr.model', function () {
  /**
   * Tracks all the instances associated with a given ID over its lifetime.
   *
   * A scoped id can be used multiple times throughout a trace, referring to
   * different objects at different times. This data structure does the
   * bookkeeping to figure out what ObjectInstance is referred to at a given
   * timestamp.
   *
   * @constructor
   */
  function TimeToObjectInstanceMap(createObjectInstanceFunction, parent, scopedId) {
    this.createObjectInstanceFunction_ = createObjectInstanceFunction;
    this.parent = parent;
    this.scopedId = scopedId;
    this.instances = [];
  }

  TimeToObjectInstanceMap.prototype = {
    idWasCreated: function (category, name, ts) {
      if (this.instances.length == 0) {
        this.instances.push(this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts));
        this.instances[0].creationTsWasExplicit = true;
        return this.instances[0];
      }

      var lastInstance = this.instances[this.instances.length - 1];
      if (ts < lastInstance.deletionTs) {
        throw new Error('Mutation of the TimeToObjectInstanceMap must be ' + 'done in ascending timestamp order.');
      }
      lastInstance = this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts);
      lastInstance.creationTsWasExplicit = true;
      this.instances.push(lastInstance);
      return lastInstance;
    },

    addSnapshot: function (category, name, ts, args, opt_baseTypeName) {
      if (this.instances.length == 0) {
        this.instances.push(this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts, opt_baseTypeName));
      }

      var i = tr.b.findIndexInSortedIntervals(this.instances, function (inst) {
        return inst.creationTs;
      }, function (inst) {
        return inst.deletionTs - inst.creationTs;
      }, ts);

      var instance;
      if (i < 0) {
        instance = this.instances[0];
        if (ts > instance.deletionTs || instance.creationTsWasExplicit) {
          throw new Error('At the provided timestamp, no instance was still alive');
        }

        if (instance.snapshots.length != 0) {
          throw new Error('Cannot shift creationTs forward, ' + 'snapshots have been added. First snap was at ts=' + instance.snapshots[0].ts + ' and creationTs was ' + instance.creationTs);
        }
        instance.creationTs = ts;
      } else if (i >= this.instances.length) {
        instance = this.instances[this.instances.length - 1];
        if (ts >= instance.deletionTs) {
          // The snap is added after our oldest and deleted instance. This means
          // that this is a new implicit instance.
          instance = this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts, opt_baseTypeName);
          this.instances.push(instance);
        } else {
          // If the ts is before the last objects deletion time, then the caller
          // is trying to add a snapshot when there may have been an instance
          // alive. In that case, try to move an instance's creationTs to
          // include this ts, provided that it has an implicit creationTs.

          // Search backward from the right for an instance that was definitely
          // deleted before this ts. Any time an instance is found that has a
          // moveable creationTs
          var lastValidIndex;
          for (var i = this.instances.length - 1; i >= 0; i--) {
            var tmp = this.instances[i];
            if (ts >= tmp.deletionTs) break;
            if (tmp.creationTsWasExplicit == false && tmp.snapshots.length == 0) lastValidIndex = i;
          }
          if (lastValidIndex === undefined) {
            throw new Error('Cannot add snapshot. No instance was alive that was mutable.');
          }
          instance = this.instances[lastValidIndex];
          instance.creationTs = ts;
        }
      } else {
        instance = this.instances[i];
      }

      return instance.addSnapshot(ts, args, name, opt_baseTypeName);
    },

    get lastInstance() {
      if (this.instances.length == 0) return undefined;
      return this.instances[this.instances.length - 1];
    },

    idWasDeleted: function (category, name, ts) {
      if (this.instances.length == 0) {
        this.instances.push(this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts));
      }
      var lastInstance = this.instances[this.instances.length - 1];
      if (ts < lastInstance.creationTs) throw new Error('Cannot delete an id before it was created');
      if (lastInstance.deletionTs == Number.MAX_VALUE) {
        lastInstance.wasDeleted(ts);
        return lastInstance;
      }

      if (ts < lastInstance.deletionTs) throw new Error('id was already deleted earlier.');

      // A new instance was deleted with no snapshots in-between.
      // Create an instance then kill it.
      lastInstance = this.createObjectInstanceFunction_(this.parent, this.scopedId, category, name, ts);
      this.instances.push(lastInstance);
      lastInstance.wasDeleted(ts);
      return lastInstance;
    },

    getInstanceAt: function (ts) {
      var i = tr.b.findIndexInSortedIntervals(this.instances, function (inst) {
        return inst.creationTs;
      }, function (inst) {
        return inst.deletionTs - inst.creationTs;
      }, ts);
      if (i < 0) {
        if (this.instances[0].creationTsWasExplicit) return undefined;
        return this.instances[0];
      } else if (i >= this.instances.length) {
        return undefined;
      }
      return this.instances[i];
    },

    logToConsole: function () {
      for (var i = 0; i < this.instances.length; i++) {
        var instance = this.instances[i];
        var cEF = '';
        var dEF = '';
        if (instance.creationTsWasExplicit) cEF = '(explicitC)';
        if (instance.deletionTsWasExplicit) dEF = '(explicit)';
        console.log(instance.creationTs, cEF, instance.deletionTs, dEF, instance.category, instance.name, instance.snapshots.length + ' snapshots');
      }
    }
  };

  return {
    TimeToObjectInstanceMap: TimeToObjectInstanceMap
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/range.js":47,"../base/sorted_array_utils.js":52}],160:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2013 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/guid.js");
require("../base/time_display_modes.js");
require("./event.js");

'use strict';

global.tr.exportTo('tr.model', function () {
  /**
   * TimedEvent is a base type for any entity in the trace model with a specific
   * start and duration.
   *
   * @constructor
   */
  function TimedEvent(start) {
    tr.model.Event.call(this);
    this.start = start;
    this.duration = 0;
    this.cpuStart = undefined;
    this.cpuDuration = undefined;
    // The set of contexts this event belongs to (order is unimportant). This
    // array should never be modified.
    this.contexts = Object.freeze([]);
  }

  TimedEvent.prototype = {
    __proto__: tr.model.Event.prototype,

    get end() {
      return this.start + this.duration;
    },

    addBoundsToRange: function (range) {
      range.addValue(this.start);
      range.addValue(this.end);
    },

    // TODO(charliea): Can this be implemented in terms of Event.range()?
    // Returns true if 'that' TimedEvent is fully contained within 'this' timed
    // event.
    bounds: function (that, opt_precisionUnit) {
      if (opt_precisionUnit === undefined) opt_precisionUnit = tr.b.TimeDisplayModes.ms;

      var startsBefore = opt_precisionUnit.roundedLess(that.start, this.start);
      var endsAfter = opt_precisionUnit.roundedLess(this.end, that.end);
      return !startsBefore && !endsAfter;
    }
  };

  return {
    TimedEvent: TimedEvent
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/guid.js":39,"../base/time_display_modes.js":55,"./event.js":116}],161:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./user_expectation.js");

'use strict';

global.tr.exportTo('tr.model.um', function () {
  function AnimationExpectation(parentModel, initiatorTitle, start, duration) {
    tr.model.um.UserExpectation.call(this, parentModel, initiatorTitle, start, duration);
    this.frameEvents_ = undefined;
  }

  AnimationExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: AnimationExpectation,

    get frameEvents() {
      if (this.frameEvents_) return this.frameEvents_;

      this.frameEvents_ = new tr.model.EventSet();

      this.associatedEvents.forEach(function (event) {
        if (event.title === tr.model.helpers.IMPL_RENDERING_STATS) this.frameEvents_.push(event);
      }, this);

      return this.frameEvents_;
    }
  };

  tr.model.um.UserExpectation.subTypes.register(AnimationExpectation, {
    stageTitle: 'Animation',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_animation')
  });

  return {
    AnimationExpectation: AnimationExpectation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./user_expectation.js":166}],162:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./user_expectation.js");

'use strict';

global.tr.exportTo('tr.model.um', function () {
  function IdleExpectation(parentModel, start, duration) {
    var initiatorTitle = '';
    tr.model.um.UserExpectation.call(this, parentModel, initiatorTitle, start, duration);
  }

  IdleExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: IdleExpectation
  };

  tr.model.um.UserExpectation.subTypes.register(IdleExpectation, {
    stageTitle: 'Idle',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_idle')
  });

  return {
    IdleExpectation: IdleExpectation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./user_expectation.js":166}],163:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./user_expectation.js");

'use strict';

global.tr.exportTo('tr.model.um', function () {
  var LOAD_SUBTYPE_NAMES = {
    SUCCESSFUL: 'Successful',
    FAILED: 'Failed'
  };

  var DOES_LOAD_SUBTYPE_NAME_EXIST = {};
  for (var key in LOAD_SUBTYPE_NAMES) {
    DOES_LOAD_SUBTYPE_NAME_EXIST[LOAD_SUBTYPE_NAMES[key]] = true;;
  }

  function LoadExpectation(parentModel, initiatorTitle, start, duration) {
    if (!DOES_LOAD_SUBTYPE_NAME_EXIST[initiatorTitle]) throw new Error(initiatorTitle + ' is not in LOAD_SUBTYPE_NAMES');

    tr.model.um.UserExpectation.call(this, parentModel, initiatorTitle, start, duration);

    // |renderProcess| is the renderer process that contains the loading
    // RenderFrame.
    this.renderProcess = undefined;

    // |renderMainThread| is the CrRendererMain thread in the |renderProcess|
    // that contains the loading RenderFrame.
    this.renderMainThread = undefined;

    // |routingId| identifies the loading RenderFrame within the renderer
    // process.
    this.routingId = undefined;

    // |parentRoutingId| identifies the RenderFrame that created and contains
    // the loading RenderFrame.
    this.parentRoutingId = undefined;

    // |loadFinishedEvent|, if present, signals that this is a main frame.
    this.loadFinishedEvent = undefined;

    // Startup LoadIRs do not have renderProcess, routingId, or
    // parentRoutingId. Maybe RenderLoadIR should be a separate class?
  }

  LoadExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: LoadExpectation
  };

  tr.model.um.UserExpectation.subTypes.register(LoadExpectation, {
    stageTitle: 'Load',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_load')
  });

  return {
    LOAD_SUBTYPE_NAMES: LOAD_SUBTYPE_NAMES,
    LoadExpectation: LoadExpectation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./user_expectation.js":166}],164:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./user_expectation.js");

'use strict';

global.tr.exportTo('tr.model.um', function () {
  function ResponseExpectation(parentModel, initiatorTitle, start, duration, opt_isAnimationBegin) {
    tr.model.um.UserExpectation.call(this, parentModel, initiatorTitle, start, duration);
    this.isAnimationBegin = opt_isAnimationBegin || false;
  }

  ResponseExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: ResponseExpectation
  };

  tr.model.um.UserExpectation.subTypes.register(ResponseExpectation, {
    stageTitle: 'Response',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('rail_response')
  });

  return {
    ResponseExpectation: ResponseExpectation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./user_expectation.js":166}],165:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./user_expectation.js");

'use strict';

global.tr.exportTo('tr.model.um', function () {
  function StartupExpectation(parentModel, start, duration) {
    tr.model.um.UserExpectation.call(this, parentModel, '', start, duration);
  }

  StartupExpectation.prototype = {
    __proto__: tr.model.um.UserExpectation.prototype,
    constructor: StartupExpectation
  };

  tr.model.um.UserExpectation.subTypes.register(StartupExpectation, {
    stageTitle: 'Startup',
    colorId: tr.b.ColorScheme.getColorIdForReservedName('startup')
  });

  return {
    StartupExpectation: StartupExpectation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./user_expectation.js":166}],166:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/range_utils.js");
require("../../base/statistics.js");
require("../../base/unit.js");
require("../compound_event_selection_state.js");
require("../event_set.js");
require("../timed_event.js");

'use strict';

global.tr.exportTo('tr.model.um', function () {
  var CompoundEventSelectionState = tr.model.CompoundEventSelectionState;

  function UserExpectation(parentModel, initiatorTitle, start, duration) {
    tr.model.TimedEvent.call(this, start);
    this.associatedEvents = new tr.model.EventSet();
    this.duration = duration;
    this.initiatorTitle_ = initiatorTitle;
    this.parentModel = parentModel;
    this.typeInfo_ = undefined;

    // sourceEvents are the ones that caused the UserModelBuilder to create this
    // UserExpectation.
    this.sourceEvents = new tr.model.EventSet();
  }

  UserExpectation.prototype = {
    __proto__: tr.model.TimedEvent.prototype,

    computeCompoundEvenSelectionState: function (selection) {
      var cess = CompoundEventSelectionState.NOT_SELECTED;
      if (selection.contains(this)) cess |= CompoundEventSelectionState.EVENT_SELECTED;

      if (this.associatedEvents.intersectionIsEmpty(selection)) return cess;

      var allContained = this.associatedEvents.every(function (event) {
        return selection.contains(event);
      });

      if (allContained) cess |= CompoundEventSelectionState.ALL_ASSOCIATED_EVENTS_SELECTED;else cess |= CompoundEventSelectionState.SOME_ASSOCIATED_EVENTS_SELECTED;
      return cess;
    },

    // Returns samples which are overlapping with V8.Execute
    get associatedSamples() {
      var samples = new tr.model.EventSet();
      this.associatedEvents.forEach(function (event) {
        if (event instanceof tr.model.ThreadSlice) samples.addEventSet(event.overlappingSamples);
      });
      return samples;
    },

    get userFriendlyName() {
      return this.title + ' User Expectation at ' + tr.b.Unit.byName.timeStampInMs.format(this.start);
    },

    get stableId() {
      return 'UserExpectation.' + this.guid;
    },

    get typeInfo() {
      if (!this.typeInfo_) {
        this.typeInfo_ = UserExpectation.subTypes.findTypeInfo(this.constructor);
      }

      // If you set Subclass.prototype = {}, then you must explicitly specify
      // constructor in that prototype object!
      // http://javascript.info/tutorial/constructor

      if (!this.typeInfo_) throw new Error('Unregistered UserExpectation');

      return this.typeInfo_;
    },

    get colorId() {
      return this.typeInfo.metadata.colorId;
    },

    get stageTitle() {
      return this.typeInfo.metadata.stageTitle;
    },

    get initiatorTitle() {
      return this.initiatorTitle_;
    },

    get title() {
      if (!this.initiatorTitle) return this.stageTitle;

      return this.initiatorTitle + ' ' + this.stageTitle;
    },

    /**
     * Returns the sum of the number of CPU ms spent by this UserExpectation.
     */
    get totalCpuMs() {
      var cpuMs = 0;
      this.associatedEvents.forEach(function (event) {
        if (event.cpuSelfTime) cpuMs += event.cpuSelfTime;
      });
      return cpuMs;
    }
  };

  var subTypes = {};
  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  tr.b.decorateExtensionRegistry(subTypes, options);

  subTypes.addEventListener('will-register', function (e) {
    var metadata = e.typeInfo.metadata;

    if (metadata.stageTitle === undefined) {
      throw new Error('Registered UserExpectations must provide ' + 'stageTitle');
    }

    if (metadata.colorId === undefined) {
      throw new Error('Registered UserExpectations must provide ' + 'colorId');
    }
  });

  tr.model.EventRegistry.register(UserExpectation, {
    name: 'userExpectation',
    pluralName: 'userExpectations',
    subTypes: subTypes
  });

  return {
    UserExpectation: UserExpectation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/range_utils.js":48,"../../base/statistics.js":53,"../../base/unit.js":57,"../compound_event_selection_state.js":107,"../event_set.js":120,"../timed_event.js":160}],167:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../event_container.js");

'use strict';

global.tr.exportTo('tr.model.um', function () {
  function UserModel(parentModel) {
    tr.model.EventContainer.call(this);
    this.parentModel_ = parentModel;
    this.expectations_ = new tr.model.EventSet();
  }

  UserModel.prototype = {
    __proto__: tr.model.EventContainer.prototype,

    get stableId() {
      return 'UserModel';
    },

    get parentModel() {
      return this.parentModel_;
    },

    sortExpectations: function () {
      this.expectations_.sortEvents((x, y) => x.start - y.start);
    },

    get expectations() {
      return this.expectations_;
    },

    shiftTimestampsForward: function (amount) {},

    addCategoriesToDict: function (categoriesDict) {},

    childEvents: function* () {
      yield* this.expectations;
    },

    childEventContainers: function* () {},

    updateBounds: function () {
      this.bounds.reset();
      this.expectations.forEach(function (expectation) {
        expectation.addBoundsToRange(this.bounds);
      }, this);
    }
  };

  return {
    UserModel: UserModel
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../event_container.js":117}],168:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/base.js");

'use strict';

/**
 * @fileoverview Provides classes for representing and classifying VM regions.
 *
 * See https://goo.gl/5SSPv0 for more details.
 */
global.tr.exportTo('tr.model', function () {

  /**
   * A single virtual memory region (also called a memory map).
   *
   * @constructor
   */
  function VMRegion(startAddress, sizeInBytes, protectionFlags, mappedFile, byteStats) {
    this.startAddress = startAddress;
    this.sizeInBytes = sizeInBytes;
    this.protectionFlags = protectionFlags;
    this.mappedFile = mappedFile || '';
    this.byteStats = byteStats || {};
  };

  VMRegion.PROTECTION_FLAG_READ = 4;
  VMRegion.PROTECTION_FLAG_WRITE = 2;
  VMRegion.PROTECTION_FLAG_EXECUTE = 1;
  VMRegion.PROTECTION_FLAG_MAYSHARE = 128;

  VMRegion.prototype = {
    get uniqueIdWithinProcess() {
      // This value is assumed to be unique within a process.
      return this.mappedFile + '#' + this.startAddress;
    },

    get protectionFlagsToString() {
      if (this.protectionFlags === undefined) return undefined;
      return (this.protectionFlags & VMRegion.PROTECTION_FLAG_READ ? 'r' : '-') + (this.protectionFlags & VMRegion.PROTECTION_FLAG_WRITE ? 'w' : '-') + (this.protectionFlags & VMRegion.PROTECTION_FLAG_EXECUTE ? 'x' : '-') + (this.protectionFlags & VMRegion.PROTECTION_FLAG_MAYSHARE ? 's' : 'p');
    }
  };

  VMRegion.fromDict = function (dict) {
    return new VMRegion(dict.startAddress, dict.sizeInBytes, dict.protectionFlags, dict.mappedFile, dict.byteStats);
  };

  /**
   * Node in a VM region classification tree.
   *
   * Note: Most users of this class should use the
   * VMRegionClassificationNode.fromRegions static method instead of this
   * constructor because it leads to better performance due to fewer memory
   * allocations.
   *
   * @constructor
   */
  function VMRegionClassificationNode(opt_rule) {
    this.rule_ = opt_rule || VMRegionClassificationNode.CLASSIFICATION_RULES;

    // True iff this node or any of its descendant classification nodes has at
    // least one classified VM region.
    this.hasRegions = false;

    // Total virtual size and byte stats of all regions matching this node's
    // rule (including its sub-rules).
    this.sizeInBytes = undefined;
    this.byteStats = {};

    // Array of child classification nodes if this is an intermediate node.
    this.children_ = undefined;

    // Array of VM regions. If this is an intermediate node, then the regions
    // are cached for lazy tree construction (i.e. its child classification
    // nodes yet have to be built).
    this.regions_ = [];
  }

  /**
   * Rules for classifying memory maps.
   *
   * These rules are derived from core/jni/android_os_Debug.cpp in Android.
   */
  VMRegionClassificationNode.CLASSIFICATION_RULES = {
    name: 'Total',
    children: [{
      name: 'Android',
      file: /^\/dev\/ashmem(?!\/libc malloc)/,
      children: [{
        name: 'Java runtime',
        file: /^\/dev\/ashmem\/dalvik-/,
        children: [{
          name: 'Spaces',
          file: /\/dalvik-(alloc|main|large object|non moving|zygote) space/, // @suppress longLineCheck
          children: [{
            name: 'Normal',
            file: /\/dalvik-(alloc|main)/
          }, {
            name: 'Large',
            file: /\/dalvik-large object/
          }, {
            name: 'Zygote',
            file: /\/dalvik-zygote/
          }, {
            name: 'Non-moving',
            file: /\/dalvik-non moving/
          }]
        }, {
          name: 'Linear Alloc',
          file: /\/dalvik-LinearAlloc/
        }, {
          name: 'Indirect Reference Table',
          file: /\/dalvik-indirect.ref/
        }, {
          name: 'Cache',
          file: /\/dalvik-jit-code-cache/
        }, {
          name: 'Accounting'
        }]
      }, {
        name: 'Cursor',
        file: /\/CursorWindow/
      }, {
        name: 'Ashmem'
      }]
    }, {
      name: 'Native heap',
      file: /^((\[heap\])|(\[anon:)|(\/dev\/ashmem\/libc malloc)|(\[discounted tracing overhead\])|$)/ // @suppress longLineCheck
    }, {
      name: 'Stack',
      file: /^\[stack/
    }, {
      name: 'Files',
      file: /\.((((jar)|(apk)|(ttf)|(odex)|(oat)|(art))$)|(dex)|(so))/,
      children: [{
        name: 'so',
        file: /\.so/
      }, {
        name: 'jar',
        file: /\.jar$/
      }, {
        name: 'apk',
        file: /\.apk$/
      }, {
        name: 'ttf',
        file: /\.ttf$/
      }, {
        name: 'dex',
        file: /\.((dex)|(odex$))/
      }, {
        name: 'oat',
        file: /\.oat$/
      }, {
        name: 'art',
        file: /\.art$/
      }]
    }, {
      name: 'Devices',
      file: /(^\/dev\/)|(anon_inode:dmabuf)/,
      children: [{
        name: 'GPU',
        file: /\/((nv)|(mali)|(kgsl))/
      }, {
        name: 'DMA',
        file: /anon_inode:dmabuf/
      }]
    }]
  };
  VMRegionClassificationNode.OTHER_RULE = { name: 'Other' };

  VMRegionClassificationNode.fromRegions = function (regions, opt_rules) {
    var tree = new VMRegionClassificationNode(opt_rules);
    tree.regions_ = regions;
    for (var i = 0; i < regions.length; i++) tree.addStatsFromRegion_(regions[i]);
    return tree;
  };

  VMRegionClassificationNode.prototype = {
    get title() {
      return this.rule_.name;
    },

    get children() {
      if (this.isLeafNode) return undefined; // Leaf nodes don't have children (by definition).
      if (this.children_ === undefined) this.buildTree_(); // Lazily classify VM regions.
      return this.children_;
    },

    get regions() {
      if (!this.isLeafNode) {
        // Intermediate nodes only temporarily cache VM regions for lazy tree
        // construction.
        return undefined;
      }
      return this.regions_;
    },

    get allRegionsForTesting() {
      if (this.regions_ !== undefined) {
        if (this.children_ !== undefined) {
          throw new Error('Internal error: a VM region classification node ' + 'cannot have both regions and children');
        }
        // Leaf node (or caching internal node).
        return this.regions_;
      }

      // Intermediate node.
      var regions = [];
      this.children_.forEach(function (childNode) {
        regions = regions.concat(childNode.allRegionsForTesting);
      });
      return regions;
    },

    get isLeafNode() {
      var children = this.rule_.children;
      return children === undefined || children.length === 0;
    },

    addRegion: function (region) {
      this.addRegionRecursively_(region, true /* addStatsToThisNode */);
    },

    someRegion: function (fn, opt_this) {
      if (this.regions_ !== undefined) {
        // Leaf node (or caching internal node).
        return this.regions_.some(fn, opt_this);
      }

      // Intermediate node.
      return this.children_.some(function (childNode) {
        return childNode.someRegion(fn, opt_this);
      });
    },

    addRegionRecursively_: function (region, addStatsToThisNode) {
      if (addStatsToThisNode) this.addStatsFromRegion_(region);

      if (this.regions_ !== undefined) {
        if (this.children_ !== undefined) {
          throw new Error('Internal error: a VM region classification node ' + 'cannot have both regions and children');
        }
        // Leaf node or an intermediate node caching VM regions (add the
        // region to this node and don't classify further).
        this.regions_.push(region);
        return;
      }

      // Non-leaf rule (classify region row further down the tree).
      function regionRowMatchesChildNide(child) {
        var fileRegExp = child.rule_.file;
        if (fileRegExp === undefined) return true;
        return fileRegExp.test(region.mappedFile);
      }

      var matchedChild = tr.b.findFirstInArray(this.children_, regionRowMatchesChildNide);
      if (matchedChild === undefined) {
        // Region belongs to the 'Other' node (created lazily).
        if (this.children_.length !== this.rule_.children.length) throw new Error('Internal error');
        matchedChild = new VMRegionClassificationNode(VMRegionClassificationNode.OTHER_RULE);
        this.children_.push(matchedChild);
      }

      matchedChild.addRegionRecursively_(region, true);
    },

    buildTree_: function () {
      var cachedRegions = this.regions_;
      this.regions_ = undefined;

      this.buildChildNodesRecursively_();
      for (var i = 0; i < cachedRegions.length; i++) {
        // Note that we don't add the VM region's stats to this node because
        // they have already been added to it.
        this.addRegionRecursively_(cachedRegions[i], false /* addStatsToThisNode */);
      }
    },

    buildChildNodesRecursively_: function () {
      if (this.children_ !== undefined) {
        throw new Error('Internal error: Classification node already has children');
      }
      if (this.regions_ !== undefined && this.regions_.length !== 0) {
        throw new Error('Internal error: Classification node should have no regions');
      }

      if (this.isLeafNode) return; // Leaf node: Nothing to do.

      // Intermediate node: Clear regions and build children recursively.
      this.regions_ = undefined;
      this.children_ = this.rule_.children.map(function (childRule) {
        var child = new VMRegionClassificationNode(childRule);
        child.buildChildNodesRecursively_();
        return child;
      });
    },

    addStatsFromRegion_: function (region) {
      this.hasRegions = true;

      // Aggregate virtual size.
      var regionSizeInBytes = region.sizeInBytes;
      if (regionSizeInBytes !== undefined) this.sizeInBytes = (this.sizeInBytes || 0) + regionSizeInBytes;

      // Aggregate byte stats.
      var thisByteStats = this.byteStats;
      var regionByteStats = region.byteStats;
      for (var byteStatName in regionByteStats) {
        var regionByteStatValue = regionByteStats[byteStatName];
        if (regionByteStatValue === undefined) continue;
        thisByteStats[byteStatName] = (thisByteStats[byteStatName] || 0) + regionByteStatValue;
      }
    }
  };

  return {
    VMRegion: VMRegion,
    VMRegionClassificationNode: VMRegionClassificationNode
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/base.js":28}],169:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./annotation.js");
require("../ui/annotations/x_marker_annotation_view.js");

'use strict';

global.tr.exportTo('tr.model', function () {

  function XMarkerAnnotation(timestamp) {
    tr.model.Annotation.apply(this, arguments);

    this.timestamp = timestamp;
    this.strokeStyle = 'rgba(0, 0, 255, 0.5)';
  }

  XMarkerAnnotation.fromDict = function (dict) {
    return new XMarkerAnnotation(dict.args.timestamp);
  };

  XMarkerAnnotation.prototype = {
    __proto__: tr.model.Annotation.prototype,

    toDict: function () {
      return {
        typeName: 'xmarker',
        args: {
          timestamp: this.timestamp
        }
      };
    },

    createView_: function (viewport) {
      return new tr.ui.annotations.XMarkerAnnotationView(viewport, this);
    }
  };

  tr.model.Annotation.register(XMarkerAnnotation, { typeName: 'xmarker' });

  return {
    XMarkerAnnotation: XMarkerAnnotation
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../ui/annotations/x_marker_annotation_view.js":173,"./annotation.js":102}],170:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/base.js");

'use strict';

global.tr.exportTo('tr.ui.annotations', function () {
  /**
   * A base class for all annotation views.
   * @constructor
   */
  function AnnotationView(viewport, annotation) {}

  AnnotationView.prototype = {
    draw: function (ctx) {
      throw new Error('Not implemented');
    }
  };

  return {
    AnnotationView: AnnotationView
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/base.js":28}],171:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./annotation_view.js");

'use strict';

global.tr.exportTo('tr.ui.annotations', function () {
  /**
   * A view of a comment box consisting of a textarea and a line to the
   * actual location.
   * @extends {AnnotationView}
   * @constructor
   */
  function CommentBoxAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
    this.textArea_ = undefined;

    this.styleWidth = 250;
    this.styleHeight = 50;
    this.fontSize = 10;
    this.rightOffset = 50;
    this.topOffset = 25;
  }

  CommentBoxAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    removeTextArea: function () {
      Polymer.dom(Polymer.dom(this.textArea_).parentNode).removeChild(this.textArea_);
    },

    draw: function (ctx) {
      var coords = this.annotation_.location.toViewCoordinates(this.viewport_);
      if (coords.viewX < 0) {
        if (this.textArea_) this.textArea_.style.visibility = 'hidden';
        return;
      }

      // Set up textarea element.
      if (!this.textArea_) {
        this.textArea_ = document.createElement('textarea');
        this.textArea_.style.position = 'absolute';
        this.textArea_.readOnly = true;
        this.textArea_.value = this.annotation_.text;
        // Set the z-index so that this is shown on top of canvas.
        this.textArea_.style.zIndex = 1;
        Polymer.dom(Polymer.dom(ctx.canvas).parentNode).appendChild(this.textArea_);
      }

      this.textArea_.style.width = this.styleWidth + 'px';
      this.textArea_.style.height = this.styleHeight + 'px';
      this.textArea_.style.fontSize = this.fontSize + 'px';
      this.textArea_.style.visibility = 'visible';

      // Update positions to latest coordinate.
      this.textArea_.style.left = coords.viewX + ctx.canvas.getBoundingClientRect().left + this.rightOffset + 'px';
      this.textArea_.style.top = coords.viewY - ctx.canvas.getBoundingClientRect().top - this.topOffset + 'px';

      // Draw pointer line from offset to actual location.
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      tr.ui.b.drawLine(ctx, coords.viewX, coords.viewY - ctx.canvas.getBoundingClientRect().top, coords.viewX + this.rightOffset, coords.viewY - this.topOffset - ctx.canvas.getBoundingClientRect().top);
      ctx.stroke();
    }
  };

  return {
    CommentBoxAnnotationView: CommentBoxAnnotationView
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./annotation_view.js":170}],172:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./annotation_view.js");

'use strict';

global.tr.exportTo('tr.ui.annotations', function () {
  /**
   * A view responsible for drawing a single highlight rectangle box on
   * the timeline.
   * @extends {AnnotationView}
   * @constructor
   */
  function RectAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
  }

  RectAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    draw: function (ctx) {
      var dt = this.viewport_.currentDisplayTransform;
      var startCoords = this.annotation_.startLocation.toViewCoordinates(this.viewport_);
      var endCoords = this.annotation_.endLocation.toViewCoordinates(this.viewport_);

      // Prevent drawing into the ruler track by clamping the initial Y
      // point and the rect's Y size.
      var startY = startCoords.viewY - ctx.canvas.getBoundingClientRect().top;
      var sizeY = endCoords.viewY - startCoords.viewY;
      if (startY + sizeY < 0) {
        // In this case sizeY is negative. If final Y is negative,
        // overwrite startY so that the rectangle ends at y=0.
        startY = sizeY;
      } else if (startY < 0) {
        startY = 0;
      }

      ctx.fillStyle = this.annotation_.fillStyle;
      ctx.fillRect(startCoords.viewX, startY, endCoords.viewX - startCoords.viewX, sizeY);
    }
  };

  return {
    RectAnnotationView: RectAnnotationView
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./annotation_view.js":170}],173:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./annotation_view.js");

'use strict';

global.tr.exportTo('tr.ui.annotations', function () {
  /**
   * A view that draws a vertical line on the timeline at a specific timestamp.
   * @extends {AnnotationView}
   * @constructor
   */
  function XMarkerAnnotationView(viewport, annotation) {
    this.viewport_ = viewport;
    this.annotation_ = annotation;
  }

  XMarkerAnnotationView.prototype = {
    __proto__: tr.ui.annotations.AnnotationView.prototype,

    draw: function (ctx) {
      var dt = this.viewport_.currentDisplayTransform;
      var viewX = dt.xWorldToView(this.annotation_.timestamp);

      ctx.beginPath();
      tr.ui.b.drawLine(ctx, viewX, 0, viewX, ctx.canvas.height);
      ctx.strokeStyle = this.annotation_.strokeStyle;
      ctx.stroke();
    }
  };

  return {
    XMarkerAnnotationView: XMarkerAnnotationView
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./annotation_view.js":170}],174:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/event.js");
require("../../base/utils.js");
require("./ui.js");
require("./utils.js");

'use strict';

/**
 * @fileoverview Implements an element that is hidden by default, but
 * when shown, dims and (attempts to) disable the main document.
 *
 * You can turn any div into an overlay. Note that while an
 * overlay element is shown, its parent is changed. Hiding the overlay
 * restores its original parentage.
 *
 */
global.tr.exportTo('tr.ui.b', function () {
  if (tr.isHeadless) return {};

  return;

  /**
   * Creates a new overlay element. It will not be visible until shown.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var Overlay = tr.ui.b.define('overlay');

  Overlay.prototype = {
    __proto__: HTMLDivElement.prototype,

    /**
     * Initializes the overlay element.
     */
    decorate: function () {
      Polymer.dom(this).classList.add('overlay');

      this.parentEl_ = this.ownerDocument.body;

      this.visible_ = false;
      this.userCanClose_ = true;

      this.onKeyDown_ = this.onKeyDown_.bind(this);
      this.onClick_ = this.onClick_.bind(this);
      this.onFocusIn_ = this.onFocusIn_.bind(this);
      this.onDocumentClick_ = this.onDocumentClick_.bind(this);
      this.onClose_ = this.onClose_.bind(this);

      this.addEventListener('visible-change', tr.ui.b.Overlay.prototype.onVisibleChange_.bind(this), true);

      // Setup the shadow root
      var createShadowRoot = this.createShadowRoot || this.webkitCreateShadowRoot;
      this.shadow_ = createShadowRoot.call(this);
      Polymer.dom(this.shadow_).appendChild(tr.ui.b.instantiateTemplate('#overlay-template', THIS_DOC));

      this.closeBtn_ = Polymer.dom(this.shadow_).querySelector('close-button');
      this.closeBtn_.addEventListener('click', this.onClose_);

      Polymer.dom(this.shadow_).querySelector('overlay-frame').addEventListener('click', this.onClick_);

      this.observer_ = new WebKitMutationObserver(this.didButtonBarMutate_.bind(this));
      this.observer_.observe(Polymer.dom(this.shadow_).querySelector('button-bar'), { childList: true });

      // title is a variable on regular HTMLElements. However, we want to
      // use it for something more useful.
      Object.defineProperty(this, 'title', {
        get: function () {
          return Polymer.dom(Polymer.dom(this.shadow_).querySelector('title')).textContent;
        },
        set: function (title) {
          Polymer.dom(Polymer.dom(this.shadow_).querySelector('title')).textContent = title;
        }
      });
    },

    set userCanClose(userCanClose) {
      this.userCanClose_ = userCanClose;
      this.closeBtn_.style.display = userCanClose ? 'block' : 'none';
    },

    get buttons() {
      return Polymer.dom(this.shadow_).querySelector('button-bar');
    },

    get visible() {
      return this.visible_;
    },

    set visible(newValue) {
      if (this.visible_ === newValue) return;

      this.visible_ = newValue;
      var e = new tr.b.Event('visible-change');
      this.dispatchEvent(e);
    },

    onVisibleChange_: function () {
      this.visible_ ? this.show_() : this.hide_();
    },

    show_: function () {
      Polymer.dom(this.parentEl_).appendChild(this);

      if (this.userCanClose_) {
        this.addEventListener('keydown', this.onKeyDown_.bind(this));
        this.addEventListener('click', this.onDocumentClick_.bind(this));
        this.closeBtn_.addEventListener('click', this.onClose_);
      }

      this.parentEl_.addEventListener('focusin', this.onFocusIn_);
      this.tabIndex = 0;

      // Focus the first thing we find that makes sense. (Skip the close button
      // as it doesn't make sense as the first thing to focus.)
      var focusEl = undefined;
      var elList = Polymer.dom(this).querySelectorAll('button, input, list, select, a');
      if (elList.length > 0) {
        if (elList[0] === this.closeBtn_) {
          if (elList.length > 1) focusEl = elList[1];
        } else {
          focusEl = elList[0];
        }
      }
      if (focusEl === undefined) focusEl = this;
      focusEl.focus();
    },

    hide_: function () {
      Polymer.dom(this.parentEl_).removeChild(this);

      this.parentEl_.removeEventListener('focusin', this.onFocusIn_);

      if (this.closeBtn_) this.closeBtn_.removeEventListener('click', this.onClose_);

      document.removeEventListener('keydown', this.onKeyDown_);
      document.removeEventListener('click', this.onDocumentClick_);
    },

    onClose_: function (e) {
      this.visible = false;
      if (e.type != 'keydown' || e.type === 'keydown' && e.keyCode === 27) e.stopPropagation();
      e.preventDefault();
      tr.b.dispatchSimpleEvent(this, 'closeclick');
    },

    onFocusIn_: function (e) {
      if (e.target === this) return;

      window.setTimeout(function () {
        this.focus();
      }, 0);
      e.preventDefault();
      e.stopPropagation();
    },

    didButtonBarMutate_: function (e) {
      var hasButtons = this.buttons.children.length > 0;
      if (hasButtons) {
        Polymer.dom(this.shadow_).querySelector('button-bar').style.display = undefined;
      } else {
        Polymer.dom(this.shadow_).querySelector('button-bar').style.display = 'none';
      }
    },

    onKeyDown_: function (e) {
      // Disallow shift-tab back to another element.
      if (e.keyCode === 9 && // tab
      e.shiftKey && e.target === this) {
        e.preventDefault();
        return;
      }

      if (e.keyCode !== 27) // escape
        return;

      this.onClose_(e);
    },

    onClick_: function (e) {
      e.stopPropagation();
    },

    onDocumentClick_: function (e) {
      if (!this.userCanClose_) return;

      this.onClose_(e);
    }
  };

  Overlay.showError = function (msg, opt_err) {
    var o = new Overlay();
    o.title = 'Error';
    Polymer.dom(o).textContent = msg;
    if (opt_err) {
      var e = tr.b.normalizeException(opt_err);

      var stackDiv = document.createElement('pre');
      Polymer.dom(stackDiv).textContent = e.stack;
      stackDiv.style.paddingLeft = '8px';
      stackDiv.style.margin = 0;
      Polymer.dom(o).appendChild(stackDiv);
    }
    var b = document.createElement('button');
    Polymer.dom(b).textContent = 'OK';
    b.addEventListener('click', function () {
      o.visible = false;
    });
    Polymer.dom(o.buttons).appendChild(b);
    o.visible = true;
    return o;
  };

  return {
    Overlay: Overlay
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/event.js":33,"../../base/utils.js":59,"./ui.js":175,"./utils.js":176}],175:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2014 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/base.js");

'use strict';

global.tr.exportTo('tr.ui.b', function () {

  /**
   * Decorates elements as an instance of a class.
   * @param {string|!Element} source The way to find the element(s) to decorate.
   *     If this is a string then {@code querySeletorAll} is used to find the
   *     elements to decorate.
   * @param {!Function} constr The constructor to decorate with. The constr
   *     needs to have a {@code decorate} function.
   */
  function decorate(source, constr) {
    var elements;
    if (typeof source == 'string') elements = Polymer.dom(tr.doc).querySelectorAll(source);else elements = [source];

    for (var i = 0, el; el = elements[i]; i++) {
      if (!(el instanceof constr)) constr.decorate(el);
    }
  }

  /**
   * Defines a tracing UI component, a function that can be called to construct
   * the component.
   *
   * tr class:
   * var List = tr.ui.b.define('list');
   * List.prototype = {
   *   __proto__: HTMLUListElement.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   *
   * Derived class:
   * var CustomList = tr.ui.b.define('custom-list', List);
   * CustomList.prototype = {
   *   __proto__: List.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   *
   * @param {string} className The className of the newly created subtype. If
   *     subclassing by passing in opt_parentConstructor, this is used for
   *     debugging. If not subclassing, then it is the tag name that will be
   *     created by the component.
    * @param {function=} opt_parentConstructor The parent class for this new
   *     element, if subclassing is desired. If provided, the parent class must
   *     be also a function created by tr.ui.b.define.
   *
   * @param {string=} opt_tagNS The namespace in which to create the base
   *     element. Has no meaning when opt_parentConstructor is passed and must
   *     either be undefined or the same namespace as the parent class.
   *
   * @return {function(Object=):Element} The newly created component
   *     constructor.
   */
  function define(className, opt_parentConstructor, opt_tagNS) {
    if (typeof className == 'function') {
      throw new Error('Passing functions as className is deprecated. Please ' + 'use (className, opt_parentConstructor) to subclass');
    }

    var className = className.toLowerCase();
    if (opt_parentConstructor && !opt_parentConstructor.tagName) throw new Error('opt_parentConstructor was not ' + 'created by tr.ui.b.define');

    // Walk up the parent constructors until we can find the type of tag
    // to create.
    var tagName = className;
    var tagNS = undefined;
    if (opt_parentConstructor) {
      if (opt_tagNS) throw new Error('Must not specify tagNS if parentConstructor is given');
      var parent = opt_parentConstructor;
      while (parent && parent.tagName) {
        tagName = parent.tagName;
        tagNS = parent.tagNS;
        parent = parent.parentConstructor;
      }
    } else {
      tagNS = opt_tagNS;
    }

    /**
     * Creates a new UI element constructor.
     * Arguments passed to the constuctor are provided to the decorate method.
     * You will need to call the parent elements decorate method from within
     * your decorate method and pass any required parameters.
     * @constructor
     */
    function f() {
      if (opt_parentConstructor && f.prototype.__proto__ != opt_parentConstructor.prototype) {
        throw new Error(className + ' prototye\'s __proto__ field is messed up. ' + 'It MUST be the prototype of ' + opt_parentConstructor.tagName);
      }

      var el;
      if (tagNS === undefined) el = tr.doc.createElement(tagName);else el = tr.doc.createElementNS(tagNS, tagName);
      f.decorate.call(this, el, arguments);
      return el;
    }

    /**
     * Decorates an element as a UI element class.
     * @param {!Element} el The element to decorate.
     */
    f.decorate = function (el) {
      el.__proto__ = f.prototype;
      el.decorate.apply(el, arguments[1]);
      el.constructor = f;
    };

    f.className = className;
    f.tagName = tagName;
    f.tagNS = tagNS;
    f.parentConstructor = opt_parentConstructor ? opt_parentConstructor : undefined;
    f.toString = function () {
      if (!f.parentConstructor) return f.tagName;
      return f.parentConstructor.toString() + '::' + f.className;
    };

    return f;
  }

  function elementIsChildOf(el, potentialParent) {
    if (el == potentialParent) return false;

    var cur = el;
    while (Polymer.dom(cur).parentNode) {
      if (cur == potentialParent) return true;
      cur = Polymer.dom(cur).parentNode;
    }
    return false;
  };

  return {
    decorate: decorate,
    define: define,
    elementIsChildOf: elementIsChildOf
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/base.js":28}],176:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright (c) 2015 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/base.js");
require("../../base/rect.js");

'use strict';

global.tr.exportTo('tr.ui.b', function () {
  function instantiateTemplate(selector, doc) {
    doc = doc || document;
    var el = Polymer.dom(doc).querySelector(selector);
    if (!el) throw new Error('Element not found');
    return doc.importNode(el.content, true);
    //    return el.createInstance();
  }

  function windowRectForElement(element) {
    var position = [element.offsetLeft, element.offsetTop];
    var size = [element.offsetWidth, element.offsetHeight];
    var node = element.offsetParent;
    while (node) {
      position[0] += node.offsetLeft;
      position[1] += node.offsetTop;
      node = node.offsetParent;
    }
    return tr.b.Rect.fromXYWH(position[0], position[1], size[0], size[1]);
  }

  function scrollIntoViewIfNeeded(el) {
    var pr = el.parentElement.getBoundingClientRect();
    var cr = el.getBoundingClientRect();
    if (cr.top < pr.top) {
      el.scrollIntoView(true);
    } else if (cr.bottom > pr.bottom) {
      el.scrollIntoView(false);
    }
  }

  function extractUrlString(url) {
    var extracted = url.replace(/url\((.*)\)/, '$1');

    // In newer versions of chrome, the contents of url() will be quoted. Remove
    // these quotes as well. If quotes are not present, match will fail and this
    // becomes a no-op.
    extracted = extracted.replace(/\"(.*)\"/, '$1');

    return extracted;
  }

  function toThreeDigitLocaleString(value) {
    return value.toLocaleString(undefined, { minimumFractionDigits: 3, maximumFractionDigits: 3 });
  }

  /**
   * Returns true if |name| is the name of an unknown HTML element.  Registered
   * polymer elements are known, so this returns false.  Typos of registered
   * polymer element names are unknown, so this returns true for typos.
   *
   * @return {boolean}
   */
  function isUnknownElementName(name) {
    return document.createElement(name) instanceof HTMLUnknownElement;
  }

  return {
    isUnknownElementName: isUnknownElementName,
    toThreeDigitLocaleString: toThreeDigitLocaleString,
    instantiateTemplate: instantiateTemplate,
    windowRectForElement: windowRectForElement,
    scrollIntoViewIfNeeded: scrollIntoViewIfNeeded,
    extractUrlString: extractUrlString
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/base.js":28,"../../base/rect.js":49}],177:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

require("./related_value_map.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  class Breakdown extends tr.v.d.Diagnostic {
    constructor() {
      super();
      this.values_ = new Map();
      this.colorScheme = undefined;
    }

    /**
     * Add a Value by an explicit name to this map.
     *
     * @param {string} name
     * @param {!(tr.v.d.ValueRef|tr.v.Value)} value
     */
    set(name, value) {
      if (typeof name !== 'string' || typeof value !== 'number') {
        throw new Error('Breakdown maps from strings to numbers');
      }
      this.values_.set(name, value);
    }

    /**
     * @param {string} name
     * @return {number}
     */
    get(name) {
      return this.values_.get(name) || 0;
    }

    *[Symbol.iterator]() {
      for (var pair of this.values_) yield pair;
    }

    asDictInto_(d) {
      d.values = {};
      for (var _ref of this) {
        var _ref2 = _slicedToArray(_ref, 2);

        var name = _ref2[0];
        var value = _ref2[1];

        d.values[name] = value;
      }if (this.colorScheme) d.colorScheme = this.colorScheme;
    }

    static fromDict(d) {
      var breakdown = new Breakdown();
      tr.b.iterItems(d.values, (name, value) => breakdown.set(name, value));
      if (d.colorScheme) breakdown.colorScheme = d.colorScheme;
      return breakdown;
    }
  }

  tr.v.d.Diagnostic.register(Breakdown, {
    elementName: 'tr-v-ui-breakdown-span'
  });

  return {
    Breakdown: Breakdown
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./related_value_map.js":185}],178:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/extension_registry.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  class Diagnostic {
    asDict() {
      var result = { type: this.constructor.name };
      this.asDictInto_(result);
      return result;
    }

    asDictInto_(d) {
      throw new Error('Abstract virtual method');
    }

    static fromDict(d) {
      var typeInfo = Diagnostic.findTypeInfoWithName(d.type);
      if (!typeInfo) throw new Error('Unrecognized diagnostic type: ' + d.type);

      return typeInfo.constructor.fromDict(d);
    }
  }

  var options = new tr.b.ExtensionRegistryOptions(tr.b.BASIC_REGISTRY_MODE);
  options.defaultMetadata = {};
  options.mandatoryBaseClass = Diagnostic;
  tr.b.decorateExtensionRegistry(Diagnostic, options);

  Diagnostic.addEventListener('will-register', function (e) {
    var constructor = e.typeInfo.constructor;
    if (!(constructor.fromDict instanceof Function) || constructor.fromDict === Diagnostic.fromDict || constructor.fromDict.length !== 1) {
      throw new Error('Diagnostics must define fromDict(d)');
    }
  });

  return {
    Diagnostic: Diagnostic
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/extension_registry.js":35}],179:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

/**
  Include all Diagnostic subclasses here so that DiagnosticMap.addDicts() and
  DiagnosticMap.fromDict() always have access to all subclasses in the
  Diagnostic registry.
**/

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

require("./breakdown.js");
require("./generic.js");
require("./iteration_info.js");
require("./related_event_set.js");
require("./related_histogram_breakdown.js");
require("./related_value_map.js");
require("./related_value_set.js");
require("./scalar.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  class DiagnosticMap extends Map {
    /**
     * Add a new Diagnostic to this map.
     *
     * @param {string} name
     * @param {!tr.v.d.Diagnostic} diagnostic
     */
    set(name, diagnostic) {
      if (typeof name !== 'string') throw new Error('name must be string, not ' + name);

      if (!(diagnostic instanceof tr.v.d.Diagnostic)) throw new Error('Must be instanceof Diagnostic: ' + diagnostic);

      Map.prototype.set.call(this, name, diagnostic);
    }

    /**
     * Add Diagnostics from a dictionary of dictionaries.
     *
     * @param {Object} dict
     */
    addDicts(dict) {
      tr.b.iterItems(dict, function (name, diagnosticDict) {
        this.set(name, tr.v.d.Diagnostic.fromDict(diagnosticDict));
      }, this);
    }

    asDict() {
      var dict = {};
      for (var _ref of this) {
        var _ref2 = _slicedToArray(_ref, 2);

        var name = _ref2[0];
        var diagnostic = _ref2[1];

        dict[name] = diagnostic.asDict();
      }
      return dict;
    }

    static fromDict(d) {
      var diagnostics = new DiagnosticMap();
      diagnostics.addDicts(d);
      return diagnostics;
    }

    static fromObject(obj) {
      var diagnostics = new DiagnosticMap();
      tr.b.iterItems(obj, function (name, diagnostic) {
        diagnostics.set(name, diagnostic);
      });
      return diagnostics;
    }
  }

  return {
    DiagnosticMap: DiagnosticMap
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./breakdown.js":177,"./generic.js":181,"./iteration_info.js":182,"./related_event_set.js":183,"./related_histogram_breakdown.js":184,"./related_value_map.js":185,"./related_value_set.js":186,"./scalar.js":187}],180:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/guid.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  /**
   * Similar to ValueRef, this is a placeholder in case the referenced Event
   * isn't available in memory to point to directly.
   */
  class EventRef {
    /**
     * @param {!Object} event
     * @param {string} event.stableId
     * @param {string} event.title
     * @param {number} event.start
     * @param {number} event.duration
     */
    constructor(event) {
      this.stableId = event.stableId;
      this.title = event.title;
      this.start = event.start;
      this.duration = event.duration;
      this.end = this.start + this.duration;

      // tr.v.d.RelatedEventSet identifies events using stableId, but
      // tr.model.EventSet uses guid.
      this.guid = tr.b.GUID.allocateSimple();
    }
  }

  return {
    EventRef: EventRef
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/guid.js":39}],181:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./diagnostic.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  /**
   * A Generic diagnostic can contain any Plain-Ol'-Data objects that can be
   * serialized using JSON.stringify(): null, boolean, number, string, array,
   * dict. Generic diagnostics cannot contain tr.v.Value objects!
   */
  class Generic extends tr.v.d.Diagnostic {
    /**
     * @param {*} value
     */
    constructor(value) {
      super();
      this.value = value;
    }

    asDictInto_(d) {
      d.value = this.value;
    }

    static fromDict(d) {
      return new Generic(d.value);
    }
  }

  tr.v.d.Diagnostic.register(Generic, {
    elementName: 'tr-v-ui-generic-diagnostic-span'
  });

  return {
    Generic: Generic
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./diagnostic.js":178}],182:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/utils.js");
require("./diagnostic.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  class IterationInfo extends tr.v.d.Diagnostic {
    constructor(opt_info) {
      super();

      this.benchmarkName_ = '';
      this.benchmarkStart_ = undefined;
      this.label_ = '';
      this.osVersion_ = '';
      this.productVersion_ = '';
      this.storyDisplayName_ = '';
      this.storyGroupingKeys_ = {};
      this.storyRepeatCounter_ = undefined;
      this.storyUrl_ = '';
      this.storysetRepeatCounter_ = undefined;

      if (opt_info) this.addInfo(opt_info);
    }

    /**
     * @param {!Object} info
     * @param {string} info.benchmarkName
     * @param {undefined|string} info.label
     * @param {undefined|!Object} info.storyGroupingKeys
     * @param {undefined|string} info.storyDisplayName
     * @param {undefined|string} info.storyUrl
     * @param {undefined|number} info.storyRepeatCounter
     * @param {number} info.storysetRepeatCounter
     * @param {number} info.benchmarkStartMs Milliseconds since Unix epoch.
     */
    addInfo(info) {
      // IterationInfo from Telemetry
      if (info.benchmarkName) this.benchmarkName_ = info.benchmarkName;
      if (info.benchmarkStartMs) this.benchmarkStart_ = new Date(info.benchmarkStartMs);
      if (info.label) this.label_ = info.label;
      if (info.storyDisplayName) this.storyDisplayName_ = info.storyDisplayName;
      if (info.storyGroupingKeys) this.storyGroupingKeys_ = info.storyGroupingKeys;
      if (info.storyRepeatCounter !== undefined) this.storyRepeatCounter_ = info.storyRepeatCounter;
      if (info.storyUrl) this.storyUrl_ = info.storyUrl;
      if (info.storysetRepeatCounter !== undefined) this.storysetRepeatCounter_ = info.storysetRepeatCounter;

      // From platform tracing metadata
      if (info['os-version']) this.osVersion_ = info['os-version'];
      if (info['product-version']) this.productVersion_ = info['product-version'];
    }

    addToValue(value) {
      value.diagnostics.set(IterationInfo.NAME, this);
    }

    /**
     * @param {!tr.v.Value} value
     * @return {(undefined|!tr.v.d.IterationInfo)}
     */
    static getFromValue(value) {
      return value.diagnostics.get(IterationInfo.NAME);
    }

    asDictInto_(d) {
      d.benchmarkName = this.benchmarkName;
      if (this.benchmarkStart) d.benchmarkStartMs = this.benchmarkStart.getTime();
      d.label = this.label;
      d.storyDisplayName = this.storyDisplayName;
      d.storyGroupingKeys = this.storyGroupingKeys;
      d.storyRepeatCounter = this.storyRepeatCounter;
      d.storyUrl = this.storyUrl;
      d.storysetRepeatCounter = this.storysetRepeatCounter;
      d['os-version'] = this.osVersion;
      d['product-version'] = this.productVersion;
    }

    static fromDict(d) {
      var info = new IterationInfo();
      info.addInfo(d);
      return info;
    }

    get displayLabel() {
      if (this.label) return this.label;
      return this.benchmarkName + ' ' + this.benchmarkStartString;
    }

    get osVersion() {
      return this.osVersion_;
    }

    get productVersion() {
      return this.productVersion_;
    }

    get benchmarkName() {
      return this.benchmarkName_;
    }

    get label() {
      return this.label_;
    }

    get storyGroupingKeys() {
      return this.storyGroupingKeys_;
    }

    get storyDisplayName() {
      return this.storyDisplayName_;
    }

    get storyUrl() {
      return this.storyUrl_;
    }

    get storyRepeatCounter() {
      return this.storyRepeatCounter_;
    }

    get storyRepeatCounterLabel() {
      return 'story repeat ' + this.storyRepeatCounter;
    }

    get storysetRepeatCounter() {
      return this.storysetRepeatCounter_;
    }

    get storysetRepeatCounterLabel() {
      return 'storyset repeat ' + this.storysetRepeatCounter;
    }

    get benchmarkStart() {
      return this.benchmarkStart_;
    }

    get benchmarkStartString() {
      if (this.benchmarkStart_ === undefined) return '';
      return tr.b.formatDate(this.benchmarkStart);
    }

    /**
     * @param {!tr.v.Value} value
     * @param {string} fieldName
     * @param {*} defaultValue
     * @return {*}
     */
    static getField(value, fieldName, defaultValue) {
      var iteration = tr.v.d.IterationInfo.getFromValue(value);
      if (!(iteration instanceof tr.v.d.IterationInfo) || !iteration[fieldName]) {
        return defaultValue;
      }
      return iteration[fieldName];
    }

    /**
     * @param {!tr.v.Value} value
     * @param {string} storyGroupingKey
     * @return {string}
     */
    static getStoryGroupingKeyLabel(value, storyGroupingKey) {
      var iteration = tr.v.d.IterationInfo.getFromValue(value);
      if (!(iteration instanceof tr.v.d.IterationInfo)) return storyGroupingKey + ': undefined';
      return storyGroupingKey + ': ' + iteration.storyGroupingKeys[storyGroupingKey];
    }
  }

  // Diagnostics generally do not need a constant name or getFromValue().
  // IterationInfo is a special kind of Diagnostic that is produced by
  // telemetry, which shepherds whole flocks of traces at once, and needs a
  // system to identify and find traces by these attributes.

  // Values produced by telemetry all have a single IterationInfo at this key in
  // their DiagnosticMap.
  IterationInfo.NAME = 'iteration';

  tr.v.d.Diagnostic.register(IterationInfo, {
    elementName: 'tr-v-ui-iteration-info-span'
  });

  return {
    IterationInfo: IterationInfo
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/utils.js":59,"./diagnostic.js":178}],183:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

require("../../model/event_set.js");
require("./diagnostic.js");
require("./event_ref.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  /**
   * @typedef {!(tr.v.d.EventRef|tr.model.Event)} EventLike
   */

  /**
   * A RelatedEventSet diagnostic contains references to Events
   */
  class RelatedEventSet extends tr.v.d.Diagnostic {
    /**
     * @param {!(tr.model.EventSet|Array.<EventLike>|EventLike)=} opt_events
     */
    constructor(opt_events) {
      super();
      this.eventsByStableId_ = new Map();
      if (opt_events) {
        if (opt_events instanceof tr.model.EventSet || opt_events instanceof Array) {
          for (var event of opt_events) this.add(event);
        } else {
          this.add(opt_events);
        }
      }
    }

    /**
     * @param {!(tr.v.d.EventRef|tr.model.Event)} event
     */
    add(event) {
      this.eventsByStableId_.set(event.stableId, event);
    }

    /**
     * @param {!(tr.v.d.EventRef|tr.model.Event)} event
     * @return {boolean}
     */
    has(event) {
      return this.eventsByStableId_.has(event.stableId);
    }

    get length() {
      return this.eventsByStableId_.size;
    }

    *[Symbol.iterator]() {
      for (var _ref of this.eventsByStableId_) {
        var _ref2 = _slicedToArray(_ref, 2);

        var stableId = _ref2[0];
        var event = _ref2[1];

        yield event;
      }
    }

    /**
     * Resolve all EventRefs into Events by finding their stableIds in |model|.
     * If a stableId cannot be found and |opt_required| is true, then throw an
     * Error.
     * If a stableId cannot be found and |opt_required| is false, then the
     * EventRef will remain an EventRef.
     *
     * @param {!tr.model.Model} model
     * @param {boolean=} opt_required
     */
    resolve(model, opt_required) {
      for (var _ref3 of this.eventsByStableId_) {
        var _ref4 = _slicedToArray(_ref3, 2);

        var stableId = _ref4[0];
        var event = _ref4[1];

        if (!(event instanceof tr.v.d.EventRef)) continue;

        event = model.getEventByStableId(stableId);
        if (event instanceof tr.model.Event) this.eventsByStableId_.set(stableId, event);else if (opt_required) throw new Error('Unable to find Event ' + stableId);
      }
    }

    asDictInto_(d) {
      d.events = [];
      for (var event of this) {
        d.events.push({
          stableId: event.stableId,
          title: event.title,
          start: event.start,
          duration: event.duration
        });
      }
    }

    static fromDict(d) {
      return new RelatedEventSet(d.events.map(event => new tr.v.d.EventRef(event)));
    }
  }

  tr.v.d.Diagnostic.register(RelatedEventSet, {
    elementName: 'tr-v-ui-related-event-set-span'
  });

  return {
    RelatedEventSet: RelatedEventSet
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../model/event_set.js":120,"./diagnostic.js":178,"./event_ref.js":180}],184:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./related_value_map.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  var COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER = 'ChromeUserFriendlyCategory';

  /**
   * RelatedHistogramBreakdown encapsulates an additive relationship between
   * Histograms: the Histogram that contains this RelatedHistogramBreakdown
   * diagnostic is composed of the Histograms referenced by this
   * RelatedHistogramBreakdown diagnostic. RelatedHistogramBreakdown is a
   * "breakdown" of its containing Histogram into its contained Histograms. This
   * additive relationship can apply to groups of other things besides Events,
   * such as memory allocations. RelatedHistogramBreakdowns over groups of
   * Events is expected to be the most common way of building
   * RelatedHistogramBreakdowns, though it is not the only way. See
   * buildFromEvents() for an example of how to build a
   * RelatedHistogramBreakdown from an EventSet and a grouping function.
   */
  class RelatedHistogramBreakdown extends tr.v.d.RelatedValueMap {
    constructor() {
      super();
      this.colorScheme = undefined;
    }

    /**
     * Add a Histogram by an explicit name to this map.
     *
     * @param {string} name
     * @param {!(tr.v.d.ValueRef|tr.v.Histogram)} value
     */
    set(name, value) {
      if (!(value instanceof tr.v.d.ValueRef)) {
        if (!(value instanceof tr.v.Histogram)) {
          throw new Error('RelatedHistogramBreakdown can only contain Histograms');
        }

        if (value.name.indexOf(name) !== value.name.length - name.length) {
          throw new Error('RelatedHistogramBreakdown name must be a suffix of value.name');
        }

        if (this.length > 0 && value.unit !== tr.b.getFirstElement(this)[1].unit) {
          throw new Error('Units mismatch', tr.b.getFirstElement(this)[1].unit, value.unit);
        }
      }

      tr.v.d.RelatedValueMap.prototype.set.call(this, name, value);
    }

    asDictInto_(d) {
      tr.v.d.RelatedValueMap.prototype.asDictInto_.call(this, d);
      if (this.colorScheme) d.colorScheme = this.colorScheme;
    }

    static fromDict(d) {
      var diagnostic = new RelatedHistogramBreakdown();
      tr.b.iterItems(d.values, function (name, guid) {
        diagnostic.set(name, new tr.v.d.ValueRef(guid));
      });
      if (d.colorScheme) diagnostic.colorScheme = d.colorScheme;
      return diagnostic;
    }

    /**
    * Build a RelatedHistogramBreakdown and its Histograms from |events|.  Group
    * events using |categoryForEvent|. Add the Histograms to |values|.
    * Histograms' names are prefixed with |namePrefix|. Histograms are built
    * with |opt_binBoundaries|. The numeric sample for each Event is derived
    * from |opt_sampleForEvent|, which defaults to event.cpuSelfTime. The caller
    * must add the result RelatedHistogramBreakdown to their Histogram's
    * diagnostics.
    *
    * @param {!tr.v.ValueSet} values
    * @param {string} namePrefix
    * @param {!tr.model.EventSet} events
    * @param {!function(!tr.model.Event):string} categoryForEvent
    * @param {!tr.b.Unit} unit
    * @param {!function(!tr.model.Event):number=} opt_sampleForEvent
    * @param {!tr.v.HistogramBinBoundaries=} opt_binBoundaries
    * @param {*=} opt_this
    * @return {!RelatedHistogramBreakdown}
    */
    static buildFromEvents(values, namePrefix, events, categoryForEvent, unit, opt_sampleForEvent, opt_binBoundaries, opt_this) {
      var sampleForEvent = opt_sampleForEvent || (event => event.cpuSelfTime);

      var diagnostic = new RelatedHistogramBreakdown();
      for (var event of events) {
        var sample = sampleForEvent.call(opt_this, event);
        if (sample === undefined) continue;

        var eventCategory = categoryForEvent.call(opt_this, event);
        var value = diagnostic.get(eventCategory);
        if (value === undefined) {
          value = new tr.v.Histogram(namePrefix + eventCategory, unit, opt_binBoundaries);
          values.addHistogram(value);
          diagnostic.set(eventCategory, value);
        }

        value.addSample(sample, { relatedEvents: new tr.v.d.RelatedEventSet([event]) });
      }
      return diagnostic;
    }
  }

  tr.v.d.Diagnostic.register(RelatedHistogramBreakdown, {
    elementName: 'tr-v-ui-breakdown-span'
  });

  return {
    COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER: COLOR_SCHEME_CHROME_USER_FRIENDLY_CATEGORY_DRIVER,
    RelatedHistogramBreakdown: RelatedHistogramBreakdown
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./related_value_map.js":185}],185:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

require("../../base/iteration_helpers.js");
require("./diagnostic.js");
require("./value_ref.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  class RelatedValueMap extends tr.v.d.Diagnostic {
    constructor() {
      super();
      this.valuesByName_ = new Map();
    }

    /**
     * Lookup a Histogram by name. Returns undefined if |name| is not found.
     *
     * @param {string} name
     * @return {!tr.v.d.ValueRef|!tr.v.Histogram|undefined}
     */
    get(name) {
      return this.valuesByName_.get(name);
    }

    /**
     * Add a Histogram by an explicit name to this map.
     *
     * @param {string} name
     * @param {!(tr.v.d.ValueRef|tr.v.Histogram)} value
     */
    set(name, value) {
      if (!(value instanceof tr.v.Histogram) && !(value instanceof tr.v.d.ValueRef)) throw new Error('Must be instanceof Histogram or ValueRef: ' + value);

      this.valuesByName_.set(name, value);
    }

    /**
     * Add a Histogram implicitly by its own name to this map.
     *
     * @param {!(tr.v.d.ValueRef|tr.v.Histogram)} value
     */
    add(value) {
      this.set(value.name, value);
    }

    get length() {
      return this.valuesByName_.size;
    }

    *[Symbol.iterator]() {
      for (var pair of this.valuesByName_) yield pair;
    }

    /**
     * Resolve all ValueRefs into Values by looking up their guids in
     * |valueSet|.
     * If a value cannot be found and |opt_required| is true, then throw an
     * Error.
     * If a value cannot be found and |opt_required| is false, then the ValueRef
     * will remain a ValueRef.
     *
     * @param {!tr.v.ValueSet} valueSet
     * @param {boolean=} opt_required
     */
    resolve(valueSet, opt_required) {
      for (var _ref of this) {
        var _ref2 = _slicedToArray(_ref, 2);

        var name = _ref2[0];
        var value = _ref2[1];

        if (!(value instanceof tr.v.d.ValueRef)) continue;

        var guid = value.guid;
        value = valueSet.lookup(guid);
        if (value instanceof tr.v.Histogram) this.valuesByName_.set(name, value);else if (opt_required) throw new Error('Unable to find Histogram ' + guid);
      }
    }

    asDictInto_(d) {
      d.values = {};
      for (var _ref3 of this) {
        var _ref4 = _slicedToArray(_ref3, 2);

        var name = _ref4[0];
        var value = _ref4[1];

        d.values[name] = value.guid;
      }
    }

    static fromDict(d) {
      var map = new RelatedValueMap();
      tr.b.iterItems(d.values, function (name, guid) {
        map.set(name, new tr.v.d.ValueRef(guid));
      });
      return map;
    }
  }

  tr.v.d.Diagnostic.register(RelatedValueMap, {
    elementName: 'tr-v-ui-related-value-map-span'
  });

  return {
    RelatedValueMap: RelatedValueMap
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/iteration_helpers.js":41,"./diagnostic.js":178,"./value_ref.js":188}],186:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

require("../../base/iteration_helpers.js");
require("./diagnostic.js");
require("./value_ref.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  class RelatedValueSet extends tr.v.d.Diagnostic {
    constructor(opt_values) {
      super();
      this.valuesByGuid_ = new Map();

      if (opt_values) for (var value of opt_values) this.add(value);
    }

    /**
     * @param {!(tr.v.d.ValueRef|tr.v.Histogram)} v
     */
    add(value) {
      if (!(value instanceof tr.v.Histogram) && !(value instanceof tr.v.d.ValueRef)) throw new Error('Must be instanceof Histogram or ValueRef: ' + value);

      if (this.valuesByGuid_.get(value.guid)) throw new Error('Tried to add same value twice');

      this.valuesByGuid_.set(value.guid, value);
    }

    has(value) {
      return this.valuesByGuid_.has(value.guid);
    }

    get length() {
      return this.valuesByGuid_.size;
    }

    *[Symbol.iterator]() {
      for (var _ref of this.valuesByGuid_) {
        var _ref2 = _slicedToArray(_ref, 2);

        var guid = _ref2[0];
        var value = _ref2[1];

        yield value;
      }
    }

    /**
     * Resolve all ValueRefs into Values by looking up their guids in
     * |valueSet|.
     * If a value cannot be found and |opt_required| is true, then throw an
     * Error.
     * If a value cannot be found and |opt_required| is false, then the ValueRef
     * will remain a ValueRef.
     *
     * @param {!tr.v.ValueSet} valueSet
     * @param {boolean=} opt_required
     */
    resolve(valueSet, opt_required) {
      for (var _ref3 of this.valuesByGuid_) {
        var _ref4 = _slicedToArray(_ref3, 2);

        var guid = _ref4[0];
        var value = _ref4[1];

        if (!(value instanceof tr.v.d.ValueRef)) continue;

        value = valueSet.lookup(guid);
        if (value instanceof tr.v.Histogram) this.valuesByGuid_.set(guid, value);else if (opt_required) throw new Error('Unable to find Histogram ' + guid);
      }
    }

    asDictInto_(d) {
      d.guids = [];
      for (var value of this) d.guids.push(value.guid);
    }

    static fromDict(d) {
      return new RelatedValueSet(d.guids.map(guid => new tr.v.d.ValueRef(guid)));
    }
  }

  tr.v.d.Diagnostic.register(RelatedValueSet, {
    elementName: 'tr-v-ui-related-value-set-span'
  });

  return {
    RelatedValueSet: RelatedValueSet
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/iteration_helpers.js":41,"./diagnostic.js":178,"./value_ref.js":188}],187:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("./diagnostic.js");
require("../numeric.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  class Scalar extends tr.v.d.Diagnostic {
    /**
     * @param {!tr.v.ScalarNumeric} value
     */
    constructor(value) {
      super();
      if (!(value instanceof tr.v.ScalarNumeric)) throw new Error("expected ScalarNumeric");
      this.value = value;
    }

    asDictInto_(d) {
      d.value = this.value.asDict();
    }

    static fromDict(d) {
      return new Scalar(tr.v.ScalarNumeric.fromDict(d.value));
    }
  }

  tr.v.d.Diagnostic.register(Scalar, {
    elementName: 'tr-v-ui-scalar-diagnostic-span'
  });

  return {
    Scalar: Scalar
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../numeric.js":190,"./diagnostic.js":178}],188:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../../base/base.js");

'use strict';

global.tr.exportTo('tr.v.d', function () {
  /** @constructor */
  function ValueRef(guid) {
    this.guid = guid;
  }

  return {
    ValueRef: ValueRef
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../base/base.js":28}],189:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

require("../base/iteration_helpers.js");
require("../base/range.js");
require("../base/running_statistics.js");
require("../base/sorted_array_utils.js");
require("../base/statistics.js");
require("../base/unit.js");
require("./diagnostics/diagnostic_map.js");
require("./numeric.js");

'use strict';

global.tr.exportTo('tr.v', function () {
  var MAX_DIAGNOSTIC_MAPS = 16;

  var DEFAULT_BOUNDARIES_FOR_UNIT = new Map();

  class HistogramBin {
    /**
     * @param {!tr.b.Range} range
     */
    constructor(range) {
      this.range = range;
      this.count = 0;
      this.diagnosticMaps = [];
    }

    /**
     * @param {*} value
     */
    addSample(value) {
      this.count += 1;
    }

    /**
     * @param {!tr.v.d.DiagnosticMap} diagnostics
     */
    addDiagnosticMap(diagnostics) {
      tr.b.Statistics.uniformlySampleStream(this.diagnosticMaps, this.count, diagnostics, MAX_DIAGNOSTIC_MAPS);
    }

    addBin(other) {
      if (!this.range.equals(other.range)) throw new Error('Merging incompatible Histogram bins.');
      tr.b.Statistics.mergeSampledStreams(this.diagnosticMaps, this.count, other.diagnosticMaps, other.count, MAX_DIAGNOSTIC_MAPS);
      this.count += other.count;
    }

    fromDict(dict) {
      this.count = dict[0];
      if (dict.length > 1) {
        for (var map of dict[1]) {
          this.diagnosticMaps.push(tr.v.d.DiagnosticMap.fromDict(map));
        }
      }
    }

    asDict() {
      if (!this.diagnosticMaps.length) {
        return [this.count];
      }
      // It's more efficient to serialize these 2 fields in an array. If you
      // add any other fields, you should re-evaluate whether it would be more
      // efficient to serialize as a dict.
      return [this.count, this.diagnosticMaps.map(d => d.asDict())];
    }
  }

  var DEFAULT_SUMMARY_OPTIONS = new Map([['avg', true], ['geometricMean', false], ['std', true], ['count', true], ['sum', true], ['min', true], ['max', true], ['nans', false]]);

  /**
   * This is basically a histogram, but so much more.
   * Histogram is serializable using asDict/fromDict.
   * Histogram computes several statistics of its contents.
   * Histograms can be merged.
   * getDifferenceSignificance() test whether one Histogram is statistically
   * significantly different from another Histogram.
   * Histogram stores a random sample of the exact number values added to it.
   * Histogram stores a random sample of optional per-sample DiagnosticMaps.
   * Histogram is visualized by <tr-v-ui-histogram-span>, which supports
   * selecting bins, and visualizing the DiagnosticMaps of selected bins.
   *
   * @param {!tr.b.Unit} unit
   * @param {!tr.v.HistogramBinBoundaries=} opt_binBoundaries
   */
  class Histogram {
    constructor(name, unit, opt_binBoundaries) {
      var binBoundaries = opt_binBoundaries;
      if (!binBoundaries) {
        var baseUnit = unit.baseUnit ? unit.baseUnit : unit;
        binBoundaries = DEFAULT_BOUNDARIES_FOR_UNIT.get(baseUnit.unitName);
      }

      // If this Histogram is being deserialized, then its guid will be set by
      // fromDict().
      // If this Histogram is being computed by a metric, then its guid will be
      // allocated the first time the guid is gotten by asDict().
      this.guid_ = undefined;

      // Serialize binBoundaries here instead of holding a reference to it in
      // case it is modified.
      this.binBoundariesDict_ = binBoundaries.asDict();

      this.centralBins = [];
      this.description = '';
      this.diagnostics = new tr.v.d.DiagnosticMap();
      this.maxCount_ = 0;
      this.name_ = name;
      this.nanDiagnosticMaps = [];
      this.numNans = 0;
      this.running = new tr.b.RunningStatistics();
      this.sampleValues_ = [];
      this.shortName = undefined;
      this.summaryOptions = new Map(DEFAULT_SUMMARY_OPTIONS);
      this.summaryOptions.set('percentile', []);
      this.unit = unit;

      this.underflowBin = new HistogramBin(tr.b.Range.fromExplicitRange(-Number.MAX_VALUE, binBoundaries.range.min));
      this.overflowBin = new HistogramBin(tr.b.Range.fromExplicitRange(binBoundaries.range.max, Number.MAX_VALUE));

      for (var range of binBoundaries.binRanges()) {
        this.centralBins.push(new HistogramBin(range));
      }

      this.allBins = [this.underflowBin];
      for (var bin of this.centralBins) this.allBins.push(bin);
      this.allBins.push(this.overflowBin);

      this.maxNumSampleValues_ = this.defaultMaxNumSampleValues_;
    }

    get maxNumSampleValues() {
      return this.maxNumSampleValues_;
    }

    set maxNumSampleValues(n) {
      this.maxNumSampleValues_ = n;
      tr.b.Statistics.uniformlySampleArray(this.sampleValues_, this.maxNumSampleValues_);
    }

    get name() {
      return this.name_;
    }

    get guid() {
      if (this.guid_ === undefined) this.guid_ = tr.b.GUID.allocateUUID4();

      return this.guid_;
    }

    set guid(guid) {
      if (this.guid_ !== undefined) throw new Error('Cannot reset guid');

      this.guid_ = guid;
    }

    static fromDict(dict) {
      var hist = new Histogram(dict.name, tr.b.Unit.fromJSON(dict.unit), HistogramBinBoundaries.fromDict(dict.binBoundaries));
      hist.guid = dict.guid;
      if (dict.shortName) {
        hist.shortName = dict.shortName;
      }
      if (dict.description) {
        hist.description = dict.description;
      }
      if (dict.diagnostics) {
        hist.diagnostics.addDicts(dict.diagnostics);
      }
      if (dict.underflowBin) {
        hist.underflowBin.fromDict(dict.underflowBin);
      }
      if (dict.overflowBin) {
        hist.overflowBin.fromDict(dict.overflowBin);
      }
      if (dict.centralBins) {
        if (dict.centralBins.length !== undefined) {
          for (var i = 0; i < dict.centralBins.length; ++i) {
            hist.centralBins[i].fromDict(dict.centralBins[i]);
          }
        } else {
          tr.b.iterItems(dict.centralBins, (i, binDict) => {
            hist.centralBins[i].fromDict(binDict);
          });
        }
      }
      for (var bin of hist.allBins) {
        hist.maxCount_ = Math.max(hist.maxCount_, bin.count);
      }
      if (dict.running) {
        hist.running = tr.b.RunningStatistics.fromDict(dict.running);
      }
      if (dict.summaryOptions) {
        hist.customizeSummaryOptions(dict.summaryOptions);
      }
      if (dict.maxNumSampleValues !== undefined) {
        hist.maxNumSampleValues = dict.maxNumSampleValues;
      }
      if (dict.sampleValues) {
        hist.sampleValues_ = dict.sampleValues;
      }
      if (dict.numNans) {
        hist.numNans = dict.numNans;
      }
      if (dict.nanDiagnostics) {
        for (var map of dict.nanDiagnostics) {
          hist.nanDiagnosticMaps.push(tr.v.d.DiagnosticMap.fromDict(map));
        }
      }
      return hist;
    }

    /**
     * Build a Histogram from a set of samples in order to effectively merge a
     * set of ScalarNumerics.
     * The range of the resulting histogram is determined by the smallest and
     * largest sample value, which is unpredictable.
     * https://github.com/catapult-project/catapult/issues/2685
     *
     * @param {!tr.b.Unit} unit
     * @param {!Array.<number>} samples
     * @return {!Histogram}
     */
    static buildFromSamples(unit, samples) {
      var boundaries = HistogramBinBoundaries.createFromSamples(samples);
      var result = new Histogram(unit, boundaries);
      result.maxNumSampleValues = 1000;

      // TODO(eakuefner): Propagate diagnosticMaps?
      for (var sample of samples) result.addSample(sample);

      return result;
    }

    get numValues() {
      return tr.b.Statistics.sum(this.allBins, function (e) {
        return e.count;
      });
    }

    get average() {
      return this.running.mean;
    }

    get standardDeviation() {
      return this.running.stddev;
    }

    get geometricMean() {
      return this.running.geometricMean;
    }

    get sum() {
      return this.running.sum;
    }

    get maxCount() {
      return this.maxCount_;
    }

    /**
     * Requires that units agree.
     * Returns DONT_CARE if that is the units' improvementDirection.
     * Returns SIGNIFICANT if the Mann-Whitney U test returns a
     * p-value less than opt_alpha or DEFAULT_ALPHA. Returns INSIGNIFICANT if
     * the p-value is greater than alpha.
     *
     * @param {!tr.v.Histogram} other
     * @param {number=} opt_alpha
     * @return {!tr.b.Statistics.Significance}
     */
    getDifferenceSignificance(other, opt_alpha) {
      if (this.unit !== other.unit) throw new Error('Cannot compare Numerics with different units');

      if (this.unit.improvementDirection === tr.b.ImprovementDirection.DONT_CARE) {
        return tr.b.Statistics.Significance.DONT_CARE;
      }

      if (!(other instanceof Histogram)) throw new Error('Unable to compute a p-value');

      var testResult = tr.b.Statistics.mwu(this.sampleValues, other.sampleValues, opt_alpha);
      return testResult.significance;
    }

    /*
     * Compute an approximation of percentile based on the counts in the bins.
     * If the real percentile lies within |this.range| then the result of
     * the function will deviate from the real percentile by at most
     * the maximum width of the bin(s) within which the point(s)
     * from which the real percentile would be calculated lie.
     * If the real percentile is outside |this.range| then the function
     * returns the closest range limit: |this.range.min| or |this.range.max|.
     *
     * @param {number} percent The percent must be between 0.0 and 1.0.
     */
    getApproximatePercentile(percent) {
      if (!(percent >= 0 && percent <= 1)) throw new Error('percent must be [0,1]');
      if (this.numValues == 0) return 0;
      var valuesToSkip = Math.floor((this.numValues - 1) * percent);
      for (var i = 0; i < this.allBins.length; i++) {
        var bin = this.allBins[i];
        valuesToSkip -= bin.count;
        if (valuesToSkip < 0) {
          if (bin === this.underflowBin) return bin.range.max;else if (bin === this.overflowBin) return bin.range.min;else return bin.range.center;
        }
      }
      throw new Error('Unreachable');
    }

    getBinForValue(value) {
      // Don't use subtraction to avoid arithmetic overflow.
      var binIndex = tr.b.findHighIndexInSortedArray(this.allBins, b => value < b.range.max ? -1 : 1);
      return this.allBins[binIndex] || this.overflowBin;
    }

    /**
     * @param {number|*} value
     * @param {(!Object|!tr.v.d.DiagnosticMap)=} opt_diagnostics
     */
    addSample(value, opt_diagnostics) {
      if (opt_diagnostics && !(opt_diagnostics instanceof tr.v.d.DiagnosticMap)) opt_diagnostics = tr.v.d.DiagnosticMap.fromObject(opt_diagnostics);

      if (typeof value !== 'number' || isNaN(value)) {
        this.numNans++;
        if (opt_diagnostics) {
          tr.b.Statistics.uniformlySampleStream(this.nanDiagnosticMaps, this.numNans, opt_diagnostics, MAX_DIAGNOSTIC_MAPS);
        }
      } else {
        this.running.add(value);

        var bin = this.getBinForValue(value);
        bin.addSample(value);
        if (opt_diagnostics) bin.addDiagnosticMap(opt_diagnostics);
        if (bin.count > this.maxCount_) this.maxCount_ = bin.count;
      }

      tr.b.Statistics.uniformlySampleStream(this.sampleValues_, this.numValues + this.numNans, value, this.maxNumSampleValues);
    }

    sampleValuesInto(samples) {
      for (var sampleValue of this.sampleValues) samples.push(sampleValue);
    }

    /**
     * Return true if this Histogram can be added to |other|.
     *
     * @param {!tr.v.Histogram} other
     * @return {boolean}
     */
    canAddHistogram(other) {
      if (this.unit !== other.unit) return false;
      if (this.allBins.length !== other.allBins.length) return false;

      for (var i = 0; i < this.allBins.length; ++i) if (!this.allBins[i].range.equals(other.allBins[i].range)) return false;

      return true;
    }

    /**
     * Add |other| to this Histogram in-place if they can be added.
     *
     * @param {!tr.v.Histogram} other
     */
    addHistogram(other) {
      if (!this.canAddHistogram(other)) {
        throw new Error('Merging incompatible Histograms');
      }

      tr.b.Statistics.mergeSampledStreams(this.nanDiagnosticMaps, this.numNans, other.nanDiagnosticMaps, other.numNans, MAX_DIAGNOSTIC_MAPS);
      tr.b.Statistics.mergeSampledStreams(this.sampleValues, this.numValues, other.sampleValues, other.numValues, tr.b.Statistics.mean([this.maxNumSampleValues, other.maxNumSampleValues]));
      this.numNans += other.numNans;
      this.running = this.running.merge(other.running);
      for (var i = 0; i < this.allBins.length; ++i) {
        this.allBins[i].addBin(other.allBins[i]);
      }
    }

    /**
     * Controls which statistics are exported to dashboard for this numeric.
     * The |summaryOptions| parameter is a dictionary with optional boolean
     * fields |count|, |sum|, |avg|, |std|, |min|, |max| and an optional
     * array field |percentile|.
     * Each percentile should be a number between 0.0 and 1.0.
     * The options not included in the |summaryOptions| will not change.
     */
    customizeSummaryOptions(summaryOptions) {
      tr.b.iterItems(summaryOptions, (key, value) => this.summaryOptions.set(key, value));
    }

    /**
     * Returns a Map {statisticName: ScalarNumeric}.
     *
     * Each enabled summary option produces the corresponding value:
     * min, max, count, sum, avg, or std.
     * Each percentile 0.x produces pct_0x0.
     * Each percentile 0.xx produces pct_0xx.
     * Each percentile 0.xxy produces pct_0xx_y.
     * Percentile 1.0 produces pct_100.
     *
     * @return {!Map.<string, ScalarNumeric>}
     */
    get statisticsScalars() {
      function statNameToKey(stat) {
        switch (stat) {
          case 'std':
            return 'stddev';
          case 'avg':
            return 'mean';
        }
        return stat;
      }
      /**
       * Converts the given percent to a string in the format specified above.
       * @param {number} percent The percent must be between 0.0 and 1.0.
       */
      function percentToString(percent) {
        if (percent < 0 || percent > 1) throw new Error('Percent must be between 0.0 and 1.0');
        switch (percent) {
          case 0:
            return '000';
          case 1:
            return '100';
        }
        var str = percent.toString();
        if (str[1] !== '.') throw new Error('Unexpected percent');
        // Pad short strings with zeros.
        str = str + '0'.repeat(Math.max(4 - str.length, 0));
        if (str.length > 4) str = str.slice(0, 4) + '_' + str.slice(4);
        return '0' + str.slice(2);
      }

      var results = new Map();
      for (var _ref of this.summaryOptions) {
        var _ref2 = _slicedToArray(_ref, 2);

        var stat = _ref2[0];
        var option = _ref2[1];

        if (!option) {
          continue;
        }

        if (stat === 'percentile') {
          for (var percent of option) {
            var percentile = this.getApproximatePercentile(percent);
            results.set('pct_' + percentToString(percent), new tr.v.ScalarNumeric(this.unit, percentile));
          }
        } else if (stat === 'nans') {
          results.set('nans', new tr.v.ScalarNumeric(tr.b.Unit.byName.count_smallerIsBetter, this.numNans));
        } else {
          var statUnit = stat === 'count' ? tr.b.Unit.byName.count_smallerIsBetter : this.unit;
          var key = statNameToKey(stat);
          var statValue = this.running[key];

          if (typeof statValue === 'number') {
            results.set(stat, new tr.v.ScalarNumeric(statUnit, statValue));
          }
        }
      }
      return results;
    }

    get sampleValues() {
      return this.sampleValues_;
    }

    /**
     * Create a new Histogram object that is exactly the same as this one, with
     * this Histogram's name, unit, and binBoundaries, guid, bin counts, and
     * diagnostics.
     * @return {!tr.v.Histogram}
     */
    clone() {
      return Histogram.fromDict(this.asDict());
    }

    /**
     * Create a new Histogram with this Histogram's name, unit, and
     * binBoundaries, but not its guid, bin counts, or diagnostics.
     * @return {!tr.v.Histogram}
     */
    cloneEmpty() {
      var binBoundaries = HistogramBinBoundaries.fromDict(this.binBoundariesDict_);
      return new Histogram(this.name, this.unit, binBoundaries);
    }

    asDict() {
      var dict = {};
      dict.binBoundaries = this.binBoundariesDict_;
      dict.name = this.name;
      dict.unit = this.unit.asJSON();
      dict.guid = this.guid;
      if (this.shortName) {
        dict.shortName = this.shortName;
      }
      if (this.description) {
        dict.description = this.description;
      }
      if (this.diagnostics.size) {
        dict.diagnostics = this.diagnostics.asDict();
      }
      if (this.maxNumSampleValues !== this.defaultMaxNumSampleValues_) {
        dict.maxNumSampleValues = this.maxNumSampleValues;
      }
      if (this.numNans) {
        dict.numNans = this.numNans;
      }
      if (this.nanDiagnosticMaps.length) {
        dict.nanDiagnostics = this.nanDiagnosticMaps.map(dm => dm.asDict());
      }
      if (this.underflowBin.count) {
        dict.underflowBin = this.underflowBin.asDict();
      }
      if (this.overflowBin.count) {
        dict.overflowBin = this.overflowBin.asDict();
      }

      if (this.numValues) {
        dict.sampleValues = this.sampleValues.slice();
        dict.running = this.running.asDict();
        dict.centralBins = this.centralBinsAsDict_();
      }

      var summaryOptions = {};
      var anyOverriddenSummaryOptions = false;
      for (var _ref3 of this.summaryOptions) {
        var _ref4 = _slicedToArray(_ref3, 2);

        var name = _ref4[0];
        var option = _ref4[1];

        if (name === 'percentile') {
          if (option.length === 0) {
            continue;
          }
          option = option.slice();
        } else if (option === DEFAULT_SUMMARY_OPTIONS.get(name)) {
          continue;
        }
        summaryOptions[name] = option;
        anyOverriddenSummaryOptions = true;
      }
      if (anyOverriddenSummaryOptions) {
        dict.summaryOptions = summaryOptions;
      }

      return dict;
    }

    centralBinsAsDict_() {
      // dict.centralBins may be either an array or a dict, whichever is more
      // efficient.
      // The overhead of the array form is significant when the histogram is
      // sparse, and the overhead of the dict form is significant when the
      // histogram is dense.
      // The dict form is more efficient when more than half of centralBins are
      // empty. The array form is more efficient when fewer than half of
      // centralBins are empty.

      var numCentralBins = this.centralBins.length;

      // If all centralBins are empty, then don't serialize anything for them.
      var emptyBins = 0;

      for (var i = 0; i < numCentralBins; ++i) {
        if (this.centralBins[i].count === 0) {
          ++emptyBins;
        }
      }

      if (emptyBins === numCentralBins) {
        return undefined;
      }

      if (emptyBins > numCentralBins / 2) {
        var centralBinsDict = {};
        for (var i = 0; i < numCentralBins; ++i) {
          var bin = this.centralBins[i];
          if (bin.count > 0) {
            centralBinsDict[i] = bin.asDict();
          }
        }
        return centralBinsDict;
      }

      var centralBinsArray = [];
      for (var i = 0; i < numCentralBins; ++i) {
        centralBinsArray.push(this.centralBins[i].asDict());
      }
      return centralBinsArray;
    }

    get defaultMaxNumSampleValues_() {
      return this.allBins.length * 10;
    }
  }

  var HISTOGRAM_BIN_BOUNDARIES_CACHE = new Map();

  /**
   * Reusable builder for tr.v.Histogram objects.
   *
   * The bins of the numeric are specified by adding the desired boundaries
   * between bins. Initially, the builder has only a single boundary:
   *
   *            range.min=range.max
   *                     |
   *                     |
   *   -MAX_INT <--------|------------------------------------------> +MAX_INT
   *       :  resulting  :                   resulting                    :
   *       :  underflow  :                    overflow                    :
   *       :     bin     :                      bin                       :
   *
   * More boundaries can be added (in increasing order) using addBinBoundary,
   * addLinearBins and addExponentialBins:
   *
   *                range.min                           range.max
   *                     |         |         |     |         |
   *                     |         |         |     |         |
   *   -MAX_INT <--------|---------|---------|-----|---------|------> +MAX_INT
   *       :  resulting  : result. : result. :     : result. : resulting  :
   *       :  underflow  : central : central : ... : central :  overflow  :
   *       :     bin     :  bin 0  :  bin 1  :     : bin N-1 :    bin     :
   *
   * An important feature of the builder is that it's reusable, i.e. it can be
   * used to build multiple numerics with the same unit and bin structure.
   *
   */
  class HistogramBinBoundaries {
    /**
     * Create a linearly scaled tr.v.HistogramBinBoundaries with |numBins| bins
     * ranging from |min| to |max|.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} numBins
     * @return {tr.v.HistogramBinBoundaries}
     */
    static createLinear(min, max, numBins) {
      return new HistogramBinBoundaries(min).addLinearBins(max, numBins);
    }

    /**
     * Create an exponentially scaled tr.v.HistogramBinBoundaries with |numBins|
     * bins ranging from |min| to |max|.
     *
     * @param {number} min
     * @param {number} max
     * @param {number} numBins
     * @return {tr.v.HistogramBinBoundaries}
     */
    static createExponential(min, max, numBins) {
      return new HistogramBinBoundaries(min).addExponentialBins(max, numBins);
    }

    /**
     * @param {Array.<number>} binBoundaries
     */
    static createWithBoundaries(binBoundaries) {
      var builder = new HistogramBinBoundaries(binBoundaries[0]);
      for (var boundary of binBoundaries.slice(1)) builder.addBinBoundary(boundary);
      return builder;
    }

    static createFromSamples(samples) {
      var range = new tr.b.Range();
      // Prevent non-numeric samples from introducing NaNs into the range.
      for (var sample of samples) if (!isNaN(Math.max(sample))) range.addValue(sample);

      // HistogramBinBoundaries.addLinearBins() requires this.
      if (range.isEmpty) range.addValue(1);
      if (range.min === range.max) range.addValue(range.min - 1);

      // This optimizes the resolution when samples are uniformly distributed
      // (which is almost never the case).
      var numBins = Math.ceil(Math.sqrt(samples.length));
      var builder = new HistogramBinBoundaries(range.min);
      builder.addLinearBins(range.max, numBins);
      return builder;
    }

    /**
     * @param {number} minBinBoundary The minimum boundary between bins, namely
     *     the underflow bin and the first central bin (or the overflow bin if
     *     no other boundaries are added later).
     */
    constructor(minBinBoundary) {
      this.boundaries_ = undefined;
      this.builder_ = [minBinBoundary];
      this.range_ = new tr.b.Range();
      this.range_.addValue(minBinBoundary);
    }

    get range() {
      return this.range_;
    }

    asDict() {
      // Copy builder_ in case ours is modified later.
      return this.builder_.slice();
    }

    static fromDict(dict) {
      // When loading a results2.html with many Histograms with the same bin
      // boundaries, caching the HistogramBinBoundaries not only speeds up
      // loading, but also prevents a bug where build_ is occasionally
      // non-deterministic, which causes similar Histograms to be unmergeable.
      var cacheKey = JSON.stringify(dict);
      if (HISTOGRAM_BIN_BOUNDARIES_CACHE.has(cacheKey)) {
        return HISTOGRAM_BIN_BOUNDARIES_CACHE.get(cacheKey);
      }

      var binBoundaries = new HistogramBinBoundaries(dict[0]);
      for (var slice of dict.slice(1)) {
        if (!(slice instanceof Array)) {
          binBoundaries.addBinBoundary(slice);
          continue;
        }
        switch (slice[0]) {
          case HistogramBinBoundaries.SLICE_TYPE.LINEAR:
            binBoundaries.addLinearBins(slice[1], slice[2]);
            break;

          case HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL:
            binBoundaries.addExponentialBins(slice[1], slice[2]);
            break;

          default:
            throw new Error('Unrecognized HistogramBinBoundaries slice type');
        }
      }
      HISTOGRAM_BIN_BOUNDARIES_CACHE.set(cacheKey, binBoundaries);
      return binBoundaries;
    }

    /**
     * Yield Ranges of adjacent boundaries.
     */
    *binRanges() {
      if (this.boundaries_ === undefined) {
        this.build_();
      }
      for (var i = 0; i < this.boundaries_.length - 1; ++i) {
        yield tr.b.Range.fromExplicitRange(this.boundaries_[i], this.boundaries_[i + 1]);
      }
    }

    build_() {
      if (typeof this.builder_[0] !== 'number') {
        throw new Error('Invalid start of builder_');
      }
      this.boundaries_ = [this.builder_[0]];

      for (var slice of this.builder_.slice(1)) {
        if (!(slice instanceof Array)) {
          this.boundaries_.push(slice);
          continue;
        }
        var nextMaxBinBoundary = slice[1];
        var binCount = slice[2];
        var curMaxBinBoundary = this.boundaries_[this.boundaries_.length - 1];

        switch (slice[0]) {
          case HistogramBinBoundaries.SLICE_TYPE.LINEAR:
            var binWidth = (nextMaxBinBoundary - curMaxBinBoundary) / binCount;
            for (var i = 1; i < binCount; i++) {
              var boundary = curMaxBinBoundary + i * binWidth;
              this.boundaries_.push(boundary);
            }
            break;

          case HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL:
            var binExponentWidth = Math.log(nextMaxBinBoundary / curMaxBinBoundary) / binCount;
            for (var i = 1; i < binCount; i++) {
              var boundary = curMaxBinBoundary * Math.exp(i * binExponentWidth);
              this.boundaries_.push(boundary);
            }
            break;

          default:
            throw new Error('Unrecognized HistogramBinBoundaries slice type');
        }
        this.boundaries_.push(nextMaxBinBoundary);
      }
    }

    /**
     * Add a bin boundary |nextMaxBinBoundary| to the builder.
     *
     * This operation effectively corresponds to appending a new central bin
     * with the range [this.range.max, nextMaxBinBoundary].
     *
     * @param {number} nextMaxBinBoundary The added bin boundary (must be
     *     greater than |this.maxMinBoundary|).
     */
    addBinBoundary(nextMaxBinBoundary) {
      if (nextMaxBinBoundary <= this.range.max) {
        throw new Error('The added max bin boundary must be larger than ' + 'the current max boundary');
      }

      // If boundaries_ had been built, then clear them.
      this.boundaries_ = undefined;

      this.builder_.push(nextMaxBinBoundary);
      this.range.addValue(nextMaxBinBoundary);
      return this;
    }

    /**
     * Add |binCount| linearly scaled bin boundaries up to |nextMaxBinBoundary|
     * to the builder.
     *
     * This operation corresponds to appending |binCount| central bins of
     * constant range width
     * W = ((|nextMaxBinBoundary| - |this.range.max|) / |binCount|)
     * with the following ranges:
     *
     *   [|this.maxMinBoundary|, |this.maxMinBoundary| + W]
     *   [|this.maxMinBoundary| + W, |this.maxMinBoundary| + 2W]
     *   [|this.maxMinBoundary| + 2W, |this.maxMinBoundary| + 3W]
     *   ...
     *   [|this.maxMinBoundary| + (|binCount| - 2) * W,
     *    |this.maxMinBoundary| + (|binCount| - 2) * W]
     *   [|this.maxMinBoundary| + (|binCount| - 1) * W,
     *    |nextMaxBinBoundary|]
     *
     * @param {number} nextBinBoundary The last added bin boundary (must be
     *     greater than |this.maxMinBoundary|).
     * @param {number} binCount Number of bins to be added (must be positive).
     */
    addLinearBins(nextMaxBinBoundary, binCount) {
      if (binCount <= 0) throw new Error('Bin count must be positive');

      if (nextMaxBinBoundary <= this.range.max) {
        throw new Error('The new max bin boundary must be greater than ' + 'the previous max bin boundary');
      }

      // If boundaries_ had been built, then clear them.
      this.boundaries_ = undefined;

      this.builder_.push([HistogramBinBoundaries.SLICE_TYPE.LINEAR, nextMaxBinBoundary, binCount]);
      this.range.addValue(nextMaxBinBoundary);
      return this;
    }

    /**
     * Add |binCount| exponentially scaled bin boundaries up to
     * |nextMaxBinBoundary| to the builder.
     *
     * This operation corresponds to appending |binCount| central bins with
     * a constant difference between the logarithms of their range min and max
     * D = ((ln(|nextMaxBinBoundary|) - ln(|this.range.max|)) / |binCount|)
     * with the following ranges:
     *
     *   [|this.maxMinBoundary|, |this.maxMinBoundary| * exp(D)]
     *   [|this.maxMinBoundary| * exp(D), |this.maxMinBoundary| * exp(2D)]
     *   [|this.maxMinBoundary| * exp(2D), |this.maxMinBoundary| * exp(3D)]
     *   ...
     *   [|this.maxMinBoundary| * exp((|binCount| - 2) * D),
     *    |this.maxMinBoundary| * exp((|binCount| - 2) * D)]
     *   [|this.maxMinBoundary| * exp((|binCount| - 1) * D),
     *    |nextMaxBinBoundary|]
     *
     * This method requires that the current max bin boundary is positive.
     *
     * @param {number} nextBinBoundary The last added bin boundary (must be
     *     greater than |this.maxMinBoundary|).
     * @param {number} binCount Number of bins to be added (must be positive).
     */
    addExponentialBins(nextMaxBinBoundary, binCount) {
      if (binCount <= 0) {
        throw new Error('Bin count must be positive');
      }
      if (this.range.max <= 0) {
        throw new Error('Current max bin boundary must be positive');
      }
      if (this.range.max >= nextMaxBinBoundary) {
        throw new Error('The last added max boundary must be greater than ' + 'the current max boundary boundary');
      }

      // If boundaries_ had been built, then clear them.
      this.boundaries_ = undefined;

      this.builder_.push([HistogramBinBoundaries.SLICE_TYPE.EXPONENTIAL, nextMaxBinBoundary, binCount]);
      this.range.addValue(nextMaxBinBoundary);
      return this;
    }
  }

  HistogramBinBoundaries.SLICE_TYPE = {
    LINEAR: 0,
    EXPONENTIAL: 1
  };

  DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.timeDurationInMs.unitName, HistogramBinBoundaries.createExponential(1e-3, 1e6, 1e2));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.timeStampInMs.unitName, HistogramBinBoundaries.createLinear(0, 1e10, 1e3));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.normalizedPercentage.unitName, HistogramBinBoundaries.createLinear(0, 1.0, 20));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.sizeInBytes.unitName, HistogramBinBoundaries.createExponential(1, 1e12, 1e2));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.energyInJoules.unitName, HistogramBinBoundaries.createExponential(1e-3, 1e3, 50));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.powerInWatts.unitName, HistogramBinBoundaries.createExponential(1e-3, 1, 50));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.unitlessNumber.unitName, HistogramBinBoundaries.createExponential(1e-3, 1e3, 50));

  DEFAULT_BOUNDARIES_FOR_UNIT.set(tr.b.Unit.byName.count.unitName, HistogramBinBoundaries.createExponential(1, 1e3, 20));

  return {
    Histogram: Histogram,
    HistogramBinBoundaries: HistogramBinBoundaries
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41,"../base/range.js":47,"../base/running_statistics.js":50,"../base/sorted_array_utils.js":52,"../base/statistics.js":53,"../base/unit.js":57,"./diagnostics/diagnostic_map.js":179,"./numeric.js":190}],190:[function(require,module,exports){
(function (global){
"use strict";
/**
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
**/

require("../base/iteration_helpers.js");
require("../base/unit.js");

'use strict';

global.tr.exportTo('tr.v', function () {
  class NumericBase {
    constructor(unit) {
      if (!(unit instanceof tr.b.Unit)) throw new Error('Expected provided unit to be instance of Unit');

      this.unit = unit;
    }

    asDict() {
      var d = {
        unit: this.unit.asJSON()
      };

      this.asDictInto_(d);
      return d;
    }

    static fromDict(d) {
      if (d.type === 'scalar') return ScalarNumeric.fromDict(d);

      throw new Error('Not implemented');
    }
  }

  class ScalarNumeric extends NumericBase {
    constructor(unit, value) {
      if (!(unit instanceof tr.b.Unit)) throw new Error('Expected Unit');

      if (!(typeof value == 'number')) throw new Error('Expected value to be number');

      super(unit);
      this.value = value;
    }

    asDictInto_(d) {
      d.type = 'scalar';

      // Infinity and NaN are left out of JSON for security reasons that do not
      // apply to our use cases.
      if (this.value === Infinity) d.value = 'Infinity';else if (this.value === -Infinity) d.value = '-Infinity';else if (isNaN(this.value)) d.value = 'NaN';else d.value = this.value;
    }

    toString() {
      return this.unit.format(this.value);
    }

    static fromDict(d) {
      // Infinity and NaN are left out of JSON for security reasons that do not
      // apply to our use cases.
      if (typeof d.value === 'string') {
        if (d.value === '-Infinity') {
          d.value = -Infinity;
        } else if (d.value === 'Infinity') {
          d.value = Infinity;
        } else if (d.value === 'NaN') {
          d.value = NaN;
        }
      }

      return new ScalarNumeric(tr.b.Unit.fromJSON(d.unit), d.value);
    }
  }

  return {
    NumericBase: NumericBase,
    ScalarNumeric: ScalarNumeric
  };
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../base/iteration_helpers.js":41,"../base/unit.js":57}],191:[function(require,module,exports){
/**
 * @license
 * Copyright 2016 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

const ExtensionProtocol = require('../../../lighthouse-core/gather/drivers/extension');
const RawProtocol = require('../../../lighthouse-core/gather/drivers/raw');
const Runner = require('../../../lighthouse-core/runner');
const Config = require('../../../lighthouse-core/config/config');
const defaultConfig = require('../../../lighthouse-core/config/default.json');
const log = require('../../../lighthouse-core/lib/log');

const STORAGE_KEY = 'lighthouse_audits';
const _flatten = arr => [].concat.apply([], arr);

window.createPageAndPopulate = function(results) {
  const tabURL = chrome.extension.getURL('/pages/report.html');
  chrome.tabs.create({url: tabURL}, tab => {
    // Results will be lost when using sendMessage without waiting for the
    // receiving side to load. Once it loads, we get a message -
    // ready=true. Respond to this message with the results.
    chrome.runtime.onMessage.addListener((message, sender, respond) => {
      if (message && message.ready && sender.tab.id === tab.id) {
        return respond(results);
      }
    });
  });
};

/**
 * @param {!Connection} connection
 * @param {string} url
 * @param {!Object} options Lighthouse options.
 * @param {!Array<string>} requestedAudits Names of audits to run.
 * @return {!Promise}
 */
window.runLighthouseForConnection = function(connection, url, options, requestedAudits) {
  // Always start with a freshly parsed default config.
  const runConfig = JSON.parse(JSON.stringify(defaultConfig));

  // Filter out audits not requested.
  requestedAudits = new Set(requestedAudits);
  runConfig.audits = runConfig.audits.filter(audit => requestedAudits.has(audit));
  const config = new Config(runConfig);

  // Add url and config to fresh options object.
  const runOptions = Object.assign({}, options, {url, config});

  // Run Lighthouse.
  return Runner.run(connection, runOptions);
};

/**
 * @param {!Object} options Lighthouse options.
 * @param {!Array<string>} requestedAudits Names of audits to run.
 * @return {!Promise}
 */
window.runLighthouseInExtension = function(options, requestedAudits) {
  // Default to 'info' logging level.
  log.setLevel('info');
  const connection = new ExtensionProtocol();
  return connection.getCurrentTabURL()
    .then(url => window.runLighthouseForConnection(connection, url, options, requestedAudits))
    .then(results => window.createPageAndPopulate(results));
};

/**
 * @param {!RawProtocol.Port} port
 * @param {string} url
 * @param {!Object} options Lighthouse options.
 * @param {!Array<string>} requestedAudits Names of audits to run.
 * @return {!Promise}
 */
window.runLighthouseInWorker = function(port, url, options, requestedAudits) {
  // Default to 'info' logging level.
  log.setLevel('info');
  const connection = new RawProtocol(port);
  return window.runLighthouseForConnection(connection, url, options, requestedAudits);
};

/**
 * Returns list of aggregation categories (each with a list of its constituent
 * audits) from the default config.
 * @return {!Array<{name: string, audits: !Array<string>}>}
 */
window.getDefaultAggregations = function() {
  return _flatten(
    defaultConfig.aggregations.map(aggregation => {
      if (aggregation.items.length === 1) {
        return {
          name: aggregation.name,
          audits: aggregation.items[0].audits,
        };
      }

      return aggregation.items;
    })
  ).map(aggregation => {
    return {
      name: aggregation.name,
      audits: Object.keys(aggregation.audits)
    };
  });
};

/**
 * Save currently selected set of aggregation categories to local storage.
 * @param {!Array<{name: string, audits: !Array<string>}>} selectedAggregations
 */
window.saveSelectedAggregations = function(selectedAggregations) {
  const storage = {
    [STORAGE_KEY]: {}
  };

  window.getDefaultAggregations().forEach(audit => {
    const selected = selectedAggregations.indexOf(audit.name) > -1;
    storage[STORAGE_KEY][audit.name] = selected;
  });

  chrome.storage.local.set(storage);
};

/**
 * Load selected aggregation categories from local storage.
 * @return {!Promise<!Object<boolean>>}
 */
window.loadSelectedAggregations = function() {
  return new Promise(resolve => {
    chrome.storage.local.get(STORAGE_KEY, result => {
      // Start with list of all default aggregations set to true so list is
      // always up to date.
      const defaultAggregations = {};
      window.getDefaultAggregations().forEach(aggregation => {
        defaultAggregations[aggregation.name] = true;
      });

      // Load saved aggregation selections.
      const savedSelections = result[STORAGE_KEY];

      // Overwrite defaults with any saved aggregation selections.
      resolve(
        Object.assign(defaultAggregations, savedSelections)
      );
    });
  });
};

window.listenForStatus = function(callback) {
  log.events.addListener('status', callback);
};

if (window.chrome && chrome.runtime) {
  chrome.runtime.onInstalled.addListener(details => {
    if (details.previousVersion) {
      console.log('previousVersion', details.previousVersion);
    }
  });
}

},{"../../../lighthouse-core/config/config":2,"../../../lighthouse-core/config/default.json":3,"../../../lighthouse-core/gather/drivers/extension":14,"../../../lighthouse-core/gather/drivers/raw":15,"../../../lighthouse-core/lib/log":21,"../../../lighthouse-core/runner":27}],192:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],193:[function(require,module,exports){

},{}],194:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"base64-js":192,"ieee754":196,"isarray":197}],195:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],196:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],197:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],198:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":199}],199:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],200:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],201:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],202:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],203:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":201,"./encode":202}],204:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":205,"punycode":200,"querystring":203}],205:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],206:[function(require,module,exports){
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;

/**
 * @constructor
 */
WebInspector.TempFile = function()
{
    this._fileEntry = null;
    this._writer = null;
}

/**
 * @param {string} dirPath
 * @param {string} name
 * @return {!Promise.<!WebInspector.TempFile>}
 */
WebInspector.TempFile.create = function(dirPath, name)
{
    var file = new WebInspector.TempFile();

    function requestTempFileSystem()
    {
        return new Promise(window.requestFileSystem.bind(window, window.TEMPORARY, 10));
    }

    /**
     * @param {!FileSystem} fs
     */
    function getDirectoryEntry(fs)
    {
        return new Promise(fs.root.getDirectory.bind(fs.root, dirPath, { create: true }));
    }

    /**
     * @param {!DirectoryEntry} dir
     */
    function getFileEntry(dir)
    {
        return new Promise(dir.getFile.bind(dir, name, { create: true }));
    }

    /**
     * @param {!FileEntry} fileEntry
     */
    function createFileWriter(fileEntry)
    {
        file._fileEntry = fileEntry;
        return new Promise(fileEntry.createWriter.bind(fileEntry));
    }

    /**
     * @param {!FileWriter} writer
     */
    function truncateFile(writer)
    {
        if (!writer.length) {
            file._writer = writer;
            return Promise.resolve(file);
        }

        /**
         * @param {function(?)} fulfill
         * @param {function(*)} reject
         */
        function truncate(fulfill, reject)
        {
            writer.onwriteend = fulfill;
            writer.onerror = reject;
            writer.truncate(0);
        }

        function didTruncate()
        {
            file._writer = writer;
            writer.onwriteend = null;
            writer.onerror = null;
            return Promise.resolve(file);
        }

        function onTruncateError(e)
        {
            writer.onwriteend = null;
            writer.onerror = null;
            throw e;
        }

        return new Promise(truncate).then(didTruncate, onTruncateError);
    }

    return WebInspector.TempFile.ensureTempStorageCleared()
        .then(requestTempFileSystem)
        .then(getDirectoryEntry)
        .then(getFileEntry)
        .then(createFileWriter)
        .then(truncateFile);
}

WebInspector.TempFile.prototype = {
    /**
     * @param {!Array.<string>} strings
     * @param {function(number)} callback
     */
    write: function(strings, callback)
    {
        var blob = new Blob(strings, {type: "text/plain"});
        this._writer.onerror = function(e)
        {
            WebInspector.console.error("Failed to write into a temp file: " + e.target.error.message);
            callback(-1);
        }
        this._writer.onwriteend = function(e)
        {
            callback(e.target.length);
        }
        this._writer.write(blob);
    },

    finishWriting: function()
    {
        this._writer = null;
    },

    /**
     * @param {function(?string)} callback
     */
    read: function(callback)
    {
        this.readRange(undefined, undefined, callback);
    },

    /**
     * @param {number|undefined} startOffset
     * @param {number|undefined} endOffset
     * @param {function(?string)} callback
     */
    readRange: function(startOffset, endOffset, callback)
    {
        /**
         * @param {!Blob} file
         */
        function didGetFile(file)
        {
            var reader = new FileReader();

            if (typeof startOffset === "number" || typeof endOffset === "number")
                file = file.slice(/** @type {number} */ (startOffset), /** @type {number} */ (endOffset));
            /**
             * @this {FileReader}
             */
            reader.onloadend = function(e)
            {
                callback(/** @type {?string} */ (this.result));
            };
            reader.onerror = function(error)
            {
                WebInspector.console.error("Failed to read from temp file: " + error.message);
            };
            reader.readAsText(file);
        }
        function didFailToGetFile(error)
        {
            WebInspector.console.error("Failed to load temp file: " + error.message);
            callback(null);
        }
        this._fileEntry.file(didGetFile, didFailToGetFile);
    },

    /**
     * @param {!WebInspector.OutputStream} outputStream
     * @param {!WebInspector.OutputStreamDelegate} delegate
     */
    copyToOutputStream: function(outputStream, delegate)
    {
        /**
         * @param {!File} file
         */
        function didGetFile(file)
        {
            var reader = new WebInspector.ChunkedFileReader(file, 10 * 1000 * 1000, delegate);
            reader.start(outputStream);
        }

        function didFailToGetFile(error)
        {
            WebInspector.console.error("Failed to load temp file: " + error.message);
            outputStream.close();
        }

        this._fileEntry.file(didGetFile, didFailToGetFile);
    },

    remove: function()
    {
        if (this._fileEntry)
            this._fileEntry.remove(function() {});
    }
}

/**
 * @constructor
 * @param {string} dirPath
 * @param {string} name
 */
WebInspector.DeferredTempFile = function(dirPath, name)
{
    /** @type {!Array.<!{strings: !Array.<string>, callback: ?function(number)}>} */
    this._chunks = [];
    this._tempFile = null;
    this._isWriting = false;
    this._finishCallback = null;
    this._finishedWriting = false;
    this._callsPendingOpen = [];
    this._pendingReads = [];
    WebInspector.TempFile.create(dirPath, name)
        .then(this._didCreateTempFile.bind(this), this._failedToCreateTempFile.bind(this));
}

WebInspector.DeferredTempFile.prototype = {
    /**
     * @param {!Array.<string>} strings
     * @param {function(number)=} callback
     */
    write: function(strings, callback)
    {
        if (this._finishCallback)
            throw new Error("No writes are allowed after close.");
        this._chunks.push({strings: strings, callback: callback || null});
        if (this._tempFile && !this._isWriting)
            this._writeNextChunk();
    },

    /**
     * @param {function(?WebInspector.TempFile)} callback
     */
    finishWriting: function(callback)
    {
        this._finishCallback = callback;
        if (this._finishedWriting)
            callback(this._tempFile);
        else if (!this._isWriting && !this._chunks.length)
            this._notifyFinished();
    },

    /**
     * @param {*} e
     */
    _failedToCreateTempFile: function(e)
    {
        WebInspector.console.error("Failed to create temp file " + e.code + " : " + e.message);
        this._notifyFinished();
    },

    /**
     * @param {!WebInspector.TempFile} tempFile
     */
    _didCreateTempFile: function(tempFile)
    {
        this._tempFile = tempFile;
        var callsPendingOpen = this._callsPendingOpen;
        this._callsPendingOpen = null;
        for (var i = 0; i < callsPendingOpen.length; ++i)
            callsPendingOpen[i]();
        if (this._chunks.length)
            this._writeNextChunk();
    },

    _writeNextChunk: function()
    {
        // File was deleted while create or write was in-flight.
        if (!this._tempFile)
            return;
        var chunk = this._chunks.shift();
        this._isWriting = true;
        this._tempFile.write(/** @type {!Array.<string>} */(chunk.strings), this._didWriteChunk.bind(this, chunk.callback));
    },

    /**
     * @param {?function(number)} callback
     * @param {number} size
     */
    _didWriteChunk: function(callback, size)
    {
        this._isWriting = false;
        if (size === -1) {
            this._tempFile = null;
            this._notifyFinished();
            return;
        }
        if (callback)
            callback(size);
        if (this._chunks.length)
            this._writeNextChunk();
        else if (this._finishCallback)
            this._notifyFinished();
    },

    _notifyFinished: function()
    {
        this._finishedWriting = true;
        if (this._tempFile)
            this._tempFile.finishWriting();
        var chunks = this._chunks;
        this._chunks = [];
        for (var i = 0; i < chunks.length; ++i) {
            if (chunks[i].callback)
                chunks[i].callback(-1);
        }
        if (this._finishCallback)
            this._finishCallback(this._tempFile);
        var pendingReads = this._pendingReads;
        this._pendingReads = [];
        for (var i = 0; i < pendingReads.length; ++i)
            pendingReads[i]();
    },

    /**
     * @param {number|undefined} startOffset
     * @param {number|undefined} endOffset
     * @param {function(string?)} callback
     */
    readRange: function(startOffset, endOffset, callback)
    {
        if (!this._finishedWriting) {
            this._pendingReads.push(this.readRange.bind(this, startOffset, endOffset, callback));
            return;
        }
        if (!this._tempFile) {
            callback(null);
            return;
        }
        this._tempFile.readRange(startOffset, endOffset, callback);
    },

    /**
     * @param {!WebInspector.OutputStream} outputStream
     * @param {!WebInspector.OutputStreamDelegate} delegate
     */
    copyToOutputStream: function(outputStream, delegate)
    {
        if (!this._finishedWriting) {
            this._pendingReads.push(this.copyToOutputStream.bind(this, outputStream, delegate));
            return;
        }
        if (this._tempFile)
            this._tempFile.copyToOutputStream(outputStream, delegate);
    },

    remove: function()
    {
        if (this._callsPendingOpen) {
            this._callsPendingOpen.push(this.remove.bind(this));
            return;
        }
        if (this._tempFile)
            this._tempFile.remove();
        this._tempFile = null;
    }
}

/**
 * @param {function(?)} fulfill
 * @param {function(*)} reject
 */
WebInspector.TempFile._clearTempStorage = function(fulfill, reject)
{
    /**
     * @param {!Event} event
     */
    function handleError(event)
    {
        WebInspector.console.error(WebInspector.UIString("Failed to clear temp storage: %s", event.data));
        reject(event.data);
    }

    /**
     * @param {!Event} event
     */
    function handleMessage(event)
    {
        if (event.data.type === "tempStorageCleared") {
            if (event.data.error)
                WebInspector.console.error(event.data.error);
            else
                fulfill(undefined);
            return;
        }
        reject(event.data);
    }

    try {
        var worker = new WebInspector.Worker("temp_storage_shared_worker", "TempStorageCleaner");
        worker.onerror = handleError;
        worker.onmessage = handleMessage;
    } catch (e) {
        if (e.name === "URLMismatchError")
            console.log("Shared worker wasn't started due to url difference. " + e);
        else
            throw e;
    }
}

/**
 * @return {!Promise.<undefined>}
 */
WebInspector.TempFile.ensureTempStorageCleared = function()
{
    if (!WebInspector.TempFile._storageCleanerPromise)
        WebInspector.TempFile._storageCleanerPromise = new Promise(WebInspector.TempFile._clearTempStorage);
    return WebInspector.TempFile._storageCleanerPromise;
}

/**
 * @constructor
 * @implements {WebInspector.BackingStorage}
 * @param {string} dirName
 */
WebInspector.TempFileBackingStorage = function(dirName)
{
    this._dirName = dirName;
    this.reset();
}

/**
 * @typedef {{
 *      string: ?string,
 *      startOffset: number,
 *      endOffset: number
 * }}
 */
WebInspector.TempFileBackingStorage.Chunk;

WebInspector.TempFileBackingStorage.prototype = {
    /**
     * @override
     * @param {string} string
     */
    appendString: function(string)
    {
        this._strings.push(string);
        this._stringsLength += string.length;
        var flushStringLength = 10 * 1024 * 1024;
        if (this._stringsLength > flushStringLength)
            this._flush(false);
    },

    /**
     * @override
     * @param {string} string
     * @return {function():!Promise.<?string>}
     */
    appendAccessibleString: function(string)
    {
        this._flush(false);
        this._strings.push(string);
        var chunk = /** @type {!WebInspector.TempFileBackingStorage.Chunk} */ (this._flush(true));

        /**
         * @param {!WebInspector.TempFileBackingStorage.Chunk} chunk
         * @param {!WebInspector.DeferredTempFile} file
         * @return {!Promise.<?string>}
         */
        function readString(chunk, file)
        {
            if (chunk.string)
                return /** @type {!Promise.<?string>} */ (Promise.resolve(chunk.string));

            console.assert(chunk.endOffset);
            if (!chunk.endOffset)
                return Promise.reject("Nor string nor offset to the string in the file were found.");

            /**
             * @param {function(?string)} fulfill
             * @param {function(*)} reject
             */
            function readRange(fulfill, reject)
            {
                // FIXME: call reject for null strings.
                file.readRange(chunk.startOffset, chunk.endOffset, fulfill);
            }

            return new Promise(readRange);
        }

        return readString.bind(null, chunk, this._file);
    },

    /**
     * @param {boolean} createChunk
     * @return {?WebInspector.TempFileBackingStorage.Chunk}
     */
    _flush: function(createChunk)
    {
        if (!this._strings.length)
            return null;

        var chunk = null;
        if (createChunk) {
            console.assert(this._strings.length === 1);
            chunk = {
                string: this._strings[0],
                startOffset: 0,
                endOffset: 0
            };
        }

        /**
         * @this {WebInspector.TempFileBackingStorage}
         * @param {?WebInspector.TempFileBackingStorage.Chunk} chunk
         * @param {number} fileSize
         */
        function didWrite(chunk, fileSize)
        {
            if (fileSize === -1)
                return;
            if (chunk) {
                chunk.startOffset = this._fileSize;
                chunk.endOffset = fileSize;
                chunk.string = null;
            }
            this._fileSize = fileSize;
        }

        this._file.write(this._strings, didWrite.bind(this, chunk));
        this._strings = [];
        this._stringsLength = 0;
        return chunk;
    },

    /**
     * @override
     */
    finishWriting: function()
    {
        this._flush(false);
        this._file.finishWriting(function() {});
    },

    /**
     * @override
     */
    reset: function()
    {
        if (this._file)
            this._file.remove();
        this._file = new WebInspector.DeferredTempFile(this._dirName, String(Date.now()));
        /**
         * @type {!Array.<string>}
         */
        this._strings = [];
        this._stringsLength = 0;
        this._fileSize = 0;
    },

    /**
     * @param {!WebInspector.OutputStream} outputStream
     * @param {!WebInspector.OutputStreamDelegate} delegate
     */
    writeToStream: function(outputStream, delegate)
    {
        this._file.copyToOutputStream(outputStream, delegate);
    }
}

},{}],207:[function(require,module,exports){
/*
 * Copyright (C) 2009 Apple Inc.  All rights reserved.
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @param {!Array.<number>} rgba
 * @param {!WebInspector.Color.Format} format
 * @param {string=} originalText
 * @constructor
 */
WebInspector.Color = function(rgba, format, originalText)
{
    this._rgba = rgba;
    this._originalText = originalText || null;
    this._originalTextIsValid = !!this._originalText;
    this._format = format;
    if (typeof this._rgba[3] === "undefined")
        this._rgba[3] = 1;

    for (var i = 0; i < 4; ++i) {
        if (this._rgba[i] < 0) {
            this._rgba[i] = 0;
            this._originalTextIsValid = false;
        }
        if (this._rgba[i] > 1) {
            this._rgba[i] = 1;
            this._originalTextIsValid = false;
        }
    }
}

/** @type {!RegExp} */
WebInspector.Color.Regex = /((?:rgb|hsl)a?\([^)]+\)|#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}|\b[a-zA-Z]+\b(?!-))/g;

/**
 * @enum {string}
 */
WebInspector.Color.Format = {
    Original: "original",
    Nickname: "nickname",
    HEX: "hex",
    ShortHEX: "shorthex",
    RGB: "rgb",
    RGBA: "rgba",
    HSL: "hsl",
    HSLA: "hsla"
}

/**
 * @param {string} text
 * @return {?WebInspector.Color}
 */
WebInspector.Color.parse = function(text)
{
    // Simple - #hex, rgb(), nickname, hsl()
    var value = text.toLowerCase().replace(/\s+/g, "");
    var simple = /^(?:#([0-9a-f]{3}|[0-9a-f]{6})|rgb\(((?:-?\d+%?,){2}-?\d+%?)\)|(\w+)|hsl\((-?\d+\.?\d*(?:,-?\d+\.?\d*%){2})\))$/i;
    var match = value.match(simple);
    if (match) {
        if (match[1]) { // hex
            var hex = match[1].toLowerCase();
            var format;
            if (hex.length === 3) {
                format = WebInspector.Color.Format.ShortHEX;
                hex = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);
            } else
                format = WebInspector.Color.Format.HEX;
            var r = parseInt(hex.substring(0,2), 16);
            var g = parseInt(hex.substring(2,4), 16);
            var b = parseInt(hex.substring(4,6), 16);
            return new WebInspector.Color([r / 255, g / 255, b / 255, 1], format, text);
        }

        if (match[2]) { // rgb
            var rgbString = match[2].split(/\s*,\s*/);
            var rgba = [ WebInspector.Color._parseRgbNumeric(rgbString[0]),
                         WebInspector.Color._parseRgbNumeric(rgbString[1]),
                         WebInspector.Color._parseRgbNumeric(rgbString[2]), 1 ];
            return new WebInspector.Color(rgba, WebInspector.Color.Format.RGB, text);
        }

        if (match[3]) { // nickname
            var nickname = match[3].toLowerCase();
            if (nickname in WebInspector.Color.Nicknames) {
                var rgba = WebInspector.Color.Nicknames[nickname];
                var color = WebInspector.Color.fromRGBA(rgba);
                color._format = WebInspector.Color.Format.Nickname;
                color._originalText = text;
                return color;
            }
            return null;
        }

        if (match[4]) { // hsl
            var hslString = match[4].replace(/%/g, "").split(/\s*,\s*/);
            var hsla = [ WebInspector.Color._parseHueNumeric(hslString[0]),
                         WebInspector.Color._parseSatLightNumeric(hslString[1]),
                         WebInspector.Color._parseSatLightNumeric(hslString[2]), 1 ];
            var rgba = [];
            WebInspector.Color.hsl2rgb(hsla, rgba);
            return new WebInspector.Color(rgba, WebInspector.Color.Format.HSL, text);
        }

        return null;
    }

    // Advanced - rgba(), hsla()
    var advanced = /^(?:rgba\(((?:-?\d+%?,){3}-?(?:\d+|\d*\.\d+))\)|hsla\((-?(?:\d+|\d*\.\d+)(?:,-?(?:\d+|\d*\.\d+)*%){2},-?(?:\d+|\d*\.\d+))\))$/;
    match = value.match(advanced);
    if (match) {
        if (match[1]) { // rgba
            var rgbaString = match[1].split(/\s*,\s*/);
            var rgba = [ WebInspector.Color._parseRgbNumeric(rgbaString[0]),
                         WebInspector.Color._parseRgbNumeric(rgbaString[1]),
                         WebInspector.Color._parseRgbNumeric(rgbaString[2]),
                         WebInspector.Color._parseAlphaNumeric(rgbaString[3]) ];
            return new WebInspector.Color(rgba, WebInspector.Color.Format.RGBA, text);
        }

        if (match[2]) { // hsla
            var hslaString = match[2].replace(/%/g, "").split(/\s*,\s*/);
            var hsla = [ WebInspector.Color._parseHueNumeric(hslaString[0]),
                         WebInspector.Color._parseSatLightNumeric(hslaString[1]),
                         WebInspector.Color._parseSatLightNumeric(hslaString[2]),
                         WebInspector.Color._parseAlphaNumeric(hslaString[3]) ];
            var rgba = [];
            WebInspector.Color.hsl2rgb(hsla, rgba);
            return new WebInspector.Color(rgba, WebInspector.Color.Format.HSLA, text);
        }
    }

    return null;
}

/**
 * @param {!Array.<number>} rgba
 * @return {!WebInspector.Color}
 */
WebInspector.Color.fromRGBA = function(rgba)
{
    return new WebInspector.Color([rgba[0] / 255, rgba[1] / 255, rgba[2] / 255, rgba[3]], WebInspector.Color.Format.RGBA);
}

/**
 * @param {!Array.<number>} hsva
 * @return {!WebInspector.Color}
 */
WebInspector.Color.fromHSVA = function(hsva)
{
    var rgba = [];
    WebInspector.Color.hsva2rgba(hsva, rgba);
    return new WebInspector.Color(rgba, WebInspector.Color.Format.HSLA);
}

WebInspector.Color.prototype = {
    /**
     * @return {!WebInspector.Color.Format}
     */
    format: function()
    {
        return this._format;
    },

    /**
     * @return {!Array.<number>} HSLA with components within [0..1]
     */
    hsla: function()
    {
        if (this._hsla)
            return this._hsla;
        var r = this._rgba[0];
        var g = this._rgba[1];
        var b = this._rgba[2];
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var diff = max - min;
        var add = max + min;

        if (min === max)
            var h = 0;
        else if (r === max)
            var h = ((1 / 6 * (g - b) / diff) + 1) % 1;
        else if (g === max)
            var h = (1 / 6 * (b - r) / diff) + 1 / 3;
        else
            var h = (1 / 6 * (r - g) / diff) + 2 / 3;

        var l = 0.5 * add;

        if (l === 0)
            var s = 0;
        else if (l === 1)
            var s = 0;
        else if (l <= 0.5)
            var s = diff / add;
        else
            var s = diff / (2 - add);

        this._hsla = [h, s, l, this._rgba[3]];
        return this._hsla;
    },

    /**
     * @return {!Array.<number>}
     */
    canonicalHSLA: function()
    {
        var hsla = this.hsla();
        return [Math.round(hsla[0] * 360), Math.round(hsla[1] * 100), Math.round(hsla[2] * 100), hsla[3]];
    },

    /**
     * @return {!Array.<number>} HSVA with components within [0..1]
     */
    hsva: function()
    {
        var hsla = this.hsla();
        var h = hsla[0];
        var s = hsla[1];
        var l = hsla[2];

        s *= l < 0.5 ? l : 1 - l;
        return [h, s !== 0 ? 2 * s / (l + s) : 0, (l + s), hsla[3]];
    },

    /**
     * @return {boolean}
     */
    hasAlpha: function()
    {
        return this._rgba[3] !== 1;
    },

    /**
     * @return {boolean}
     */
    canBeShortHex: function()
    {
        if (this.hasAlpha())
            return false;
        for (var i = 0; i < 3; ++i) {
            var c = Math.round(this._rgba[i] * 255);
            if (c % 17)
                return false;
        }
        return true;
    },

    /**
     * @return {?string}
     */
    asString: function(format)
    {
        if (format === this._format && this._originalTextIsValid)
            return this._originalText;

        if (!format)
            format = this._format;

        /**
         * @param {number} value
         * @return {number}
         */
        function toRgbValue(value)
        {
            return Math.round(value * 255);
        }

        /**
         * @param {number} value
         * @return {string}
         */
        function toHexValue(value)
        {
            var hex = Math.round(value * 255).toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        }

        /**
         * @param {number} value
         * @return {string}
         */
        function toShortHexValue(value)
        {
            return (Math.round(value * 255) / 17).toString(16);
        }

        switch (format) {
        case WebInspector.Color.Format.Original:
            return this._originalText;
        case WebInspector.Color.Format.RGB:
            if (this.hasAlpha())
                return null;
            return String.sprintf("rgb(%d, %d, %d)", toRgbValue(this._rgba[0]), toRgbValue(this._rgba[1]), toRgbValue(this._rgba[2]));
        case WebInspector.Color.Format.RGBA:
            return String.sprintf("rgba(%d, %d, %d, %f)", toRgbValue(this._rgba[0]), toRgbValue(this._rgba[1]), toRgbValue(this._rgba[2]), this._rgba[3]);
        case WebInspector.Color.Format.HSL:
            if (this.hasAlpha())
                return null;
            var hsl = this.hsla();
            return String.sprintf("hsl(%d, %d%, %d%)", Math.round(hsl[0] * 360), Math.round(hsl[1] * 100), Math.round(hsl[2] * 100));
        case WebInspector.Color.Format.HSLA:
            var hsla = this.hsla();
            return String.sprintf("hsla(%d, %d%, %d%, %f)", Math.round(hsla[0] * 360), Math.round(hsla[1] * 100), Math.round(hsla[2] * 100), hsla[3]);
        case WebInspector.Color.Format.HEX:
            if (this.hasAlpha())
                return null;
            return String.sprintf("#%s%s%s", toHexValue(this._rgba[0]), toHexValue(this._rgba[1]), toHexValue(this._rgba[2])).toLowerCase();
        case WebInspector.Color.Format.ShortHEX:
            if (!this.canBeShortHex())
                return null;
            return String.sprintf("#%s%s%s", toShortHexValue(this._rgba[0]), toShortHexValue(this._rgba[1]), toShortHexValue(this._rgba[2])).toLowerCase();
        case WebInspector.Color.Format.Nickname:
            return this.nickname();
        }

        return this._originalText;
    },


    /**
     * @return {!Array<number>}
     */
    rgba: function()
    {
        return this._rgba.slice();
    },

    /**
     * @return {!Array.<number>}
     */
    canonicalRGBA: function()
    {
        var rgba = new Array(4);
        for (var i = 0; i < 3; ++i)
            rgba[i] = Math.round(this._rgba[i] * 255);
        rgba[3] = this._rgba[3];
        return rgba;
    },

    /**
     * @return {?string} nickname
     */
    nickname: function()
    {
        if (!WebInspector.Color._rgbaToNickname) {
            WebInspector.Color._rgbaToNickname = {};
            for (var nickname in WebInspector.Color.Nicknames) {
                var rgba = WebInspector.Color.Nicknames[nickname];
                if (rgba.length !== 4)
                    rgba = rgba.concat(1);
                WebInspector.Color._rgbaToNickname[rgba] = nickname;
            }
        }

        return WebInspector.Color._rgbaToNickname[this.canonicalRGBA()] || null;
    },

    /**
     * @return {!DOMAgent.RGBA}
     */
    toProtocolRGBA: function()
    {
        var rgba = this.canonicalRGBA();
        var result = { r: rgba[0], g: rgba[1], b: rgba[2] };
        if (rgba[3] !== 1)
            result.a = rgba[3];
        return result;
    },

    /**
     * @return {!WebInspector.Color}
     */
    invert: function()
    {
        var rgba = [];
        rgba[0] = 1 - this._rgba[0];
        rgba[1] = 1 - this._rgba[1];
        rgba[2] = 1 - this._rgba[2];
        rgba[3] = this._rgba[3];
        return new WebInspector.Color(rgba, WebInspector.Color.Format.RGBA);
    },

    /**
     * @param {number} alpha
     * @return {!WebInspector.Color}
     */
    setAlpha: function(alpha)
    {
        var rgba = this._rgba.slice();
        rgba[3] = alpha;
        return new WebInspector.Color(rgba, WebInspector.Color.Format.RGBA);
    }
}

/**
 * @param {string} value
 * return {number}
 */
WebInspector.Color._parseRgbNumeric = function(value)
{
    var parsed = parseInt(value, 10);
    if (value.indexOf("%") !== -1)
        parsed /= 100;
    else
        parsed /= 255;
    return parsed;
}

/**
 * @param {string} value
 * return {number}
 */
WebInspector.Color._parseHueNumeric = function(value)
{
    return isNaN(value) ? 0 : (parseFloat(value) / 360) % 1;
}

/**
 * @param {string} value
 * return {number}
 */
WebInspector.Color._parseSatLightNumeric = function(value)
{
    return Math.min(1, parseFloat(value) / 100);
}

/**
 * @param {string} value
 * return {number}
 */
WebInspector.Color._parseAlphaNumeric = function(value)
{
    return isNaN(value) ? 0 : parseFloat(value);
}

/**
 * @param {!Array.<number>} hsva
 * @param {!Array.<number>} out_hsla
 */
WebInspector.Color._hsva2hsla = function(hsva, out_hsla)
{
    var h = hsva[0];
    var s = hsva[1];
    var v = hsva[2];

    var t = (2 - s) * v;
    if (v === 0 || s === 0)
        s = 0;
    else
        s *= v / (t < 1 ? t : 2 - t);

    out_hsla[0] = h;
    out_hsla[1] = s;
    out_hsla[2] = t / 2;
    out_hsla[3] = hsva[3];
}

/**
 * @param {!Array.<number>} hsl
 * @param {!Array.<number>} out_rgb
 */
WebInspector.Color.hsl2rgb = function(hsl, out_rgb)
{
    var h = hsl[0];
    var s = hsl[1];
    var l = hsl[2];

    function hue2rgb(p, q, h)
    {
        if (h < 0)
            h += 1;
        else if (h > 1)
            h -= 1;

        if ((h * 6) < 1)
            return p + (q - p) * h * 6;
        else if ((h * 2) < 1)
            return q;
        else if ((h * 3) < 2)
            return p + (q - p) * ((2 / 3) - h) * 6;
        else
            return p;
    }

    if (s < 0)
        s = 0;

    if (l <= 0.5)
        var q = l * (1 + s);
    else
        var q = l + s - (l * s);

    var p = 2 * l - q;

    var tr = h + (1 / 3);
    var tg = h;
    var tb = h - (1 / 3);

    out_rgb[0] = hue2rgb(p, q, tr);
    out_rgb[1] = hue2rgb(p, q, tg);
    out_rgb[2] = hue2rgb(p, q, tb);
    out_rgb[3] = hsl[3];
}

/**
 * @param {!Array<number>} hsva
 * @param {!Array<number>} out_rgba
 */
WebInspector.Color.hsva2rgba = function(hsva, out_rgba)
{
    WebInspector.Color._hsva2hsla(hsva, WebInspector.Color.hsva2rgba._tmpHSLA);
    WebInspector.Color.hsl2rgb(WebInspector.Color.hsva2rgba._tmpHSLA, out_rgba);

    for (var i = 0; i < WebInspector.Color.hsva2rgba._tmpHSLA.length; i++)
        WebInspector.Color.hsva2rgba._tmpHSLA[i] = 0;
};

/** @type {!Array<number>} */
WebInspector.Color.hsva2rgba._tmpHSLA = [0, 0, 0, 0];


/**
 * Calculate the luminance of this color using the WCAG algorithm.
 * See http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
 * @param {!Array<number>} rgba
 * @return {number}
 */
WebInspector.Color.luminance = function(rgba)
{
    var rSRGB = rgba[0];
    var gSRGB = rgba[1];
    var bSRGB = rgba[2];

    var r = rSRGB <= 0.03928 ? rSRGB / 12.92 : Math.pow(((rSRGB + 0.055) / 1.055), 2.4);
    var g = gSRGB <= 0.03928 ? gSRGB / 12.92 : Math.pow(((gSRGB + 0.055) / 1.055), 2.4);
    var b = bSRGB <= 0.03928 ? bSRGB / 12.92 : Math.pow(((bSRGB + 0.055) / 1.055), 2.4);

    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

/**
 * Combine the two given color according to alpha blending.
 * @param {!Array<number>} fgRGBA
 * @param {!Array<number>} bgRGBA
 * @param {!Array<number>} out_blended
 */
WebInspector.Color.blendColors = function(fgRGBA, bgRGBA, out_blended)
{
    var alpha = fgRGBA[3];

    out_blended[0] = ((1 - alpha) * bgRGBA[0]) + (alpha * fgRGBA[0]);
    out_blended[1] = ((1 - alpha) * bgRGBA[1]) + (alpha * fgRGBA[1]);
    out_blended[2] = ((1 - alpha) * bgRGBA[2]) + (alpha * fgRGBA[2]);
    out_blended[3] = alpha + (bgRGBA[3] * (1 - alpha));
}

/**
 * Calculate the contrast ratio between a foreground and a background color.
 * Returns the ratio to 1, for example for two two colors with a contrast ratio of 21:1, this function will return 21.
 * See http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
 * @param {!Array<number>} fgRGBA
 * @param {!Array<number>} bgRGBA
 * @return {number}
 */
WebInspector.Color.calculateContrastRatio = function(fgRGBA, bgRGBA)
{
    WebInspector.Color.blendColors(fgRGBA, bgRGBA, WebInspector.Color.calculateContrastRatio._blendedFg);

    var fgLuminance = WebInspector.Color.luminance(WebInspector.Color.calculateContrastRatio._blendedFg);
    var bgLuminance = WebInspector.Color.luminance(bgRGBA);
    var contrastRatio = (Math.max(fgLuminance, bgLuminance) + 0.05) /
        (Math.min(fgLuminance, bgLuminance) + 0.05);

    for (var i = 0; i < WebInspector.Color.calculateContrastRatio._blendedFg.length; i++)
        WebInspector.Color.calculateContrastRatio._blendedFg[i] = 0;

    return contrastRatio;
}

WebInspector.Color.calculateContrastRatio._blendedFg = [0, 0, 0, 0];

/**
 * Compute a desired luminance given a given luminance and a desired contrast
 * ratio.
 * @param {number} luminance The given luminance.
 * @param {number} contrast The desired contrast ratio.
 * @param {boolean} lighter Whether the desired luminance is lighter or darker
 * than the given luminance. If no luminance can be found which meets this
 * requirement, a luminance which meets the inverse requirement will be
 * returned.
 * @return {number} The desired luminance.
 */
WebInspector.Color.desiredLuminance = function(luminance, contrast, lighter)
{
    function computeLuminance()
    {
        if (lighter)
            return (luminance + 0.05) * contrast - 0.05;
        else
            return (luminance + 0.05) / contrast - 0.05;
    }
    var desiredLuminance = computeLuminance();
    if (desiredLuminance < 0 || desiredLuminance > 1) {
        lighter = !lighter;
        desiredLuminance = computeLuminance();
    }
    return desiredLuminance;
};


WebInspector.Color.Nicknames = {
    "aliceblue":          [240,248,255],
    "antiquewhite":       [250,235,215],
    "aqua":               [0,255,255],
    "aquamarine":         [127,255,212],
    "azure":              [240,255,255],
    "beige":              [245,245,220],
    "bisque":             [255,228,196],
    "black":              [0,0,0],
    "blanchedalmond":     [255,235,205],
    "blue":               [0,0,255],
    "blueviolet":         [138,43,226],
    "brown":              [165,42,42],
    "burlywood":          [222,184,135],
    "cadetblue":          [95,158,160],
    "chartreuse":         [127,255,0],
    "chocolate":          [210,105,30],
    "coral":              [255,127,80],
    "cornflowerblue":     [100,149,237],
    "cornsilk":           [255,248,220],
    "crimson":            [237,20,61],
    "cyan":               [0,255,255],
    "darkblue":           [0,0,139],
    "darkcyan":           [0,139,139],
    "darkgoldenrod":      [184,134,11],
    "darkgray":           [169,169,169],
    "darkgrey":           [169,169,169],
    "darkgreen":          [0,100,0],
    "darkkhaki":          [189,183,107],
    "darkmagenta":        [139,0,139],
    "darkolivegreen":     [85,107,47],
    "darkorange":         [255,140,0],
    "darkorchid":         [153,50,204],
    "darkred":            [139,0,0],
    "darksalmon":         [233,150,122],
    "darkseagreen":       [143,188,143],
    "darkslateblue":      [72,61,139],
    "darkslategray":      [47,79,79],
    "darkslategrey":      [47,79,79],
    "darkturquoise":      [0,206,209],
    "darkviolet":         [148,0,211],
    "deeppink":           [255,20,147],
    "deepskyblue":        [0,191,255],
    "dimgray":            [105,105,105],
    "dimgrey":            [105,105,105],
    "dodgerblue":         [30,144,255],
    "firebrick":          [178,34,34],
    "floralwhite":        [255,250,240],
    "forestgreen":        [34,139,34],
    "fuchsia":            [255,0,255],
    "gainsboro":          [220,220,220],
    "ghostwhite":         [248,248,255],
    "gold":               [255,215,0],
    "goldenrod":          [218,165,32],
    "gray":               [128,128,128],
    "grey":               [128,128,128],
    "green":              [0,128,0],
    "greenyellow":        [173,255,47],
    "honeydew":           [240,255,240],
    "hotpink":            [255,105,180],
    "indianred":          [205,92,92],
    "indigo":             [75,0,130],
    "ivory":              [255,255,240],
    "khaki":              [240,230,140],
    "lavender":           [230,230,250],
    "lavenderblush":      [255,240,245],
    "lawngreen":          [124,252,0],
    "lemonchiffon":       [255,250,205],
    "lightblue":          [173,216,230],
    "lightcoral":         [240,128,128],
    "lightcyan":          [224,255,255],
    "lightgoldenrodyellow":[250,250,210],
    "lightgreen":         [144,238,144],
    "lightgray":          [211,211,211],
    "lightgrey":          [211,211,211],
    "lightpink":          [255,182,193],
    "lightsalmon":        [255,160,122],
    "lightseagreen":      [32,178,170],
    "lightskyblue":       [135,206,250],
    "lightslategray":     [119,136,153],
    "lightslategrey":     [119,136,153],
    "lightsteelblue":     [176,196,222],
    "lightyellow":        [255,255,224],
    "lime":               [0,255,0],
    "limegreen":          [50,205,50],
    "linen":              [250,240,230],
    "magenta":            [255,0,255],
    "maroon":             [128,0,0],
    "mediumaquamarine":   [102,205,170],
    "mediumblue":         [0,0,205],
    "mediumorchid":       [186,85,211],
    "mediumpurple":       [147,112,219],
    "mediumseagreen":     [60,179,113],
    "mediumslateblue":    [123,104,238],
    "mediumspringgreen":  [0,250,154],
    "mediumturquoise":    [72,209,204],
    "mediumvioletred":    [199,21,133],
    "midnightblue":       [25,25,112],
    "mintcream":          [245,255,250],
    "mistyrose":          [255,228,225],
    "moccasin":           [255,228,181],
    "navajowhite":        [255,222,173],
    "navy":               [0,0,128],
    "oldlace":            [253,245,230],
    "olive":              [128,128,0],
    "olivedrab":          [107,142,35],
    "orange":             [255,165,0],
    "orangered":          [255,69,0],
    "orchid":             [218,112,214],
    "palegoldenrod":      [238,232,170],
    "palegreen":          [152,251,152],
    "paleturquoise":      [175,238,238],
    "palevioletred":      [219,112,147],
    "papayawhip":         [255,239,213],
    "peachpuff":          [255,218,185],
    "peru":               [205,133,63],
    "pink":               [255,192,203],
    "plum":               [221,160,221],
    "powderblue":         [176,224,230],
    "purple":             [128,0,128],
    "rebeccapurple":      [102,51,153],
    "red":                [255,0,0],
    "rosybrown":          [188,143,143],
    "royalblue":          [65,105,225],
    "saddlebrown":        [139,69,19],
    "salmon":             [250,128,114],
    "sandybrown":         [244,164,96],
    "seagreen":           [46,139,87],
    "seashell":           [255,245,238],
    "sienna":             [160,82,45],
    "silver":             [192,192,192],
    "skyblue":            [135,206,235],
    "slateblue":          [106,90,205],
    "slategray":          [112,128,144],
    "slategrey":          [112,128,144],
    "snow":               [255,250,250],
    "springgreen":        [0,255,127],
    "steelblue":          [70,130,180],
    "tan":                [210,180,140],
    "teal":               [0,128,128],
    "thistle":            [216,191,216],
    "tomato":             [255,99,71],
    "turquoise":          [64,224,208],
    "violet":             [238,130,238],
    "wheat":              [245,222,179],
    "white":              [255,255,255],
    "whitesmoke":         [245,245,245],
    "yellow":             [255,255,0],
    "yellowgreen":        [154,205,50],
    "transparent":        [0, 0, 0, 0],
};

WebInspector.Color.PageHighlight = {
    Content: WebInspector.Color.fromRGBA([111, 168, 220, .66]),
    ContentLight: WebInspector.Color.fromRGBA([111, 168, 220, .5]),
    ContentOutline: WebInspector.Color.fromRGBA([9, 83, 148]),
    Padding: WebInspector.Color.fromRGBA([147, 196, 125, .55]),
    PaddingLight: WebInspector.Color.fromRGBA([147, 196, 125, .4]),
    Border: WebInspector.Color.fromRGBA([255, 229, 153, .66]),
    BorderLight: WebInspector.Color.fromRGBA([255, 229, 153, .5]),
    Margin: WebInspector.Color.fromRGBA([246, 178, 107, .66]),
    MarginLight: WebInspector.Color.fromRGBA([246, 178, 107, .5]),
    EventTarget: WebInspector.Color.fromRGBA([255, 196, 196, .66]),
    Shape: WebInspector.Color.fromRGBA([96, 82, 177, 0.8]),
    ShapeMargin: WebInspector.Color.fromRGBA([96, 82, 127, .6])
}

/**
 * @param {!WebInspector.Color} color
 * @return {!WebInspector.Color.Format}
 */
WebInspector.Color.detectColorFormat = function(color)
{
    const cf = WebInspector.Color.Format;
    var format;
    var formatSetting = WebInspector.moduleSetting("colorFormat").get();
    if (formatSetting === cf.Original)
        format = cf.Original;
    else if (formatSetting === cf.RGB)
        format = (color.hasAlpha() ? cf.RGBA : cf.RGB);
    else if (formatSetting === cf.HSL)
        format = (color.hasAlpha() ? cf.HSLA : cf.HSL);
    else if (!color.hasAlpha())
        format = (color.canBeShortHex() ? cf.ShortHEX : cf.HEX);
    else
        format = cf.RGBA;

    return format;
}

},{}],208:[function(require,module,exports){
/*
 * Copyright (C) 2008 Apple Inc. All Rights Reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @implements {WebInspector.EventTarget}
 */
WebInspector.Object = function() {
}

WebInspector.Object.prototype = {
    /**
     * @override
     * @param {string|symbol} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     * @return {!WebInspector.EventTarget.EventDescriptor}
     */
    addEventListener: function(eventType, listener, thisObject)
    {
        if (!listener)
            console.assert(false);

        if (!this._listeners)
            this._listeners = new Map();
        if (!this._listeners.has(eventType))
            this._listeners.set(eventType, []);
        this._listeners.get(eventType).push({ thisObject: thisObject, listener: listener });
        return new WebInspector.EventTarget.EventDescriptor(this, eventType, thisObject, listener);
    },

    /**
     * @override
     * @param {string|symbol} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeEventListener: function(eventType, listener, thisObject)
    {
        console.assert(listener);

        if (!this._listeners || !this._listeners.has(eventType))
            return;
        var listeners = this._listeners.get(eventType);
        for (var i = 0; i < listeners.length; ++i) {
            if (listeners[i].listener === listener && listeners[i].thisObject === thisObject)
                listeners.splice(i--, 1);
        }

        if (!listeners.length)
            this._listeners.delete(eventType);
    },

    /**
     * @override
     */
    removeAllListeners: function()
    {
        delete this._listeners;
    },

    /**
     * @override
     * @param {string|symbol} eventType
     * @return {boolean}
     */
    hasEventListeners: function(eventType)
    {
        return this._listeners && this._listeners.has(eventType);
    },

    /**
     * @override
     * @param {string|symbol} eventType
     * @param {*=} eventData
     * @return {boolean}
     */
    dispatchEventToListeners: function(eventType, eventData)
    {
        if (!this._listeners || !this._listeners.has(eventType))
            return false;

        var event = new WebInspector.Event(this, eventType, eventData);
        var listeners = this._listeners.get(eventType).slice(0);
        for (var i = 0; i < listeners.length; ++i) {
            listeners[i].listener.call(listeners[i].thisObject, event);
            if (event._stoppedPropagation)
                break;
        }

        return event.defaultPrevented;
    }
}

/**
 * @constructor
 * @param {!WebInspector.EventTarget} target
 * @param {string|symbol} type
 * @param {*=} data
 */
WebInspector.Event = function(target, type, data)
{
    this.target = target;
    this.type = type;
    this.data = data;
    this.defaultPrevented = false;
    this._stoppedPropagation = false;
}

WebInspector.Event.prototype = {
    stopPropagation: function()
    {
        this._stoppedPropagation = true;
    },

    preventDefault: function()
    {
        this.defaultPrevented = true;
    },

    /**
     * @param {boolean=} preventDefault
     */
    consume: function(preventDefault)
    {
        this.stopPropagation();
        if (preventDefault)
            this.preventDefault();
    }
}

/**
 * @interface
 */
WebInspector.EventTarget = function()
{
}

/**
 * @param {!Array<!WebInspector.EventTarget.EventDescriptor>} eventList
 */
WebInspector.EventTarget.removeEventListeners = function(eventList)
{
    for (var i = 0; i < eventList.length; ++i) {
        var eventInfo = eventList[i];
        eventInfo.eventTarget.removeEventListener(eventInfo.eventType, eventInfo.method, eventInfo.receiver);
    }
    // Do not hold references on unused event descriptors.
    eventList.splice(0, eventList.length);
}

WebInspector.EventTarget.prototype = {
    /**
     * @param {string|symbol} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     * @return {!WebInspector.EventTarget.EventDescriptor}
     */
    addEventListener: function(eventType, listener, thisObject) { },

    /**
     * @param {string|symbol} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeEventListener: function(eventType, listener, thisObject) { },

    removeAllListeners: function() { },

    /**
     * @param {string|symbol} eventType
     * @return {boolean}
     */
    hasEventListeners: function(eventType) { },

    /**
     * @param {string|symbol} eventType
     * @param {*=} eventData
     * @return {boolean}
     */
    dispatchEventToListeners: function(eventType, eventData) { },
}

/**
 * @constructor
 * @param {!WebInspector.EventTarget} eventTarget
 * @param {string|symbol} eventType
 * @param {(!Object|undefined)} receiver
 * @param {function(?):?} method
 */
WebInspector.EventTarget.EventDescriptor = function(eventTarget, eventType, receiver, method)
{
    this.eventTarget = eventTarget;
    this.eventType = eventType;
    this.receiver = receiver;
    this.method = method;
}

},{}],209:[function(require,module,exports){
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GOOGLE INC. AND ITS CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GOOGLE INC.
 * OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {string} url
 */
WebInspector.ParsedURL = function(url)
{
    this.isValid = false;
    this.url = url;
    this.scheme = "";
    this.host = "";
    this.port = "";
    this.path = "";
    this.queryParams = "";
    this.fragment = "";
    this.folderPathComponents = "";
    this.lastPathComponent = "";

    // RegExp groups:
    // 1 - scheme (using the RFC3986 grammar)
    // 2 - hostname
    // 3 - ?port
    // 4 - ?path
    // 5 - ?fragment
    var match = url.match(/^([A-Za-z][A-Za-z0-9+.-]*):\/\/([^\s\/:]*)(?::([\d]+))?(?:(\/[^#]*)(?:#(.*))?)?$/i);
    if (match) {
        this.isValid = true;
        this.scheme = match[1].toLowerCase();
        this.host = match[2];
        this.port = match[3];
        this.path = match[4] || "/";
        this.fragment = match[5];
    } else {
        if (this.url.startsWith("data:")) {
            this.scheme = "data";
            return;
        }
        if (this.url === "about:blank") {
            this.scheme = "about";
            return;
        }
        this.path = this.url;
    }

    // First cut the query params.
    var path = this.path;
    var indexOfQuery = path.indexOf("?");
    if (indexOfQuery !== -1) {
        this.queryParams = path.substring(indexOfQuery + 1);
        path = path.substring(0, indexOfQuery);
    }

    // Then take last path component.
    var lastSlashIndex = path.lastIndexOf("/");
    if (lastSlashIndex !== -1) {
        this.folderPathComponents = path.substring(0, lastSlashIndex);
        this.lastPathComponent = path.substring(lastSlashIndex + 1);
    } else
        this.lastPathComponent = path;
}

/**
 * @param {string} url
 * @return {!Array.<string>}
 */
WebInspector.ParsedURL.splitURLIntoPathComponents = function(url)
{
    if (url.startsWith("/"))
        url = "file://" + url;
    var parsedURL = new WebInspector.ParsedURL(url);
    var origin;
    var folderPath;
    var name;
    if (parsedURL.isValid) {
        origin = parsedURL.scheme + "://" + parsedURL.host;
        if (parsedURL.port)
            origin += ":" + parsedURL.port;
        folderPath = parsedURL.folderPathComponents;
        name = parsedURL.lastPathComponent;
        if (parsedURL.queryParams)
            name += "?" + parsedURL.queryParams;
    } else {
        origin = "";
        folderPath = "";
        name = url;
    }
    var result = [origin];
    var splittedPath = folderPath.split("/");
    for (var i = 1; i < splittedPath.length; ++i) {
        if (!splittedPath[i])
            continue;
        result.push(splittedPath[i]);
    }
    result.push(name);
    return result;
}

/**
 * @param {string} url
 * @return {string}
 */
WebInspector.ParsedURL.extractOrigin = function(url)
{
    var parsedURL = new WebInspector.ParsedURL(url);
    if (!parsedURL.isValid)
        return "";

    var origin = parsedURL.scheme + "://" + parsedURL.host;
    if (parsedURL.port)
        origin += ":" + parsedURL.port;
    return origin;
}

/**
 * @param {string} url
 * @return {string}
 */
WebInspector.ParsedURL.extractExtension = function(url)
{
    var lastIndexOfDot = url.lastIndexOf(".");
    var extension = lastIndexOfDot !== -1 ? url.substr(lastIndexOfDot + 1) : "";
    var indexOfQuestionMark = extension.indexOf("?");
    if (indexOfQuestionMark !== -1)
        extension = extension.substr(0, indexOfQuestionMark);
    return extension;
}

/**
 * @param {string} url
 * @return {string}
 */
WebInspector.ParsedURL.extractName = function(url)
{
    var index = url.lastIndexOf("/");
    return index !== -1 ? url.substr(index + 1) : url;
}

/**
 * @param {string} baseURL
 * @param {string} href
 * @return {?string}
 */
WebInspector.ParsedURL.completeURL = function(baseURL, href)
{
    if (href) {
        // Return special URLs as-is.
        var trimmedHref = href.trim();
        if (trimmedHref.startsWith("data:") || trimmedHref.startsWith("blob:") || trimmedHref.startsWith("javascript:"))
            return href;

        // Return absolute URLs as-is.
        var parsedHref = trimmedHref.asParsedURL();
        if (parsedHref && parsedHref.scheme)
            return trimmedHref;
    } else {
        return baseURL;
    }

    var parsedURL = baseURL.asParsedURL();
    if (parsedURL) {
        if (parsedURL.isDataURL())
            return href;
        var path = href;

        var query = path.indexOf("?");
        var postfix = "";
        if (query !== -1) {
            postfix = path.substring(query);
            path = path.substring(0, query);
        } else {
            var fragment = path.indexOf("#");
            if (fragment !== -1) {
                postfix = path.substring(fragment);
                path = path.substring(0, fragment);
            }
        }

        if (!path) {  // empty path, must be postfix
            var basePath = parsedURL.path;
            if (postfix.charAt(0) === "?") {
                // A href of "?foo=bar" implies "basePath?foo=bar".
                // With "basePath?a=b" and "?foo=bar" we should get "basePath?foo=bar".
                var baseQuery = parsedURL.path.indexOf("?");
                if (baseQuery !== -1)
                    basePath = basePath.substring(0, baseQuery);
            } // else it must be a fragment
            return parsedURL.scheme + "://" + parsedURL.host + (parsedURL.port ? (":" + parsedURL.port) : "") + basePath + postfix;
        } else if (path.charAt(0) !== "/") {  // relative path
            var prefix = parsedURL.path;
            var prefixQuery = prefix.indexOf("?");
            if (prefixQuery !== -1)
                prefix = prefix.substring(0, prefixQuery);
            prefix = prefix.substring(0, prefix.lastIndexOf("/")) + "/";
            path = prefix + path;
        } else if (path.length > 1 && path.charAt(1) === "/") {
            // href starts with "//" which is a full URL with the protocol dropped (use the baseURL protocol).
            return parsedURL.scheme + ":" + path + postfix;
        }  // else absolute path
        return parsedURL.scheme + "://" + parsedURL.host + (parsedURL.port ? (":" + parsedURL.port) : "") + Runtime.normalizePath(path) + postfix;
    }
    return null;
}

WebInspector.ParsedURL.prototype = {
    get displayName()
    {
        if (this._displayName)
            return this._displayName;

        if (this.isDataURL())
            return this.dataURLDisplayName();
        if (this.isAboutBlank())
            return this.url;

        this._displayName = this.lastPathComponent;
        if (!this._displayName)
            this._displayName = (this.host || "") + "/";
        if (this._displayName === "/")
            this._displayName = this.url;
        return this._displayName;
    },

    /**
     * @return {string}
     */
    dataURLDisplayName: function()
    {
        if (this._dataURLDisplayName)
            return this._dataURLDisplayName;
        if (!this.isDataURL())
            return "";
        this._dataURLDisplayName = this.url.trimEnd(20);
        return this._dataURLDisplayName;
    },

    /**
     * @return {boolean}
     */
    isAboutBlank: function()
    {
        return this.url === "about:blank";
    },

    /**
     * @return {boolean}
     */
    isDataURL: function()
    {
        return this.scheme === "data";
    },

    /**
     * @return {string}
     */
    lastPathComponentWithFragment: function()
    {
        return this.lastPathComponent + (this.fragment ? "#" + this.fragment : "");
    },

    /**
     * @return {string}
     */
    domain: function()
    {
        if (this.isDataURL())
            return "data:";
        return this.host + (this.port ? ":" + this.port : "");
    },

    /**
     * @return {string}
     */
    securityOrigin: function()
    {
        if (this.isDataURL())
            return "data:";
        return this.scheme + "://" + this.domain();
    },

    /**
     * @return {string}
     */
    urlWithoutScheme: function()
    {
        if (this.scheme && this.url.startsWith(this.scheme + "://"))
            return this.url.substring(this.scheme.length + 3);
        return this.url;
    },
}

/**
 * @param {string} string
 * @return {!{url: string, lineNumber: (number|undefined), columnNumber: (number|undefined)}}
 */
WebInspector.ParsedURL.splitLineAndColumn = function(string)
{
    var lineColumnRegEx = /(?::(\d+))?(?::(\d+))?$/;
    var lineColumnMatch = lineColumnRegEx.exec(string);
    var lineNumber;
    var columnNumber;
    console.assert(lineColumnMatch);

    if (typeof(lineColumnMatch[1]) === "string") {
        lineNumber = parseInt(lineColumnMatch[1], 10);
        // Immediately convert line and column to 0-based numbers.
        lineNumber = isNaN(lineNumber) ? undefined : lineNumber - 1;
    }
    if (typeof(lineColumnMatch[2]) === "string") {
        columnNumber = parseInt(lineColumnMatch[2], 10);
        columnNumber = isNaN(columnNumber) ? undefined : columnNumber - 1;
    }

    return {url: string.substring(0, string.length - lineColumnMatch[0].length), lineNumber: lineNumber, columnNumber: columnNumber};
}

/**
 * @param {string} url
 * @return {boolean}
 */
WebInspector.ParsedURL.isRelativeURL = function(url)
{
    return !(/^[A-Za-z][A-Za-z0-9+.-]*:/.test(url));
}

/**
 * @return {?WebInspector.ParsedURL}
 */
String.prototype.asParsedURL = function()
{
    var parsedURL = new WebInspector.ParsedURL(this.toString());
    if (parsedURL.isValid)
        return parsedURL;
    return null;
}

},{}],210:[function(require,module,exports){
/*
 * Copyright (C) 2012 Google Inc.  All rights reserved.
 * Copyright (C) 2007, 2008 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {string} name
 * @param {string} title
 * @param {!WebInspector.ResourceCategory} category
 * @param {boolean} isTextType
 */
WebInspector.ResourceType = function(name, title, category, isTextType)
{
    this._name = name;
    this._title = title;
    this._category = category;
    this._isTextType = isTextType;
}

WebInspector.ResourceType.prototype = {
    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @return {string}
     */
    title: function()
    {
        return this._title;
    },

    /**
     * @return {!WebInspector.ResourceCategory}
     */
    category: function()
    {
        return this._category;
    },

    /**
     * @return {boolean}
     */
    isTextType: function()
    {
        return this._isTextType;
    },

    /**
     * @return {boolean}
     */
    isScript: function()
    {
        return this._name === "script" || this._name === "sm-script";
    },

    /**
     * @return {boolean}
     */
    hasScripts: function()
    {
        return this.isScript() || this.isDocument();
    },

    /**
     * @return {boolean}
     */
    isStyleSheet: function()
    {
        return this._name === "stylesheet" || this._name === "sm-stylesheet";
    },

    /**
     * @return {boolean}
     */
    isDocument: function()
    {
        return this._name === "document";
    },

    /**
     * @return {boolean}
     */
    isDocumentOrScriptOrStyleSheet: function()
    {
        return this.isDocument() || this.isScript() || this.isStyleSheet();
    },

    /**
     * @return {boolean}
     */
    isFromSourceMap: function()
    {
        return this._name.startsWith("sm-");
    },

    /**
     * @override
     * @return {string}
     */
    toString: function()
    {
        return this._name;
    },

    /**
     * @return {string}
     */
    canonicalMimeType: function()
    {
        if (this.isDocument())
            return "text/html";
        if (this.isScript())
            return "text/javascript";
        if (this.isStyleSheet())
            return "text/css";
        return "";
    }
}

/**
 * @constructor
 * @param {string} title
 * @param {string} shortTitle
 */
WebInspector.ResourceCategory = function(title, shortTitle)
{
    this.title = title;
    this.shortTitle = shortTitle;
}

WebInspector.resourceCategories = {
    XHR: new WebInspector.ResourceCategory("XHR and Fetch", "XHR"),
    Script: new WebInspector.ResourceCategory("Scripts", "JS"),
    Stylesheet: new WebInspector.ResourceCategory("Stylesheets", "CSS"),
    Image: new WebInspector.ResourceCategory("Images", "Img"),
    Media: new WebInspector.ResourceCategory("Media", "Media"),
    Font: new WebInspector.ResourceCategory("Fonts", "Font"),
    Document: new WebInspector.ResourceCategory("Documents", "Doc"),
    WebSocket: new WebInspector.ResourceCategory("WebSockets", "WS"),
    Manifest: new WebInspector.ResourceCategory("Manifest", "Manifest"),
    Other: new WebInspector.ResourceCategory("Other", "Other")
}

/**
 * Keep these in sync with WebCore::InspectorPageAgent::resourceTypeJson
 * @enum {!WebInspector.ResourceType}
 */
WebInspector.resourceTypes = {
    XHR: new WebInspector.ResourceType("xhr", "XHR", WebInspector.resourceCategories.XHR, true),
    Fetch: new WebInspector.ResourceType("fetch", "Fetch", WebInspector.resourceCategories.XHR, true),
    EventSource: new WebInspector.ResourceType("eventsource", "EventSource", WebInspector.resourceCategories.XHR, true),
    Script: new WebInspector.ResourceType("script", "Script", WebInspector.resourceCategories.Script, true),
    Stylesheet: new WebInspector.ResourceType("stylesheet", "Stylesheet", WebInspector.resourceCategories.Stylesheet, true),
    Image: new WebInspector.ResourceType("image", "Image", WebInspector.resourceCategories.Image, false),
    Media: new WebInspector.ResourceType("media", "Media", WebInspector.resourceCategories.Media, false),
    Font: new WebInspector.ResourceType("font", "Font", WebInspector.resourceCategories.Font, false),
    Document: new WebInspector.ResourceType("document", "Document", WebInspector.resourceCategories.Document, true),
    TextTrack: new WebInspector.ResourceType("texttrack", "TextTrack", WebInspector.resourceCategories.Other, true),
    WebSocket: new WebInspector.ResourceType("websocket", "WebSocket", WebInspector.resourceCategories.WebSocket, false),
    Other: new WebInspector.ResourceType("other", "Other", WebInspector.resourceCategories.Other, false),
    SourceMapScript: new WebInspector.ResourceType("sm-script", "Script", WebInspector.resourceCategories.Script, false),
    SourceMapStyleSheet: new WebInspector.ResourceType("sm-stylesheet", "Stylesheet", WebInspector.resourceCategories.Stylesheet, false),
    Manifest: new WebInspector.ResourceType("manifest", "Manifest", WebInspector.resourceCategories.Manifest, true),
}

/**
 * @param {string} url
 * @return {string|undefined}
 */
WebInspector.ResourceType.mimeFromURL = function(url)
{
    var name = WebInspector.ParsedURL.extractName(url);
    if (WebInspector.ResourceType._mimeTypeByName.has(name)) {
        return WebInspector.ResourceType._mimeTypeByName.get(name);
    }
    var ext = WebInspector.ParsedURL.extractExtension(url).toLowerCase();
    return WebInspector.ResourceType._mimeTypeByExtension.get(ext);
}

WebInspector.ResourceType._mimeTypeByName = new Map([
    // CoffeeScript
    ["Cakefile", "text/x-coffeescript"]
]);

WebInspector.ResourceType._mimeTypeByExtension = new Map([
    // Web extensions
    ["js", "text/javascript"],
    ["css", "text/css"],
    ["html", "text/html"],
    ["htm", "text/html"],
    ["xml", "application/xml"],
    ["xsl", "application/xml"],

    // HTML Embedded Scripts, ASP], JSP
    ["asp", "application/x-aspx"],
    ["aspx", "application/x-aspx"],
    ["jsp", "application/x-jsp"],

    // C/C++
    ["c", "text/x-c++src"],
    ["cc", "text/x-c++src"],
    ["cpp", "text/x-c++src"],
    ["h", "text/x-c++src"],
    ["m", "text/x-c++src"],
    ["mm", "text/x-c++src"],

    // CoffeeScript
    ["coffee", "text/x-coffeescript"],

    // Dart
    ["dart", "text/javascript"],

    // TypeScript
    ["ts", "text/typescript"],
    ["tsx", "text/typescript"],

    // JSON
    ["json", "application/json"],
    ["gyp", "application/json"],
    ["gypi", "application/json"],

    // C#
    ["cs", "text/x-csharp"],

    // Java
    ["java", "text/x-java"],

    // Less
    ["less", "text/x-less"],

    // PHP
    ["php", "text/x-php"],
    ["phtml", "application/x-httpd-php"],

    // Python
    ["py", "text/x-python"],

    // Shell
    ["sh", "text/x-sh"],

    // SCSS
    ["scss", "text/x-scss"],

    // Video Text Tracks.
    ["vtt", "text/vtt"],

    // LiveScript
    ["ls", "text/x-livescript"],

    // ClojureScript
    ["cljs", "text/x-clojure"],
    ["cljc", "text/x-clojure"],
    ["cljx", "text/x-clojure"],

    // Stylus
    ["styl", "text/x-styl"],

    // JSX
    ["jsx", "text/jsx"],

    // Image
    ["jpeg", "image/jpeg"],
    ["jpg", "image/jpeg"],
    ["svg", "image/svg"],
    ["gif", "image/gif"],
    ["webp", "image/webp"],
    ["png", "image/png"],
    ["ico", "image/ico"],
    ["tiff", "image/tiff"],
    ["tif", "image/tif"],
    ["bmp", "image/bmp"],

    // Font
    ["ttf", "font/opentype"],
    ["otf", "font/opentype"],
    ["ttc", "font/opentype"],
    ["woff", "application/font-woff"]
]);

},{}],211:[function(require,module,exports){
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {number} begin
 * @param {number} end
 * @param {*} data
 */
WebInspector.Segment = function(begin, end, data)
{
    if (begin > end)
        console.assert(false, "Invalid segment");
    this.begin = begin;
    this.end = end;
    this.data = data;
}

WebInspector.Segment.prototype = {
    /**
     * @param {!WebInspector.Segment} that
     * @return {boolean}
     */
    intersects: function(that)
    {
        return this.begin < that.end && that.begin < this.end;
    }
};

/**
 * @constructor
 * @param {(function(!WebInspector.Segment, !WebInspector.Segment): ?WebInspector.Segment)=} mergeCallback
 */
WebInspector.SegmentedRange = function(mergeCallback)
{
    /** @type {!Array<!WebInspector.Segment>} */
    this._segments = [];
    this._mergeCallback = mergeCallback;
}

WebInspector.SegmentedRange.prototype = {
    /**
     * @param {!WebInspector.Segment} newSegment
     */
    append: function(newSegment)
    {
        // 1. Find the proper insertion point for new segment
        var startIndex = this._segments.lowerBound(newSegment, (a, b) => a.begin - b.begin);
        var endIndex = startIndex;
        var merged = null;
        if (startIndex > 0) {
            // 2. Try mering the preceding segment
            var precedingSegment = this._segments[startIndex - 1];
            merged = this._tryMerge(precedingSegment, newSegment);
            if (merged) {
                --startIndex;
                newSegment = merged;
            } else if (this._segments[startIndex - 1].end >= newSegment.begin) {
                // 2a. If merge failed and segments overlap, adjust preceding segment.
                // If an old segment entirely contains new one, split it in two.
                if (newSegment.end < precedingSegment.end)
                    this._segments.splice(startIndex, 0, new WebInspector.Segment(newSegment.end, precedingSegment.end, precedingSegment.data));
                precedingSegment.end = newSegment.begin;
            }
        }
        // 3. Consume all segments that are entirely covered by the new one.
        while (endIndex < this._segments.length && this._segments[endIndex].end <= newSegment.end)
            ++endIndex;
        // 4. Merge or adjust the succeeding segment if it overlaps.
        if (endIndex < this._segments.length) {
            merged = this._tryMerge(newSegment, this._segments[endIndex]);
            if (merged) {
                endIndex++;
                newSegment = merged;
            } else if (newSegment.intersects(this._segments[endIndex]))
                this._segments[endIndex].begin = newSegment.end;
        }
        this._segments.splice(startIndex, endIndex - startIndex, newSegment);
    },

    /**
     * @param {!WebInspector.SegmentedRange} that
     */
    appendRange: function(that)
    {
        that.segments().forEach(segment => this.append(segment));
    },

    /**
     * @return {!Array<!WebInspector.Segment>}
     */
    segments: function()
    {
        return this._segments;
    },

    /**
     * @param {!WebInspector.Segment} first
     * @param {!WebInspector.Segment} second
     * @return {?WebInspector.Segment}
     */
    _tryMerge: function(first, second)
    {
        var merged = this._mergeCallback && this._mergeCallback(first, second);
        if (!merged)
            return null;
        merged.begin = first.begin;
        merged.end = Math.max(first.end, second.end);
        return merged;
    }
}

},{}],212:[function(require,module,exports){
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {number} startLine
 * @param {number} startColumn
 * @param {number} endLine
 * @param {number} endColumn
 */
WebInspector.TextRange = function(startLine, startColumn, endLine, endColumn)
{
    this.startLine = startLine;
    this.startColumn = startColumn;
    this.endLine = endLine;
    this.endColumn = endColumn;
}

/**
 * @param {number} line
 * @param {number} column
 * @return {!WebInspector.TextRange}
 */
WebInspector.TextRange.createFromLocation = function(line, column)
{
    return new WebInspector.TextRange(line, column, line, column);
}

/**
 * @param {!Object} serializedTextRange
 * @return {!WebInspector.TextRange}
 */
WebInspector.TextRange.fromObject = function(serializedTextRange)
{
    return new WebInspector.TextRange(serializedTextRange.startLine, serializedTextRange.startColumn, serializedTextRange.endLine, serializedTextRange.endColumn);
}

/**
 * @param {!WebInspector.TextRange} range1
 * @param {!WebInspector.TextRange} range2
 * @return {number}
 */
WebInspector.TextRange.comparator = function(range1, range2)
{
    return range1.compareTo(range2);
}

WebInspector.TextRange.prototype = {
    /**
     * @return {boolean}
     */
    isEmpty: function()
    {
        return this.startLine === this.endLine && this.startColumn === this.endColumn;
    },

    /**
     * @param {!WebInspector.TextRange} range
     * @return {boolean}
     */
    immediatelyPrecedes: function(range)
    {
        if (!range)
            return false;
        return this.endLine === range.startLine && this.endColumn === range.startColumn;
    },

    /**
     * @param {!WebInspector.TextRange} range
     * @return {boolean}
     */
    immediatelyFollows: function(range)
    {
        if (!range)
            return false;
        return range.immediatelyPrecedes(this);
    },

    /**
     * @param {!WebInspector.TextRange} range
     * @return {boolean}
     */
    follows: function(range)
    {
        return (range.endLine === this.startLine && range.endColumn <= this.startColumn)
            || range.endLine < this.startLine;
    },

    /**
     * @return {number}
     */
    get linesCount()
    {
        return this.endLine - this.startLine;
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    collapseToEnd: function()
    {
        return new WebInspector.TextRange(this.endLine, this.endColumn, this.endLine, this.endColumn);
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    collapseToStart: function()
    {
        return new WebInspector.TextRange(this.startLine, this.startColumn, this.startLine, this.startColumn);
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    normalize: function()
    {
        if (this.startLine > this.endLine || (this.startLine === this.endLine && this.startColumn > this.endColumn))
            return new WebInspector.TextRange(this.endLine, this.endColumn, this.startLine, this.startColumn);
        else
            return this.clone();
    },

    /**
     * @return {!WebInspector.TextRange}
     */
    clone: function()
    {
        return new WebInspector.TextRange(this.startLine, this.startColumn, this.endLine, this.endColumn);
    },

    /**
     * @return {!{startLine: number, startColumn: number, endLine: number, endColumn: number}}
     */
    serializeToObject: function()
    {
        var serializedTextRange = {};
        serializedTextRange.startLine = this.startLine;
        serializedTextRange.startColumn = this.startColumn;
        serializedTextRange.endLine = this.endLine;
        serializedTextRange.endColumn = this.endColumn;
        return serializedTextRange;
    },

    /**
     * @param {!WebInspector.TextRange} other
     * @return {number}
     */
    compareTo: function(other)
    {
        if (this.startLine > other.startLine)
            return 1;
        if (this.startLine < other.startLine)
            return -1;
        if (this.startColumn > other.startColumn)
            return 1;
        if (this.startColumn < other.startColumn)
            return -1;
        return 0;
    },

    /**
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {number}
     */
    compareToPosition: function(lineNumber, columnNumber)
    {
        if (lineNumber < this.startLine || (lineNumber === this.startLine && columnNumber < this.startColumn))
            return -1;
        if (lineNumber > this.endLine || (lineNumber === this.endLine && columnNumber > this.endColumn))
            return 1;
        return 0;
    },

    /**
     * @param {!WebInspector.TextRange} other
     * @return {boolean}
     */
    equal: function(other)
    {
        return this.startLine === other.startLine && this.endLine === other.endLine &&
            this.startColumn === other.startColumn && this.endColumn === other.endColumn;
    },

    /**
     * @param {number} line
     * @param {number} column
     * @return {!WebInspector.TextRange}
     */
    relativeTo: function(line, column)
    {
        var relative = this.clone();

        if (this.startLine === line)
            relative.startColumn -= column;
        if (this.endLine === line)
            relative.endColumn -= column;

        relative.startLine -= line;
        relative.endLine -= line;
        return relative;
    },

    /**
     * @param {!WebInspector.TextRange} originalRange
     * @param {!WebInspector.TextRange} editedRange
     * @return {!WebInspector.TextRange}
     */
    rebaseAfterTextEdit: function(originalRange, editedRange)
    {
        console.assert(originalRange.startLine === editedRange.startLine);
        console.assert(originalRange.startColumn === editedRange.startColumn);
        var rebase = this.clone();
        if (!this.follows(originalRange))
            return rebase;
        var lineDelta = editedRange.endLine - originalRange.endLine;
        var columnDelta = editedRange.endColumn - originalRange.endColumn;
        rebase.startLine += lineDelta;
        rebase.endLine += lineDelta;
        if (rebase.startLine === editedRange.endLine)
            rebase.startColumn += columnDelta;
        if (rebase.endLine === editedRange.endLine)
            rebase.endColumn += columnDelta;
        return rebase;
    },

    /**
     * @override
     * @return {string}
     */
    toString: function()
    {
        return JSON.stringify(this);
    },

    /**
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {boolean}
     */
    containsLocation: function(lineNumber, columnNumber)
    {
        if (this.startLine === this.endLine)
            return this.startLine === lineNumber && this.startColumn <= columnNumber && columnNumber <= this.endColumn;
        if (this.startLine === lineNumber)
            return this.startColumn <= columnNumber;
        if (this.endLine === lineNumber)
            return columnNumber <= this.endColumn;
        return this.startLine < lineNumber && lineNumber < this.endLine;
    }
}

/**
 * @param {!WebInspector.TextRange} oldRange
 * @param {string} newText
 * @return {!WebInspector.TextRange}
 */
WebInspector.TextRange.fromEdit = function(oldRange, newText)
{
    var endLine = oldRange.startLine;
    var endColumn = oldRange.startColumn + newText.length;
    var lineEndings = newText.computeLineEndings();
    if (lineEndings.length > 1) {
        endLine = oldRange.startLine + lineEndings.length - 1;
        var len = lineEndings.length;
        endColumn = lineEndings[len - 1] - lineEndings[len - 2] - 1;
    }
    return new WebInspector.TextRange(
        oldRange.startLine,
        oldRange.startColumn,
        endLine,
        endColumn);
}

/**
 * @constructor
 * @param {number} offset
 * @param {number} length
 */
WebInspector.SourceRange = function(offset, length)
{
    this.offset = offset;
    this.length = length;
}

/**
 * @constructor
 * @param {string} sourceURL
 * @param {!WebInspector.TextRange} oldRange
 * @param {string} newText
 */
WebInspector.SourceEdit = function(sourceURL, oldRange, newText)
{
    this.sourceURL = sourceURL;
    this.oldRange = oldRange;
    this.newText = newText;
}

WebInspector.SourceEdit.prototype = {
    /**
     * @return {!WebInspector.TextRange}
     */
    newRange: function()
    {
        return WebInspector.TextRange.fromEdit(this.oldRange, this.newText);
    },
}

/**
 * @param {!WebInspector.SourceEdit} edit1
 * @param {!WebInspector.SourceEdit} edit2
 * @return {number}
 */
WebInspector.SourceEdit.comparator = function(edit1, edit2)
{
    return WebInspector.TextRange.comparator(edit1.oldRange, edit2.oldRange);
}

},{}],213:[function(require,module,exports){
/*
 * Copyright (C) 2011 Google Inc.  All rights reserved.
 * Copyright (C) 2006, 2007, 2008 Apple Inc.  All rights reserved.
 * Copyright (C) 2007 Matt Lilek (pewtermoose@gmail.com).
 * Copyright (C) 2009 Joseph Pecoraro
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @param {string} string
 * @param {...*} vararg
 * @return {string}
 */
WebInspector.UIString = function(string, vararg)
{
    return String.vsprintf(WebInspector.localize(string), Array.prototype.slice.call(arguments, 1));
}

/**
 * @param {string} string
 * @param {...*} vararg
 * @return {string}
 */
WebInspector.UIString.capitalize = function(string, vararg)
{
    if (WebInspector._useLowerCaseMenuTitles === undefined)
        throw "WebInspector.setLocalizationPlatform() has not been called";

    var localized = WebInspector.localize(string);
    var capitalized;
    if (WebInspector._useLowerCaseMenuTitles)
        capitalized = localized.replace(/\^(.)/g, "$1");
    else
        capitalized = localized.replace(/\^(.)/g, function(str, char) { return char.toUpperCase(); });
    return String.vsprintf(capitalized, Array.prototype.slice.call(arguments, 1));
}

/**
 * @param {string} platform
 */
WebInspector.setLocalizationPlatform = function(platform)
{
    WebInspector._useLowerCaseMenuTitles = platform === "windows";
}

/**
 * @param {string} string
 * @return {string}
 */
WebInspector.localize = function(string)
{
    return string;
}

/**
 * @constructor
 * @param {string} format
 */
WebInspector.UIStringFormat = function(format)
{
    /** @type {string} */
    this._localizedFormat = WebInspector.localize(format);
    /** @type {!Array.<!Object>} */
    this._tokenizedFormat = String.tokenizeFormatString(this._localizedFormat, String.standardFormatters);
}

/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
WebInspector.UIStringFormat._append = function(a, b)
{
    return a + b;
}

WebInspector.UIStringFormat.prototype = {
    /**
     * @param {...*} vararg
     * @return {string}
     */
    format: function(vararg)
    {
        return String.format(this._localizedFormat, arguments,
            String.standardFormatters, "", WebInspector.UIStringFormat._append, this._tokenizedFormat).formattedResult;
    }
}

},{}],214:[function(require,module,exports){
/*
 * Copyright 2015 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @constructor
 * @param {!WebInspector.TracingModel} tracingModel
 * @param {number=} zeroTime
 */
WebInspector.FilmStripModel = function(tracingModel, zeroTime)
{
    this.reset(tracingModel, zeroTime);
}

WebInspector.FilmStripModel._category = "disabled-by-default-devtools.screenshot";

WebInspector.FilmStripModel.TraceEvents = {
    CaptureFrame: "CaptureFrame",
    Screenshot: "Screenshot"
}

WebInspector.FilmStripModel.prototype = {
    /**
     * @param {!WebInspector.TracingModel} tracingModel
     * @param {number=} zeroTime
     */
    reset: function(tracingModel, zeroTime)
    {
        this._zeroTime = zeroTime || tracingModel.minimumRecordTime();
        this._spanTime = tracingModel.maximumRecordTime() - this._zeroTime;

        /** @type {!Array<!WebInspector.FilmStripModel.Frame>} */
        this._frames = [];
        var browserMain = WebInspector.TracingModel.browserMainThread(tracingModel);
        if (!browserMain)
            return;

        var events = browserMain.events();
        for (var i = 0; i < events.length; ++i) {
            var event = events[i];
            if (event.startTime < this._zeroTime)
                continue;
            if (!event.hasCategory(WebInspector.FilmStripModel._category))
                continue;
            if (event.name === WebInspector.FilmStripModel.TraceEvents.CaptureFrame) {
                var data = event.args["data"];
                if (data)
                    this._frames.push(WebInspector.FilmStripModel.Frame._fromEvent(this, event, this._frames.length));
            } else if (event.name === WebInspector.FilmStripModel.TraceEvents.Screenshot) {
                this._frames.push(WebInspector.FilmStripModel.Frame._fromSnapshot(this, /** @type {!WebInspector.TracingModel.ObjectSnapshot} */ (event), this._frames.length));
            }
        }
    },

    /**
     * @return {!Array<!WebInspector.FilmStripModel.Frame>}
     */
    frames: function()
    {
        return this._frames;
    },

    /**
     * @return {number}
     */
    zeroTime: function()
    {
        return this._zeroTime;
    },

    /**
     * @return {number}
     */
    spanTime: function()
    {
        return this._spanTime;
    },

    /**
     * @param {number} timestamp
     * @return {?WebInspector.FilmStripModel.Frame}
     */
    frameByTimestamp: function(timestamp)
    {
        var index = this._frames.upperBound(timestamp, (timestamp, frame) => timestamp - frame.timestamp) - 1;
        return index >= 0 ? this._frames[index] : null;
    }
}

/**
 * @constructor
 * @param {!WebInspector.FilmStripModel} model
 * @param {number} timestamp
 * @param {number} index
 */
WebInspector.FilmStripModel.Frame = function(model, timestamp, index)
{
    this._model = model;
    this.timestamp = timestamp;
    this.index = index;
    /** @type {?string} */
    this._imageData = null;
    /** @type {?WebInspector.TracingModel.ObjectSnapshot} */
    this._snapshot = null;
}

/**
 * @param {!WebInspector.FilmStripModel} model
 * @param {!WebInspector.TracingModel.Event} event
 * @param {number} index
 * @return {!WebInspector.FilmStripModel.Frame}
 */
WebInspector.FilmStripModel.Frame._fromEvent = function(model, event, index)
{
    var frame = new WebInspector.FilmStripModel.Frame(model, event.startTime, index);
    frame._imageData = event.args["data"];
    return frame;
}

/**
 * @param {!WebInspector.FilmStripModel} model
 * @param {!WebInspector.TracingModel.ObjectSnapshot} snapshot
 * @param {number} index
 * @return {!WebInspector.FilmStripModel.Frame}
 */
WebInspector.FilmStripModel.Frame._fromSnapshot = function(model, snapshot, index)
{
    var frame = new WebInspector.FilmStripModel.Frame(model, snapshot.startTime, index);
    frame._snapshot = snapshot;
    return frame;
}

WebInspector.FilmStripModel.Frame.prototype = {
    /**
     * @return {!WebInspector.FilmStripModel}
     */
    model: function()
    {
        return this._model;
    },

    /**
     * @return {!Promise<?string>}
     */
    imageDataPromise: function()
    {
        if (this._imageData || !this._snapshot)
            return Promise.resolve(this._imageData);

        return /** @type {!Promise<?string>} */ (this._snapshot.objectPromise());
    }
}

},{}],215:[function(require,module,exports){
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @implements {WebInspector.FormatterWorkerContentParser}
 */
WebInspector.SCSSParser = function()
{
}

WebInspector.SCSSParser.prototype = {
    /**
     * @override
     * @param {string} content
     * @return {!Array<!WebInspector.SCSSParser.Rule>}
     */
    parse: function(content)
    {
        var ast = null;
        try {
            ast = gonzales.parse(content, {syntax: "scss"});
        } catch (e) {
            return [];
        }

        /** @type {!{properties: !Array<!Gonzales.Node>, node: !Gonzales.Node}} */
        var rootBlock = {
            properties: [],
            node: ast
        };
        /** @type {!Array<!{properties: !Array<!Gonzales.Node>, node: !Gonzales.Node}>} */
        var blocks = [rootBlock];
        ast.selectors = [];
        WebInspector.SCSSParser.extractNodes(ast, blocks, rootBlock);

        var rules = [];
        for (var block of blocks)
            this._handleBlock(block, rules);
        return rules;
    },

    /**
     * @param {!{node: !Gonzales.Node, properties: !Array<!Gonzales.Node>}} block
     * @param {!Array<!WebInspector.SCSSParser.Rule>} output
     */
    _handleBlock: function(block, output)
    {
        var selectors = block.node.selectors.map(WebInspector.SCSSParser.rangeFromNode);
        var properties = [];
        var styleRange = WebInspector.SCSSParser.rangeFromNode(block.node);
        styleRange.startColumn += 1;
        styleRange.endColumn -= 1;
        for (var node of block.properties) {
            if (node.type === "declaration")
                this._handleDeclaration(node, properties);
            else if (node.type === "include")
                this._handleInclude(node, properties);
            else if (node.type === "multilineComment" && node.start.line === node.end.line)
                this._handleComment(node, properties);
        }
        if (!selectors.length && !properties.length)
            return;
        var rule = new WebInspector.SCSSParser.Rule(selectors, properties, styleRange);
        output.push(rule);
    },

    /**
     * @param {!Gonzales.Node} node
     * @param {!Array<!WebInspector.SCSSParser.Property>} output
     */
    _handleDeclaration: function(node, output)
    {
        var propertyNode = node.content.find(node => node.type === "property");
        var valueNode = node.content.find(node => node.type === "value");
        if (!propertyNode || !valueNode)
            return;

        var nameRange = WebInspector.SCSSParser.rangeFromNode(propertyNode);
        var valueRange = WebInspector.SCSSParser.rangeFromNode(valueNode);
        var range = /** @type {!WebInspector.TextRange} */(node.declarationRange);

        var property = new WebInspector.SCSSParser.Property(range, nameRange, valueRange, false);
        output.push(property);
    },

    /**
     * @param {!Gonzales.Node} node
     * @param {!Array<!WebInspector.SCSSParser.Property>} output
     */
    _handleInclude: function(node, output)
    {
        var mixinName = node.content.find(node => node.type === "ident");
        if (!mixinName)
            return;
        var nameRange = WebInspector.SCSSParser.rangeFromNode(mixinName);
        var mixinArguments = node.content.find(node => node.type === "arguments");
        if (!mixinArguments)
            return;
        var parameters = mixinArguments.content.filter(node => node.type !== "delimiter" && node.type !== "space");
        for (var parameter of parameters) {
            var range = WebInspector.SCSSParser.rangeFromNode(node);
            var valueRange = WebInspector.SCSSParser.rangeFromNode(parameter);
            var property = new WebInspector.SCSSParser.Property(range, nameRange, valueRange, false);
            output.push(property);
        }
    },

    /**
     * @param {!Gonzales.Node} node
     * @param {!Array<!WebInspector.SCSSParser.Property>} output
     */
    _handleComment: function(node, output)
    {
        if (node.start.line !== node.end.line)
            return;
        var innerText = /** @type {string} */(node.content);
        var innerResult = this.parse(innerText);
        if (innerResult.length !== 1 || innerResult[0].properties.length !== 1)
            return;
        var property = innerResult[0].properties[0];
        var disabledProperty = property.rebaseInsideOneLineComment(node);
        output.push(disabledProperty);
    },
}

/**
 * @param {!Gonzales.Node} node
 * @return {!WebInspector.TextRange}
 */
WebInspector.SCSSParser.rangeFromNode = function(node)
{
    return new WebInspector.TextRange(node.start.line - 1, node.start.column - 1, node.end.line - 1, node.end.column);
}

/**
 * @constructor
 * @param {!WebInspector.TextRange} range
 * @param {!WebInspector.TextRange} nameRange
 * @param {!WebInspector.TextRange} valueRange
 * @param {boolean} disabled
 */
WebInspector.SCSSParser.Property = function(range, nameRange, valueRange, disabled)
{
    this.range = range;
    this.name = nameRange;
    this.value = valueRange;
    this.disabled = disabled;
}

WebInspector.SCSSParser.Property.prototype = {
    /**
     * @param {!Gonzales.Node} commentNode
     * @return {!WebInspector.SCSSParser.Property}
     */
    rebaseInsideOneLineComment: function(commentNode)
    {
        var lineOffset = commentNode.start.line - 1;
        // Account for the "/*".
        var columnOffset = commentNode.start.column - 1 + 2;
        var range = WebInspector.SCSSParser.rangeFromNode(commentNode);
        var name = rebaseRange(this.name, lineOffset, columnOffset);
        var value = rebaseRange(this.value, lineOffset, columnOffset);
        return new WebInspector.SCSSParser.Property(range, name, value, true);

        /**
         * @param {!WebInspector.TextRange} range
         * @param {number} lineOffset
         * @param {number} columnOffset
         * @return {!WebInspector.TextRange}
         */
        function rebaseRange(range, lineOffset, columnOffset)
        {
            return new WebInspector.TextRange(range.startLine + lineOffset, range.startColumn + columnOffset, range.endLine + lineOffset, range.endColumn + columnOffset);
        }
    }
}

/**
 * @constructor
 * @param {!Array<!WebInspector.TextRange>} selectors
 * @param {!Array<!WebInspector.SCSSParser.Property>} properties
 * @param {!WebInspector.TextRange} styleRange
 */
WebInspector.SCSSParser.Rule = function(selectors, properties, styleRange)
{
    this.selectors = selectors;
    this.properties = properties;
    this.styleRange = styleRange;
}

/**
 * @param {!Gonzales.Node} node
 * @param {!Array<{node: !Gonzales.Node, properties: !Array<!Gonzales.Node>}>} blocks
 * @param {!{node: !Gonzales.Node, properties: !Array<!Gonzales.Node>}} lastBlock
 */
WebInspector.SCSSParser.extractNodes = function(node, blocks, lastBlock)
{
    if (!Array.isArray(node.content))
        return;
    if (node.type === "block") {
        lastBlock = {
            node: node,
            properties: []
        };
        blocks.push(lastBlock);
    }
    var lastDeclaration = null;
    var selectors = [];
    for (var i = 0; i < node.content.length; ++i) {
        var child = node.content[i];
        if (child.type === "declarationDelimiter" && lastDeclaration) {
            lastDeclaration.declarationRange.endLine = child.end.line - 1;
            lastDeclaration.declarationRange.endColumn = child.end.column;
            lastDeclaration = null;
        } else if (child.type === "selector") {
            selectors.push(child);
        } else if (child.type === "block") {
            child.selectors = selectors;
            selectors = [];
        }
        if (child.type === "include" || child.type === "declaration" || child.type === "multilineComment")
            lastBlock.properties.push(child);
        if (child.type === "declaration") {
            lastDeclaration = child;
            lastDeclaration.declarationRange = WebInspector.TextRange.createFromLocation(child.start.line - 1, child.start.column - 1);
        }
        WebInspector.SCSSParser.extractNodes(child, blocks, lastBlock);
    }
    if (lastDeclaration) {
        lastDeclaration.declarationRange.endLine = node.end.line - 1;
        lastDeclaration.declarationRange.endColumn = node.end.column - 1;
    }
}

},{}],216:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["gonzales"] = factory();
	else
		root["gonzales"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(1);
	var parse = __webpack_require__(7);

	module.exports = {
	  createNode: function (options) {
	    return new Node(options);
	  },
	  parse: parse
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * @param {string} type
	 * @param {array|string} content
	 * @param {number} line
	 * @param {number} column
	 * @constructor
	 */

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var Node = (function () {
	  function Node(options) {
	    _classCallCheck(this, Node);

	    this.type = options.type;
	    this.content = options.content;
	    this.syntax = options.syntax;

	    if (options.start) this.start = options.start;
	    if (options.end) this.end = options.end;
	  }

	  /**
	   * @param {String} type Node type
	   * @return {Boolean} Whether there is a child node of given type
	   */

	  Node.prototype.contains = function contains(type) {
	    return this.content.some(function (node) {
	      return node.type === type;
	    });
	  };

	  /**
	   * @param {String} type Node type
	   * @param {Function} callback Function to call for every found node
	   */

	  Node.prototype.eachFor = function eachFor(type, callback) {
	    if (!Array.isArray(this.content)) return;

	    if (typeof type !== 'string') {
	      callback = type;
	      type = null;
	    }

	    var l = this.content.length;
	    var breakLoop;

	    for (var i = l; i--;) {
	      if (breakLoop === null) break;

	      if (!type || this.content[i] && this.content[i].type === type) breakLoop = callback(this.content[i], i, this);
	    }

	    if (breakLoop === null) return null;
	  };

	  /**
	   * @param {String} type
	   * @return {?Node} First child node or `null` if nothing's been found.
	   */

	  Node.prototype.first = function first(type) {
	    if (!Array.isArray(this.content)) return null;

	    if (!type) return this.content[0];

	    var i = 0;
	    var l = this.content.length;

	    for (; i < l; i++) {
	      if (this.content[i].type === type) return this.content[i];
	    }

	    return null;
	  };

	  /**
	   * @param {String} type Node type
	   * @param {Function} callback Function to call for every found node
	   */

	  Node.prototype.forEach = function forEach(type, callback) {
	    if (!Array.isArray(this.content)) return;

	    if (typeof type !== 'string') {
	      callback = type;
	      type = null;
	    }

	    var i = 0;
	    var l = this.content.length;
	    var breakLoop;

	    for (; i < l; i++) {
	      if (breakLoop === null) break;

	      if (!type || this.content[i] && this.content[i].type === type) breakLoop = callback(this.content[i], i, this);
	    }

	    if (breakLoop === null) return null;
	  };

	  /**
	   * @param {Number} index
	   * @return {?Node}
	   */

	  Node.prototype.get = function get(index) {
	    if (!Array.isArray(this.content)) return null;

	    var node = this.content[index];
	    return node ? node : null;
	  };

	  /**
	   * @param {Number} index
	   * @param {Node} node
	   */

	  Node.prototype.insert = function insert(index, node) {
	    if (!Array.isArray(this.content)) return;

	    this.content.splice(index, 0, node);
	  };

	  /**
	   * @param {String} type
	   * @return {Boolean} Whether the node is of given type
	   */

	  Node.prototype.is = function is(type) {
	    return this.type === type;
	  };

	  /**
	   * @param {String} type
	   * @return {?Node} Last child node or `null` if nothing's been found.
	   */

	  Node.prototype.last = function last(type) {
	    if (!Array.isArray(this.content)) return null;

	    var i = this.content.length - 1;
	    if (!type) return this.content[i];

	    for (;; i--) {
	      if (this.content[i].type === type) return this.content[i];
	    }

	    return null;
	  };

	  /**
	   * Number of child nodes.
	   * @type {number}
	   */

	  /**
	   * @param {Number} index
	   * @return {Node}
	   */

	  Node.prototype.removeChild = function removeChild(index) {
	    if (!Array.isArray(this.content)) return;

	    var removedChild = this.content.splice(index, 1);

	    return removedChild;
	  };

	  Node.prototype.toJson = function toJson() {
	    return JSON.stringify(this, false, 2);
	  };

	  Node.prototype.toString = function toString() {
	    var stringify = undefined;

	    try {
	      stringify = __webpack_require__(2)("./" + this.syntax + '/stringify');
	    } catch (e) {
	      var message = 'Syntax "' + this.syntax + '" is not supported yet, sorry';
	      return console.error(message);
	    }

	    return stringify(this);
	  };

	  /**
	   * @param {Function} callback
	   */

	  Node.prototype.traverse = function traverse(callback, index) {
	    var level = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
	    var parent = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];

	    var breakLoop;
	    var x;

	    level++;

	    callback(this, index, parent, level);

	    if (!Array.isArray(this.content)) return;

	    for (var i = 0, l = this.content.length; i < l; i++) {
	      breakLoop = this.content[i].traverse(callback, i, level, this);
	      if (breakLoop === null) break;

	      // If some nodes were removed or added:
	      if (x = this.content.length - l) {
	        l += x;
	        i += x;
	      }
	    }

	    if (breakLoop === null) return null;
	  };

	  Node.prototype.traverseByType = function traverseByType(type, callback) {
	    this.traverse(function (node) {
	      if (node.type === type) callback.apply(node, arguments);
	    });
	  };

	  Node.prototype.traverseByTypes = function traverseByTypes(types, callback) {
	    this.traverse(function (node) {
	      if (types.indexOf(node.type) !== -1) callback.apply(node, arguments);
	    });
	  };

	  _createClass(Node, [{
	    key: 'length',
	    get: function () {
	      if (!Array.isArray(this.content)) return 0;
	      return this.content.length;
	    }
	  }]);

	  return Node;
	})();

	module.exports = Node;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./css/stringify": 3,
		"./less/stringify": 4,
		"./sass/stringify": 5,
		"./scss/stringify": 6
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 2;


/***/ },
/* 3 */
/***/ function(module, exports) {

	// jscs:disable maximumLineLength

	'use strict';

	module.exports = function stringify(tree) {
	  // TODO: Better error message
	  if (!tree) throw new Error('We need tree to translate');

	  function _t(tree) {
	    var type = tree.type;
	    if (_unique[type]) return _unique[type](tree);
	    if (typeof tree.content === 'string') return tree.content;
	    if (Array.isArray(tree.content)) return _composite(tree.content);
	    return '';
	  }

	  function _composite(t, i) {
	    if (!t) return '';

	    var s = '';
	    i = i || 0;
	    for (; i < t.length; i++) s += _t(t[i]);
	    return s;
	  }

	  var _unique = {
	    'arguments': function (t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'atkeyword': function (t) {
	      return '@' + _composite(t.content);
	    },
	    'attributeSelector': function (t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'block': function (t) {
	      return '{' + _composite(t.content) + '}';
	    },
	    'brackets': function (t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'class': function (t) {
	      return '.' + _composite(t.content);
	    },
	    'color': function (t) {
	      return '#' + t.content;
	    },
	    'expression': function (t) {
	      return 'expression(' + t.content + ')';
	    },
	    'id': function (t) {
	      return '#' + _composite(t.content);
	    },
	    'multilineComment': function (t) {
	      return '/*' + t.content + '*/';
	    },
	    'nthSelector': function (t) {
	      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';
	    },
	    'parentheses': function (t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'percentage': function (t) {
	      return _composite(t.content) + '%';
	    },
	    'pseudoClass': function (t) {
	      return ':' + _composite(t.content);
	    },
	    'pseudoElement': function (t) {
	      return '::' + _composite(t.content);
	    },
	    'uri': function (t) {
	      return 'url(' + _composite(t.content) + ')';
	    }
	  };

	  return _t(tree);
	};

/***/ },
/* 4 */
/***/ function(module, exports) {

	// jscs:disable maximumLineLength

	'use strict';

	module.exports = function stringify(tree) {
	  // TODO: Better error message
	  if (!tree) throw new Error('We need tree to translate');

	  function _t(tree) {
	    var type = tree.type;
	    if (_unique[type]) return _unique[type](tree);
	    if (typeof tree.content === 'string') return tree.content;
	    if (Array.isArray(tree.content)) return _composite(tree.content);
	    return '';
	  }

	  function _composite(t, i) {
	    if (!t) return '';

	    var s = '';
	    i = i || 0;
	    for (; i < t.length; i++) s += _t(t[i]);
	    return s;
	  }

	  var _unique = {
	    'arguments': function (t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'atkeyword': function (t) {
	      return '@' + _composite(t.content);
	    },
	    'attributeSelector': function (t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'block': function (t) {
	      return '{' + _composite(t.content) + '}';
	    },
	    'brackets': function (t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'class': function (t) {
	      return '.' + _composite(t.content);
	    },
	    'color': function (t) {
	      return '#' + t.content;
	    },
	    'escapedString': function (t) {
	      return '~' + t.content;
	    },
	    'expression': function (t) {
	      return 'expression(' + t.content + ')';
	    },
	    'id': function (t) {
	      return '#' + _composite(t.content);
	    },
	    'interpolatedVariable': function (t) {
	      return '@{' + _composite(t.content) + '}';
	    },
	    'multilineComment': function (t) {
	      return '/*' + t.content + '*/';
	    },
	    'nthSelector': function (t) {
	      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';
	    },
	    'parentheses': function (t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'percentage': function (t) {
	      return _composite(t.content) + '%';
	    },
	    'pseudoClass': function (t) {
	      return ':' + _composite(t.content);
	    },
	    'pseudoElement': function (t) {
	      return '::' + _composite(t.content);
	    },
	    'singlelineComment': function (t) {
	      return '/' + '/' + t.content;
	    },
	    'uri': function (t) {
	      return 'url(' + _composite(t.content) + ')';
	    },
	    'variable': function (t) {
	      return '@' + _composite(t.content);
	    },
	    'variablesList': function (t) {
	      return _composite(t.content) + '...';
	    }
	  };

	  return _t(tree);
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	// jscs:disable maximumLineLength

	'use strict';

	module.exports = function stringify(tree) {
	  // TODO: Better error message
	  if (!tree) throw new Error('We need tree to translate');

	  function _t(tree) {
	    var type = tree.type;
	    if (_unique[type]) return _unique[type](tree);
	    if (typeof tree.content === 'string') return tree.content;
	    if (Array.isArray(tree.content)) return _composite(tree.content);
	    return '';
	  }

	  function _composite(t, i) {
	    if (!t) return '';

	    var s = '';
	    i = i || 0;
	    for (; i < t.length; i++) s += _t(t[i]);
	    return s;
	  }

	  var _unique = {
	    'arguments': function (t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'atkeyword': function (t) {
	      return '@' + _composite(t.content);
	    },
	    'attributeSelector': function (t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'block': function (t) {
	      return _composite(t.content);
	    },
	    'brackets': function (t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'class': function (t) {
	      return '.' + _composite(t.content);
	    },
	    'color': function (t) {
	      return '#' + t.content;
	    },
	    'expression': function (t) {
	      return 'expression(' + t.content + ')';
	    },
	    'id': function (t) {
	      return '#' + _composite(t.content);
	    },
	    'interpolation': function (t) {
	      return '#{' + _composite(t.content) + '}';
	    },
	    'multilineComment': function (t) {
	      return '/*' + t.content;
	    },
	    'nthSelector': function (t) {
	      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';
	    },
	    'parentheses': function (t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'percentage': function (t) {
	      return _composite(t.content) + '%';
	    },
	    'placeholder': function (t) {
	      return '%' + _composite(t.content);
	    },
	    'pseudoClass': function (t) {
	      return ':' + _composite(t.content);
	    },
	    'pseudoElement': function (t) {
	      return '::' + _composite(t.content);
	    },
	    'singlelineComment': function (t) {
	      return '/' + '/' + t.content;
	    },
	    'uri': function (t) {
	      return 'url(' + _composite(t.content) + ')';
	    },
	    'variable': function (t) {
	      return '$' + _composite(t.content);
	    },
	    'variablesList': function (t) {
	      return _composite(t.content) + '...';
	    }
	  };

	  return _t(tree);
	};

/***/ },
/* 6 */
/***/ function(module, exports) {

	// jscs:disable maximumLineLength

	'use strict';

	module.exports = function stringify(tree) {
	  // TODO: Better error message
	  if (!tree) throw new Error('We need tree to translate');

	  function _t(tree) {
	    var type = tree.type;
	    if (_unique[type]) return _unique[type](tree);
	    if (typeof tree.content === 'string') return tree.content;
	    if (Array.isArray(tree.content)) return _composite(tree.content);
	    return '';
	  }

	  function _composite(t, i) {
	    if (!t) return '';

	    var s = '';
	    i = i || 0;
	    for (; i < t.length; i++) s += _t(t[i]);
	    return s;
	  }

	  var _unique = {
	    'arguments': function (t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'atkeyword': function (t) {
	      return '@' + _composite(t.content);
	    },
	    'attributeSelector': function (t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'block': function (t) {
	      return '{' + _composite(t.content) + '}';
	    },
	    'brackets': function (t) {
	      return '[' + _composite(t.content) + ']';
	    },
	    'class': function (t) {
	      return '.' + _composite(t.content);
	    },
	    'color': function (t) {
	      return '#' + t.content;
	    },
	    'expression': function (t) {
	      return 'expression(' + t.content + ')';
	    },
	    'id': function (t) {
	      return '#' + _composite(t.content);
	    },
	    'interpolation': function (t) {
	      return '#{' + _composite(t.content) + '}';
	    },
	    'multilineComment': function (t) {
	      return '/*' + t.content + '*/';
	    },
	    'nthSelector': function (t) {
	      return ':' + _t(t.content[0]) + '(' + _composite(t.content.slice(1)) + ')';
	    },
	    'parentheses': function (t) {
	      return '(' + _composite(t.content) + ')';
	    },
	    'percentage': function (t) {
	      return _composite(t.content) + '%';
	    },
	    'placeholder': function (t) {
	      return '%' + _composite(t.content);
	    },
	    'pseudoClass': function (t) {
	      return ':' + _composite(t.content);
	    },
	    'pseudoElement': function (t) {
	      return '::' + _composite(t.content);
	    },
	    'singlelineComment': function (t) {
	      return '/' + '/' + t.content;
	    },
	    'uri': function (t) {
	      return 'url(' + _composite(t.content) + ')';
	    },
	    'variable': function (t) {
	      return '$' + _composite(t.content);
	    },
	    'variablesList': function (t) {
	      return _composite(t.content) + '...';
	    }
	  };

	  return _t(tree);
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ParsingError = __webpack_require__(8);
	var syntaxes = __webpack_require__(10);

	var isInteger = Number.isInteger || function (value) {
	  return typeof value === 'number' && Math.floor(value) === value;
	};

	/**
	 * @param {String} css
	 * @param {Object} options
	 * @return {Object} AST
	 */
	function parser(css, options) {
	  if (typeof css !== 'string') throw new Error('Please, pass a string to parse');else if (!css) return __webpack_require__(16)();

	  var syntax = options && options.syntax || 'css';
	  var context = options && options.context || 'stylesheet';
	  var tabSize = options && options.tabSize;
	  if (!isInteger(tabSize) || tabSize < 1) tabSize = 1;

	  var syntaxParser = undefined;
	  if (syntaxes[syntax]) {
	    syntaxParser = syntaxes[syntax];
	  } else {
	    syntaxParser = syntaxes;
	  }

	  if (!syntaxParser) {
	    var message = 'Syntax "' + syntax + '" is not supported yet, sorry';
	    return console.error(message);
	  }

	  var getTokens = syntaxParser.tokenizer;
	  var mark = syntaxParser.mark;
	  var parse = syntaxParser.parse;

	  var tokens = getTokens(css, tabSize);
	  mark(tokens);

	  var ast;
	  try {
	    ast = parse(tokens, context);
	  } catch (e) {
	    if (!e.syntax) throw e;
	    throw new ParsingError(e, css);
	  }

	  return ast;
	}

	module.exports = parser;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var parserPackage = __webpack_require__(9);

	/**
	 * @param {Error} e
	 * @param {String} css
	 */
	function ParsingError(e, css) {
	  this.line = e.line;
	  this.syntax = e.syntax;
	  this.css_ = css;
	}

	ParsingError.prototype = Object.defineProperties({
	  /**
	   * @type {String}
	   * @private
	   */
	  customMessage_: '',

	  /**
	   * @type {Number}
	   */
	  line: null,

	  /**
	   * @type {String}
	   */
	  name: 'Parsing error',

	  /**
	   * @type {String}
	   */
	  syntax: null,

	  /**
	   * @type {String}
	   */
	  version: parserPackage.version,

	  /**
	   * @return {String}
	   */
	  toString: function () {
	    return [this.name + ': ' + this.message, '', this.context, '', 'Syntax: ' + this.syntax, 'Gonzales PE version: ' + this.version].join('\n');
	  }
	}, {
	  context: { /**
	              * @type {String}
	              */

	    get: function () {
	      var LINES_AROUND = 2;

	      var result = [];
	      var currentLineNumber = this.line;
	      var start = currentLineNumber - 1 - LINES_AROUND;
	      var end = currentLineNumber + LINES_AROUND;
	      var lines = this.css_.split(/\r\n|\r|\n/);

	      for (var i = start; i < end; i++) {
	        var line = lines[i];
	        if (!line) continue;
	        var ln = i + 1;
	        var mark = ln === currentLineNumber ? '*' : ' ';
	        result.push(ln + mark + '| ' + line);
	      }

	      return result.join('\n');
	    },
	    configurable: true,
	    enumerable: true
	  },
	  message: {

	    /**
	     * @type {String}
	     */

	    get: function () {
	      if (this.customMessage_) {
	        return this.customMessage_;
	      } else {
	        var message = 'Please check validity of the block';
	        if (typeof this.line === 'number') message += ' starting from line #' + this.line;
	        return message;
	      }
	    },
	    set: function (message) {
	      this.customMessage_ = message;
	    },
	    configurable: true,
	    enumerable: true
	  }
	});

	module.exports = ParsingError;

/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = {
		"name": "gonzales-pe",
		"description": "Gonzales Preprocessor Edition (fast CSS parser)",
		"version": "3.3.1",
		"homepage": "http://github.com/tonyganch/gonzales-pe",
		"bugs": "http://github.com/tonyganch/gonzales-pe/issues",
		"license": "MIT",
		"author": {
			"name": "Tony Ganch",
			"email": "tonyganch+github@gmail.com",
			"url": "http://tonyganch.com"
		},
		"main": "./lib/gonzales",
		"repository": {
			"type": "git",
			"url": "http://github.com/tonyganch/gonzales-pe.git"
		},
		"scripts": {
			"autofix-tests": "bash ./scripts/build.sh && bash ./scripts/autofix-tests.sh",
			"build": "bash ./scripts/build.sh",
			"init": "bash ./scripts/init.sh",
			"log": "bash ./scripts/log.sh",
			"prepublish": "bash ./scripts/prepublish.sh",
			"postpublish": "bash ./scripts/postpublish.sh",
			"test": "bash ./scripts/build.sh && bash ./scripts/test.sh",
			"watch": "bash ./scripts/watch.sh"
		},
		"bin": {
			"gonzales": "./bin/gonzales.js"
		},
		"dependencies": {
			"minimist": "1.1.x"
		},
		"devDependencies": {
			"babel-loader": "^5.3.2",
			"coffee-script": "~1.7.1",
			"jscs": "2.1.0",
			"jshint": "2.8.0",
			"json-loader": "^0.5.3",
			"mocha": "2.2.x",
			"webpack": "^1.12.2"
		},
		"engines": {
			"node": ">=0.6.0"
		}
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = {
	  mark: __webpack_require__(11),
	  parse: __webpack_require__(13),
	  stringify: __webpack_require__(6),
	  tokenizer: __webpack_require__(15)
	};
	module.exports = exports['default'];

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var TokenType = __webpack_require__(12);

	module.exports = (function () {
	  /**
	  * Mark whitespaces and comments
	  */
	  function markSC(tokens) {
	    var tokensLength = tokens.length;
	    var ws = -1; // Flag for whitespaces
	    var sc = -1; // Flag for whitespaces and comments
	    var t = undefined; // Current token

	    // For every token in the token list, mark spaces and line breaks
	    // as spaces (set both `ws` and `sc` flags). Mark multiline comments
	    // with `sc` flag.
	    // If there are several spaces or tabs or line breaks or multiline
	    // comments in a row, group them: take the last one's index number
	    // and save it to the first token in the group as a reference:
	    // e.g., `ws_last = 7` for a group of whitespaces or `sc_last = 9`
	    // for a group of whitespaces and comments.
	    for (var i = 0; i < tokensLength; i++) {
	      t = tokens[i];
	      switch (t.type) {
	        case TokenType.Space:
	        case TokenType.Tab:
	        case TokenType.Newline:
	          t.ws = true;
	          t.sc = true;

	          if (ws === -1) ws = i;
	          if (sc === -1) sc = i;

	          break;
	        case TokenType.CommentML:
	        case TokenType.CommentSL:
	          if (ws !== -1) {
	            tokens[ws].ws_last = i - 1;
	            ws = -1;
	          }

	          t.sc = true;

	          break;
	        default:
	          if (ws !== -1) {
	            tokens[ws].ws_last = i - 1;
	            ws = -1;
	          }

	          if (sc !== -1) {
	            tokens[sc].sc_last = i - 1;
	            sc = -1;
	          }
	      }
	    }

	    if (ws !== -1) tokens[ws].ws_last = i - 1;
	    if (sc !== -1) tokens[sc].sc_last = i - 1;
	  }

	  /**
	  * Pair brackets
	  */
	  function markBrackets(tokens) {
	    var tokensLength = tokens.length;
	    var ps = []; // Parentheses
	    var sbs = []; // Square brackets
	    var cbs = []; // Curly brackets
	    var t = undefined; // Current token

	    // For every token in the token list, if we meet an opening (left)
	    // bracket, push its index number to a corresponding array.
	    // If we then meet a closing (right) bracket, look at the corresponding
	    // array. If there are any elements (records about previously met
	    // left brackets), take a token of the last left bracket (take
	    // the last index number from the array and find a token with
	    // this index number) and save right bracket's index as a reference:
	    for (var i = 0; i < tokensLength; i++) {
	      t = tokens[i];
	      switch (t.type) {
	        case TokenType.LeftParenthesis:
	          ps.push(i);
	          break;
	        case TokenType.RightParenthesis:
	          if (ps.length) {
	            t.left = ps.pop();
	            tokens[t.left].right = i;
	          }
	          break;
	        case TokenType.LeftSquareBracket:
	          sbs.push(i);
	          break;
	        case TokenType.RightSquareBracket:
	          if (sbs.length) {
	            t.left = sbs.pop();
	            tokens[t.left].right = i;
	          }
	          break;
	        case TokenType.LeftCurlyBracket:
	          cbs.push(i);
	          break;
	        case TokenType.RightCurlyBracket:
	          if (cbs.length) {
	            t.left = cbs.pop();
	            tokens[t.left].right = i;
	          }
	          break;
	      }
	    }
	  }

	  return function (tokens) {
	    markBrackets(tokens);
	    markSC(tokens);
	  };
	})();

/***/ },
/* 12 */
/***/ function(module, exports) {

	// jscs:disable

	'use strict';

	module.exports = {
	    StringSQ: 'StringSQ',
	    StringDQ: 'StringDQ',
	    CommentML: 'CommentML',
	    CommentSL: 'CommentSL',

	    Newline: 'Newline',
	    Space: 'Space',
	    Tab: 'Tab',

	    ExclamationMark: 'ExclamationMark', // !
	    QuotationMark: 'QuotationMark', // "
	    NumberSign: 'NumberSign', // #
	    DollarSign: 'DollarSign', // $
	    PercentSign: 'PercentSign', // %
	    Ampersand: 'Ampersand', // &
	    Apostrophe: 'Apostrophe', // '
	    LeftParenthesis: 'LeftParenthesis', // (
	    RightParenthesis: 'RightParenthesis', // )
	    Asterisk: 'Asterisk', // *
	    PlusSign: 'PlusSign', // +
	    Comma: 'Comma', // ,
	    HyphenMinus: 'HyphenMinus', // -
	    FullStop: 'FullStop', // .
	    Solidus: 'Solidus', // /
	    Colon: 'Colon', // :
	    Semicolon: 'Semicolon', // ;
	    LessThanSign: 'LessThanSign', // <
	    EqualsSign: 'EqualsSign', // =
	    EqualitySign: 'EqualitySign', // ==
	    InequalitySign: 'InequalitySign', // !=
	    GreaterThanSign: 'GreaterThanSign', // >
	    QuestionMark: 'QuestionMark', // ?
	    CommercialAt: 'CommercialAt', // @
	    LeftSquareBracket: 'LeftSquareBracket', // [
	    ReverseSolidus: 'ReverseSolidus', // \
	    RightSquareBracket: 'RightSquareBracket', // ]
	    CircumflexAccent: 'CircumflexAccent', // ^
	    LowLine: 'LowLine', // _
	    LeftCurlyBracket: 'LeftCurlyBracket', // {
	    VerticalLine: 'VerticalLine', // |
	    RightCurlyBracket: 'RightCurlyBracket', // }
	    Tilde: 'Tilde', // ~

	    Identifier: 'Identifier',
	    DecimalNumber: 'DecimalNumber'
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	// jscs:disable maximumLineLength
	'use strict';var Node=__webpack_require__(1);var NodeType=__webpack_require__(14);var TokenType=__webpack_require__(12);var tokens=undefined;var tokensLength=undefined;var pos=undefined;var contexts={'arguments':function(){return checkArguments(pos) && getArguments();},'atkeyword':function(){return checkAtkeyword(pos) && getAtkeyword();},'atrule':function(){return checkAtrule(pos) && getAtrule();},'block':function(){return checkBlock(pos) && getBlock();},'brackets':function(){return checkBrackets(pos) && getBrackets();},'class':function(){return checkClass(pos) && getClass();},'combinator':function(){return checkCombinator(pos) && getCombinator();},'commentML':function(){return checkCommentML(pos) && getCommentML();},'commentSL':function(){return checkCommentSL(pos) && getCommentSL();},'condition':function(){return checkCondition(pos) && getCondition();},'conditionalStatement':function(){return checkConditionalStatement(pos) && getConditionalStatement();},'declaration':function(){return checkDeclaration(pos) && getDeclaration();},'declDelim':function(){return checkDeclDelim(pos) && getDeclDelim();},'default':function(){return checkDefault(pos) && getDefault();},'delim':function(){return checkDelim(pos) && getDelim();},'dimension':function(){return checkDimension(pos) && getDimension();},'expression':function(){return checkExpression(pos) && getExpression();},'extend':function(){return checkExtend(pos) && getExtend();},'function':function(){return checkFunction(pos) && getFunction();},'global':function(){return checkGlobal(pos) && getGlobal();},'ident':function(){return checkIdent(pos) && getIdent();},'important':function(){return checkImportant(pos) && getImportant();},'include':function(){return checkInclude(pos) && getInclude();},'interpolation':function(){return checkInterpolation(pos) && getInterpolation();},'loop':function(){return checkLoop(pos) && getLoop();},'mixin':function(){return checkMixin(pos) && getMixin();},'namespace':function(){return checkNamespace(pos) && getNamespace();},'number':function(){return checkNumber(pos) && getNumber();},'operator':function(){return checkOperator(pos) && getOperator();},'optional':function(){return checkOptional(pos) && getOptional();},'parentheses':function(){return checkParentheses(pos) && getParentheses();},'parentselector':function(){return checkParentSelector(pos) && getParentSelector();},'percentage':function(){return checkPercentage(pos) && getPercentage();},'placeholder':function(){return checkPlaceholder(pos) && getPlaceholder();},'progid':function(){return checkProgid(pos) && getProgid();},'property':function(){return checkProperty(pos) && getProperty();},'propertyDelim':function(){return checkPropertyDelim(pos) && getPropertyDelim();},'pseudoc':function(){return checkPseudoc(pos) && getPseudoc();},'pseudoe':function(){return checkPseudoe(pos) && getPseudoe();},'ruleset':function(){return checkRuleset(pos) && getRuleset();},'s':function(){return checkS(pos) && getS();},'selector':function(){return checkSelector(pos) && getSelector();},'shash':function(){return checkShash(pos) && getShash();},'string':function(){return checkString(pos) && getString();},'stylesheet':function(){return checkStylesheet(pos) && getStylesheet();},'unary':function(){return checkUnary(pos) && getUnary();},'uri':function(){return checkUri(pos) && getUri();},'value':function(){return checkValue(pos) && getValue();},'variable':function(){return checkVariable(pos) && getVariable();},'variableslist':function(){return checkVariablesList(pos) && getVariablesList();},'vhash':function(){return checkVhash(pos) && getVhash();}}; /**
	 * Stop parsing and display error
	 * @param {Number=} i Token's index number
	 */function throwError(i){var ln=i?tokens[i].ln:tokens[pos].ln;throw {line:ln,syntax:'scss'};} /**
	 * @param {Object} exclude
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkExcluding(exclude,i){var start=i;while(i < tokensLength) {if(exclude[tokens[i++].type])break;}return i - start - 2;} /**
	 * @param {Number} start
	 * @param {Number} finish
	 * @returns {String}
	 */function joinValues(start,finish){var s='';for(var i=start;i < finish + 1;i++) {s += tokens[i].value;}return s;} /**
	 * @param {Number} start
	 * @param {Number} num
	 * @returns {String}
	 */function joinValues2(start,num){if(start + num - 1 >= tokensLength)return;var s='';for(var i=0;i < num;i++) {s += tokens[start + i].value;}return s;}function getLastPosition(content,line,column,colOffset){return typeof content === 'string'?getLastPositionForString(content,line,column,colOffset):getLastPositionForArray(content,line,column,colOffset);}function getLastPositionForString(content,line,column,colOffset){var position=[];if(!content){position = [line,column];if(colOffset)position[1] += colOffset - 1;return position;}var lastLinebreak=content.lastIndexOf('\n');var endsWithLinebreak=lastLinebreak === content.length - 1;var splitContent=content.split('\n');var linebreaksCount=splitContent.length - 1;var prevLinebreak=linebreaksCount === 0 || linebreaksCount === 1?-1:content.length - splitContent[linebreaksCount - 1].length - 2; // Line:
	var offset=endsWithLinebreak?linebreaksCount - 1:linebreaksCount;position[0] = line + offset; // Column:
	if(endsWithLinebreak){offset = prevLinebreak !== -1?content.length - prevLinebreak:content.length - 1;}else {offset = linebreaksCount !== 0?content.length - lastLinebreak - column - 1:content.length - 1;}position[1] = column + offset;if(!colOffset)return position;if(endsWithLinebreak){position[0]++;position[1] = colOffset;}else {position[1] += colOffset;}return position;}function getLastPositionForArray(content,line,column,colOffset){var position;if(content.length === 0){position = [line,column];}else {var c=content[content.length - 1];if(c.hasOwnProperty('end')){position = [c.end.line,c.end.column];}else {position = getLastPosition(c.content,line,column);}}if(!colOffset)return position;if(tokens[pos - 1].type !== 'Newline'){position[1] += colOffset;}else {position[0]++;position[1] = 1;}return position;}function newNode(type,content,line,column,end){if(!end)end = getLastPosition(content,line,column);return new Node({type:type,content:content,start:{line:line,column:column},end:{line:end[0],column:end[1]},syntax:'scss'});} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkAny(i){return checkBrackets(i) || checkParentheses(i) || checkString(i) || checkVariablesList(i) || checkVariable(i) || checkPlaceholder(i) || checkPercentage(i) || checkDimension(i) || checkNumber(i) || checkUri(i) || checkExpression(i) || checkFunction(i) || checkInterpolation(i) || checkIdent(i) || checkClass(i) || checkUnary(i);} /**
	 * @returns {Array}
	 */function getAny(){if(checkBrackets(pos))return getBrackets();else if(checkParentheses(pos))return getParentheses();else if(checkString(pos))return getString();else if(checkVariablesList(pos))return getVariablesList();else if(checkVariable(pos))return getVariable();else if(checkPlaceholder(pos))return getPlaceholder();else if(checkPercentage(pos))return getPercentage();else if(checkDimension(pos))return getDimension();else if(checkNumber(pos))return getNumber();else if(checkUri(pos))return getUri();else if(checkExpression(pos))return getExpression();else if(checkFunction(pos))return getFunction();else if(checkInterpolation(pos))return getInterpolation();else if(checkIdent(pos))return getIdent();else if(checkClass(pos))return getClass();else if(checkUnary(pos))return getUnary();} /**
	 * Check if token is part of mixin's arguments.
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of arguments
	 */function checkArguments(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;i++;while(i < tokens[start].right) {if(l = checkArgument(i))i += l;else return 0;}return tokens[start].right - start + 1;} /**
	 * Check if token is valid to be part of arguments list
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of argument
	 */function checkArgument(i){return checkBrackets(i) || checkParentheses(i) || checkDeclaration(i) || checkFunction(i) || checkVariablesList(i) || checkVariable(i) || checkSC(i) || checkDelim(i) || checkDeclDelim(i) || checkString(i) || checkPercentage(i) || checkDimension(i) || checkNumber(i) || checkUri(i) || checkInterpolation(i) || checkIdent(i) || checkVhash(i) || checkOperator(i) || checkUnary(i);} /**
	 * @returns {Array} Node that is part of arguments list
	 */function getArgument(){if(checkBrackets(pos))return getBrackets();else if(checkParentheses(pos))return getParentheses();else if(checkDeclaration(pos))return getDeclaration();else if(checkFunction(pos))return getFunction();else if(checkVariablesList(pos))return getVariablesList();else if(checkVariable(pos))return getVariable();else if(checkSC(pos))return getSC();else if(checkDelim(pos))return getDelim();else if(checkDeclDelim(pos))return getDeclDelim();else if(checkString(pos))return getString();else if(checkPercentage(pos))return getPercentage();else if(checkDimension(pos))return getDimension();else if(checkNumber(pos))return getNumber();else if(checkUri(pos))return getUri();else if(checkInterpolation(pos))return getInterpolation();else if(checkIdent(pos))return getIdent();else if(checkVhash(pos))return getVhash();else if(checkOperator(pos))return getOperator();else if(checkUnary(pos))return getUnary();} /**
	 * Check if token is part of an @-word (e.g. `@import`, `@include`)
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkAtkeyword(i){var l; // Check that token is `@`:
	if(i >= tokensLength || tokens[i++].type !== TokenType.CommercialAt)return 0;return (l = checkIdentOrInterpolation(i))?l + 1:0;} /**
	 * Get node with @-word
	 * @returns {Array} `['atkeyword', ['ident', x]]` where `x` is
	 *      an identifier without
	 *      `@` (e.g. `import`, `include`)
	 */function getAtkeyword(){var startPos=pos;var x=undefined;pos++;x = getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.AtkeywordType,x,token.ln,token.col);} /**
	 * Check if token is a part of an @-rule
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of @-rule
	 */function checkAtrule(i){var l;if(i >= tokensLength)return 0; // If token already has a record of being part of an @-rule,
	// return the @-rule's length:
	if(tokens[i].atrule_l !== undefined)return tokens[i].atrule_l; // If token is part of an @-rule, save the rule's type to token:
	if(l = checkKeyframesRule(i))tokens[i].atrule_type = 4;else if(l = checkAtruler(i))tokens[i].atrule_type = 1; // @-rule with ruleset
	else if(l = checkAtruleb(i))tokens[i].atrule_type = 2; // Block @-rule
	else if(l = checkAtrules(i))tokens[i].atrule_type = 3; // Single-line @-rule
	else return 0; // If token is part of an @-rule, save the rule's length to token:
	tokens[i].atrule_l = l;return l;} /**
	 * Get node with @-rule
	 * @returns {Array}
	 */function getAtrule(){switch(tokens[pos].atrule_type){case 1:return getAtruler(); // @-rule with ruleset
	case 2:return getAtruleb(); // Block @-rule
	case 3:return getAtrules(); // Single-line @-rule
	case 4:return getKeyframesRule();}} /**
	 * Check if token is part of a block @-rule
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the @-rule
	 */function checkAtruleb(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**
	 * Get node with a block @-rule
	 * @returns {Array} `['atruleb', ['atkeyword', x], y, ['block', z]]`
	 */function getAtruleb(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets()).concat([getBlock()]);var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**
	 * Check if token is part of an @-rule with ruleset
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the @-rule
	 */function checkAtruler(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;if(i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket)i++;else return 0;if(l = checkAtrulers(i))i += l;if(i < tokensLength && tokens[i].type === TokenType.RightCurlyBracket)i++;else return 0;return i - start;} /**
	 * Get node with an @-rule with ruleset
	 * @returns {Array} ['atruler', ['atkeyword', x], y, z]
	 */function getAtruler(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets());x.push(getAtrulers());var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkAtrulers(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;while(l = checkRuleset(i) || checkAtrule(i) || checkSC(i)) {i += l;}if(i < tokensLength)tokens[i].atrulers_end = 1;return i - start;} /**
	 * @returns {Array} `['atrulers', x]`
	 */function getAtrulers(){var startPos=pos;var x=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;x = getSC();while(!tokens[pos].atrulers_end) {if(checkSC(pos))x = x.concat(getSC());else if(checkAtrule(pos))x.push(getAtrule());else if(checkRuleset(pos))x.push(getRuleset());}x = x.concat(getSC());var end=getLastPosition(x,line,column,1);pos++;return newNode(NodeType.BlockType,x,token.ln,token.col,end);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkAtrules(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(l = checkTsets(i))i += l;return i - start;} /**
	 * @returns {Array} `['atrules', ['atkeyword', x], y]`
	 */function getAtrules(){var startPos=pos;var x=undefined;x = [getAtkeyword()].concat(getTsets());var token=tokens[startPos];return newNode(NodeType.AtruleType,x,token.ln,token.col);} /**
	 * Check if token is part of a block (e.g. `{...}`).
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the block
	 */function checkBlock(i){return i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket?tokens[i].right - i + 1:0;} /**
	 * Get node with a block
	 * @returns {Array} `['block', x]`
	 */function getBlock(){var startPos=pos;var end=tokens[pos].right;var x=[];var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;while(pos < end) {if(checkBlockdecl(pos))x = x.concat(getBlockdecl());else throwError();}var end_=getLastPosition(x,line,column,1);pos = end + 1;return newNode(NodeType.BlockType,x,token.ln,token.col,end_);} /**
	 * Check if token is part of a declaration (property-value pair)
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the declaration
	 */function checkBlockdecl(i){var l;if(i >= tokensLength)return 0;if(l = checkBlockdecl1(i))tokens[i].bd_type = 1;else if(l = checkBlockdecl2(i))tokens[i].bd_type = 2;else if(l = checkBlockdecl3(i))tokens[i].bd_type = 3;else if(l = checkBlockdecl4(i))tokens[i].bd_type = 4;else return 0;return l;} /**
	 * @returns {Array}
	 */function getBlockdecl(){switch(tokens[pos].bd_type){case 1:return getBlockdecl1();case 2:return getBlockdecl2();case 3:return getBlockdecl3();case 4:return getBlockdecl4();}} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkBlockdecl1(i){var start=i;var l=undefined;if(l = checkSC(i))i += l;if(l = checkConditionalStatement(i))tokens[i].bd_kind = 1;else if(l = checkInclude(i))tokens[i].bd_kind = 2;else if(l = checkExtend(i))tokens[i].bd_kind = 4;else if(l = checkLoop(i))tokens[i].bd_kind = 3;else if(l = checkAtrule(i))tokens[i].bd_kind = 6;else if(l = checkRuleset(i))tokens[i].bd_kind = 7;else if(l = checkDeclaration(i))tokens[i].bd_kind = 5;else return 0;i += l;if(i < tokensLength && (l = checkDeclDelim(i)))i += l;else return 0;if(l = checkSC(i))i += l;return i - start;} /**
	 * @returns {Array}
	 */function getBlockdecl1(){var sc=getSC();var x=undefined;switch(tokens[pos].bd_kind){case 1:x = getConditionalStatement();break;case 2:x = getInclude();break;case 3:x = getLoop();break;case 4:x = getExtend();break;case 5:x = getDeclaration();break;case 6:x = getAtrule();break;case 7:x = getRuleset();break;}return sc.concat([x]).concat([getDeclDelim()]).concat(getSC());} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkBlockdecl2(i){var start=i;var l=undefined;if(l = checkSC(i))i += l;if(l = checkConditionalStatement(i))tokens[i].bd_kind = 1;else if(l = checkInclude(i))tokens[i].bd_kind = 2;else if(l = checkExtend(i))tokens[i].bd_kind = 4;else if(l = checkMixin(i))tokens[i].bd_kind = 8;else if(l = checkLoop(i))tokens[i].bd_kind = 3;else if(l = checkAtrule(i))tokens[i].bd_kind = 6;else if(l = checkRuleset(i))tokens[i].bd_kind = 7;else if(l = checkDeclaration(i))tokens[i].bd_kind = 5;else return 0;i += l;if(l = checkSC(i))i += l;return i - start;} /**
	 * @returns {Array}
	 */function getBlockdecl2(){var sc=getSC();var x=undefined;switch(tokens[pos].bd_kind){case 1:x = getConditionalStatement();break;case 2:x = getInclude();break;case 3:x = getLoop();break;case 4:x = getExtend();break;case 5:x = getDeclaration();break;case 6:x = getAtrule();break;case 7:x = getRuleset();break;case 8:x = getMixin();break;}return sc.concat([x]).concat(getSC());} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkBlockdecl3(i){var start=i;var l=undefined;if(l = checkSC(i))i += l;if(l = checkDeclDelim(i))i += l;else return 0;if(l = checkSC(i))i += l;return i - start;} /**
	 * @returns {Array} `[s0, ['declDelim'], s1]` where `s0` and `s1` are
	 *      are optional whitespaces.
	 */function getBlockdecl3(){return getSC().concat([getDeclDelim()]).concat(getSC());} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkBlockdecl4(i){return checkSC(i);} /**
	 * @returns {Array}
	 */function getBlockdecl4(){return getSC();} /**
	 * Check if token is part of text inside square brackets, e.g. `[1]`
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkBrackets(i){if(i >= tokensLength || tokens[i].type !== TokenType.LeftSquareBracket)return 0;return tokens[i].right - i + 1;} /**
	 * Get node with text inside parentheses or square brackets (e.g. `(1)`)
	 * @return {Node}
	 */function getBrackets(){var startPos=pos;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;var tsets=getTsets();var end=getLastPosition(tsets,line,column,1);pos++;return newNode(NodeType.BracketsType,tsets,token.ln,token.col,end);} /**
	 * Check if token is part of a class selector (e.g. `.abc`)
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the class selector
	 */function checkClass(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(tokens[i].class_l)return tokens[i].class_l;if(tokens[i++].type !== TokenType.FullStop)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;} /**
	 * Get node with a class selector
	 * @returns {Array} `['class', ['ident', x]]` where x is a class's
	 *      identifier (without `.`, e.g. `abc`).
	 */function getClass(){var startPos=pos;var x=[];pos++;x = x.concat(getIdentOrInterpolation());var token=tokens[startPos];return newNode(NodeType.ClassType,x,token.ln,token.col);}function checkCombinator(i){if(i >= tokensLength)return 0;var l=undefined;if(l = checkCombinator1(i))tokens[i].combinatorType = 1;else if(l = checkCombinator2(i))tokens[i].combinatorType = 2;else if(l = checkCombinator3(i))tokens[i].combinatorType = 3;return l;}function getCombinator(){var type=tokens[pos].combinatorType;if(type === 1)return getCombinator1();if(type === 2)return getCombinator2();if(type === 3)return getCombinator3();} /**
	 * (1) `||`
	 */function checkCombinator1(i){if(tokens[i].type === TokenType.VerticalLine && tokens[i + 1].type === TokenType.VerticalLine)return 2;else return 0;}function getCombinator1(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='||';pos += 2;return newNode(type,content,line,column);} /**
	 * (1) `>`
	 * (2) `+`
	 * (3) `~`
	 */function checkCombinator2(i){var type=tokens[i].type;if(type === TokenType.PlusSign || type === TokenType.GreaterThanSign || type === TokenType.Tilde)return 1;else return 0;}function getCombinator2(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=tokens[pos++].value;return newNode(type,content,line,column);} /**
	 * (1) `/panda/`
	 */function checkCombinator3(i){var start=i;if(tokens[i].type === TokenType.Solidus)i++;else return 0;var l=undefined;if(l = checkIdent(i))i += l;else return 0;if(tokens[i].type === TokenType.Solidus)i++;else return 0;return i - start;}function getCombinator3(){var type=NodeType.CombinatorType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `/`.
	pos++;var ident=getIdent(); // Skip `/`.
	pos++;var content='/' + ident.content + '/';return newNode(type,content,line,column);} /**
	 * Check if token is a multiline comment.
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is a multiline comment, otherwise `0`
	 */function checkCommentML(i){return i < tokensLength && tokens[i].type === TokenType.CommentML?1:0;} /**
	 * Get node with a multiline comment
	 * @returns {Array} `['commentML', x]` where `x`
	 *      is the comment's text (without `/*` and `* /`).
	 */function getCommentML(){var startPos=pos;var s=tokens[pos].value.substring(2);var l=s.length;var token=tokens[startPos];var line=token.ln;var column=token.col;if(s.charAt(l - 2) === '*' && s.charAt(l - 1) === '/')s = s.substring(0,l - 2);var end=getLastPosition(s,line,column,2);if(end[0] === line)end[1] += 2;pos++;return newNode(NodeType.CommentMLType,s,token.ln,token.col,end);} /**
	 * Check if token is part of a single-line comment.
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is a single-line comment, otherwise `0`
	 */function checkCommentSL(i){return i < tokensLength && tokens[i].type === TokenType.CommentSL?1:0;} /**
	 * Get node with a single-line comment.
	 * @returns {Array} `['commentSL', x]` where `x` is comment's message
	 *      (without `//`)
	 */function getCommentSL(){var startPos=pos;var x=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;x = tokens[pos++].value.substring(2);var end=getLastPosition(x,line,column + 2);return newNode(NodeType.CommentSLType,x,token.ln,token.col,end);} /**
	 * Check if token is part of a condition
	 * (e.g. `@if ...`, `@else if ...` or `@else ...`).
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the condition
	 */function checkCondition(i){var start=i;var l=undefined;var _i=undefined;var s=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(['if','else'].indexOf(tokens[start + 1].value) < 0)return 0;while(i < tokensLength) {if(l = checkBlock(i))break;s = checkSC(i);_i = i + s;if(l = _checkCondition(_i))i += l + s;else break;}return i - start;}function _checkCondition(i){return checkVariable(i) || checkNumber(i) || checkInterpolation(i) || checkIdent(i) || checkOperator(i) || checkCombinator(i) || checkString(i);} /**
	 * Get node with a condition.
	 * @returns {Array} `['condition', x]`
	 */function getCondition(){var startPos=pos;var x=[];var s;var _pos;x.push(getAtkeyword());while(pos < tokensLength) {if(checkBlock(pos))break;s = checkSC(pos);_pos = pos + s;if(!_checkCondition(_pos))break;if(s)x = x.concat(getSC());x.push(_getCondition());}var token=tokens[startPos];return newNode(NodeType.ConditionType,x,token.ln,token.col);}function _getCondition(){if(checkVariable(pos))return getVariable();if(checkNumber(pos))return getNumber();if(checkInterpolation(pos))return getInterpolation();if(checkIdent(pos))return getIdent();if(checkOperator(pos))return getOperator();if(checkCombinator(pos))return getCombinator();if(checkString(pos))return getString();} /**
	 * Check if token is part of a conditional statement
	 * (e.g. `@if ... {} @else if ... {} @else ... {}`).
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the condition
	 */function checkConditionalStatement(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkCondition(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**
	 * Get node with a condition.
	 * @returns {Array} `['condition', x]`
	 */function getConditionalStatement(){var startPos=pos;var x=[];x.push(getCondition());x = x.concat(getSC());x.push(getBlock());var token=tokens[startPos];return newNode(NodeType.ConditionalStatementType,x,token.ln,token.col);} /**
	 * Check if token is part of a declaration (property-value pair)
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the declaration
	 */function checkDeclaration(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkProperty(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkPropertyDelim(i))i++;else return 0;if(l = checkSC(i))i += l;if(l = checkValue(i))i += l;else return 0;return i - start;} /**
	 * Get node with a declaration
	 * @returns {Array} `['declaration', ['property', x], ['propertyDelim'],
	 *       ['value', y]]`
	 */function getDeclaration(){var startPos=pos;var x=[];x.push(getProperty());x = x.concat(getSC());x.push(getPropertyDelim());x = x.concat(getSC());x.push(getValue());var token=tokens[startPos];return newNode(NodeType.DeclarationType,x,token.ln,token.col);} /**
	 * Check if token is a semicolon
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is a semicolon, otherwise `0`
	 */function checkDeclDelim(i){return i < tokensLength && tokens[i].type === TokenType.Semicolon?1:0;} /**
	 * Get node with a semicolon
	 * @returns {Array} `['declDelim']`
	 */function getDeclDelim(){var startPos=pos++;var token=tokens[startPos];return newNode(NodeType.DeclDelimType,';',token.ln,token.col);} /**
	 * Check if token if part of `!default` word.
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the `!default` word
	 */function checkDefault(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'default'){tokens[start].defaultEnd = i;return i - start + 1;}else {return 0;}} /**
	 * Get node with a `!default` word
	 * @returns {Array} `['default', sc]` where `sc` is optional whitespace
	 */function getDefault(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.defaultEnd);pos = token.defaultEnd + 1;return newNode(NodeType.DefaultType,content,line,column);} /**
	 * Check if token is a comma
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is a comma, otherwise `0`
	 */function checkDelim(i){return i < tokensLength && tokens[i].type === TokenType.Comma?1:0;} /**
	 * Get node with a comma
	 * @returns {Array} `['delim']`
	 */function getDelim(){var startPos=pos;pos++;var token=tokens[startPos];return newNode(NodeType.DelimType,',',token.ln,token.col);} /**
	 * Check if token is part of a number with dimension unit (e.g. `10px`)
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkDimension(i){var ln=checkNumber(i);var li=undefined;if(i >= tokensLength || !ln || i + ln >= tokensLength)return 0;return (li = checkNmName2(i + ln))?ln + li:0;} /**
	 * Get node of a number with dimension unit
	 * @returns {Array} `['dimension', ['number', x], ['ident', y]]` where
	 *      `x` is a number converted to string (e.g. `'10'`) and `y` is
	 *      a dimension unit (e.g. `'px'`).
	 */function getDimension(){var startPos=pos;var x=[getNumber()];var token=tokens[pos];var ident=newNode(NodeType.IdentType,getNmName2(),token.ln,token.col);x.push(ident);token = tokens[startPos];return newNode(NodeType.DimensionType,x,token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkExpression(i){var start=i;if(i >= tokensLength || tokens[i++].value !== 'expression' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;return tokens[i].right - start + 1;} /**
	 * @returns {Array}
	 */function getExpression(){var startPos=pos;var e;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;e = joinValues(pos + 1,tokens[pos].right - 1);var end=getLastPosition(e,line,column,1);if(end[0] === line)end[1] += 11;pos = tokens[pos].right + 1;return newNode(NodeType.ExpressionType,e,token.ln,token.col,end);}function checkExtend(i){var l=0;if(l = checkExtend1(i))tokens[i].extend_child = 1;else if(l = checkExtend2(i))tokens[i].extend_child = 2;return l;}function getExtend(){var type=tokens[pos].extend_child;if(type === 1)return getExtend1();else if(type === 2)return getExtend2();} /**
	 * Checks if token is part of an extend with `!optional` flag.
	 * @param {Number} i
	 */function checkExtend1(i){var start=i;var l;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'extend')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkOptional(i))i += l;else return 0;return i - start;}function getExtend1(){var startPos=pos;var x=[].concat([getAtkeyword()],getSC(),getSelectorsGroup(),getSC(),[getOptional()]);var token=tokens[startPos];return newNode(NodeType.ExtendType,x,token.ln,token.col);} /**
	 * Checks if token is part of an extend without `!optional` flag.
	 * @param {Number} i
	 */function checkExtend2(i){var start=i;var l;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'extend')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;return i - start;}function getExtend2(){var startPos=pos;var x=[].concat([getAtkeyword()],getSC(),getSelectorsGroup());var token=tokens[startPos];return newNode(NodeType.ExtendType,x,token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkFunction(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i < tokensLength && tokens[i].type === TokenType.LeftParenthesis?tokens[i].right - start + 1:0;} /**
	 * @returns {Array}
	 */function getFunction(){var startPos=pos;var x=getIdentOrInterpolation();var body=undefined;body = getArguments();x.push(body);var token=tokens[startPos];return newNode(NodeType.FunctionType,x,token.ln,token.col);} /**
	 * @returns {Array}
	 */function getArguments(){var startPos=pos;var x=[];var body=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;while(pos < tokensLength && tokens[pos].type !== TokenType.RightParenthesis) {if(checkDeclaration(pos))x.push(getDeclaration());else if(checkArgument(pos)){body = getArgument();if(typeof body.content === 'string')x.push(body);else x = x.concat(body);}else if(checkClass(pos))x.push(getClass());else throwError();}var end=getLastPosition(x,line,column,1);pos++;return newNode(NodeType.ArgumentsType,x,token.ln,token.col,end);} /**
	 * Check if token is part of an identifier
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the identifier
	 */function checkIdent(i){var start=i;var interpolations=[];var wasIdent=undefined;var wasInt=false;var l=undefined;if(i >= tokensLength)return 0; // Check if token is part of an identifier starting with `_`:
	if(tokens[i].type === TokenType.LowLine)return checkIdentLowLine(i);if(tokens[i].type === TokenType.HyphenMinus && tokens[i + 1].type === TokenType.DecimalNumber)return 0; // If token is a character, `-`, `$` or `*`, skip it & continue:
	if(l = _checkIdent(i))i += l;else return 0; // Remember if previous token's type was identifier:
	wasIdent = tokens[i - 1].type === TokenType.Identifier;while(i < tokensLength) {l = _checkIdent(i);if(!l)break;wasIdent = true;i += l;}if(!wasIdent && !wasInt && tokens[start].type !== TokenType.Asterisk)return 0;tokens[start].ident_last = i - 1;if(interpolations.length)tokens[start].interpolations = interpolations;return i - start;}function _checkIdent(i){if(tokens[i].type === TokenType.HyphenMinus || tokens[i].type === TokenType.Identifier || tokens[i].type === TokenType.DollarSign || tokens[i].type === TokenType.LowLine || tokens[i].type === TokenType.DecimalNumber || tokens[i].type === TokenType.Asterisk)return 1;return 0;} /**
	 * Check if token is part of an identifier starting with `_`
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the identifier
	 */function checkIdentLowLine(i){var start=i;if(i++ >= tokensLength)return 0;for(;i < tokensLength;i++) {if(tokens[i].type !== TokenType.HyphenMinus && tokens[i].type !== TokenType.DecimalNumber && tokens[i].type !== TokenType.LowLine && tokens[i].type !== TokenType.Identifier)break;} // Save index number of the last token of the identifier:
	tokens[start].ident_last = i - 1;return i - start;} /**
	 * Get node with an identifier
	 * @returns {Array} `['ident', x]` where `x` is identifier's name
	 */function getIdent(){var startPos=pos;var x=joinValues(pos,tokens[pos].ident_last);pos = tokens[pos].ident_last + 1;var token=tokens[startPos];return newNode(NodeType.IdentType,x,token.ln,token.col);}function checkIdentOrInterpolation(i){var start=i;var l=undefined;while(i < tokensLength) {if(l = checkInterpolation(i) || checkIdent(i))i += l;else break;}return i - start;}function getIdentOrInterpolation(){var x=[];while(pos < tokensLength) {if(checkInterpolation(pos))x.push(getInterpolation());else if(checkIdent(pos))x.push(getIdent());else break;}return x;} /**
	 * Check if token is part of `!important` word
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkImportant(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'important'){tokens[start].importantEnd = i;return i - start + 1;}else {return 0;}} /**
	 * Get node with `!important` word
	 * @returns {Array} `['important', sc]` where `sc` is optional whitespace
	 */function getImportant(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.importantEnd);pos = token.importantEnd + 1;return newNode(NodeType.ImportantType,content,line,column);} /**
	 * Check if token is part of an included mixin (`@include` or `@extend`
	 *      directive).
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the included mixin
	 */function checkInclude(i){var l;if(i >= tokensLength)return 0;if(l = checkInclude1(i))tokens[i].include_type = 1;else if(l = checkInclude2(i))tokens[i].include_type = 2;else if(l = checkInclude3(i))tokens[i].include_type = 3;else if(l = checkInclude4(i))tokens[i].include_type = 4;else if(l = checkInclude5(i))tokens[i].include_type = 5;return l;} /**
	 * Check if token is part of `!global` word
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkGlobal(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'global'){tokens[start].globalEnd = i;return i - start + 1;}else {return 0;}} /**
	 * Get node with `!global` word
	 */function getGlobal(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.globalEnd);pos = token.globalEnd + 1;return newNode(NodeType.GlobalType,content,line,column);} /**
	 * Get node with included mixin
	 * @returns {Array} `['include', x]`
	 */function getInclude(){switch(tokens[pos].include_type){case 1:return getInclude1();case 2:return getInclude2();case 3:return getInclude3();case 4:return getInclude4();case 5:return getInclude5();}} /**
	 * Get node with included mixin with keyfames selector like
	 * `@include nani(foo) { 0% {}}`
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the include
	 */function checkInclude1(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkKeyframesBlocks(i))i += l;else return 0;return i - start;} /**
	 * Get node with included mixin with keyfames selector like
	 * `@include nani(foo) { 0% {}}`
	 * @returns {Array} `['include', ['atkeyword', x], sc, ['selector', y], sc,
	 *      ['arguments', z], sc, ['block', q], sc` where `x` is `include` or
	 *      `extend`, `y` is mixin's identifier (selector), `z` are arguments
	 *      passed to the mixin, `q` is block passed to the mixin containing a
	 *      ruleset > selector > keyframesSelector, and `sc` are optional
	 *      whitespaces
	 */function getInclude1(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getArguments(),getSC(),getKeyframesBlocks());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**
	 * Check if token is part of an included mixin like `@include nani(foo) {...}`
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the include
	 */function checkInclude2(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**
	 * Get node with included mixin like `@include nani(foo) {...}`
	 * @returns {Array} `['include', ['atkeyword', x], sc, ['selector', y], sc,
	 *      ['arguments', z], sc, ['block', q], sc` where `x` is `include` or
	 *      `extend`, `y` is mixin's identifier (selector), `z` are arguments
	 *      passed to the mixin, `q` is block passed to the mixin and `sc`
	 *      are optional whitespaces
	 */function getInclude2(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getArguments(),getSC(),getBlock());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**
	 * Check if token is part of an included mixin like `@include nani(foo)`
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the include
	 */function checkInclude3(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;else return 0;return i - start;} /**
	 * Get node with included mixin like `@include nani(foo)`
	 * @returns {Array} `['include', ['atkeyword', x], sc, ['selector', y], sc,
	 *      ['arguments', z], sc]` where `x` is `include` or `extend`, `y` is
	 *      mixin's identifier (selector), `z` are arguments passed to the
	 *      mixin and `sc` are optional whitespaces
	 */function getInclude3(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getArguments());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**
	 * Check if token is part of an included mixin with a content block passed
	 *      as an argument (e.g. `@include nani {...}`)
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the mixin
	 */function checkInclude4(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**
	 * Get node with an included mixin with a content block passed
	 *      as an argument (e.g. `@include nani {...}`)
	 * @returns {Array} `['include', x]`
	 */function getInclude4(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation(),getSC(),getBlock());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkInclude5(i){var start=i;var l=undefined;if(l = checkAtkeyword(i))i += l;else return 0;if(tokens[start + 1].value !== 'include')return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;} /**
	 * @returns {Array} `['include', x]`
	 */function getInclude5(){var startPos=pos;var x=[].concat(getAtkeyword(),getSC(),getIdentOrInterpolation());var token=tokens[startPos];return newNode(NodeType.IncludeType,x,token.ln,token.col);} /**
	 * Check if token is part of an interpolated variable (e.g. `#{$nani}`).
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkInterpolation(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.NumberSign || !tokens[i + 1] || tokens[i + 1].type !== TokenType.LeftCurlyBracket)return 0;i += 2;while(tokens[i].type !== TokenType.RightCurlyBracket) {if(l = checkArgument(i))i += l;else return 0;}return tokens[i].type === TokenType.RightCurlyBracket?i - start + 1:0;} /**
	 * Get node with an interpolated variable
	 * @returns {Array} `['interpolation', x]`
	 */function getInterpolation(){var startPos=pos;var x=[];var token=tokens[startPos];var line=token.ln;var column=token.col; // Skip `#{`:
	pos += 2;while(pos < tokensLength && tokens[pos].type !== TokenType.RightCurlyBracket) {var body=getArgument();if(typeof body.content === 'string')x.push(body);else x = x.concat(body);}var end=getLastPosition(x,line,column,1); // Skip `}`:
	pos++;return newNode(NodeType.InterpolationType,x,token.ln,token.col,end);}function checkKeyframesBlock(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkKeyframesSelector(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;}function getKeyframesBlock(){var type=NodeType.RulesetType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[].concat([getKeyframesSelector()],getSC(),[getBlock()]);return newNode(type,content,line,column);}function checkKeyframesBlocks(i){var start=i;var l=undefined;if(i < tokensLength && tokens[i].type === TokenType.LeftCurlyBracket)i++;else return 0;if(l = checkSC(i))i += l;if(l = checkKeyframesBlock(i))i += l;else return 0;while(tokens[i].type !== TokenType.RightCurlyBracket) {if(l = checkSC(i))i += l;else if(l = checkKeyframesBlock(i))i += l;else break;}if(i < tokensLength && tokens[i].type === TokenType.RightCurlyBracket)i++;else return 0;return i - start;}function getKeyframesBlocks(){var type=NodeType.BlockType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];var keyframesBlocksEnd=token.right; // Skip `{`.
	pos++;while(pos < keyframesBlocksEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkKeyframesBlock(pos))content.push(getKeyframesBlock());}var end=getLastPosition(content,line,column,1); // Skip `}`.
	pos++;return newNode(type,content,line,column,end);} /**
	 * Check if token is part of a @keyframes rule.
	 * @param {Number} i Token's index number
	 * @return {Number} Length of the @keyframes rule
	 */function checkKeyframesRule(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;var atruleName=joinValues2(i - l,l);if(atruleName.indexOf('keyframes') === -1)return 0;if(l = checkSC(i))i += l;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkKeyframesBlocks(i))i += l;else return 0;return i - start;} /**
	 * @return {Node}
	 */function getKeyframesRule(){var type=NodeType.AtruleType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[].concat([getAtkeyword()],getSC(),getIdentOrInterpolation(),getSC(),[getKeyframesBlocks()]);return newNode(type,content,line,column);}function checkKeyframesSelector(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkIdent(i)){ // Valid selectors are only `from` and `to`.
	var selector=joinValues2(i,l);if(selector !== 'from' && selector !== 'to')return 0;i += l;tokens[start].keyframesSelectorType = 1;}else if(l = checkPercentage(i)){i += l;tokens[start].keyframesSelectorType = 2;}else if(l = checkInterpolation(i)){i += l;tokens[start].keyframesSelectorType = 3;}else {return 0;}return i - start;}function getKeyframesSelector(){var keyframesSelectorType=NodeType.KeyframesSelectorType;var selectorType=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(token.keyframesSelectorType === 1){content.push(getIdent());}else if(token.keyframesSelectorType === 2){content.push(getPercentage());}else {content.push(getInterpolation());}var keyframesSelector=newNode(keyframesSelectorType,content,line,column);return newNode(selectorType,[keyframesSelector],line,column);} /**
	 * Check if token is part of a loop.
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the loop
	 */function checkLoop(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkAtkeyword(i))i += l;else return 0;if(['for','each','while'].indexOf(tokens[start + 1].value) < 0)return 0;while(i < tokensLength) {if(l = checkBlock(i)){i += l;break;}else if(l = checkVariable(i) || checkNumber(i) || checkInterpolation(i) || checkIdent(i) || checkSC(i) || checkOperator(i) || checkCombinator(i) || checkString(i))i += l;else return 0;}return i - start;} /**
	 * Get node with a loop.
	 * @returns {Array} `['loop', x]`
	 */function getLoop(){var startPos=pos;var x=[];x.push(getAtkeyword());while(pos < tokensLength) {if(checkBlock(pos)){x.push(getBlock());break;}else if(checkVariable(pos))x.push(getVariable());else if(checkNumber(pos))x.push(getNumber());else if(checkInterpolation(pos))x.push(getInterpolation());else if(checkIdent(pos))x.push(getIdent());else if(checkOperator(pos))x.push(getOperator());else if(checkCombinator(pos))x.push(getCombinator());else if(checkSC(pos))x = x.concat(getSC());else if(checkString(pos))x.push(getString());}var token=tokens[startPos];return newNode(NodeType.LoopType,x,token.ln,token.col);} /**
	 * Check if token is part of a mixin
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the mixin
	 */function checkMixin(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if((l = checkAtkeyword(i)) && tokens[i + 1].value === 'mixin')i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkArguments(i))i += l;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;} /**
	 * Get node with a mixin
	 * @returns {Array} `['mixin', x]`
	 */function getMixin(){var startPos=pos;var x=[getAtkeyword()];x = x.concat(getSC());if(checkIdentOrInterpolation(pos))x = x.concat(getIdentOrInterpolation());x = x.concat(getSC());if(checkArguments(pos))x.push(getArguments());x = x.concat(getSC());if(checkBlock(pos))x.push(getBlock());var token=tokens[startPos];return newNode(NodeType.MixinType,x,token.ln,token.col);} /**
	 * Check if token is a namespace sign (`|`)
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is `|`, `0` if not
	 */function checkNamespace(i){return i < tokensLength && tokens[i].type === TokenType.VerticalLine?1:0;} /**
	 * Get node with a namespace sign
	 * @returns {Array} `['namespace']`
	 */function getNamespace(){var startPos=pos;pos++;var token=tokens[startPos];return newNode(NodeType.NamespaceType,'|',token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkNmName2(i){if(tokens[i].type === TokenType.Identifier)return 1;else if(tokens[i].type !== TokenType.DecimalNumber)return 0;i++;return i < tokensLength && tokens[i].type === TokenType.Identifier?2:1;} /**
	 * @returns {String}
	 */function getNmName2(){var s=tokens[pos].value;if(tokens[pos++].type === TokenType.DecimalNumber && pos < tokensLength && tokens[pos].type === TokenType.Identifier)s += tokens[pos++].value;return s;} /**
	 * Check if token is part of a number
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of number
	 */function checkNumber(i){if(i >= tokensLength)return 0;if(tokens[i].number_l)return tokens[i].number_l; // `10`:
	if(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && (!tokens[i + 1] || tokens[i + 1] && tokens[i + 1].type !== TokenType.FullStop))return tokens[i].number_l = 1,tokens[i].number_l; // `10.`:
	if(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && (!tokens[i + 2] || tokens[i + 2].type !== TokenType.DecimalNumber))return tokens[i].number_l = 2,tokens[i].number_l; // `.10`:
	if(i < tokensLength && tokens[i].type === TokenType.FullStop && tokens[i + 1].type === TokenType.DecimalNumber)return tokens[i].number_l = 2,tokens[i].number_l; // `10.10`:
	if(i < tokensLength && tokens[i].type === TokenType.DecimalNumber && tokens[i + 1] && tokens[i + 1].type === TokenType.FullStop && tokens[i + 2] && tokens[i + 2].type === TokenType.DecimalNumber)return tokens[i].number_l = 3,tokens[i].number_l;return 0;} /**
	 * Get node with number
	 * @returns {Array} `['number', x]` where `x` is a number converted
	 *      to string.
	 */function getNumber(){var s='';var startPos=pos;var l=tokens[pos].number_l;for(var j=0;j < l;j++) {s += tokens[pos + j].value;}pos += l;var token=tokens[startPos];return newNode(NodeType.NumberType,s,token.ln,token.col);} /**
	 * Check if token is an operator (`/`, `%`, `,`, `:` or `=`).
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is an operator, otherwise `0`
	 */function checkOperator(i){if(i >= tokensLength)return 0;switch(tokens[i].type){case TokenType.Solidus:case TokenType.PercentSign:case TokenType.Comma:case TokenType.Colon:case TokenType.EqualsSign:case TokenType.EqualitySign:case TokenType.InequalitySign:case TokenType.LessThanSign:case TokenType.GreaterThanSign:case TokenType.Asterisk:return 1;}return 0;} /**
	 * Get node with an operator
	 * @returns {Array} `['operator', x]` where `x` is an operator converted
	 *      to string.
	 */function getOperator(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.OperatorType,x,token.ln,token.col);} /**
	 * Check if token is part of `!optional` word
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkOptional(i){var start=i;var l=undefined;if(i >= tokensLength || tokens[i++].type !== TokenType.ExclamationMark)return 0;if(l = checkSC(i))i += l;if(tokens[i].value === 'optional'){tokens[start].optionalEnd = i;return i - start + 1;}else {return 0;}} /**
	 * Get node with `!optional` word
	 */function getOptional(){var token=tokens[pos];var line=token.ln;var column=token.col;var content=joinValues(pos,token.optionalEnd);pos = token.optionalEnd + 1;return newNode(NodeType.OptionalType,content,line,column);} /**
	 * Check if token is part of text inside parentheses, e.g. `(1)`
	 * @param {Number} i Token's index number
	 * @return {Number}
	 */function checkParentheses(i){if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;return tokens[i].right - i + 1;} /**
	 * Get node with text inside parentheses, e.g. `(1)`
	 * @return {Node}
	 */function getParentheses(){var type=NodeType.ParenthesesType;var token=tokens[pos];var line=token.ln;var column=token.col;pos++;var tsets=getTsets();var end=getLastPosition(tsets,line,column,1);pos++;return newNode(type,tsets,line,column,end);} /**
	 * Check if token is a parent selector (`&`).
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkParentSelector(i){return i < tokensLength && tokens[i].type === TokenType.Ampersand?1:0;} /**
	 * Get node with a parent selector
	 */function getParentSelector(){var startPos=pos;pos++;var token=tokens[startPos];return newNode(NodeType.ParentSelectorType,'&',token.ln,token.col);}function checkParentSelectorExtension(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;while(i < tokensLength) {if(l = checkNumber(i) || checkIdentOrInterpolation(i))i += l;else break;}return i - start;}function getParentSelectorExtension(){var type=NodeType.ParentSelectorExtensionType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];while(pos < tokensLength) {if(checkNumber(pos))content.push(getNumber());else if(checkIdentOrInterpolation(pos))content = content.concat(getIdentOrInterpolation());else break;}return newNode(type,content,line,column);}function checkParentSelectorWithExtension(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkParentSelector(i))i += l;else return 0;if(l = checkParentSelectorExtension(i))i += l;return i - start;}function getParentSelectorWithExtension(){var content=[getParentSelector()];if(checkParentSelectorExtension(pos))content.push(getParentSelectorExtension());return content;} /**
	 * Check if token is part of a number with percent sign (e.g. `10%`)
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkPercentage(i){var x;if(i >= tokensLength)return 0;x = checkNumber(i);if(!x || i + x >= tokensLength)return 0;return tokens[i + x].type === TokenType.PercentSign?x + 1:0;} /**
	 * Get node of number with percent sign
	 * @returns {Array} `['percentage', ['number', x]]` where `x` is a number
	 *      (without percent sign) converted to string.
	 */function getPercentage(){var startPos=pos;var x=[getNumber()];var token=tokens[startPos];var line=token.ln;var column=token.col;var end=getLastPosition(x,line,column,1);pos++;return newNode(NodeType.PercentageType,x,token.ln,token.col,end);} /**
	 * Check if token is part of a placeholder selector (e.g. `%abc`).
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the selector
	 */function checkPlaceholder(i){var l;if(i >= tokensLength)return 0;if(tokens[i].placeholder_l)return tokens[i].placeholder_l;if(tokens[i].type === TokenType.PercentSign && (l = checkIdentOrInterpolation(i + 1))){tokens[i].placeholder_l = l + 1;return l + 1;}else return 0;} /**
	 * Get node with a placeholder selector
	 * @returns {Array} `['placeholder', ['ident', x]]` where x is a placeholder's
	 *      identifier (without `%`, e.g. `abc`).
	 */function getPlaceholder(){var startPos=pos;pos++;var x=getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.PlaceholderType,x,token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkProgid(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(joinValues2(i,6) === 'progid:DXImageTransform.Microsoft.')i += 6;else return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(tokens[i].type === TokenType.LeftParenthesis){tokens[start].progid_end = tokens[i].right;i = tokens[i].right + 1;}else return 0;return i - start;} /**
	 * @returns {Array}
	 */function getProgid(){var startPos=pos;var progid_end=tokens[pos].progid_end;var x=joinValues(pos,progid_end);pos = progid_end + 1;var token=tokens[startPos];return newNode(NodeType.ProgidType,x,token.ln,token.col);} /**
	 * Check if token is part of a property
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the property
	 */function checkProperty(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkVariable(i) || checkIdentOrInterpolation(i))i += l;else return 0;return i - start;} /**
	 * Get node with a property
	 * @returns {Array} `['property', x]`
	 */function getProperty(){var startPos=pos;var x=[];if(checkVariable(pos)){x.push(getVariable());}else {x = x.concat(getIdentOrInterpolation());}var token=tokens[startPos];return newNode(NodeType.PropertyType,x,token.ln,token.col);} /**
	 * Check if token is a colon
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is a colon, otherwise `0`
	 */function checkPropertyDelim(i){return i < tokensLength && tokens[i].type === TokenType.Colon?1:0;} /**
	 * Get node with a colon
	 * @returns {Array} `['propertyDelim']`
	 */function getPropertyDelim(){var startPos=pos;pos++;var token=tokens[startPos];return newNode(NodeType.PropertyDelimType,':',token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkPseudo(i){return checkPseudoe(i) || checkPseudoc(i);} /**
	 * @returns {Array}
	 */function getPseudo(){if(checkPseudoe(pos))return getPseudoe();if(checkPseudoc(pos))return getPseudoc();} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkPseudoe(i){var l;if(i >= tokensLength || tokens[i++].type !== TokenType.Colon || i >= tokensLength || tokens[i++].type !== TokenType.Colon)return 0;return (l = checkIdentOrInterpolation(i))?l + 2:0;} /**
	 * @returns {Array}
	 */function getPseudoe(){var startPos=pos;pos += 2;var x=getIdentOrInterpolation();var token=tokens[startPos];return newNode(NodeType.PseudoeType,x,token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkPseudoc(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.Colon)return 0;if(l = checkPseudoClass3(i))tokens[i].pseudoClassType = 3;else if(l = checkPseudoClass4(i))tokens[i].pseudoClassType = 4;else if(l = checkPseudoClass5(i))tokens[i].pseudoClassType = 5;else if(l = checkPseudoClass1(i))tokens[i].pseudoClassType = 1;else if(l = checkPseudoClass2(i))tokens[i].pseudoClassType = 2;else if(l = checkPseudoClass6(i))tokens[i].pseudoClassType = 6;else return 0;return l;} /**
	 * @returns {Array}
	 */function getPseudoc(){var childType=tokens[pos].pseudoClassType;if(childType === 1)return getPseudoClass1();if(childType === 2)return getPseudoClass2();if(childType === 3)return getPseudoClass3();if(childType === 4)return getPseudoClass4();if(childType === 5)return getPseudoClass5();if(childType === 6)return getPseudoClass6();} /**
	 * (-) `:not(panda)`
	 */function checkPseudoClass1(i){var start=i; // Skip `:`.
	i++;if(i >= tokensLength)return 0;var l=undefined;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.
	i++;if(l = checkSelectorsGroup(i))i += l;else return 0;if(i !== right)return 0;return right - start + 1;} /**
	 * (-) `:not(panda)`
	 */function getPseudoClass1(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `:`.
	pos++;content = content.concat(getIdentOrInterpolation());{var _type=NodeType.ArgumentsType;var _token=tokens[pos];var _line=_token.ln;var _column=_token.col; // Skip `(`.
	pos++;var selectors=getSelectorsGroup();var end=getLastPosition(selectors,_line,_column,1);var args=newNode(_type,selectors,_line,_column,end);content.push(args); // Skip `)`.
	pos++;}return newNode(type,content,line,column);} /**
	 * (1) `:nth-child(odd)`
	 * (2) `:nth-child(even)`
	 * (3) `:lang(de-DE)`
	 */function checkPseudoClass2(i){var start=i;var l=0; // Skip `:`.
	i++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.
	i++;if(l = checkSC(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass2(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `:`.
	pos++;content = content.concat(getIdentOrInterpolation());var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.
	pos++;value = value.concat(getSC()).concat(getIdentOrInterpolation()).concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.
	pos++;return newNode(type,content,line,column);} /**
	 * (-) `:nth-child(-3n + 2)`
	 */function checkPseudoClass3(i){var start=i;var l=0; // Skip `:`.
	i++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.
	i++;if(l = checkSC(i))i += l;if(l = checkUnary(i))i += l;if(i >= tokensLength)return 0;if(tokens[i].type === TokenType.DecimalNumber)i++;if(i >= tokensLength)return 0;if(tokens[i].value === 'n')i++;else return 0;if(l = checkSC(i))i += l;if(i >= tokensLength)return 0;if(tokens[i].value === '+' || tokens[i].value === '-')i++;else return 0;if(l = checkSC(i))i += l;if(tokens[i].type === TokenType.DecimalNumber)i++;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass3(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.
	pos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.
	pos++;if(checkUnary(pos))value.push(getUnary());if(checkNumber(pos))value.push(getNumber());{var _l=tokens[pos].ln;var _c=tokens[pos].col;var _content=tokens[pos].value;var ident=newNode(NodeType.IdentType,_content,_l,_c);value.push(ident);pos++;}value = value.concat(getSC());if(checkUnary(pos))value.push(getUnary());value = value.concat(getSC());if(checkNumber(pos))value.push(getNumber());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.
	pos++;return newNode(type,content,line,column);} /**
	 * (-) `:nth-child(-3n)`
	 */function checkPseudoClass4(i){var start=i;var l=0; // Skip `:`.
	i++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.
	i++;if(l = checkSC(i))i += l;if(l = checkUnary(i))i += l;if(tokens[i].type === TokenType.DecimalNumber)i++;if(tokens[i].value === 'n')i++;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass4(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.
	pos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.
	pos++;value = value.concat(getSC());if(checkUnary(pos))value.push(getUnary());if(checkNumber(pos))value.push(getNumber());if(checkIdent(pos))value.push(getIdent());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.
	pos++;return newNode(type,content,line,column);} /**
	 * (-) `:nth-child(+8)`
	 */function checkPseudoClass5(i){var start=i;var l=0; // Skip `:`.
	i++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;if(i >= tokensLength)return 0;if(tokens[i].type !== TokenType.LeftParenthesis)return 0;var right=tokens[i].right; // Skip `(`.
	i++;if(l = checkSC(i))i += l;if(l = checkUnary(i))i += l;if(tokens[i].type === TokenType.DecimalNumber)i++;else return 0;if(l = checkSC(i))i += l;if(i !== right)return 0;return i - start + 1;}function getPseudoClass5(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.
	pos++;var content=getIdentOrInterpolation();var l=tokens[pos].ln;var c=tokens[pos].col;var value=[]; // Skip `(`.
	pos++;if(checkUnary(pos))value.push(getUnary());if(checkNumber(pos))value.push(getNumber());value = value.concat(getSC());var end=getLastPosition(value,l,c,1);var args=newNode(NodeType.ArgumentsType,value,l,c,end);content.push(args); // Skip `)`.
	pos++;return newNode(type,content,line,column);} /**
	 * (-) `:checked`
	 */function checkPseudoClass6(i){var start=i;var l=0; // Skip `:`.
	i++;if(i >= tokensLength)return 0;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getPseudoClass6(){var type=NodeType.PseudocType;var token=tokens[pos];var line=token.ln;var column=token.col; // Skip `:`.
	pos++;var content=getIdentOrInterpolation();return newNode(type,content,line,column);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkRuleset(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkSelectorsGroup(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkBlock(i))i += l;else return 0;return i - start;}function getRuleset(){var type=NodeType.RulesetType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];content = content.concat(getSelectorsGroup());content = content.concat(getSC());content.push(getBlock());return newNode(type,content,line,column);} /**
	 * Check if token is marked as a space (if it's a space or a tab
	 *      or a line break).
	 * @param {Number} i
	 * @returns {Number} Number of spaces in a row starting with the given token.
	 */function checkS(i){return i < tokensLength && tokens[i].ws?tokens[i].ws_last - i + 1:0;} /**
	 * Get node with spaces
	 * @returns {Array} `['s', x]` where `x` is a string containing spaces
	 */function getS(){var startPos=pos;var x=joinValues(pos,tokens[pos].ws_last);pos = tokens[pos].ws_last + 1;var token=tokens[startPos];return newNode(NodeType.SType,x,token.ln,token.col);} /**
	 * Check if token is a space or a comment.
	 * @param {Number} i Token's index number
	 * @returns {Number} Number of similar (space or comment) tokens
	 *      in a row starting with the given token.
	 */function checkSC(i){if(i >= tokensLength)return 0;var l=undefined;var lsc=0;while(i < tokensLength) {if(!(l = checkS(i)) && !(l = checkCommentML(i)) && !(l = checkCommentSL(i)))break;i += l;lsc += l;}return lsc || 0;} /**
	 * Get node with spaces and comments
	 * @returns {Array} Array containing nodes with spaces (if there are any)
	 *      and nodes with comments (if there are any):
	 *      `[['s', x]*, ['comment', y]*]` where `x` is a string of spaces
	 *      and `y` is a comment's text (without `/*` and `* /`).
	 */function getSC(){var sc=[];if(pos >= tokensLength)return sc;while(pos < tokensLength) {if(checkS(pos))sc.push(getS());else if(checkCommentML(pos))sc.push(getCommentML());else if(checkCommentSL(pos))sc.push(getCommentSL());else break;}return sc;} /**
	 * Check if token is part of a hexadecimal number (e.g. `#fff`) inside
	 *      a simple selector
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkShash(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.NumberSign)return 0;return (l = checkIdentOrInterpolation(i + 1))?l + 1:0;} /**
	 * Get node with a hexadecimal number (e.g. `#fff`) inside a simple
	 *      selector
	 * @returns {Array} `['shash', x]` where `x` is a hexadecimal number
	 *      converted to string (without `#`, e.g. `fff`)
	 */function getShash(){var startPos=pos;var token=tokens[startPos];pos++;var x=getIdentOrInterpolation();return newNode(NodeType.ShashType,x,token.ln,token.col);} /**
	 * Check if token is part of a string (text wrapped in quotes)
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is part of a string, `0` if not
	 */function checkString(i){return i < tokensLength && (tokens[i].type === TokenType.StringSQ || tokens[i].type === TokenType.StringDQ)?1:0;} /**
	 * Get string's node
	 * @returns {Array} `['string', x]` where `x` is a string (including
	 *      quotes).
	 */function getString(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.StringType,x,token.ln,token.col);} /**
	 * Validate stylesheet: it should consist of any number (0 or more) of
	 * rulesets (sets of rules with selectors), @-rules, whitespaces or
	 * comments.
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkStylesheet(i){var start=i;var l=undefined;while(i < tokensLength) {if(l = checkSC(i) || checkDeclaration(i) || checkDeclDelim(i) || checkInclude(i) || checkExtend(i) || checkMixin(i) || checkLoop(i) || checkConditionalStatement(i) || checkAtrule(i) || checkRuleset(i))i += l;else throwError(i);}return i - start;} /**
	 * @returns {Array} `['stylesheet', x]` where `x` is all stylesheet's
	 *      nodes.
	 */function getStylesheet(){var startPos=pos;var x=[];while(pos < tokensLength) {if(checkSC(pos))x = x.concat(getSC());else if(checkRuleset(pos))x.push(getRuleset());else if(checkInclude(pos))x.push(getInclude());else if(checkExtend(pos))x.push(getExtend());else if(checkMixin(pos))x.push(getMixin());else if(checkLoop(pos))x.push(getLoop());else if(checkConditionalStatement(pos))x.push(getConditionalStatement());else if(checkAtrule(pos))x.push(getAtrule());else if(checkDeclaration(pos))x.push(getDeclaration());else if(checkDeclDelim(pos))x.push(getDeclDelim());else throwError();}var token=tokens[startPos];return newNode(NodeType.StylesheetType,x,token.ln,token.col);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkTset(i){return checkVhash(i) || checkOperator(i) || checkAny(i) || checkSC(i) || checkInterpolation(i);} /**
	 * @returns {Array}
	 */function getTset(){if(checkVhash(pos))return getVhash();else if(checkOperator(pos))return getOperator();else if(checkAny(pos))return getAny();else if(checkSC(pos))return getSC();else if(checkInterpolation(pos))return getInterpolation();} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkTsets(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;while(l = checkTset(i)) {i += l;}return i - start;} /**
	 * @returns {Array}
	 */function getTsets(){var x=[];var t=undefined;while(t = getTset()) {if(typeof t.content === 'string')x.push(t);else x = x.concat(t);}return x;} /**
	 * Check if token is an unary (arithmetical) sign (`+` or `-`)
	 * @param {Number} i Token's index number
	 * @returns {Number} `1` if token is an unary sign, `0` if not
	 */function checkUnary(i){return i < tokensLength && (tokens[i].type === TokenType.HyphenMinus || tokens[i].type === TokenType.PlusSign)?1:0;} /**
	 * Get node with an unary (arithmetical) sign (`+` or `-`)
	 * @returns {Array} `['unary', x]` where `x` is an unary sign
	 *      converted to string.
	 */function getUnary(){var startPos=pos;var x=tokens[pos++].value;var token=tokens[startPos];return newNode(NodeType.OperatorType,x,token.ln,token.col);} /**
	 * Check if token is part of URI (e.g. `url('/css/styles.css')`)
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of URI
	 */function checkUri(i){var start=i;if(i >= tokensLength || tokens[i++].value !== 'url' || i >= tokensLength || tokens[i].type !== TokenType.LeftParenthesis)return 0;return tokens[i].right - start + 1;} /**
	 * Get node with URI
	 * @returns {Array} `['uri', x]` where `x` is URI's nodes (without `url`
	 *      and braces, e.g. `['string', ''/css/styles.css'']`).
	 */function getUri(){var startPos=pos;var uriExcluding={};var uri=undefined;var token=undefined;var l=undefined;var raw=undefined;pos += 2;uriExcluding[TokenType.Space] = 1;uriExcluding[TokenType.Tab] = 1;uriExcluding[TokenType.Newline] = 1;uriExcluding[TokenType.LeftParenthesis] = 1;uriExcluding[TokenType.RightParenthesis] = 1;if(checkUriContent(pos)){uri = [].concat(getSC()).concat(getUriContent()).concat(getSC());}else {uri = [].concat(getSC());l = checkExcluding(uriExcluding,pos);token = tokens[pos];raw = newNode(NodeType.RawType,joinValues(pos,pos + l),token.ln,token.col);uri.push(raw);pos += l + 1;uri = uri.concat(getSC());}token = tokens[startPos];var line=token.ln;var column=token.col;var end=getLastPosition(uri,line,column,1);pos++;return newNode(NodeType.UriType,uri,token.ln,token.col,end);} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkUriContent(i){return checkUri1(i) || checkFunction(i);} /**
	 * @returns {Array}
	 */function getUriContent(){if(checkUri1(pos))return getString();else if(checkFunction(pos))return getFunction();} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkUri1(i){var start=i;var l=undefined;if(i >= tokensLength)return 0;if(l = checkSC(i))i += l;if(tokens[i].type !== TokenType.StringDQ && tokens[i].type !== TokenType.StringSQ)return 0;i++;if(l = checkSC(i))i += l;return i - start;} /**
	 * Check if token is part of a value
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the value
	 */function checkValue(i){var start=i;var l=undefined;var s=undefined;var _i=undefined;while(i < tokensLength) {if(checkDeclDelim(i))break;s = checkSC(i);_i = i + s;if(l = _checkValue(_i))i += l + s;if(!l || checkBlock(i - l))break;}return i - start;} /**
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function _checkValue(i){return checkInterpolation(i) || checkVariable(i) || checkVhash(i) || checkBlock(i) || checkAtkeyword(i) || checkOperator(i) || checkImportant(i) || checkGlobal(i) || checkDefault(i) || checkProgid(i) || checkAny(i);} /**
	 * @returns {Array}
	 */function getValue(){var startPos=pos;var x=[];var _pos=undefined;var s=undefined;while(pos < tokensLength) {s = checkSC(pos);_pos = pos + s;if(checkDeclDelim(_pos))break;if(!_checkValue(_pos))break;if(s)x = x.concat(getSC());x.push(_getValue());if(checkBlock(_pos))break;}var token=tokens[startPos];return newNode(NodeType.ValueType,x,token.ln,token.col);} /**
	 * @returns {Array}
	 */function _getValue(){if(checkInterpolation(pos))return getInterpolation();else if(checkVariable(pos))return getVariable();else if(checkVhash(pos))return getVhash();else if(checkBlock(pos))return getBlock();else if(checkAtkeyword(pos))return getAtkeyword();else if(checkOperator(pos))return getOperator();else if(checkImportant(pos))return getImportant();else if(checkGlobal(pos))return getGlobal();else if(checkDefault(pos))return getDefault();else if(checkProgid(pos))return getProgid();else if(checkAny(pos))return getAny();} /**
	 * Check if token is part of a variable
	 * @param {Number} i Token's index number
	 * @returns {Number} Length of the variable
	 */function checkVariable(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.DollarSign)return 0;return (l = checkIdent(i + 1))?l + 1:0;} /**
	 * Get node with a variable
	 * @returns {Array} `['variable', ['ident', x]]` where `x` is
	 *      a variable name.
	 */function getVariable(){var startPos=pos;var x=[];pos++;x.push(getIdent());var token=tokens[startPos];return newNode(NodeType.VariableType,x,token.ln,token.col);} /**
	 * Check if token is part of a variables list (e.g. `$values...`).
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkVariablesList(i){var d=0; // Number of dots
	var l=undefined;if(i >= tokensLength)return 0;if(l = checkVariable(i))i += l;else return 0;while(i < tokensLength && tokens[i].type === TokenType.FullStop) {d++;i++;}return d === 3?l + d:0;} /**
	 * Get node with a variables list
	 * @returns {Array} `['variableslist', ['variable', ['ident', x]]]` where
	 *      `x` is a variable name.
	 */function getVariablesList(){var startPos=pos;var x=getVariable();var token=tokens[startPos];var line=token.ln;var column=token.col;var end=getLastPosition([x],line,column,3);pos += 3;return newNode(NodeType.VariablesListType,[x],token.ln,token.col,end);} /**
	 * Check if token is part of a hexadecimal number (e.g. `#fff`) inside
	 *      some value
	 * @param {Number} i Token's index number
	 * @returns {Number}
	 */function checkVhash(i){var l;if(i >= tokensLength || tokens[i].type !== TokenType.NumberSign)return 0;return (l = checkNmName2(i + 1))?l + 1:0;} /**
	 * Get node with a hexadecimal number (e.g. `#fff`) inside some value
	 * @returns {Array} `['vhash', x]` where `x` is a hexadecimal number
	 *      converted to string (without `#`, e.g. `'fff'`).
	 */function getVhash(){var startPos=pos;var x=undefined;var token=tokens[startPos];var line=token.ln;var column=token.col;pos++;x = getNmName2();var end=getLastPosition(x,line,column + 1);return newNode(NodeType.VhashType,x,token.ln,token.col,end);}module.exports = function(_tokens,context){tokens = _tokens;tokensLength = tokens.length;pos = 0;return contexts[context]();};function checkSelectorsGroup(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkSelector(i))i += l;else return 0;while(i < tokensLength) {var sb=checkSC(i);var c=checkDelim(i + sb);if(!c)break;var sa=checkSC(i + sb + c);if(l = checkSelector(i + sb + c + sa))i += sb + c + sa + l;else break;}tokens[start].selectorsGroupEnd = i;return i - start;}function getSelectorsGroup(){var selectorsGroup=[];var selectorsGroupEnd=tokens[pos].selectorsGroupEnd;selectorsGroup.push(getSelector());while(pos < selectorsGroupEnd) {selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getDelim());selectorsGroup = selectorsGroup.concat(getSC());selectorsGroup.push(getSelector());}return selectorsGroup;}function checkSelector(i){var l;if(l = checkSelector1(i))tokens[i].selectorType = 1;else if(l = checkSelector2(i))tokens[i].selectorType = 2;return l;}function getSelector(){var selectorType=tokens[pos].selectorType;if(selectorType === 1)return getSelector1();else return getSelector2();} /**
	 * Checks for selector which starts with a compound selector.
	 */function checkSelector1(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkCompoundSelector(i))i += l;else return 0;while(i < tokensLength) {var s=checkSC(i);var c=checkCombinator(i + s);if(!s && !c)break;if(c){i += s + c;s = checkSC(i);}if(l = checkCompoundSelector(i + s))i += s + l;else break;}tokens[start].selectorEnd = i;return i - start;}function getSelector1(){var type=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var selectorEnd=token.selectorEnd;var content=getCompoundSelector();while(pos < selectorEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkCombinator(pos))content.push(getCombinator());else if(checkCompoundSelector(pos))content = content.concat(getCompoundSelector());}return newNode(type,content,line,column);} /**
	 * Checks for a selector that starts with a combinator.
	 */function checkSelector2(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkCombinator(i))i += l;else return 0;while(i < tokensLength) {var sb=checkSC(i);if(l = checkCompoundSelector(i + sb))i += sb + l;else break;var sa=checkSC(i);var c=checkCombinator(i + sa);if(!sa && !c)break;if(c){i += sa + c;}}tokens[start].selectorEnd = i;return i - start;}function getSelector2(){var type=NodeType.SelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var selectorEnd=token.selectorEnd;var content=[getCombinator()];while(pos < selectorEnd) {if(checkSC(pos))content = content.concat(getSC());else if(checkCombinator(pos))content.push(getCombinator());else if(checkCompoundSelector(pos))content = content.concat(getCompoundSelector());}return newNode(type,content,line,column);}function checkCompoundSelector(i){var l=undefined;if(l = checkCompoundSelector1(i)){tokens[i].compoundSelectorType = 1;}else if(l = checkCompoundSelector2(i)){tokens[i].compoundSelectorType = 2;}return l;}function getCompoundSelector(){var type=tokens[pos].compoundSelectorType;if(type === 1)return getCompoundSelector1();if(type === 2)return getCompoundSelector2();}function checkCompoundSelector1(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkTypeSelector(i) || checkPlaceholder(i) || checkParentSelectorWithExtension(i))i += l;else return 0;while(i < tokensLength) {var _l2=checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i) || checkPlaceholder(i);if(_l2)i += _l2;else break;}tokens[start].compoundSelectorEnd = i;return i - start;}function getCompoundSelector1(){var sequence=[];var compoundSelectorEnd=tokens[pos].compoundSelectorEnd;if(checkTypeSelector(pos))sequence.push(getTypeSelector());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());else if(checkParentSelectorWithExtension(pos))sequence = sequence.concat(getParentSelectorWithExtension());while(pos < compoundSelectorEnd) {if(checkShash(pos))sequence.push(getShash());else if(checkClass(pos))sequence.push(getClass());else if(checkAttributeSelector(pos))sequence.push(getAttributeSelector());else if(checkPseudo(pos))sequence.push(getPseudo());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());}return sequence;}function checkCompoundSelector2(i){if(i >= tokensLength)return 0;var start=i;while(i < tokensLength) {var l=checkShash(i) || checkClass(i) || checkAttributeSelector(i) || checkPseudo(i) || checkPlaceholder(i);if(l)i += l;else break;}tokens[start].compoundSelectorEnd = i;return i - start;}function getCompoundSelector2(){var sequence=[];var compoundSelectorEnd=tokens[pos].compoundSelectorEnd;while(pos < compoundSelectorEnd) {if(checkShash(pos))sequence.push(getShash());else if(checkClass(pos))sequence.push(getClass());else if(checkAttributeSelector(pos))sequence.push(getAttributeSelector());else if(checkPseudo(pos))sequence.push(getPseudo());else if(checkPlaceholder(pos))sequence.push(getPlaceholder());}return sequence;}function checkTypeSelector(i){if(i >= tokensLength)return 0;var start=i;var l=undefined;if(l = checkNamePrefix(i))i += l;if(tokens[i].type === TokenType.Asterisk)i++;else if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getTypeSelector(){var type=NodeType.TypeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkNamePrefix(pos))content.push(getNamePrefix());if(checkIdentOrInterpolation(pos))content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeSelector(i){var l=undefined;if(l = checkAttributeSelector1(i))tokens[i].attributeSelectorType = 1;else if(l = checkAttributeSelector2(i))tokens[i].attributeSelectorType = 2;return l;}function getAttributeSelector(){var type=tokens[pos].attributeSelectorType;if(type === 1)return getAttributeSelector1();else return getAttributeSelector2();} /**
	 * (1) `[panda=nani]`
	 * (2) `[panda='nani']`
	 * (3) `[panda='nani' i]`
	 *
	 */function checkAttributeSelector1(i){var start=i;if(tokens[i].type === TokenType.LeftSquareBracket)i++;else return 0;var l=undefined;if(l = checkSC(i))i += l;if(l = checkAttributeName(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeMatch(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeValue(i))i += l;else return 0;if(l = checkSC(i))i += l;if(l = checkAttributeFlags(i)){i += l;if(l = checkSC(i))i += l;}if(tokens[i].type === TokenType.RightSquareBracket)i++;else return 0;return i - start;}function getAttributeSelector1(){var type=NodeType.AttributeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `[`.
	pos++;content = content.concat(getSC());content.push(getAttributeName());content = content.concat(getSC());content.push(getAttributeMatch());content = content.concat(getSC());content.push(getAttributeValue());content = content.concat(getSC());if(checkAttributeFlags(pos)){content.push(getAttributeFlags());content = content.concat(getSC());} // Skip `]`.
	pos++;var end=getLastPosition(content,line,column,1);return newNode(type,content,line,column,end);} /**
	 * (1) `[panda]`
	 */function checkAttributeSelector2(i){var start=i;if(tokens[i].type === TokenType.LeftSquareBracket)i++;else return 0;var l=undefined;if(l = checkSC(i))i += l;if(l = checkAttributeName(i))i += l;else return 0;if(l = checkSC(i))i += l;if(tokens[i].type === TokenType.RightSquareBracket)i++;else return 0;return i - start;}function getAttributeSelector2(){var type=NodeType.AttributeSelectorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[]; // Skip `[`.
	pos++;content = content.concat(getSC());content.push(getAttributeName());content = content.concat(getSC()); // Skip `]`.
	pos++;var end=getLastPosition(content,line,column,1);return newNode(type,content,line,column,end);}function checkAttributeName(i){var start=i;var l=undefined;if(l = checkNamePrefix(i))i += l;if(l = checkIdentOrInterpolation(i))i += l;else return 0;return i - start;}function getAttributeName(){var type=NodeType.AttributeNameType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkNamePrefix(pos))content.push(getNamePrefix());content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeMatch(i){var l=undefined;if(l = checkAttributeMatch1(i))tokens[i].attributeMatchType = 1;else if(l = checkAttributeMatch2(i))tokens[i].attributeMatchType = 2;return l;}function getAttributeMatch(){var type=tokens[pos].attributeMatchType;if(type === 1)return getAttributeMatch1();else return getAttributeMatch2();}function checkAttributeMatch1(i){var start=i;var type=tokens[i].type;if(type === TokenType.Tilde || type === TokenType.VerticalLine || type === TokenType.CircumflexAccent || type === TokenType.DollarSign || type === TokenType.Asterisk)i++;else return 0;if(tokens[i].type === TokenType.EqualsSign)i++;else return 0;return i - start;}function getAttributeMatch1(){var type=NodeType.AttributeMatchType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=tokens[pos].value + tokens[pos + 1].value;pos += 2;return newNode(type,content,line,column);}function checkAttributeMatch2(i){if(tokens[i].type === TokenType.EqualsSign)return 1;else return 0;}function getAttributeMatch2(){var type=NodeType.AttributeMatchType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='=';pos++;return newNode(type,content,line,column);}function checkAttributeValue(i){return checkString(i) || checkIdentOrInterpolation(i);}function getAttributeValue(){var type=NodeType.AttributeValueType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkString(pos))content.push(getString());else content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);}function checkAttributeFlags(i){return checkIdentOrInterpolation(i);}function getAttributeFlags(){var type=NodeType.AttributeFlagsType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=getIdentOrInterpolation();return newNode(type,content,line,column);}function checkNamePrefix(i){if(i >= tokensLength)return 0;var l=undefined;if(l = checkNamePrefix1(i))tokens[i].namePrefixType = 1;else if(l = checkNamePrefix2(i))tokens[i].namePrefixType = 2;return l;}function getNamePrefix(){var type=tokens[pos].namePrefixType;if(type === 1)return getNamePrefix1();else return getNamePrefix2();} /**
	 * (1) `panda|`
	 * (2) `panda<comment>|`
	 */function checkNamePrefix1(i){var start=i;var l=undefined;if(l = checkNamespacePrefix(i))i += l;else return 0;if(l = checkCommentML(i))i += l;if(l = checkNamespaceSeparator(i))i += l;else return 0;return i - start;}function getNamePrefix1(){var type=NodeType.NamePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];content.push(getNamespacePrefix());if(checkCommentML(pos))content.push(getCommentML());content.push(getNamespaceSeparator());return newNode(type,content,line,column);} /**
	 * (1) `|`
	 */function checkNamePrefix2(i){return checkNamespaceSeparator(i);}function getNamePrefix2(){var type=NodeType.NamePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[getNamespaceSeparator()];return newNode(type,content,line,column);} /**
	 * (1) `*`
	 * (2) `panda`
	 */function checkNamespacePrefix(i){if(i >= tokensLength)return 0;var l=undefined;if(tokens[i].type === TokenType.Asterisk)return 1;else if(l = checkIdentOrInterpolation(i))return l;else return 0;}function getNamespacePrefix(){var type=NodeType.NamespacePrefixType;var token=tokens[pos];var line=token.ln;var column=token.col;var content=[];if(checkIdentOrInterpolation(pos))content = content.concat(getIdentOrInterpolation());return newNode(type,content,line,column);} /**
	 * (1) `|`
	 */function checkNamespaceSeparator(i){if(i >= tokensLength)return 0;if(tokens[i].type === TokenType.VerticalLine)return 1;else return 0;}function getNamespaceSeparator(){var type=NodeType.NamespaceSeparatorType;var token=tokens[pos];var line=token.ln;var column=token.col;var content='|';pos++;return newNode(type,content,line,column);}

/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';

	module.exports = {
	  ArgumentsType: 'arguments',
	  AtkeywordType: 'atkeyword',
	  AtruleType: 'atrule',
	  AttributeSelectorType: 'attributeSelector',
	  AttributeNameType: 'attributeName',
	  AttributeFlagsType: 'attributeFlags',
	  AttributeMatchType: 'attributeMatch',
	  AttributeValueType: 'attributeValue',
	  BlockType: 'block',
	  BracketsType: 'brackets',
	  ClassType: 'class',
	  CombinatorType: 'combinator',
	  CommentMLType: 'multilineComment',
	  CommentSLType: 'singlelineComment',
	  ConditionType: 'condition',
	  ConditionalStatementType: 'conditionalStatement',
	  DeclarationType: 'declaration',
	  DeclDelimType: 'declarationDelimiter',
	  DefaultType: 'default',
	  DelimType: 'delimiter',
	  DimensionType: 'dimension',
	  EscapedStringType: 'escapedString',
	  ExtendType: 'extend',
	  ExpressionType: 'expression',
	  FunctionType: 'function',
	  GlobalType: 'global',
	  IdentType: 'ident',
	  ImportantType: 'important',
	  IncludeType: 'include',
	  InterpolationType: 'interpolation',
	  InterpolatedVariableType: 'interpolatedVariable',
	  KeyframesSelectorType: 'keyframesSelector',
	  LoopType: 'loop',
	  MixinType: 'mixin',
	  NamePrefixType: 'namePrefix',
	  NamespacePrefixType: 'namespacePrefix',
	  NamespaceSeparatorType: 'namespaceSeparator',
	  NumberType: 'number',
	  OperatorType: 'operator',
	  OptionalType: 'optional',
	  ParenthesesType: 'parentheses',
	  ParentSelectorType: 'parentSelector',
	  ParentSelectorExtensionType: 'parentSelectorExtension',
	  PercentageType: 'percentage',
	  PlaceholderType: 'placeholder',
	  ProgidType: 'progid',
	  PropertyType: 'property',
	  PropertyDelimType: 'propertyDelimiter',
	  PseudocType: 'pseudoClass',
	  PseudoeType: 'pseudoElement',
	  RawType: 'raw',
	  RulesetType: 'ruleset',
	  SType: 'space',
	  SelectorType: 'selector',
	  ShashType: 'id',
	  StringType: 'string',
	  StylesheetType: 'stylesheet',
	  TypeSelectorType: 'typeSelector',
	  UriType: 'uri',
	  ValueType: 'value',
	  VariableType: 'variable',
	  VariablesListType: 'variablesList',
	  VhashType: 'color'
	};

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = function (css, tabSize) {
	  var TokenType = __webpack_require__(12);

	  var tokens = [];
	  var urlMode = false;
	  var blockMode = 0;
	  var c = undefined; // Current character
	  var cn = undefined; // Next character
	  var pos = 0;
	  var tn = 0;
	  var ln = 1;
	  var col = 1;

	  var Punctuation = {
	    ' ': TokenType.Space,
	    '\n': TokenType.Newline,
	    '\r': TokenType.Newline,
	    '\t': TokenType.Tab,
	    '!': TokenType.ExclamationMark,
	    '"': TokenType.QuotationMark,
	    '#': TokenType.NumberSign,
	    '$': TokenType.DollarSign,
	    '%': TokenType.PercentSign,
	    '&': TokenType.Ampersand,
	    '\'': TokenType.Apostrophe,
	    '(': TokenType.LeftParenthesis,
	    ')': TokenType.RightParenthesis,
	    '*': TokenType.Asterisk,
	    '+': TokenType.PlusSign,
	    ',': TokenType.Comma,
	    '-': TokenType.HyphenMinus,
	    '.': TokenType.FullStop,
	    '/': TokenType.Solidus,
	    ':': TokenType.Colon,
	    ';': TokenType.Semicolon,
	    '<': TokenType.LessThanSign,
	    '=': TokenType.EqualsSign,
	    '==': TokenType.EqualitySign,
	    '!=': TokenType.InequalitySign,
	    '>': TokenType.GreaterThanSign,
	    '?': TokenType.QuestionMark,
	    '@': TokenType.CommercialAt,
	    '[': TokenType.LeftSquareBracket,
	    ']': TokenType.RightSquareBracket,
	    '^': TokenType.CircumflexAccent,
	    '_': TokenType.LowLine,
	    '{': TokenType.LeftCurlyBracket,
	    '|': TokenType.VerticalLine,
	    '}': TokenType.RightCurlyBracket,
	    '~': TokenType.Tilde
	  };

	  /**
	   * Add a token to the token list
	   * @param {string} type
	   * @param {string} value
	   */
	  function pushToken(type, value, column) {
	    tokens.push({
	      tn: tn++,
	      ln: ln,
	      col: column,
	      type: type,
	      value: value
	    });
	  }

	  /**
	   * Check if a character is a decimal digit
	   * @param {string} c Character
	   * @returns {boolean}
	   */
	  function isDecimalDigit(c) {
	    return '0123456789'.indexOf(c) >= 0;
	  }

	  /**
	   * Parse spaces
	   * @param {string} css Unparsed part of CSS string
	   */
	  function parseSpaces(css) {
	    var start = pos;

	    // Read the string until we meet a non-space character:
	    for (; pos < css.length; pos++) {
	      if (css.charAt(pos) !== ' ') break;
	    }

	    // Add a substring containing only spaces to tokens:
	    pushToken(TokenType.Space, css.substring(start, pos--), col);
	    col += pos - start;
	  }

	  /**
	   * Parse a string within quotes
	   * @param {string} css Unparsed part of CSS string
	   * @param {string} q Quote (either `'` or `"`)
	   */
	  function parseString(css, q) {
	    var start = pos;

	    // Read the string until we meet a matching quote:
	    for (pos++; pos < css.length; pos++) {
	      // Skip escaped quotes:
	      if (css.charAt(pos) === '\\') pos++;else if (css.charAt(pos) === q) break;
	    }

	    // Add the string (including quotes) to tokens:
	    var type = q === '"' ? TokenType.StringDQ : TokenType.StringSQ;
	    pushToken(type, css.substring(start, pos + 1), col);
	    col += pos - start;
	  }

	  /**
	   * Parse numbers
	   * @param {string} css Unparsed part of CSS string
	   */
	  function parseDecimalNumber(css) {
	    var start = pos;

	    // Read the string until we meet a character that's not a digit:
	    for (; pos < css.length; pos++) {
	      if (!isDecimalDigit(css.charAt(pos))) break;
	    }

	    // Add the number to tokens:
	    pushToken(TokenType.DecimalNumber, css.substring(start, pos--), col);
	    col += pos - start;
	  }

	  /**
	   * Parse identifier
	   * @param {string} css Unparsed part of CSS string
	   */
	  function parseIdentifier(css) {
	    var start = pos;

	    // Skip all opening slashes:
	    while (css.charAt(pos) === '/') pos++;

	    // Read the string until we meet a punctuation mark:
	    for (; pos < css.length; pos++) {
	      // Skip all '\':
	      if (css.charAt(pos) === '\\') pos++;else if (css.charAt(pos) in Punctuation) break;
	    }

	    var ident = css.substring(start, pos--);

	    // Enter url mode if parsed substring is `url`:
	    if (!urlMode && ident === 'url' && css.charAt(pos + 1) === '(') {
	      urlMode = true;
	    }

	    // Add identifier to tokens:
	    pushToken(TokenType.Identifier, ident, col);
	    col += pos - start;
	  }

	  /**
	   * Parse equality sign
	   */
	  function parseEquality() {
	    pushToken(TokenType.EqualitySign, '==', col);
	    pos++;
	    col++;
	  }

	  /**
	   * Parse inequality sign
	   */
	  function parseInequality() {
	    pushToken(TokenType.InequalitySign, '!=', col);
	    pos++;
	    col++;
	  }

	  /**
	  * Parse a multiline comment
	  * @param {string} css Unparsed part of CSS string
	  */
	  function parseMLComment(css) {
	    var start = pos;

	    // Read the string until we meet `*/`.
	    // Since we already know first 2 characters (`/*`), start reading
	    // from `pos + 2`:
	    for (pos += 2; pos < css.length; pos++) {
	      if (css.charAt(pos) === '*' && css.charAt(pos + 1) === '/') {
	        pos++;
	        break;
	      }
	    }

	    // Add full comment (including `/*` and `*/`) to the list of tokens:
	    var comment = css.substring(start, pos + 1);
	    pushToken(TokenType.CommentML, comment, col);

	    var newlines = comment.split('\n');
	    if (newlines.length > 1) {
	      ln += newlines.length - 1;
	      col = newlines[newlines.length - 1].length;
	    } else {
	      col += pos - start;
	    }
	  }

	  /**
	  * Parse a single line comment
	  * @param {string} css Unparsed part of CSS string
	  */
	  function parseSLComment(css) {
	    var start = pos;

	    // Read the string until we meet line break.
	    // Since we already know first 2 characters (`//`), start reading
	    // from `pos + 2`:
	    for (pos += 2; pos < css.length; pos++) {
	      if (css.charAt(pos) === '\n' || css.charAt(pos) === '\r') {
	        break;
	      }
	    }

	    // Add comment (including `//` and line break) to the list of tokens:
	    pushToken(TokenType.CommentSL, css.substring(start, pos--), col);
	    col += pos - start;
	  }

	  /**
	   * Convert a CSS string to a list of tokens
	   * @param {string} css CSS string
	   * @returns {Array} List of tokens
	   * @private
	   */
	  function getTokens(css) {
	    // Parse string, character by character:
	    for (pos = 0; pos < css.length; col++, pos++) {
	      c = css.charAt(pos);
	      cn = css.charAt(pos + 1);

	      // If we meet `/*`, it's a start of a multiline comment.
	      // Parse following characters as a multiline comment:
	      if (c === '/' && cn === '*') {
	        parseMLComment(css);
	      }

	      // If we meet `//` and it is not a part of url:
	      else if (!urlMode && c === '/' && cn === '/') {
	          // If we're currently inside a block, treat `//` as a start
	          // of identifier. Else treat `//` as a start of a single-line
	          // comment:
	          parseSLComment(css);
	        }

	        // If current character is a double or single quote, it's a start
	        // of a string:
	        else if (c === '"' || c === "'") {
	            parseString(css, c);
	          }

	          // If current character is a space:
	          else if (c === ' ') {
	              parseSpaces(css);
	            }

	            // If current character is `=`, it must be combined with next `=`
	            else if (c === '=' && cn === '=') {
	                parseEquality(css);
	              }

	              // If we meet `!=`, this must be inequality
	              else if (c === '!' && cn === '=') {
	                  parseInequality(css);
	                }

	                // If current character is a punctuation mark:
	                else if (c in Punctuation) {
	                    // Check for CRLF here or just LF
	                    if (c === '\r' && cn === '\n' || c === '\n') {
	                      // If \r we know the next character is \n due to statement above
	                      // so we push a CRLF token type to the token list and importantly
	                      // skip the next character so as not to double count newlines or
	                      // columns etc
	                      if (c === '\r') {
	                        pushToken(TokenType.Newline, '\r\n', col);
	                        pos++; // If CRLF skip the next character and push crlf token
	                      } else if (c === '\n') {
	                          // If just a LF newline and not part of CRLF newline we can just
	                          // push punctuation as usual
	                          pushToken(Punctuation[c], c, col);
	                        }

	                      ln++; // Go to next line
	                      col = 0; // Reset the column count
	                    } else if (c !== '\r' && c !== '\n') {
	                        // Handle all other punctuation and add to list of tokens
	                        pushToken(Punctuation[c], c, col);
	                      } // Go to next line
	                    if (c === ')') urlMode = false; // Exit url mode
	                    if (c === '{') blockMode++; // Enter a block
	                    if (c === '}') blockMode--; // Exit a block
	                    else if (c === '\t' && tabSize > 1) col += tabSize - 1;
	                  }

	                  // If current character is a decimal digit:
	                  else if (isDecimalDigit(c)) {
	                      parseDecimalNumber(css);
	                    }

	                    // If current character is anything else:
	                    else {
	                        parseIdentifier(css);
	                      }
	    }

	    return tokens;
	  }

	  return getTokens(css);
	};

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Node = __webpack_require__(1);
	var NodeTypes = __webpack_require__(14);

	module.exports = function () {
	  return new Node({
	    type: NodeTypes.StylesheetType,
	    content: [],
	    start: [0, 0],
	    end: [0, 0]
	  });
	};

/***/ }
/******/ ])
});
;
},{}],217:[function(require,module,exports){
/*
 * Copyright (C) 2007 Apple Inc.  All rights reserved.
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// FIXME: This performance optimization should be moved to blink so that all developers could enjoy it.
// console is retrieved with V8Window.getAttribute method which is slow. Here we copy it to a js variable for faster access.
console = console;
console.__originalAssert = console.assert;
console.assert = function(value, message)
{
    if (value)
        return;
    console.__originalAssert(value, message);
}

/** @typedef {Array|NodeList|Arguments|{length: number}} */
var ArrayLike;

/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
function mod(m, n)
{
    return ((m % n) + n) % n;
}

/**
 * @param {string} string
 * @return {!Array.<number>}
 */
String.prototype.findAll = function(string)
{
    var matches = [];
    var i = this.indexOf(string);
    while (i !== -1) {
        matches.push(i);
        i = this.indexOf(string, i + string.length);
    }
    return matches;
}

/**
 * @return {string}
 */
String.prototype.replaceControlCharacters = function()
{
    // Replace C0 and C1 control character sets with printable character.
    // Do not replace '\t', \n' and '\r'.
    return this.replace(/[\u0000-\u0008\u000b\u000c\u000e-\u001f\u0080-\u009f]/g, "�");
}

/**
 * @return {boolean}
 */
String.prototype.isWhitespace = function()
{
    return /^\s*$/.test(this);
}

/**
 * @return {!Array.<number>}
 */
String.prototype.computeLineEndings = function()
{
    var endings = this.findAll("\n");
    endings.push(this.length);
    return endings;
}

/**
 * @param {string} chars
 * @return {string}
 */
String.prototype.escapeCharacters = function(chars)
{
    var foundChar = false;
    for (var i = 0; i < chars.length; ++i) {
        if (this.indexOf(chars.charAt(i)) !== -1) {
            foundChar = true;
            break;
        }
    }

    if (!foundChar)
        return String(this);

    var result = "";
    for (var i = 0; i < this.length; ++i) {
        if (chars.indexOf(this.charAt(i)) !== -1)
            result += "\\";
        result += this.charAt(i);
    }

    return result;
}

/**
 * @return {string}
 */
String.regexSpecialCharacters = function()
{
    return "^[]{}()\\.^$*+?|-,";
}

/**
 * @return {string}
 */
String.prototype.escapeForRegExp = function()
{
    return this.escapeCharacters(String.regexSpecialCharacters());
}

/**
 * @return {string}
 */
String.prototype.escapeHTML = function()
{
    return this.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;"); // " doublequotes just for editor
}

/**
 * @return {string}
 */
String.prototype.unescapeHTML = function()
{
    return this.replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&#58;/g, ":")
        .replace(/&quot;/g, "\"")
        .replace(/&#60;/g, "<")
        .replace(/&#62;/g, ">")
        .replace(/&amp;/g, "&");
}

/**
 * @return {string}
 */
String.prototype.collapseWhitespace = function()
{
    return this.replace(/[\s\xA0]+/g, " ");
}

/**
 * @param {number} maxLength
 * @return {string}
 */
String.prototype.trimMiddle = function(maxLength)
{
    if (this.length <= maxLength)
        return String(this);
    var leftHalf = maxLength >> 1;
    var rightHalf = maxLength - leftHalf - 1;
    return this.substr(0, leftHalf) + "\u2026" + this.substr(this.length - rightHalf, rightHalf);
}

/**
 * @param {number} maxLength
 * @return {string}
 */
String.prototype.trimEnd = function(maxLength)
{
    if (this.length <= maxLength)
        return String(this);
    return this.substr(0, maxLength - 1) + "\u2026";
}

/**
 * @param {?string=} baseURLDomain
 * @return {string}
 */
String.prototype.trimURL = function(baseURLDomain)
{
    var result = this.replace(/^(https|http|file):\/\//i, "");
    if (baseURLDomain) {
        if (result.toLowerCase().startsWith(baseURLDomain.toLowerCase()))
            result = result.substr(baseURLDomain.length);
    }
    return result;
}

/**
 * @return {string}
 */
String.prototype.toTitleCase = function()
{
    return this.substring(0, 1).toUpperCase() + this.substring(1);
}

/**
 * @param {string} other
 * @return {number}
 */
String.prototype.compareTo = function(other)
{
    if (this > other)
        return 1;
    if (this < other)
        return -1;
    return 0;
}

/**
 * @return {string}
 */
String.prototype.removeURLFragment = function()
{
    var fragmentIndex = this.indexOf("#");
    if (fragmentIndex === -1)
        fragmentIndex = this.length;
    return this.substring(0, fragmentIndex);
}

/**
 * @param {string|undefined} string
 * @return {number}
 */
String.hashCode = function(string)
{
    if (!string)
        return 0;
    // Hash algorithm for substrings is described in "Über die Komplexität der Multiplikation in
    // eingeschränkten Branchingprogrammmodellen" by Woelfe.
    // http://opendatastructures.org/versions/edition-0.1d/ods-java/node33.html#SECTION00832000000000000000
    var p = ((1 << 30) * 4 - 5); // prime: 2^32 - 5
    var z = 0x5033d967;          // 32 bits from random.org
    var z2 = 0x59d2f15d;         // random odd 32 bit number
    var s = 0;
    var zi = 1;
    for (var i = 0; i < string.length; i++) {
        var xi = string.charCodeAt(i) * z2;
        s = (s + zi * xi) % p;
        zi = (zi * z) % p;
    }
    s = (s + zi * (p - 1)) % p;
    return Math.abs(s | 0);
}

/**
 * @param {string} string
 * @param {number} index
 * @return {boolean}
 */
String.isDigitAt = function(string, index)
{
    var c = string.charCodeAt(index);
    return (48 <= c && c <= 57);
}

/**
 * @return {string}
 */
String.prototype.toBase64 = function()
{
    /**
     * @param {number} b
     * @return {number}
     */
    function encodeBits(b)
    {
        return b < 26 ? b + 65 : b < 52 ? b + 71 : b < 62 ? b - 4 : b === 62 ? 43 : b === 63 ? 47 : 65;
    }
    var encoder = new TextEncoder();
    var data = encoder.encode(this.toString());
    var n = data.length;
    var encoded = "";
    if (n === 0)
        return encoded;
    var shift;
    var v = 0;
    for (var i = 0; i < n; i++) {
        shift = i % 3;
        v |= data[i] << (16 >>> shift & 24);
        if (shift === 2) {
            encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), encodeBits(v & 63));
            v = 0;
        }
    }
    if (shift === 0)
        encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), 61, 61);
    else if (shift === 1)
        encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), 61);
    return encoded;
}

/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
String.naturalOrderComparator = function(a, b)
{
    var chunk = /^\d+|^\D+/;
    var chunka, chunkb, anum, bnum;
    while (1) {
        if (a) {
            if (!b)
                return 1;
        } else {
            if (b)
                return -1;
            else
                return 0;
        }
        chunka = a.match(chunk)[0];
        chunkb = b.match(chunk)[0];
        anum = !isNaN(chunka);
        bnum = !isNaN(chunkb);
        if (anum && !bnum)
            return -1;
        if (bnum && !anum)
            return 1;
        if (anum && bnum) {
            var diff = chunka - chunkb;
            if (diff)
                return diff;
            if (chunka.length !== chunkb.length) {
                if (!+chunka && !+chunkb) // chunks are strings of all 0s (special case)
                    return chunka.length - chunkb.length;
                else
                    return chunkb.length - chunka.length;
            }
        } else if (chunka !== chunkb)
            return (chunka < chunkb) ? -1 : 1;
        a = a.substring(chunka.length);
        b = b.substring(chunkb.length);
    }
}

/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */
String.caseInsensetiveComparator = function(a, b)
{
    a = a.toUpperCase();
    b = b.toUpperCase();
    if (a === b)
        return 0;
    return a > b ? 1 : -1;
}

/**
 * @param {number} num
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
Number.constrain = function(num, min, max)
{
    if (num < min)
        num = min;
    else if (num > max)
        num = max;
    return num;
}

/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
Number.gcd = function(a, b)
{
    if (b === 0)
        return a;
    else
        return Number.gcd(b, a % b);
}

/**
 * @param {string} value
 * @return {string}
 */
Number.toFixedIfFloating = function(value)
{
    if (!value || isNaN(value))
        return value;
    var number = Number(value);
    return number % 1 ? number.toFixed(3) : String(number);
}

/**
 * @return {string}
 */
Date.prototype.toISO8601Compact = function()
{
    /**
     * @param {number} x
     * @return {string}
     */
    function leadZero(x)
    {
        return (x > 9 ? "" : "0") + x;
    }
    return this.getFullYear() +
           leadZero(this.getMonth() + 1) +
           leadZero(this.getDate()) + "T" +
           leadZero(this.getHours()) +
           leadZero(this.getMinutes()) +
           leadZero(this.getSeconds());
}

/**
 * @return {string}
 */
Date.prototype.toConsoleTime = function()
{
    /**
     * @param {number} x
     * @return {string}
     */
    function leadZero2(x)
    {
        return (x > 9 ? "" : "0") + x;
    }

    /**
     * @param {number} x
     * @return {string}
     */
    function leadZero3(x)
    {
        return "0".repeat(3 - x.toString().length) + x;
    }

    return this.getFullYear() + "-" +
           leadZero2(this.getMonth() + 1) + "-" +
           leadZero2(this.getDate()) + " " +
           leadZero2(this.getHours()) + ":" +
           leadZero2(this.getMinutes()) + ":" +
           leadZero2(this.getSeconds()) + "." +
           leadZero3(this.getMilliseconds());
}

Object.defineProperty(Array.prototype, "remove", {
    /**
     * @param {!T} value
     * @param {boolean=} firstOnly
     * @return {boolean}
     * @this {Array.<!T>}
     * @template T
     */
    value: function(value, firstOnly)
    {
        var index = this.indexOf(value);
        if (index === -1)
            return false;
        if (firstOnly) {
            this.splice(index, 1);
            return true;
        }
        for (var i = index + 1, n = this.length; i < n; ++i) {
            if (this[i] !== value)
                this[index++] = this[i];
        }
        this.length = index;
        return true;
    }
});

Object.defineProperty(Array.prototype, "pushAll", {
    /**
     * @param {!Array.<!T>} array
     * @this {Array.<!T>}
     * @template T
     */
    value: function(array)
    {
        Array.prototype.push.apply(this, array);
    }
});

Object.defineProperty(Array.prototype, "rotate", {
    /**
     * @param {number} index
     * @return {!Array.<!T>}
     * @this {Array.<!T>}
     * @template T
     */
    value: function(index)
    {
        var result = [];
        for (var i = index; i < index + this.length; ++i)
            result.push(this[i % this.length]);
        return result;
    }
});

Object.defineProperty(Array.prototype, "sortNumbers", {
    /**
     * @this {Array.<number>}
     */
    value: function()
    {
        /**
         * @param {number} a
         * @param {number} b
         * @return {number}
         */
        function numericComparator(a, b)
        {
            return a - b;
        }

        this.sort(numericComparator);
    }
});

Object.defineProperty(Uint32Array.prototype, "sort", {
    value: Array.prototype.sort
});

(function() {
    var partition = {
        /**
         * @this {Array.<number>}
         * @param {function(number, number): number} comparator
         * @param {number} left
         * @param {number} right
         * @param {number} pivotIndex
         */
        value: function(comparator, left, right, pivotIndex)
        {
            function swap(array, i1, i2)
            {
                var temp = array[i1];
                array[i1] = array[i2];
                array[i2] = temp;
            }

            var pivotValue = this[pivotIndex];
            swap(this, right, pivotIndex);
            var storeIndex = left;
            for (var i = left; i < right; ++i) {
                if (comparator(this[i], pivotValue) < 0) {
                    swap(this, storeIndex, i);
                    ++storeIndex;
                }
            }
            swap(this, right, storeIndex);
            return storeIndex;
        }
    };
    Object.defineProperty(Array.prototype, "partition", partition);
    Object.defineProperty(Uint32Array.prototype, "partition", partition);

    var sortRange = {
        /**
         * @param {function(number, number): number} comparator
         * @param {number} leftBound
         * @param {number} rightBound
         * @param {number} sortWindowLeft
         * @param {number} sortWindowRight
         * @return {!Array.<number>}
         * @this {Array.<number>}
         */
        value: function(comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight)
        {
            function quickSortRange(array, comparator, left, right, sortWindowLeft, sortWindowRight)
            {
                if (right <= left)
                    return;
                var pivotIndex = Math.floor(Math.random() * (right - left)) + left;
                var pivotNewIndex = array.partition(comparator, left, right, pivotIndex);
                if (sortWindowLeft < pivotNewIndex)
                    quickSortRange(array, comparator, left, pivotNewIndex - 1, sortWindowLeft, sortWindowRight);
                if (pivotNewIndex < sortWindowRight)
                    quickSortRange(array, comparator, pivotNewIndex + 1, right, sortWindowLeft, sortWindowRight);
            }
            if (leftBound === 0 && rightBound === (this.length - 1) && sortWindowLeft === 0 && sortWindowRight >= rightBound)
                this.sort(comparator);
            else
                quickSortRange(this, comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight);
            return this;
        }
    }
    Object.defineProperty(Array.prototype, "sortRange", sortRange);
    Object.defineProperty(Uint32Array.prototype, "sortRange", sortRange);
})();

Object.defineProperty(Array.prototype, "stableSort", {
    /**
     * @param {function(?T, ?T): number=} comparator
     * @return {!Array.<?T>}
     * @this {Array.<?T>}
     * @template T
     */
    value: function(comparator)
    {
        function defaultComparator(a, b)
        {
            return a < b ? -1 : (a > b ? 1 : 0);
        }
        comparator = comparator || defaultComparator;

        var indices = new Array(this.length);
        for (var i = 0; i < this.length; ++i)
            indices[i] = i;
        var self = this;
        /**
         * @param {number} a
         * @param {number} b
         * @return {number}
         */
        function indexComparator(a, b)
        {
            var result = comparator(self[a], self[b]);
            return result ? result : a - b;
        }
        indices.sort(indexComparator);

        for (var i = 0; i < this.length; ++i) {
            if (indices[i] < 0 || i === indices[i])
                continue;
            var cyclical = i;
            var saved = this[i];
            while (true) {
                var next = indices[cyclical];
                indices[cyclical] = -1;
                if (next === i) {
                    this[cyclical] = saved;
                    break;
                } else {
                    this[cyclical] = this[next];
                    cyclical = next;
                }
            }
        }
        return this;
    }
});

Object.defineProperty(Array.prototype, "qselect", {
    /**
     * @param {number} k
     * @param {function(number, number): number=} comparator
     * @return {number|undefined}
     * @this {Array.<number>}
     */
    value: function(k, comparator)
    {
        if (k < 0 || k >= this.length)
            return;
        if (!comparator)
            comparator = function(a, b) { return a - b; }

        var low = 0;
        var high = this.length - 1;
        for (;;) {
            var pivotPosition = this.partition(comparator, low, high, Math.floor((high + low) / 2));
            if (pivotPosition === k)
                return this[k];
            else if (pivotPosition > k)
                high = pivotPosition - 1;
            else
                low = pivotPosition + 1;
        }
    }
});

Object.defineProperty(Array.prototype, "lowerBound", {
    /**
     * Return index of the leftmost element that is equal or greater
     * than the specimen object. If there's no such element (i.e. all
     * elements are smaller than the specimen) returns right bound.
     * The function works for sorted array.
     * When specified, |left| (inclusive) and |right| (exclusive) indices
     * define the search window.
     *
     * @param {!T} object
     * @param {function(!T,!S):number=} comparator
     * @param {number=} left
     * @param {number=} right
     * @return {number}
     * @this {Array.<!S>}
     * @template T,S
     */
    value: function(object, comparator, left, right)
    {
        function defaultComparator(a, b)
        {
            return a < b ? -1 : (a > b ? 1 : 0);
        }
        comparator = comparator || defaultComparator;
        var l = left || 0;
        var r = right !== undefined ? right : this.length;
        while (l < r) {
            var m = (l + r) >> 1;
            if (comparator(object, this[m]) > 0)
                l = m + 1;
            else
                r = m;
        }
        return r;
    }
});

Object.defineProperty(Array.prototype, "upperBound", {
    /**
     * Return index of the leftmost element that is greater
     * than the specimen object. If there's no such element (i.e. all
     * elements are smaller or equal to the specimen) returns right bound.
     * The function works for sorted array.
     * When specified, |left| (inclusive) and |right| (exclusive) indices
     * define the search window.
     *
     * @param {!T} object
     * @param {function(!T,!S):number=} comparator
     * @param {number=} left
     * @param {number=} right
     * @return {number}
     * @this {Array.<!S>}
     * @template T,S
     */
    value: function(object, comparator, left, right)
    {
        function defaultComparator(a, b)
        {
            return a < b ? -1 : (a > b ? 1 : 0);
        }
        comparator = comparator || defaultComparator;
        var l = left || 0;
        var r = right !== undefined ? right : this.length;
        while (l < r) {
            var m = (l + r) >> 1;
            if (comparator(object, this[m]) >= 0)
                l = m + 1;
            else
                r = m;
        }
        return r;
    }
});

Object.defineProperty(Uint32Array.prototype, "lowerBound", {
    value: Array.prototype.lowerBound
});

Object.defineProperty(Uint32Array.prototype, "upperBound", {
    value: Array.prototype.upperBound
});

Object.defineProperty(Float64Array.prototype, "lowerBound", {
    value: Array.prototype.lowerBound
});

Object.defineProperty(Array.prototype, "binaryIndexOf", {
    /**
     * @param {!T} value
     * @param {function(!T,!S):number} comparator
     * @return {number}
     * @this {Array.<!S>}
     * @template T,S
     */
    value: function(value, comparator)
    {
        var index = this.lowerBound(value, comparator);
        return index < this.length && comparator(value, this[index]) === 0 ? index : -1;
    }
});

Object.defineProperty(Array.prototype, "select", {
    /**
     * @param {string} field
     * @return {!Array.<!T>}
     * @this {Array.<!Object.<string,!T>>}
     * @template T
     */
    value: function(field)
    {
        var result = new Array(this.length);
        for (var i = 0; i < this.length; ++i)
            result[i] = this[i][field];
        return result;
    }
});

Object.defineProperty(Array.prototype, "peekLast", {
    /**
     * @return {!T|undefined}
     * @this {Array.<!T>}
     * @template T
     */
    value: function()
    {
        return this[this.length - 1];
    }
});

(function(){
    /**
     * @param {!Array.<T>} array1
     * @param {!Array.<T>} array2
     * @param {function(T,T):number} comparator
     * @param {boolean} mergeNotIntersect
     * @return {!Array.<T>}
     * @template T
     */
    function mergeOrIntersect(array1, array2, comparator, mergeNotIntersect)
    {
        var result = [];
        var i = 0;
        var j = 0;
        while (i < array1.length && j < array2.length) {
            var compareValue = comparator(array1[i], array2[j]);
            if (mergeNotIntersect || !compareValue)
                result.push(compareValue <= 0 ? array1[i] : array2[j]);
            if (compareValue <= 0)
                i++;
            if (compareValue >= 0)
                j++;
        }
        if (mergeNotIntersect) {
            while (i < array1.length)
                result.push(array1[i++]);
            while (j < array2.length)
                result.push(array2[j++]);
        }
        return result;
    }

    Object.defineProperty(Array.prototype, "intersectOrdered", {
        /**
         * @param {!Array.<T>} array
         * @param {function(T,T):number} comparator
         * @return {!Array.<T>}
         * @this {!Array.<T>}
         * @template T
         */
        value: function(array, comparator)
        {
            return mergeOrIntersect(this, array, comparator, false);
        }
    });

    Object.defineProperty(Array.prototype, "mergeOrdered", {
        /**
         * @param {!Array.<T>} array
         * @param {function(T,T):number} comparator
         * @return {!Array.<T>}
         * @this {!Array.<T>}
         * @template T
         */
        value: function(array, comparator)
        {
            return mergeOrIntersect(this, array, comparator, true);
        }
    });
})();

/**
 * @param {string} format
 * @param {...*} var_arg
 * @return {string}
 */
String.sprintf = function(format, var_arg)
{
    return String.vsprintf(format, Array.prototype.slice.call(arguments, 1));
}

/**
 * @param {string} format
 * @param {!Object.<string, function(string, ...):*>} formatters
 * @return {!Array.<!Object>}
 */
String.tokenizeFormatString = function(format, formatters)
{
    var tokens = [];
    var substitutionIndex = 0;

    function addStringToken(str)
    {
        if (tokens.length && tokens[tokens.length - 1].type === "string")
            tokens[tokens.length - 1].value += str;
        else
            tokens.push({ type: "string", value: str });
    }

    function addSpecifierToken(specifier, precision, substitutionIndex)
    {
        tokens.push({ type: "specifier", specifier: specifier, precision: precision, substitutionIndex: substitutionIndex });
    }

    var index = 0;
    for (var precentIndex = format.indexOf("%", index); precentIndex !== -1; precentIndex = format.indexOf("%", index)) {
        if (format.length === index)  // unescaped % sign at the end of the format string.
            break;
        addStringToken(format.substring(index, precentIndex));
        index = precentIndex + 1;

        if (format[index] === "%") {
            // %% escape sequence.
            addStringToken("%");
            ++index;
            continue;
        }

        if (String.isDigitAt(format, index)) {
            // The first character is a number, it might be a substitution index.
            var number = parseInt(format.substring(index), 10);
            while (String.isDigitAt(format, index))
                ++index;

            // If the number is greater than zero and ends with a "$",
            // then this is a substitution index.
            if (number > 0 && format[index] === "$") {
                substitutionIndex = (number - 1);
                ++index;
            }
        }

        var precision = -1;
        if (format[index] === ".") {
            // This is a precision specifier. If no digit follows the ".",
            // then the precision should be zero.
            ++index;
            precision = parseInt(format.substring(index), 10);
            if (isNaN(precision))
                precision = 0;

            while (String.isDigitAt(format, index))
                ++index;
        }

        if (!(format[index] in formatters)) {
            addStringToken(format.substring(precentIndex, index + 1));
            ++index;
            continue;
        }

        addSpecifierToken(format[index], precision, substitutionIndex);

        ++substitutionIndex;
        ++index;
    }

    addStringToken(format.substring(index));

    return tokens;
}

String.standardFormatters = {
    /**
     * @return {number}
     */
    d: function(substitution)
    {
        return !isNaN(substitution) ? substitution : 0;
    },

    /**
     * @return {number}
     */
    f: function(substitution, token)
    {
        if (substitution && token.precision > -1)
            substitution = substitution.toFixed(token.precision);
        return !isNaN(substitution) ? substitution : (token.precision > -1 ? Number(0).toFixed(token.precision) : 0);
    },

    /**
     * @return {string}
     */
    s: function(substitution)
    {
        return substitution;
    }
}

/**
 * @param {string} format
 * @param {!Array.<*>} substitutions
 * @return {string}
 */
String.vsprintf = function(format, substitutions)
{
    return String.format(format, substitutions, String.standardFormatters, "", function(a, b) { return a + b; }).formattedResult;
}

/**
 * @param {string} format
 * @param {?ArrayLike} substitutions
 * @param {!Object.<string, function(string, ...):Q>} formatters
 * @param {!T} initialValue
 * @param {function(T, Q): T|undefined} append
 * @param {!Array.<!Object>=} tokenizedFormat
 * @return {!{formattedResult: T, unusedSubstitutions: ?ArrayLike}};
 * @template T, Q
 */
String.format = function(format, substitutions, formatters, initialValue, append, tokenizedFormat)
{
    if (!format || !substitutions || !substitutions.length)
        return { formattedResult: append(initialValue, format), unusedSubstitutions: substitutions };

    function prettyFunctionName()
    {
        return "String.format(\"" + format + "\", \"" + Array.prototype.join.call(substitutions, "\", \"") + "\")";
    }

    function warn(msg)
    {
        console.warn(prettyFunctionName() + ": " + msg);
    }

    function error(msg)
    {
        console.error(prettyFunctionName() + ": " + msg);
    }

    var result = initialValue;
    var tokens = tokenizedFormat || String.tokenizeFormatString(format, formatters);
    var usedSubstitutionIndexes = {};

    for (var i = 0; i < tokens.length; ++i) {
        var token = tokens[i];

        if (token.type === "string") {
            result = append(result, token.value);
            continue;
        }

        if (token.type !== "specifier") {
            error("Unknown token type \"" + token.type + "\" found.");
            continue;
        }

        if (token.substitutionIndex >= substitutions.length) {
            // If there are not enough substitutions for the current substitutionIndex
            // just output the format specifier literally and move on.
            error("not enough substitution arguments. Had " + substitutions.length + " but needed " + (token.substitutionIndex + 1) + ", so substitution was skipped.");
            result = append(result, "%" + (token.precision > -1 ? token.precision : "") + token.specifier);
            continue;
        }

        usedSubstitutionIndexes[token.substitutionIndex] = true;

        if (!(token.specifier in formatters)) {
            // Encountered an unsupported format character, treat as a string.
            warn("unsupported format character \u201C" + token.specifier + "\u201D. Treating as a string.");
            result = append(result, substitutions[token.substitutionIndex]);
            continue;
        }

        result = append(result, formatters[token.specifier](substitutions[token.substitutionIndex], token));
    }

    var unusedSubstitutions = [];
    for (var i = 0; i < substitutions.length; ++i) {
        if (i in usedSubstitutionIndexes)
            continue;
        unusedSubstitutions.push(substitutions[i]);
    }

    return { formattedResult: result, unusedSubstitutions: unusedSubstitutions };
}

/**
 * @param {string} query
 * @param {boolean} caseSensitive
 * @param {boolean} isRegex
 * @return {!RegExp}
 */
function createSearchRegex(query, caseSensitive, isRegex)
{
    var regexFlags = caseSensitive ? "g" : "gi";
    var regexObject;

    if (isRegex) {
        try {
            regexObject = new RegExp(query, regexFlags);
        } catch (e) {
            // Silent catch.
        }
    }

    if (!regexObject)
        regexObject = createPlainTextSearchRegex(query, regexFlags);

    return regexObject;
}

/**
 * @param {string} query
 * @param {string=} flags
 * @return {!RegExp}
 */
function createPlainTextSearchRegex(query, flags)
{
    // This should be kept the same as the one in StringUtil.cpp.
    var regexSpecialCharacters = String.regexSpecialCharacters();
    var regex = "";
    for (var i = 0; i < query.length; ++i) {
        var c = query.charAt(i);
        if (regexSpecialCharacters.indexOf(c) !== -1)
            regex += "\\";
        regex += c;
    }
    return new RegExp(regex, flags || "");
}

/**
 * @param {!RegExp} regex
 * @param {string} content
 * @return {number}
 */
function countRegexMatches(regex, content)
{
    var text = content;
    var result = 0;
    var match;
    while (text && (match = regex.exec(text))) {
        if (match[0].length > 0)
            ++result;
        text = text.substring(match.index + 1);
    }
    return result;
}

/**
 * @param {number} spacesCount
 * @return {string}
 */
function spacesPadding(spacesCount)
{
    return "\u00a0".repeat(spacesCount);
}

/**
 * @param {number} value
 * @param {number} symbolsCount
 * @return {string}
 */
function numberToStringWithSpacesPadding(value, symbolsCount)
{
    var numberString = value.toString();
    var paddingLength = Math.max(0, symbolsCount - numberString.length);
    return spacesPadding(paddingLength) + numberString;
}

/**
 * @return {!Array.<T>}
 * @template T
 */
Set.prototype.valuesArray = function()
{
    return Array.from(this.values());
}

/**
 * @param {!Iterable<T>|!Array<!T>} iterable
 * @template T
 */
Set.prototype.addAll = function(iterable)
{
    for (var e of iterable)
        this.add(e);
}

/**
 * @param {!Iterable<T>|!Array<!T>} iterable
 * @return {boolean}
 * @template T
 */
Set.prototype.containsAll = function(iterable)
{
    for (var e of iterable) {
        if (!this.has(e))
            return false;
    }
    return true;
}

/**
 * @return {T}
 * @template T
 */
Map.prototype.remove = function(key)
{
    var value = this.get(key);
    this.delete(key);
    return value;
}

/**
 * @return {!Array<!VALUE>}
 */
Map.prototype.valuesArray = function()
{
    return Array.from(this.values());
}

/**
 * @return {!Array<!KEY>}
 */
Map.prototype.keysArray = function()
{
    return Array.from(this.keys());
}

/**
 * @return {!Multimap<!KEY, !VALUE>}
 */
Map.prototype.inverse = function()
{
    var result = new Multimap();
    for (var key of this.keys()) {
        var value = this.get(key);
        result.set(value, key);
    }
    return result;
}

/**
 * @constructor
 * @template K, V
 */
var Multimap = function()
{
    /** @type {!Map.<K, !Set.<!V>>} */
    this._map = new Map();
}

Multimap.prototype = {
    /**
     * @param {K} key
     * @param {V} value
     */
    set: function(key, value)
    {
        var set = this._map.get(key);
        if (!set) {
            set = new Set();
            this._map.set(key, set);
        }
        set.add(value);
    },

    /**
     * @param {K} key
     * @return {!Set.<!V>}
     */
    get: function(key)
    {
        var result = this._map.get(key);
        if (!result)
            result = new Set();
        return result;
    },

    /**
     * @param {K} key
     * @return {boolean}
     */
    has: function(key)
    {
        return this._map.has(key);
    },

    /**
     * @param {K} key
     * @param {V} value
     * @return {boolean}
     */
    hasValue: function(key, value)
    {
        var set = this._map.get(key);
        if (!set)
            return false;
        return set.has(value);
    },

    /**
     * @return {number}
     */
    get size()
    {
        return this._map.size;
    },

    /**
     * @param {K} key
     * @param {V} value
     */
    remove: function(key, value)
    {
        var values = this.get(key);
        values.delete(value);
        if (!values.size)
            this._map.delete(key);
    },

    /**
     * @param {K} key
     */
    removeAll: function(key)
    {
        this._map.delete(key);
    },

    /**
     * @return {!Array.<K>}
     */
    keysArray: function()
    {
        return this._map.keysArray();
    },

    /**
     * @return {!Array.<!V>}
     */
    valuesArray: function()
    {
        var result = [];
        var keys = this.keysArray();
        for (var i = 0; i < keys.length; ++i)
            result.pushAll(this.get(keys[i]).valuesArray());
        return result;
    },

    clear: function()
    {
        this._map.clear();
    }
}

/**
 * @param {string} url
 * @return {!Promise.<string>}
 */
function loadXHR(url)
{
    return new Promise(load);

    function load(successCallback, failureCallback)
    {
        function onReadyStateChanged()
        {
            if (xhr.readyState !== XMLHttpRequest.DONE)
                return;
            if (xhr.status !== 200) {
                xhr.onreadystatechange = null;
                failureCallback(new Error(xhr.status));
                return;
            }
            xhr.onreadystatechange = null;
            successCallback(xhr.responseText);
        }

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = false;
        xhr.open("GET", url, true);
        xhr.onreadystatechange = onReadyStateChanged;
        xhr.send(null);
    }
}

/**
 * @constructor
 */
function CallbackBarrier()
{
    this._pendingIncomingCallbacksCount = 0;
}

CallbackBarrier.prototype = {
    /**
     * @param {function(...)=} userCallback
     * @return {function(...)}
     */
    createCallback: function(userCallback)
    {
        console.assert(!this._outgoingCallback, "CallbackBarrier.createCallback() is called after CallbackBarrier.callWhenDone()");
        ++this._pendingIncomingCallbacksCount;
        return this._incomingCallback.bind(this, userCallback);
    },

    /**
     * @param {function()} callback
     */
    callWhenDone: function(callback)
    {
        console.assert(!this._outgoingCallback, "CallbackBarrier.callWhenDone() is called multiple times");
        this._outgoingCallback = callback;
        if (!this._pendingIncomingCallbacksCount)
            this._outgoingCallback();
    },

    /**
     * @return {!Promise.<undefined>}
     */
    donePromise: function()
    {
        return new Promise(promiseConstructor.bind(this));

        /**
         * @param {function()} success
         * @this {CallbackBarrier}
         */
        function promiseConstructor(success)
        {
            this.callWhenDone(success);
        }
    },

    /**
     * @param {function(...)=} userCallback
     */
    _incomingCallback: function(userCallback)
    {
        console.assert(this._pendingIncomingCallbacksCount > 0);
        if (userCallback) {
            var args = Array.prototype.slice.call(arguments, 1);
            userCallback.apply(null, args);
        }
        if (!--this._pendingIncomingCallbacksCount && this._outgoingCallback)
            this._outgoingCallback();
    }
}

/**
 * @param {*} value
 */
function suppressUnused(value)
{
}

/**
 * @param {function()} callback
 * @return {number}
 */
self.setImmediate = function(callback)
{
    Promise.resolve().then(callback);
    return 0;
}

/**
 * @param {function(...?)} callback
 * @return {!Promise.<T>}
 * @template T
 */
Promise.prototype.spread = function(callback)
{
    return this.then(spreadPromise);

    function spreadPromise(arg)
    {
        return callback.apply(null, arg);
    }
}

/**
 * @param {T} defaultValue
 * @return {!Promise.<T>}
 * @template T
 */
Promise.prototype.catchException = function(defaultValue) {
    return this.catch(function(error) {
        console.error(error);
        return defaultValue;
    });
}

/**
 * @param {!Map<number, ?>} other
 * @param {function(!VALUE,?):boolean} isEqual
 * @return {!{removed: !Array<!VALUE>, added: !Array<?>, equal: !Array<!VALUE>}}
 * @this {Map<number, VALUE>}
 */
Map.prototype.diff = function(other, isEqual)
{
    var leftKeys = this.keysArray();
    var rightKeys = other.keysArray();
    leftKeys.sort((a, b) => a - b);
    rightKeys.sort((a, b) => a - b);

    var removed = [];
    var added = [];
    var equal = [];
    var leftIndex = 0;
    var rightIndex = 0;
    while (leftIndex < leftKeys.length && rightIndex < rightKeys.length) {
        var leftKey = leftKeys[leftIndex];
        var rightKey = rightKeys[rightIndex];
        if (leftKey === rightKey && isEqual(this.get(leftKey), other.get(rightKey))) {
            equal.push(this.get(leftKey));
            ++leftIndex;
            ++rightIndex;
            continue;
        }
        if (leftKey <= rightKey) {
            removed.push(this.get(leftKey));
            ++leftIndex;
            continue;
        }
        added.push(other.get(rightKey));
        ++rightIndex;
    }
    while (leftIndex < leftKeys.length) {
        var leftKey = leftKeys[leftIndex++];
        removed.push(this.get(leftKey));
    }
    while (rightIndex < rightKeys.length) {
        var rightKey = rightKeys[rightIndex++];
        added.push(other.get(rightKey));
    }
    return {
        added: added,
        removed: removed,
        equal: equal
    }
}

},{}],218:[function(require,module,exports){
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.ProfileNode}
 * @param {!ProfilerAgent.ProfileNode} node
 * @param {number} sampleTime
 */
WebInspector.CPUProfileNode = function(node, sampleTime)
{
    var callFrame = node.callFrame || /** @type {!RuntimeAgent.CallFrame} */ ({
        // Backward compatibility for old SamplingHeapProfileNode format.
        functionName: node["functionName"],
        scriptId: node["scriptId"],
        url: node["url"],
        lineNumber: node["lineNumber"] - 1,
        columnNumber: node["columnNumber"] - 1
    });
    WebInspector.ProfileNode.call(this, callFrame);
    this.id = node.id;
    this.self = node.hitCount * sampleTime;
    this.positionTicks = node.positionTicks;
    // Compatibility: legacy backends could provide "no reason" for optimized functions.
    this.deoptReason = node.deoptReason && node.deoptReason !== "no reason" ? node.deoptReason : null;
}

WebInspector.CPUProfileNode.prototype = {
    __proto__: WebInspector.ProfileNode.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ProfileTreeModel}
 * @param {!ProfilerAgent.Profile} profile
 */
WebInspector.CPUProfileDataModel = function(profile)
{
    var isLegacyFormat = !!profile["head"];
    if (isLegacyFormat) {
        // Legacy format contains raw timestamps and start/stop times are in seconds.
        this.profileStartTime = profile.startTime * 1000;
        this.profileEndTime = profile.endTime * 1000;
        this.timestamps = profile.timestamps;
        this._compatibilityConversionHeadToNodes(profile);
    } else {
        // Current format encodes timestamps as deltas. Start/stop times are in microseconds.
        this.profileStartTime = profile.startTime / 1000;
        this.profileEndTime = profile.endTime / 1000;
        this.timestamps = this._convertTimeDeltas(profile);
    }
    this.samples = profile.samples;
    this.totalHitCount = 0;
    this.profileHead = this._translateProfileTree(profile.nodes);
    WebInspector.ProfileTreeModel.call(this, this.profileHead);
    this._extractMetaNodes();
    if (this.samples) {
        this._buildIdToNodeMap();
        this._sortSamples();
        this._normalizeTimestamps();
    }
}

WebInspector.CPUProfileDataModel.prototype = {
    /**
     * @param {!ProfilerAgent.Profile} profile
     */
    _compatibilityConversionHeadToNodes: function(profile)
    {
        if (!profile.head || profile.nodes)
            return;
        /** @type {!Array<!ProfilerAgent.ProfileNode>} */
        var nodes = [];
        convertNodesTree(profile.head);
        profile.nodes = nodes;
        delete profile.head;
        /**
         * @param {!ProfilerAgent.ProfileNode} node
         * @return {number}
         */
        function convertNodesTree(node)
        {
            nodes.push(node);
            node.children = (/** @type {!Array<!ProfilerAgent.ProfileNode>} */(node.children)).map(convertNodesTree);
            return node.id;
        }
    },

    /**
     * @param {!ProfilerAgent.Profile} profile
     * @return {?Array<number>}
     */
    _convertTimeDeltas: function(profile)
    {
        if (!profile.timeDeltas)
            return null;
        var lastTimeUsec = profile.startTime;
        var timestamps = new Array(profile.timeDeltas.length);
        for (var i = 0; i < timestamps.length; ++i) {
            lastTimeUsec += profile.timeDeltas[i];
            timestamps[i] = lastTimeUsec;
        }
        return timestamps;
    },

    /**
     * @param {!Array<!ProfilerAgent.ProfileNode>} nodes
     * @return {!WebInspector.CPUProfileNode}
     */
    _translateProfileTree: function(nodes)
    {
        /**
         * @param {!ProfilerAgent.ProfileNode} node
         * @return {boolean}
         */
        function isNativeNode(node)
        {
            if (node.callFrame)
                return !!node.callFrame.url && node.callFrame.url.startsWith("native ");
            return !!node.url && node.url.startsWith("native ");
        }
        /**
         * @param {!Array<!ProfilerAgent.ProfileNode>} nodes
         */
        function buildChildrenFromParents(nodes)
        {
            if (nodes[0].children)
                return;
            nodes[0].children = [];
            for (var i = 1; i < nodes.length; ++i) {
                var node = nodes[i];
                var parentNode = nodeByIdMap.get(node.parent);
                if (parentNode.children)
                    parentNode.children.push(node.id);
                else
                    parentNode.children = [node.id];
            }
        }
        /** @type {!Map<number, !ProfilerAgent.ProfileNode>} */
        var nodeByIdMap = new Map();
        for (var i = 0; i < nodes.length; ++i) {
            var node = nodes[i];
            nodeByIdMap.set(node.id, node);
        }
        buildChildrenFromParents(nodes);
        this.totalHitCount = nodes.reduce((acc, node) => acc + node.hitCount, 0);
        var sampleTime = (this.profileEndTime - this.profileStartTime) / this.totalHitCount;
        var keepNatives = !!WebInspector.moduleSetting("showNativeFunctionsInJSProfile").get();
        var root = nodes[0];
        /** @type {!Map<number, number>} */
        var idMap = new Map([[root.id, root.id]]);
        var resultRoot = new WebInspector.CPUProfileNode(root, sampleTime);
        var parentNodeStack = root.children.map(() => resultRoot);
        var sourceNodeStack = root.children.map(id => nodeByIdMap.get(id));
        while (sourceNodeStack.length) {
            var parentNode = parentNodeStack.pop();
            var sourceNode = sourceNodeStack.pop();
            if (!sourceNode.children)
                sourceNode.children = [];
            var targetNode = new WebInspector.CPUProfileNode(sourceNode, sampleTime);
            if (keepNatives || !isNativeNode(sourceNode)) {
                parentNode.children.push(targetNode);
                parentNode = targetNode;
            } else {
                parentNode.self += targetNode.self;
            }
            idMap.set(sourceNode.id, parentNode.id);
            parentNodeStack.push.apply(parentNodeStack, sourceNode.children.map(() => parentNode));
            sourceNodeStack.push.apply(sourceNodeStack, sourceNode.children.map(id => nodeByIdMap.get(id)));
        }
        if (this.samples)
            this.samples = this.samples.map(id => idMap.get(id));
        return resultRoot;
    },

    _sortSamples: function()
    {
        var timestamps = this.timestamps;
        if (!timestamps)
            return;
        var samples = this.samples;
        var indices = timestamps.map((x, index) => index);
        indices.sort((a, b) => timestamps[a] - timestamps[b]);
        for (var i = 0; i < timestamps.length; ++i) {
            var index = indices[i];
            if (index === i)
                continue;
            // Move items in a cycle.
            var savedTimestamp = timestamps[i];
            var savedSample = samples[i];
            var currentIndex = i;
            while (index !== i) {
                samples[currentIndex] = samples[index];
                timestamps[currentIndex] = timestamps[index];
                currentIndex = index;
                index = indices[index];
                indices[currentIndex] = currentIndex;
            }
            samples[currentIndex] = savedSample;
            timestamps[currentIndex] = savedTimestamp;
        }
    },

    _normalizeTimestamps: function()
    {
        var timestamps = this.timestamps;
        if (!timestamps) {
            // Support loading old CPU profiles that are missing timestamps.
            // Derive timestamps from profile start and stop times.
            var profileStartTime = this.profileStartTime;
            var interval = (this.profileEndTime - profileStartTime) / this.samples.length;
            timestamps = new Float64Array(this.samples.length + 1);
            for (var i = 0; i < timestamps.length; ++i)
                timestamps[i] = profileStartTime + i * interval;
            this.timestamps = timestamps;
            return;
        }

        // Convert samples from usec to msec
        for (var i = 0; i < timestamps.length; ++i)
            timestamps[i] /= 1000;
        var averageSample = (timestamps.peekLast() - timestamps[0]) / (timestamps.length - 1);
        // Add an extra timestamp used to calculate the last sample duration.
        this.timestamps.push(timestamps.peekLast() + averageSample);
        this.profileStartTime = timestamps[0];
        this.profileEndTime = timestamps.peekLast();
    },

    _buildIdToNodeMap: function()
    {
        /** @type {!Map<number, !WebInspector.CPUProfileNode>} */
        this._idToNode = new Map();
        var idToNode = this._idToNode;
        var stack = [this.profileHead];
        while (stack.length) {
            var node = stack.pop();
            idToNode.set(node.id, node);
            stack.push.apply(stack, node.children);
        }
    },

    _extractMetaNodes: function()
    {
        var topLevelNodes = this.profileHead.children;
        for (var i = 0; i < topLevelNodes.length && !(this.gcNode && this.programNode && this.idleNode); i++) {
            var node = topLevelNodes[i];
            if (node.functionName === "(garbage collector)")
                this.gcNode = node;
            else if (node.functionName === "(program)")
                this.programNode = node;
            else if (node.functionName === "(idle)")
                this.idleNode = node;
        }
    },

    /**
     * @param {function(number, !WebInspector.CPUProfileNode, number)} openFrameCallback
     * @param {function(number, !WebInspector.CPUProfileNode, number, number, number)} closeFrameCallback
     * @param {number=} startTime
     * @param {number=} stopTime
     */
    forEachFrame: function(openFrameCallback, closeFrameCallback, startTime, stopTime)
    {
        if (!this.profileHead || !this.samples)
            return;

        startTime = startTime || 0;
        stopTime = stopTime || Infinity;
        var samples = this.samples;
        var timestamps = this.timestamps;
        var idToNode = this._idToNode;
        var gcNode = this.gcNode;
        var samplesCount = samples.length;
        var startIndex = timestamps.lowerBound(startTime);
        var stackTop = 0;
        var stackNodes = [];
        var prevId = this.profileHead.id;
        var sampleTime = timestamps[samplesCount];
        var gcParentNode = null;

        if (!this._stackStartTimes)
            this._stackStartTimes = new Float64Array(this.maxDepth + 2);
        var stackStartTimes = this._stackStartTimes;
        if (!this._stackChildrenDuration)
            this._stackChildrenDuration = new Float64Array(this.maxDepth + 2);
        var stackChildrenDuration = this._stackChildrenDuration;

        for (var sampleIndex = startIndex; sampleIndex < samplesCount; sampleIndex++) {
            sampleTime = timestamps[sampleIndex];
            if (sampleTime >= stopTime)
                break;
            var id = samples[sampleIndex];
            if (id === prevId)
                continue;
            var node = idToNode.get(id);
            var prevNode = idToNode.get(prevId);

            if (node === gcNode) {
                // GC samples have no stack, so we just put GC node on top of the last recorded sample.
                gcParentNode = prevNode;
                openFrameCallback(gcParentNode.depth + 1, gcNode, sampleTime);
                stackStartTimes[++stackTop] = sampleTime;
                stackChildrenDuration[stackTop] = 0;
                prevId = id;
                continue;
            }
            if (prevNode === gcNode) {
                // end of GC frame
                var start = stackStartTimes[stackTop];
                var duration = sampleTime - start;
                stackChildrenDuration[stackTop - 1] += duration;
                closeFrameCallback(gcParentNode.depth + 1, gcNode, start, duration, duration - stackChildrenDuration[stackTop]);
                --stackTop;
                prevNode = gcParentNode;
                prevId = prevNode.id;
                gcParentNode = null;
            }

            while (node.depth > prevNode.depth) {
                stackNodes.push(node);
                node = node.parent;
            }

            // Go down to the LCA and close current intervals.
            while (prevNode !== node) {
                var start = stackStartTimes[stackTop];
                var duration = sampleTime - start;
                stackChildrenDuration[stackTop - 1] += duration;
                closeFrameCallback(prevNode.depth, /** @type {!WebInspector.CPUProfileNode} */(prevNode), start, duration, duration - stackChildrenDuration[stackTop]);
                --stackTop;
                if (node.depth === prevNode.depth) {
                    stackNodes.push(node);
                    node = node.parent;
                }
                prevNode = prevNode.parent;
            }

            // Go up the nodes stack and open new intervals.
            while (stackNodes.length) {
                node = stackNodes.pop();
                openFrameCallback(node.depth, node, sampleTime);
                stackStartTimes[++stackTop] = sampleTime;
                stackChildrenDuration[stackTop] = 0;
            }

            prevId = id;
        }

        if (idToNode.get(prevId) === gcNode) {
            var start = stackStartTimes[stackTop];
            var duration = sampleTime - start;
            stackChildrenDuration[stackTop - 1] += duration;
            closeFrameCallback(gcParentNode.depth + 1, node, start, duration, duration - stackChildrenDuration[stackTop]);
            --stackTop;
        }

        for (var node = idToNode.get(prevId); node.parent; node = node.parent) {
            var start = stackStartTimes[stackTop];
            var duration = sampleTime - start;
            stackChildrenDuration[stackTop - 1] += duration;
            closeFrameCallback(node.depth, /** @type {!WebInspector.CPUProfileNode} */(node), start, duration, duration - stackChildrenDuration[stackTop]);
            --stackTop;
        }
    },

    /**
     * @param {number} index
     * @return {?WebInspector.CPUProfileNode}
     */
    nodeByIndex: function(index)
    {
        return this._idToNode.get(this.samples[index]) || null;
    },

    __proto__: WebInspector.ProfileTreeModel.prototype
}

},{}],219:[function(require,module,exports){
/*
 * Copyright (C) 2011 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKModel}
 * @param {!WebInspector.Target} target
 */
WebInspector.NetworkManager = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.NetworkManager, target);
    this._dispatcher = new WebInspector.NetworkDispatcher(this);
    this._target = target;
    this._networkAgent = target.networkAgent();
    target.registerNetworkDispatcher(this._dispatcher);
    if (WebInspector.moduleSetting("cacheDisabled").get())
        this._networkAgent.setCacheDisabled(true);
    if (WebInspector.moduleSetting("monitoringXHREnabled").get())
        this._networkAgent.setMonitoringXHREnabled(true);

    // Limit buffer when talking to a remote device.
    if (Runtime.queryParam("remoteFrontend") || Runtime.queryParam("ws"))
        this._networkAgent.enable(10000000, 5000000);
    else
        this._networkAgent.enable();

    this._bypassServiceWorkerSetting = WebInspector.settings.createSetting("bypassServiceWorker", false);
    if (this._bypassServiceWorkerSetting.get())
        this._bypassServiceWorkerChanged();
    this._bypassServiceWorkerSetting.addChangeListener(this._bypassServiceWorkerChanged, this);

    WebInspector.moduleSetting("cacheDisabled").addChangeListener(this._cacheDisabledSettingChanged, this);
}

/** @enum {symbol} */
WebInspector.NetworkManager.Events = {
    RequestStarted: Symbol("RequestStarted"),
    RequestUpdated: Symbol("RequestUpdated"),
    RequestFinished: Symbol("RequestFinished"),
    RequestUpdateDropped: Symbol("RequestUpdateDropped"),
    ResponseReceived: Symbol("ResponseReceived")
}

WebInspector.NetworkManager._MIMETypes = {
    "text/html":                   {"document": true},
    "text/xml":                    {"document": true},
    "text/plain":                  {"document": true},
    "application/xhtml+xml":       {"document": true},
    "image/svg+xml":               {"document": true},
    "text/css":                    {"stylesheet": true},
    "text/xsl":                    {"stylesheet": true},
    "text/vtt":                    {"texttrack": true},
}

/**
 * @param {!WebInspector.Target} target
 * @return {?WebInspector.NetworkManager}
 */
WebInspector.NetworkManager.fromTarget = function(target)
{
    return /** @type {?WebInspector.NetworkManager} */ (target.model(WebInspector.NetworkManager));
}

/** @typedef {{download: number, upload: number, latency: number, title: string}} */
WebInspector.NetworkManager.Conditions;
/** @type {!WebInspector.NetworkManager.Conditions} */
WebInspector.NetworkManager.NoThrottlingConditions = {title: WebInspector.UIString("No throttling"), download: -1, upload: -1, latency: 0};
/** @type {!WebInspector.NetworkManager.Conditions} */
WebInspector.NetworkManager.OfflineConditions = {title: WebInspector.UIString("Offline"), download: 0, upload: 0, latency: 0};

/**
 * @param {!WebInspector.NetworkManager.Conditions} conditions
 * @return {!NetworkAgent.ConnectionType}
 * TODO(allada): this belongs to NetworkConditionsSelector, which should hardcode/guess it.
 */
WebInspector.NetworkManager._connectionType = function(conditions)
{
    if (!conditions.download && !conditions.upload)
        return NetworkAgent.ConnectionType.None;
    var types = WebInspector.NetworkManager._connectionTypes;
    if (!types) {
        WebInspector.NetworkManager._connectionTypes = [];
        types = WebInspector.NetworkManager._connectionTypes;
        types.push(["2g", NetworkAgent.ConnectionType.Cellular2g]);
        types.push(["3g", NetworkAgent.ConnectionType.Cellular3g]);
        types.push(["4g", NetworkAgent.ConnectionType.Cellular4g]);
        types.push(["bluetooth", NetworkAgent.ConnectionType.Bluetooth]);
        types.push(["wifi", NetworkAgent.ConnectionType.Wifi]);
        types.push(["wimax", NetworkAgent.ConnectionType.Wimax]);
    }
    for (var type of types) {
        if (conditions.title.toLowerCase().indexOf(type[0]) !== -1)
            return type[1];
    }
    return NetworkAgent.ConnectionType.Other;
}

WebInspector.NetworkManager.prototype = {
    /**
     * @param {string} url
     * @return {!WebInspector.NetworkRequest}
     */
    inflightRequestForURL: function(url)
    {
        return this._dispatcher._inflightRequestsByURL[url];
    },

    /**
     * @param {!WebInspector.Event} event
     */
    _cacheDisabledSettingChanged: function(event)
    {
        var enabled = /** @type {boolean} */ (event.data);
        this._networkAgent.setCacheDisabled(enabled);
    },

    dispose: function()
    {
        WebInspector.moduleSetting("cacheDisabled").removeChangeListener(this._cacheDisabledSettingChanged, this);
    },

    /**
     * @return {!WebInspector.Setting}
     */
    bypassServiceWorkerSetting: function()
    {
        return this._bypassServiceWorkerSetting;
    },

    _bypassServiceWorkerChanged: function()
    {
        this._networkAgent.setBypassServiceWorker(this._bypassServiceWorkerSetting.get());
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
 * @constructor
 * @implements {NetworkAgent.Dispatcher}
 */
WebInspector.NetworkDispatcher = function(manager)
{
    this._manager = manager;
    this._inflightRequestsById = {};
    this._inflightRequestsByURL = {};
}

WebInspector.NetworkDispatcher.prototype = {
    /**
     * @param {!NetworkAgent.Headers} headersMap
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    _headersMapToHeadersArray: function(headersMap)
    {
        var result = [];
        for (var name in headersMap) {
            var values = headersMap[name].split("\n");
            for (var i = 0; i < values.length; ++i)
                result.push({name: name, value: values[i]});
        }
        return result;
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     * @param {!NetworkAgent.Request} request
     */
    _updateNetworkRequestWithRequest: function(networkRequest, request)
    {
        networkRequest.requestMethod = request.method;
        networkRequest.setRequestHeaders(this._headersMapToHeadersArray(request.headers));
        networkRequest.requestFormData = request.postData;
        networkRequest.setInitialPriority(request.initialPriority);
        networkRequest.mixedContentType = request.mixedContentType || NetworkAgent.RequestMixedContentType.None;
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     * @param {!NetworkAgent.Response=} response
     */
    _updateNetworkRequestWithResponse: function(networkRequest, response)
    {
        if (response.url && networkRequest.url !== response.url)
            networkRequest.url = response.url;
        networkRequest.mimeType = response.mimeType;
        networkRequest.statusCode = response.status;
        networkRequest.statusText = response.statusText;
        networkRequest.responseHeaders = this._headersMapToHeadersArray(response.headers);
        if (response.encodedDataLength >= 0)
            networkRequest.setTransferSize(response.encodedDataLength);
        if (response.headersText)
            networkRequest.responseHeadersText = response.headersText;
        if (response.requestHeaders) {
            networkRequest.setRequestHeaders(this._headersMapToHeadersArray(response.requestHeaders));
            networkRequest.setRequestHeadersText(response.requestHeadersText || "");
        }

        networkRequest.connectionReused = response.connectionReused;
        networkRequest.connectionId = String(response.connectionId);
        if (response.remoteIPAddress)
            networkRequest.setRemoteAddress(response.remoteIPAddress, response.remotePort || -1);

        if (response.fromServiceWorker)
            networkRequest.fetchedViaServiceWorker = true;

        if (response.fromDiskCache)
            networkRequest.setFromDiskCache();
        networkRequest.timing = response.timing;

        networkRequest.protocol = response.protocol;

        networkRequest.setSecurityState(response.securityState);

        if (!this._mimeTypeIsConsistentWithType(networkRequest)) {
            var consoleModel = this._manager._target.consoleModel;
            consoleModel.addMessage(new WebInspector.ConsoleMessage(consoleModel.target(), WebInspector.ConsoleMessage.MessageSource.Network,
                WebInspector.ConsoleMessage.MessageLevel.Log,
                WebInspector.UIString("Resource interpreted as %s but transferred with MIME type %s: \"%s\".", networkRequest.resourceType().title(), networkRequest.mimeType, networkRequest.url),
                WebInspector.ConsoleMessage.MessageType.Log,
                "",
                0,
                0,
                networkRequest.requestId));
        }

        if (response.securityDetails)
            networkRequest.setSecurityDetails(response.securityDetails);
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     * @return {boolean}
     */
    _mimeTypeIsConsistentWithType: function(networkRequest)
    {
        // If status is an error, content is likely to be of an inconsistent type,
        // as it's going to be an error message. We do not want to emit a warning
        // for this, though, as this will already be reported as resource loading failure.
        // Also, if a URL like http://localhost/wiki/load.php?debug=true&lang=en produces text/css and gets reloaded,
        // it is 304 Not Modified and its guessed mime-type is text/php, which is wrong.
        // Don't check for mime-types in 304-resources.
        if (networkRequest.hasErrorStatusCode() || networkRequest.statusCode === 304 || networkRequest.statusCode === 204)
            return true;

        var resourceType = networkRequest.resourceType();
        if (resourceType !== WebInspector.resourceTypes.Stylesheet &&
            resourceType !== WebInspector.resourceTypes.Document &&
            resourceType !== WebInspector.resourceTypes.TextTrack) {
            return true;
        }

        if (!networkRequest.mimeType)
            return true; // Might be not known for cached resources with null responses.

        if (networkRequest.mimeType in WebInspector.NetworkManager._MIMETypes)
            return resourceType.name() in WebInspector.NetworkManager._MIMETypes[networkRequest.mimeType];

        return false;
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.ResourcePriority} newPriority
     * @param {!NetworkAgent.Timestamp} timestamp
     */
    resourceChangedPriority: function(requestId, newPriority, timestamp)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (networkRequest)
            networkRequest.setPriority(newPriority);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!PageAgent.FrameId} frameId
     * @param {!NetworkAgent.LoaderId} loaderId
     * @param {string} documentURL
     * @param {!NetworkAgent.Request} request
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.Timestamp} wallTime
     * @param {!NetworkAgent.Initiator} initiator
     * @param {!NetworkAgent.Response=} redirectResponse
     * @param {!PageAgent.ResourceType=} resourceType
     */
    requestWillBeSent: function(requestId, frameId, loaderId, documentURL, request, time, wallTime, initiator, redirectResponse, resourceType)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (networkRequest) {
            // FIXME: move this check to the backend.
            if (!redirectResponse)
                return;
            this.responseReceived(requestId, frameId, loaderId, time, PageAgent.ResourceType.Other, redirectResponse);
            networkRequest = this._appendRedirect(requestId, time, request.url);
        } else
            networkRequest = this._createNetworkRequest(requestId, frameId, loaderId, request.url, documentURL, initiator);
        networkRequest.hasNetworkData = true;
        this._updateNetworkRequestWithRequest(networkRequest, request);
        networkRequest.setIssueTime(time, wallTime);
        networkRequest.setResourceType(WebInspector.resourceTypes[resourceType]);

        this._startNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     */
    requestServedFromCache: function(requestId)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.setFromMemoryCache();
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!PageAgent.FrameId} frameId
     * @param {!NetworkAgent.LoaderId} loaderId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!PageAgent.ResourceType} resourceType
     * @param {!NetworkAgent.Response} response
     */
    responseReceived: function(requestId, frameId, loaderId, time, resourceType, response)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest) {
            // We missed the requestWillBeSent.
            var eventData = {};
            eventData.url = response.url;
            eventData.frameId = frameId;
            eventData.loaderId = loaderId;
            eventData.resourceType = resourceType;
            eventData.mimeType = response.mimeType;
            this._manager.dispatchEventToListeners(WebInspector.NetworkManager.Events.RequestUpdateDropped, eventData);
            return;
        }

        networkRequest.responseReceivedTime = time;
        networkRequest.setResourceType(WebInspector.resourceTypes[resourceType]);

        this._updateNetworkRequestWithResponse(networkRequest, response);

        this._updateNetworkRequest(networkRequest);
        this._manager.dispatchEventToListeners(WebInspector.NetworkManager.Events.ResponseReceived, networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {number} dataLength
     * @param {number} encodedDataLength
     */
    dataReceived: function(requestId, time, dataLength, encodedDataLength)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.resourceSize += dataLength;
        if (encodedDataLength !== -1)
            networkRequest.increaseTransferSize(encodedDataLength);
        networkRequest.endTime = time;

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} finishTime
     * @param {number} encodedDataLength
     */
    loadingFinished: function(requestId, finishTime, encodedDataLength)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;
        this._finishNetworkRequest(networkRequest, finishTime, encodedDataLength);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!PageAgent.ResourceType} resourceType
     * @param {string} localizedDescription
     * @param {boolean=} canceled
     * @param {!NetworkAgent.BlockedReason=} blockedReason
     */
    loadingFailed: function(requestId, time, resourceType, localizedDescription, canceled, blockedReason)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.failed = true;
        networkRequest.setResourceType(WebInspector.resourceTypes[resourceType]);
        networkRequest.canceled = canceled;
        if (blockedReason) {
            networkRequest.setBlockedReason(blockedReason);
            if (blockedReason === NetworkAgent.BlockedReason.Inspector) {
                var consoleModel = this._manager._target.consoleModel;
                consoleModel.addMessage(new WebInspector.ConsoleMessage(consoleModel.target(), WebInspector.ConsoleMessage.MessageSource.Network,
                    WebInspector.ConsoleMessage.MessageLevel.Warning,
                    WebInspector.UIString("Request was blocked by DevTools: \"%s\".", networkRequest.url),
                    WebInspector.ConsoleMessage.MessageType.Log,
                    "",
                    0,
                    0,
                    networkRequest.requestId));
            }
        }
        networkRequest.localizedFailDescription = localizedDescription;
        this._finishNetworkRequest(networkRequest, time, -1);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {string} requestURL
     * @param {!NetworkAgent.Initiator=} initiator
     */
    webSocketCreated: function(requestId, requestURL, initiator)
    {
        var networkRequest = new WebInspector.NetworkRequest(this._manager._target, requestId, requestURL, "", "", "", initiator || null);
        networkRequest.setResourceType(WebInspector.resourceTypes.WebSocket);
        this._startNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.Timestamp} wallTime
     * @param {!NetworkAgent.WebSocketRequest} request
     */
    webSocketWillSendHandshakeRequest: function(requestId, time, wallTime, request)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.requestMethod = "GET";
        networkRequest.setRequestHeaders(this._headersMapToHeadersArray(request.headers));
        networkRequest.setIssueTime(time, wallTime);

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.WebSocketResponse} response
     */
    webSocketHandshakeResponseReceived: function(requestId, time, response)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.statusCode = response.status;
        networkRequest.statusText = response.statusText;
        networkRequest.responseHeaders = this._headersMapToHeadersArray(response.headers);
        networkRequest.responseHeadersText = response.headersText;
        if (response.requestHeaders)
            networkRequest.setRequestHeaders(this._headersMapToHeadersArray(response.requestHeaders));
        if (response.requestHeadersText)
            networkRequest.setRequestHeadersText(response.requestHeadersText);
        networkRequest.responseReceivedTime = time;
        networkRequest.protocol = "websocket";

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.WebSocketFrame} response
     */
    webSocketFrameReceived: function(requestId, time, response)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.addFrame(response, time);
        networkRequest.responseReceivedTime = time;

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {!NetworkAgent.WebSocketFrame} response
     */
    webSocketFrameSent: function(requestId, time, response)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.addFrame(response, time, true);
        networkRequest.responseReceivedTime = time;

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {string} errorMessage
     */
    webSocketFrameError: function(requestId, time, errorMessage)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;

        networkRequest.addFrameError(errorMessage, time);
        networkRequest.responseReceivedTime = time;

        this._updateNetworkRequest(networkRequest);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     */
    webSocketClosed: function(requestId, time)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;
        this._finishNetworkRequest(networkRequest, time, -1);
    },

    /**
     * @override
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {string} eventName
     * @param {string} eventId
     * @param {string} data
     */
    eventSourceMessageReceived: function(requestId, time, eventName, eventId, data)
    {
        var networkRequest = this._inflightRequestsById[requestId];
        if (!networkRequest)
            return;
        networkRequest.addEventSourceMessage(time, eventName, eventId, data);
    },

    /**
     * @param {!NetworkAgent.RequestId} requestId
     * @param {!NetworkAgent.Timestamp} time
     * @param {string} redirectURL
     * @return {!WebInspector.NetworkRequest}
     */
    _appendRedirect: function(requestId, time, redirectURL)
    {
        var originalNetworkRequest = this._inflightRequestsById[requestId];
        var previousRedirects = originalNetworkRequest.redirects || [];
        originalNetworkRequest.requestId = requestId + ":redirected." + previousRedirects.length;
        delete originalNetworkRequest.redirects;
        if (previousRedirects.length > 0)
            originalNetworkRequest.redirectSource = previousRedirects[previousRedirects.length - 1];
        this._finishNetworkRequest(originalNetworkRequest, time, -1);
        var newNetworkRequest = this._createNetworkRequest(requestId, originalNetworkRequest.frameId, originalNetworkRequest.loaderId,
             redirectURL, originalNetworkRequest.documentURL, originalNetworkRequest.initiator());
        newNetworkRequest.redirects = previousRedirects.concat(originalNetworkRequest);
        return newNetworkRequest;
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     */
    _startNetworkRequest: function(networkRequest)
    {
        this._inflightRequestsById[networkRequest.requestId] = networkRequest;
        this._inflightRequestsByURL[networkRequest.url] = networkRequest;
        this._dispatchEventToListeners(WebInspector.NetworkManager.Events.RequestStarted, networkRequest);
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     */
    _updateNetworkRequest: function(networkRequest)
    {
        this._dispatchEventToListeners(WebInspector.NetworkManager.Events.RequestUpdated, networkRequest);
    },

    /**
     * @param {!WebInspector.NetworkRequest} networkRequest
     * @param {!NetworkAgent.Timestamp} finishTime
     * @param {number} encodedDataLength
     */
    _finishNetworkRequest: function(networkRequest, finishTime, encodedDataLength)
    {
        networkRequest.endTime = finishTime;
        networkRequest.finished = true;
        if (encodedDataLength >= 0)
            networkRequest.setTransferSize(encodedDataLength);
        this._dispatchEventToListeners(WebInspector.NetworkManager.Events.RequestFinished, networkRequest);
        delete this._inflightRequestsById[networkRequest.requestId];
        delete this._inflightRequestsByURL[networkRequest.url];
    },

    /**
     * @param {string} eventType
     * @param {!WebInspector.NetworkRequest} networkRequest
     */
    _dispatchEventToListeners: function(eventType, networkRequest)
    {
        this._manager.dispatchEventToListeners(eventType, networkRequest);
    },

    /**
     * @param {!NetworkAgent.RequestId} requestId
     * @param {string} frameId
     * @param {!NetworkAgent.LoaderId} loaderId
     * @param {string} url
     * @param {string} documentURL
     * @param {?NetworkAgent.Initiator} initiator
     */
    _createNetworkRequest: function(requestId, frameId, loaderId, url, documentURL, initiator)
    {
        return new WebInspector.NetworkRequest(this._manager._target, requestId, url, documentURL, frameId, loaderId, initiator);
    }
}


/**
 * @constructor
 * @extends {WebInspector.Object}
 * @implements {WebInspector.TargetManager.Observer}
 */
WebInspector.MultitargetNetworkManager = function()
{
    WebInspector.Object.call(this);
    WebInspector.targetManager.observeTargets(this);

    /** @type {!Set<string>} */
    this._blockedURLs = new Set();
    this._blockedSetting = WebInspector.moduleSetting("blockedURLs");
    this._blockedSetting.addChangeListener(this._updateBlockedURLs, this);
    this._blockedSetting.set([]);
    this._updateBlockedURLs();

    this._userAgentOverride = "";
    /** @type {!Set<!Protocol.NetworkAgent>} */
    this._agents = new Set();
    /** @type {!WebInspector.NetworkManager.Conditions} */
    this._networkConditions = WebInspector.NetworkManager.NoThrottlingConditions;
}

/** @enum {symbol} */
WebInspector.MultitargetNetworkManager.Events = {
    ConditionsChanged: Symbol("ConditionsChanged"),
    UserAgentChanged: Symbol("UserAgentChanged")
}

/**
 * @param {string} uaString
 * @return {string}
 */
WebInspector.MultitargetNetworkManager.patchUserAgentWithChromeVersion = function(uaString)
{
    // Patches Chrome/CriOS version from user agent ("1.2.3.4" when user agent is: "Chrome/1.2.3.4").
    var chromeRegex = new RegExp("(?:^|\\W)Chrome/(\\S+)");
    var chromeMatch = navigator.userAgent.match(chromeRegex);
    if (chromeMatch && chromeMatch.length > 1)
        return String.sprintf(uaString, chromeMatch[1]);
    return uaString;
}

WebInspector.MultitargetNetworkManager.prototype = {
    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target)
    {
        var networkAgent = target.networkAgent();
        if (this._extraHeaders)
            networkAgent.setExtraHTTPHeaders(this._extraHeaders);
        if (this._currentUserAgent())
            networkAgent.setUserAgentOverride(this._currentUserAgent());
        for (var url of this._blockedURLs)
            networkAgent.addBlockedURL(url);
        this._agents.add(networkAgent);
        if (this.isThrottling())
            this._updateNetworkConditions(networkAgent);
    },

    /**
     * @override
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target)
    {
        this._agents.delete(target.networkAgent());
    },

    /**
     * @return {boolean}
     */
    isThrottling: function()
    {
        return this._networkConditions.download >= 0 || this._networkConditions.upload >= 0 || this._networkConditions.latency > 0;
    },

    /**
     * @return {boolean}
     */
    isOffline: function()
    {
        return !this._networkConditions.download && !this._networkConditions.upload;
    },

    /**
     * @param {!WebInspector.NetworkManager.Conditions} conditions
     */
    setNetworkConditions: function(conditions)
    {
        this._networkConditions = conditions;
        for (var agent of this._agents)
            this._updateNetworkConditions(agent);
        this.dispatchEventToListeners(WebInspector.MultitargetNetworkManager.Events.ConditionsChanged);
    },

    /**
     * @return {!WebInspector.NetworkManager.Conditions}
     */
    networkConditions: function()
    {
        return this._networkConditions;
    },

    /**
     * @param {!Protocol.NetworkAgent} networkAgent
     */
    _updateNetworkConditions: function(networkAgent)
    {
        var conditions = this._networkConditions;
        if (!this.isThrottling()) {
            networkAgent.emulateNetworkConditions(false, 0, 0, 0);
        } else {
            networkAgent.emulateNetworkConditions(this.isOffline(), conditions.latency, conditions.download < 0 ? 0 : conditions.download, conditions.upload < 0 ? 0 : conditions.upload, WebInspector.NetworkManager._connectionType(conditions));
        }
    },

    /**
     * @param {!NetworkAgent.Headers} headers
     */
    setExtraHTTPHeaders: function(headers)
    {
        this._extraHeaders = headers;
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().setExtraHTTPHeaders(this._extraHeaders);
    },

    /**
     * @return {string}
     */
    _currentUserAgent: function()
    {
        return this._customUserAgent ? this._customUserAgent : this._userAgentOverride;
    },

    _updateUserAgentOverride: function()
    {
        var userAgent = this._currentUserAgent();
        WebInspector.ResourceLoader.targetUserAgent = userAgent;
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().setUserAgentOverride(userAgent);
    },

    /**
     * @param {string} userAgent
     */
    setUserAgentOverride: function(userAgent)
    {
        if (this._userAgentOverride === userAgent)
            return;
        this._userAgentOverride = userAgent;
        if (!this._customUserAgent)
            this._updateUserAgentOverride();
        this.dispatchEventToListeners(WebInspector.MultitargetNetworkManager.Events.UserAgentChanged);
    },

    /**
     * @return {string}
     */
    userAgentOverride: function()
    {
        return this._userAgentOverride;
    },

    /**
     * @param {string} userAgent
     */
    setCustomUserAgentOverride: function(userAgent)
    {
        this._customUserAgent = userAgent;
        this._updateUserAgentOverride();
    },

    _updateBlockedURLs: function()
    {
        var blocked = this._blockedSetting.get();
        for (var url of blocked) {
            if (!this._blockedURLs.has(url))
                this._addBlockedURL(url);
        }
        for (var url of this._blockedURLs) {
            if (blocked.indexOf(url) === -1)
                this._removeBlockedURL(url);
        }
    },

    /**
     * @param {string} url
     */
    _addBlockedURL: function(url)
    {
        this._blockedURLs.add(url);
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().addBlockedURL(url);
    },

    /**
     * @param {string} url
     */
    _removeBlockedURL: function(url)
    {
        this._blockedURLs.delete(url);
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().removeBlockedURL(url);
    },

    clearBrowserCache: function()
    {
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().clearBrowserCache();
    },

    clearBrowserCookies: function()
    {
        for (var target of WebInspector.targetManager.targets())
            target.networkAgent().clearBrowserCookies();
    },

    /**
     * @param {string} origin
     * @param {function(!Array<string>)} callback
     */
    getCertificate: function(origin, callback)
    {
        var target = WebInspector.targetManager.mainTarget();
        target.networkAgent().getCertificate(origin, mycallback);

        /**
         * @param {?Protocol.Error} error
         * @param {!Array<string>} certificate
         */
        function mycallback(error, certificate)
        {
            callback(error ? [] : certificate);
        }
    },

    /**
     * @param {string} url
     * @param {function(number, !Object.<string, string>, string)} callback
     */
    loadResource: function(url, callback)
    {
        var headers = {};

        var currentUserAgent = this._currentUserAgent();
        if (currentUserAgent)
            headers["User-Agent"] = currentUserAgent;

        if (WebInspector.moduleSetting("cacheDisabled").get())
            headers["Cache-Control"] = "no-cache";

        WebInspector.ResourceLoader.load(url, headers, callback);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @type {!WebInspector.MultitargetNetworkManager}
 */
WebInspector.multitargetNetworkManager;

},{}],220:[function(require,module,exports){
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @implements {WebInspector.ContentProvider}
 * @param {!NetworkAgent.RequestId} requestId
 * @param {!WebInspector.Target} target
 * @param {string} url
 * @param {string} documentURL
 * @param {!PageAgent.FrameId} frameId
 * @param {!NetworkAgent.LoaderId} loaderId
 * @param {?NetworkAgent.Initiator} initiator
 */
WebInspector.NetworkRequest = function(target, requestId, url, documentURL, frameId, loaderId, initiator)
{
    WebInspector.SDKObject.call(this, target);

    this._networkLog = /** @type {!WebInspector.NetworkLog} */ (WebInspector.NetworkLog.fromTarget(target));
    this._networkManager = /** @type {!WebInspector.NetworkManager} */ (WebInspector.NetworkManager.fromTarget(target));
    this._requestId = requestId;
    this.url = url;
    this._documentURL = documentURL;
    this._frameId = frameId;
    this._loaderId = loaderId;
    /** @type {?NetworkAgent.Initiator} */
    this._initiator = initiator;
    this._issueTime = -1;
    this._startTime = -1;
    this._endTime = -1;
    /** @type {!NetworkAgent.BlockedReason|undefined} */
    this._blockedReason = undefined;

    this.statusCode = 0;
    this.statusText = "";
    this.requestMethod = "";
    this.requestTime = 0;
    this.protocol = "";
    /** @type {!NetworkAgent.RequestMixedContentType} */
    this.mixedContentType = NetworkAgent.RequestMixedContentType.None;

    /** @type {?NetworkAgent.ResourcePriority} */
    this._initialPriority = null;
    /** @type {?NetworkAgent.ResourcePriority} */
    this._currentPriority = null;

    /** @type {!WebInspector.ResourceType} */
    this._resourceType = WebInspector.resourceTypes.Other;
    this._contentEncoded = false;
    this._pendingContentCallbacks = [];
    /** @type {!Array.<!WebInspector.NetworkRequest.WebSocketFrame>} */
    this._frames = [];
    /** @type {!Array.<!WebInspector.NetworkRequest.EventSourceMessage>} */
    this._eventSourceMessages = [];

    this._responseHeaderValues = {};

    this._remoteAddress = "";

    /** @type {!SecurityAgent.SecurityState} */
    this._securityState = SecurityAgent.SecurityState.Unknown;
    /** @type {?NetworkAgent.SecurityDetails} */
    this._securityDetails = null;

    /** @type {string} */
    this.connectionId = "0";
}

/** @enum {symbol} */
WebInspector.NetworkRequest.Events = {
    FinishedLoading: Symbol("FinishedLoading"),
    TimingChanged: Symbol("TimingChanged"),
    RemoteAddressChanged: Symbol("RemoteAddressChanged"),
    RequestHeadersChanged: Symbol("RequestHeadersChanged"),
    ResponseHeadersChanged: Symbol("ResponseHeadersChanged"),
    WebsocketFrameAdded: Symbol("WebsocketFrameAdded"),
    EventSourceMessageAdded: Symbol("EventSourceMessageAdded")
}

/** @enum {string} */
WebInspector.NetworkRequest.InitiatorType = {
    Other: "other",
    Parser: "parser",
    Redirect: "redirect",
    Script: "script"
}

/** @typedef {!{name: string, value: string}} */
WebInspector.NetworkRequest.NameValue;

/** @enum {string} */
WebInspector.NetworkRequest.WebSocketFrameType = {
    Send: "send",
    Receive: "receive",
    Error: "error"
}

/** @typedef {!{type: WebInspector.NetworkRequest.WebSocketFrameType, time: number, text: string, opCode: number, mask: boolean}} */
WebInspector.NetworkRequest.WebSocketFrame;

/** @typedef {!{time: number, eventName: string, eventId: string, data: string}} */
WebInspector.NetworkRequest.EventSourceMessage;

WebInspector.NetworkRequest.prototype = {
    /**
     * @param {!WebInspector.NetworkRequest} other
     * @return {number}
     */
    indentityCompare: function(other)
    {
        if (this._requestId > other._requestId)
            return 1;
        if (this._requestId < other._requestId)
            return -1;
        return 0;
    },

    /**
     * @return {!NetworkAgent.RequestId}
     */
    get requestId()
    {
        return this._requestId;
    },

    set requestId(requestId)
    {
        this._requestId = requestId;
    },

    /**
     * @return {string}
     */
    get url()
    {
        return this._url;
    },

    set url(x)
    {
        if (this._url === x)
            return;

        this._url = x;
        this._parsedURL = new WebInspector.ParsedURL(x);
        delete this._queryString;
        delete this._parsedQueryParameters;
        delete this._name;
        delete this._path;
    },

    /**
     * @return {string}
     */
    get documentURL()
    {
        return this._documentURL;
    },

    get parsedURL()
    {
        return this._parsedURL;
    },

    /**
     * @return {!PageAgent.FrameId}
     */
    get frameId()
    {
        return this._frameId;
    },

    /**
     * @return {!NetworkAgent.LoaderId}
     */
    get loaderId()
    {
        return this._loaderId;
    },

    /**
     * @param {string} ip
     * @param {number} port
     */
    setRemoteAddress: function(ip, port)
    {
        this._remoteAddress = ip + ":" + port;
        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.RemoteAddressChanged, this);
    },

    /**
     * @return {string}
     */
    remoteAddress: function()
    {
        return this._remoteAddress;
    },

    /**
     * @return {!SecurityAgent.SecurityState}
     */
    securityState: function()
    {
        return this._securityState;
    },

    /**
     * @param {!SecurityAgent.SecurityState} securityState
     */
    setSecurityState: function(securityState)
    {
        this._securityState = securityState;
    },

    /**
     * @return {?NetworkAgent.SecurityDetails}
     */
    securityDetails: function()
    {
        return this._securityDetails;
    },

    /**
     * @param {!NetworkAgent.SecurityDetails} securityDetails
     */
    setSecurityDetails: function(securityDetails)
    {
        this._securityDetails = securityDetails;
    },

    /**
     * @return {number}
     */
    get startTime()
    {
        return this._startTime || -1;
    },

    /**
     * @param {number} monotonicTime
     * @param {number} wallTime
     */
    setIssueTime: function(monotonicTime, wallTime)
    {
        this._issueTime = monotonicTime;
        this._wallIssueTime = wallTime;
        this._startTime = monotonicTime;
    },

    /**
     * @return {number}
     */
    issueTime: function()
    {
        return this._issueTime;
    },

    /**
     * @param {number} monotonicTime
     * @return {number}
     */
    pseudoWallTime: function(monotonicTime)
    {
        return this._wallIssueTime ? this._wallIssueTime - this._issueTime + monotonicTime : monotonicTime;
    },

    /**
     * @return {number}
     */
    get responseReceivedTime()
    {
        return this._responseReceivedTime || -1;
    },

    set responseReceivedTime(x)
    {
        this._responseReceivedTime = x;
    },

    /**
     * @return {number}
     */
    get endTime()
    {
        return this._endTime || -1;
    },

    set endTime(x)
    {
        if (this.timing && this.timing.requestTime) {
            // Check against accurate responseReceivedTime.
            this._endTime = Math.max(x, this.responseReceivedTime);
        } else {
            // Prefer endTime since it might be from the network stack.
            this._endTime = x;
            if (this._responseReceivedTime > x)
                this._responseReceivedTime = x;
        }
        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.TimingChanged, this);
    },

    /**
     * @return {number}
     */
    get duration()
    {
        if (this._endTime === -1 || this._startTime === -1)
            return -1;
        return this._endTime - this._startTime;
    },

    /**
     * @return {number}
     */
    get latency()
    {
        if (this._responseReceivedTime === -1 || this._startTime === -1)
            return -1;
        return this._responseReceivedTime - this._startTime;
    },

    /**
     * @return {number}
     */
    get resourceSize()
    {
        return this._resourceSize || 0;
    },

    set resourceSize(x)
    {
        this._resourceSize = x;
    },

    /**
     * @return {number}
     */
    get transferSize()
    {
        return this._transferSize || 0;
    },

    /**
     * @param {number} x
     */
    increaseTransferSize: function(x)
    {
        this._transferSize = (this._transferSize || 0) + x;
    },

    /**
     * @param {number} x
     */
    setTransferSize: function(x)
    {
        this._transferSize = x;
    },

    /**
     * @return {boolean}
     */
    get finished()
    {
        return this._finished;
    },

    set finished(x)
    {
        if (this._finished === x)
            return;

        this._finished = x;

        if (x) {
            this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.FinishedLoading, this);
            if (this._pendingContentCallbacks.length)
                this._innerRequestContent();
        }
    },

    /**
     * @return {boolean}
     */
    get failed()
    {
        return this._failed;
    },

    set failed(x)
    {
        this._failed = x;
    },

    /**
     * @return {boolean}
     */
    get canceled()
    {
        return this._canceled;
    },

    set canceled(x)
    {
        this._canceled = x;
    },

    /**
     * @return {!NetworkAgent.BlockedReason|undefined}
     */
    blockedReason: function()
    {
        return this._blockedReason;
    },

    /**
     * @param {!NetworkAgent.BlockedReason} reason
     */
    setBlockedReason: function(reason)
    {
        this._blockedReason = reason;
    },

    /**
     * @return {boolean}
     */
    wasBlocked: function()
    {
        return !!this._blockedReason;
    },

    /**
     * @return {boolean}
     */
    cached: function()
    {
        return (!!this._fromMemoryCache || !!this._fromDiskCache) && !this._transferSize;
    },

    /**
     * @return {boolean}
     */
    cachedInMemory: function()
    {
        return !!this._fromMemoryCache && !this._transferSize;
    },

    setFromMemoryCache: function()
    {
        this._fromMemoryCache = true;
        delete this._timing;
    },

    setFromDiskCache: function()
    {
        this._fromDiskCache = true;
    },

    /**
     * @return {boolean}
     */
    get fetchedViaServiceWorker()
    {
        return this._fetchedViaServiceWorker;
    },

    set fetchedViaServiceWorker(x)
    {
        this._fetchedViaServiceWorker = x;
    },

    /**
     * @return {!NetworkAgent.ResourceTiming|undefined}
     */
    get timing()
    {
        return this._timing;
    },

    set timing(x)
    {
        if (x && !this._fromMemoryCache) {
            // Take startTime and responseReceivedTime from timing data for better accuracy.
            // Timing's requestTime is a baseline in seconds, rest of the numbers there are ticks in millis.
            this._startTime = x.requestTime;
            this._responseReceivedTime = x.requestTime + x.receiveHeadersEnd / 1000.0;

            this._timing = x;
            this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.TimingChanged, this);
        }
    },

    /**
     * @return {string}
     */
    get mimeType()
    {
        return this._mimeType;
    },

    set mimeType(x)
    {
        this._mimeType = x;
    },

    /**
     * @return {string}
     */
    get displayName()
    {
        return this._parsedURL.displayName;
    },

    /**
     * @return {string}
     */
    name: function()
    {
        if (this._name)
            return this._name;
        this._parseNameAndPathFromURL();
        return this._name;
    },

    /**
     * @return {string}
     */
    path: function()
    {
        if (this._path)
            return this._path;
        this._parseNameAndPathFromURL();
        return this._path;
    },

    _parseNameAndPathFromURL: function()
    {
        if (this._parsedURL.isDataURL()) {
            this._name = this._parsedURL.dataURLDisplayName();
            this._path = "";
        } else if (this._parsedURL.isAboutBlank()) {
            this._name = this._parsedURL.url;
            this._path = "";
        } else {
            this._path = this._parsedURL.host + this._parsedURL.folderPathComponents;

            var inspectedURL = this.target().inspectedURL().asParsedURL();
            this._path = this._path.trimURL(inspectedURL ? inspectedURL.host : "");
            if (this._parsedURL.lastPathComponent || this._parsedURL.queryParams)
                this._name = this._parsedURL.lastPathComponent + (this._parsedURL.queryParams ? "?" + this._parsedURL.queryParams : "");
            else if (this._parsedURL.folderPathComponents) {
                this._name = this._parsedURL.folderPathComponents.substring(this._parsedURL.folderPathComponents.lastIndexOf("/") + 1) + "/";
                this._path = this._path.substring(0, this._path.lastIndexOf("/"));
            } else {
                this._name = this._parsedURL.host;
                this._path = "";
            }
        }
    },

    /**
     * @return {string}
     */
    get folder()
    {
        var path = this._parsedURL.path;
        var indexOfQuery = path.indexOf("?");
        if (indexOfQuery !== -1)
            path = path.substring(0, indexOfQuery);
        var lastSlashIndex = path.lastIndexOf("/");
        return lastSlashIndex !== -1 ? path.substring(0, lastSlashIndex) : "";
    },

    /**
     * @return {!WebInspector.ResourceType}
     */
    resourceType: function()
    {
        return this._resourceType;
    },

    /**
     * @param {!WebInspector.ResourceType} resourceType
     */
    setResourceType: function(resourceType)
    {
        this._resourceType = resourceType;
    },

    /**
     * @return {string}
     */
    get domain()
    {
        return this._parsedURL.host;
    },

    /**
     * @return {string}
     */
    get scheme()
    {
        return this._parsedURL.scheme;
    },

    /**
     * @return {?WebInspector.NetworkRequest}
     */
    get redirectSource()
    {
        if (this.redirects && this.redirects.length > 0)
            return this.redirects[this.redirects.length - 1];
        return this._redirectSource;
    },

    set redirectSource(x)
    {
        this._redirectSource = x;
        delete this._initiatorInfo;
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    requestHeaders: function()
    {
        return this._requestHeaders || [];
    },

    /**
     * @param {!Array.<!WebInspector.NetworkRequest.NameValue>} headers
     */
    setRequestHeaders: function(headers)
    {
        this._requestHeaders = headers;
        delete this._requestCookies;

        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.RequestHeadersChanged);
    },

    /**
     * @return {string|undefined}
     */
    requestHeadersText: function()
    {
        return this._requestHeadersText;
    },

    /**
     * @param {string} text
     */
    setRequestHeadersText: function(text)
    {
        this._requestHeadersText = text;

        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.RequestHeadersChanged);
    },

    /**
     * @param {string} headerName
     * @return {string|undefined}
     */
    requestHeaderValue: function(headerName)
    {
        return this._headerValue(this.requestHeaders(), headerName);
    },

    /**
     * @return {!Array.<!WebInspector.Cookie>}
     */
    get requestCookies()
    {
        if (!this._requestCookies)
            this._requestCookies = WebInspector.CookieParser.parseCookie(this.target(), this.requestHeaderValue("Cookie"));
        return this._requestCookies;
    },

    /**
     * @return {string|undefined}
     */
    get requestFormData()
    {
        return this._requestFormData;
    },

    set requestFormData(x)
    {
        this._requestFormData = x;
        delete this._parsedFormParameters;
    },

    /**
     * @return {string}
     */
    requestHttpVersion: function()
    {
        var headersText = this.requestHeadersText();
        if (!headersText)
            return this.requestHeaderValue("version") || this.requestHeaderValue(":version") || "unknown";
        var firstLine = headersText.split(/\r\n/)[0];
        var match = firstLine.match(/(HTTP\/\d+\.\d+)$/);
        return match ? match[1] : "HTTP/0.9";
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    get responseHeaders()
    {
        return this._responseHeaders || [];
    },

    set responseHeaders(x)
    {
        this._responseHeaders = x;
        delete this._sortedResponseHeaders;
        delete this._serverTimings;
        delete this._responseCookies;
        this._responseHeaderValues = {};

        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.ResponseHeadersChanged);
    },

    /**
     * @return {string}
     */
    get responseHeadersText()
    {
        return this._responseHeadersText;
    },

    set responseHeadersText(x)
    {
        this._responseHeadersText = x;

        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.ResponseHeadersChanged);
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    get sortedResponseHeaders()
    {
        if (this._sortedResponseHeaders !== undefined)
            return this._sortedResponseHeaders;

        this._sortedResponseHeaders = this.responseHeaders.slice();
        this._sortedResponseHeaders.sort(function(a, b) { return a.name.toLowerCase().compareTo(b.name.toLowerCase()); });
        return this._sortedResponseHeaders;
    },

    /**
     * @param {string} headerName
     * @return {string|undefined}
     */
    responseHeaderValue: function(headerName)
    {
        var value = this._responseHeaderValues[headerName];
        if (value === undefined) {
            value = this._headerValue(this.responseHeaders, headerName);
            this._responseHeaderValues[headerName] = (value !== undefined) ? value : null;
        }
        return (value !== null) ? value : undefined;
    },

    /**
     * @return {!Array.<!WebInspector.Cookie>}
     */
    get responseCookies()
    {
        if (!this._responseCookies)
            this._responseCookies = WebInspector.CookieParser.parseSetCookie(this.target(), this.responseHeaderValue("Set-Cookie"));
        return this._responseCookies;
    },

    /**
     * @return {?Array.<!WebInspector.ServerTiming>}
     */
    get serverTimings()
    {
        if (typeof this._serverTimings === "undefined")
            this._serverTimings = WebInspector.ServerTiming.parseHeaders(this.responseHeaders);
        return this._serverTimings;
    },

    /**
     * @return {?string}
     */
    queryString: function()
    {
        if (this._queryString !== undefined)
            return this._queryString;

        var queryString = null;
        var url = this.url;
        var questionMarkPosition = url.indexOf("?");
        if (questionMarkPosition !== -1) {
            queryString = url.substring(questionMarkPosition + 1);
            var hashSignPosition = queryString.indexOf("#");
            if (hashSignPosition !== -1)
                queryString = queryString.substring(0, hashSignPosition);
        }
        this._queryString = queryString;
        return this._queryString;
    },

    /**
     * @return {?Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    get queryParameters()
    {
        if (this._parsedQueryParameters)
            return this._parsedQueryParameters;
        var queryString = this.queryString();
        if (!queryString)
            return null;
        this._parsedQueryParameters = this._parseParameters(queryString);
        return this._parsedQueryParameters;
    },

    /**
     * @return {?Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    get formParameters()
    {
        if (this._parsedFormParameters)
            return this._parsedFormParameters;
        if (!this.requestFormData)
            return null;
        var requestContentType = this.requestContentType();
        if (!requestContentType || !requestContentType.match(/^application\/x-www-form-urlencoded\s*(;.*)?$/i))
            return null;
        this._parsedFormParameters = this._parseParameters(this.requestFormData);
        return this._parsedFormParameters;
    },

    /**
     * @return {string}
     */
    responseHttpVersion: function()
    {
        var headersText = this._responseHeadersText;
        if (!headersText)
            return this.responseHeaderValue("version") || this.responseHeaderValue(":version") || "unknown";
        var firstLine = headersText.split(/\r\n/)[0];
        var match = firstLine.match(/^(HTTP\/\d+\.\d+)/);
        return match ? match[1] : "HTTP/0.9";
    },

    /**
     * @param {string} queryString
     * @return {!Array.<!WebInspector.NetworkRequest.NameValue>}
     */
    _parseParameters: function(queryString)
    {
        function parseNameValue(pair)
        {
            var position = pair.indexOf("=");
            if (position === -1)
                return {name: pair, value: ""};
            else
                return {name: pair.substring(0, position), value: pair.substring(position + 1)};
        }
        return queryString.split("&").map(parseNameValue);
    },

    /**
     * @param {!Array.<!WebInspector.NetworkRequest.NameValue>} headers
     * @param {string} headerName
     * @return {string|undefined}
     */
    _headerValue: function(headers, headerName)
    {
        headerName = headerName.toLowerCase();

        var values = [];
        for (var i = 0; i < headers.length; ++i) {
            if (headers[i].name.toLowerCase() === headerName)
                values.push(headers[i].value);
        }
        if (!values.length)
            return undefined;
        // Set-Cookie values should be separated by '\n', not comma, otherwise cookies could not be parsed.
        if (headerName === "set-cookie")
            return values.join("\n");
        return values.join(", ");
    },

    /**
     * @return {?string|undefined}
     */
    get content()
    {
        return this._content;
    },

    /**
     * @return {?Protocol.Error|undefined}
     */
    contentError: function()
    {
        return this._contentError;
    },

    /**
     * @return {boolean}
     */
    get contentEncoded()
    {
        return this._contentEncoded;
    },

    /**
     * @override
     * @return {string}
     */
    contentURL: function()
    {
        return this._url;
    },

    /**
     * @override
     * @return {!WebInspector.ResourceType}
     */
    contentType: function()
    {
        return this._resourceType;
    },

    /**
     * @override
     * @return {!Promise<?string>}
     */
    requestContent: function()
    {
        // We do not support content retrieval for WebSockets at the moment.
        // Since WebSockets are potentially long-living, fail requests immediately
        // to prevent caller blocking until resource is marked as finished.
        if (this._resourceType === WebInspector.resourceTypes.WebSocket)
            return Promise.resolve(/** @type {?string} */(null));
        if (typeof this._content !== "undefined")
            return Promise.resolve(/** @type {?string} */(this.content || null));
        var callback;
        var promise = new Promise(fulfill => callback = fulfill);
        this._pendingContentCallbacks.push(callback);
        if (this.finished)
            this._innerRequestContent();
        return promise;
    },

    /**
     * @override
     * @param {string} query
     * @param {boolean} caseSensitive
     * @param {boolean} isRegex
     * @param {function(!Array.<!WebInspector.ContentProvider.SearchMatch>)} callback
     */
    searchInContent: function(query, caseSensitive, isRegex, callback)
    {
        callback([]);
    },

    /**
     * @return {boolean}
     */
    isHttpFamily: function()
    {
        return !!this.url.match(/^https?:/i);
    },

    /**
     * @return {string|undefined}
     */
    requestContentType: function()
    {
        return this.requestHeaderValue("Content-Type");
    },

    /**
     * @return {boolean}
     */
    hasErrorStatusCode: function()
    {
        return this.statusCode >= 400;
    },

    /**
     * @param {!NetworkAgent.ResourcePriority} priority
     */
    setInitialPriority: function(priority)
    {
        this._initialPriority = priority;
    },

    /**
     * @return {?NetworkAgent.ResourcePriority}
     */
    initialPriority: function()
    {
        return this._initialPriority;
    },

    /**
     * @param {!NetworkAgent.ResourcePriority} priority
     */
    setPriority: function(priority)
    {
        this._currentPriority = priority;
    },

    /**
     * @return {?NetworkAgent.ResourcePriority}
     */
    priority: function()
    {
        return this._currentPriority || this._initialPriority || null;
    },

    /**
     * @param {!Element} image
     */
    populateImageSource: function(image)
    {
        /**
         * @param {?string} content
         * @this {WebInspector.NetworkRequest}
         */
        function onResourceContent(content)
        {
            var imageSrc = WebInspector.ContentProvider.contentAsDataURL(content, this._mimeType, true);
            if (imageSrc === null)
                imageSrc = this._url;
            image.src = imageSrc;
        }

        this.requestContent().then(onResourceContent.bind(this));
    },

    /**
     * @return {?string}
     */
    asDataURL: function()
    {
        var content = this._content;
        var charset = null;
        if (!this._contentEncoded) {
            content = content.toBase64();
            charset = "utf-8";
        }
        return WebInspector.ContentProvider.contentAsDataURL(content, this.mimeType, true, charset);
    },

    _innerRequestContent: function()
    {
        if (this._contentRequested)
            return;
        this._contentRequested = true;

        /**
         * @param {?Protocol.Error} error
         * @param {string} content
         * @param {boolean} contentEncoded
         * @this {WebInspector.NetworkRequest}
         */
        function onResourceContent(error, content, contentEncoded)
        {
            this._content = error ? null : content;
            this._contentError = error;
            this._contentEncoded = contentEncoded;
            var callbacks = this._pendingContentCallbacks.slice();
            for (var i = 0; i < callbacks.length; ++i)
                callbacks[i](this._content);
            this._pendingContentCallbacks.length = 0;
            delete this._contentRequested;
        }
        this.target().networkAgent().getResponseBody(this._requestId, onResourceContent.bind(this));
    },

    /**
     * @return {?NetworkAgent.Initiator}
     */
    initiator: function()
    {
        return this._initiator;
    },

    /**
     * @return {!{type: !WebInspector.NetworkRequest.InitiatorType, url: string, lineNumber: number, columnNumber: number, scriptId: ?string}}
     */
    initiatorInfo: function()
    {
        if (this._initiatorInfo)
            return this._initiatorInfo;

        var type = WebInspector.NetworkRequest.InitiatorType.Other;
        var url = "";
        var lineNumber = -Infinity;
        var columnNumber = -Infinity;
        var scriptId = null;
        var initiator = this._initiator;

        if (this.redirectSource) {
            type = WebInspector.NetworkRequest.InitiatorType.Redirect;
            url = this.redirectSource.url;
        } else if (initiator) {
            if (initiator.type === NetworkAgent.InitiatorType.Parser) {
                type = WebInspector.NetworkRequest.InitiatorType.Parser;
                url = initiator.url ? initiator.url : url;
                lineNumber = initiator.lineNumber ? initiator.lineNumber : lineNumber;
            } else if (initiator.type === NetworkAgent.InitiatorType.Script) {
                for (var stack = initiator.stack; stack; stack = stack.parent) {
                    var topFrame = stack.callFrames.length ? stack.callFrames[0] : null;
                    if (!topFrame)
                        continue;
                    type = WebInspector.NetworkRequest.InitiatorType.Script;
                    url = topFrame.url || WebInspector.UIString("<anonymous>");
                    lineNumber = topFrame.lineNumber;
                    columnNumber = topFrame.columnNumber;
                    scriptId = topFrame.scriptId;
                    break;
                }
            }
        }

        this._initiatorInfo = {type: type, url: url, lineNumber: lineNumber, columnNumber: columnNumber, scriptId: scriptId};
        return this._initiatorInfo;
    },

    /**
     * @return {?WebInspector.NetworkRequest}
     */
    initiatorRequest: function()
    {
        if (this._initiatorRequest === undefined)
            this._initiatorRequest = this._networkLog.requestForURL(this.initiatorInfo().url);
        return this._initiatorRequest;
    },

    /**
     * @return {!Set<!WebInspector.NetworkRequest>}
     */
    initiatorChain: function()
    {
        if (this._initiatorChain)
            return this._initiatorChain;
        this._initiatorChain = new Set();
        var request = this;
        while (request) {
            this._initiatorChain.add(request);
            request = request.initiatorRequest();
        }
        return this._initiatorChain;
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.WebSocketFrame>}
     */
    frames: function()
    {
        return this._frames;
    },

    /**
     * @param {string} errorMessage
     * @param {number} time
     */
    addFrameError: function(errorMessage, time)
    {
        this._addFrame({ type: WebInspector.NetworkRequest.WebSocketFrameType.Error, text: errorMessage, time: this.pseudoWallTime(time), opCode: -1, mask: false });
    },

    /**
     * @param {!NetworkAgent.WebSocketFrame} response
     * @param {number} time
     * @param {boolean} sent
     */
    addFrame: function(response, time, sent)
    {
        var type = sent ? WebInspector.NetworkRequest.WebSocketFrameType.Send : WebInspector.NetworkRequest.WebSocketFrameType.Receive;
        this._addFrame({ type: type, text: response.payloadData, time: this.pseudoWallTime(time), opCode: response.opcode, mask: response.mask });
    },

    /**
     * @param {!WebInspector.NetworkRequest.WebSocketFrame} frame
     */
    _addFrame: function(frame)
    {
        this._frames.push(frame);
        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.WebsocketFrameAdded, frame);
    },

    /**
     * @return {!Array.<!WebInspector.NetworkRequest.EventSourceMessage>}
     */
    eventSourceMessages: function()
    {
        return this._eventSourceMessages;
    },

    /**
     * @param {number} time
     * @param {string} eventName
     * @param {string} eventId
     * @param {string} data
     */
    addEventSourceMessage: function(time, eventName, eventId, data)
    {
        var message = {time: this.pseudoWallTime(time), eventName: eventName, eventId: eventId, data: data};
        this._eventSourceMessages.push(message);
        this.dispatchEventToListeners(WebInspector.NetworkRequest.Events.EventSourceMessageAdded, message);
    },

    replayXHR: function()
    {
        this.target().networkAgent().replayXHR(this.requestId);
    },

    /**
     * @return {!WebInspector.NetworkLog}
     */
    networkLog: function()
    {
        return this._networkLog;
    },

    /**
     * @return {!WebInspector.NetworkManager}
     */
    networkManager: function()
    {
        return this._networkManager;
    },

    __proto__: WebInspector.SDKObject.prototype
}

},{}],221:[function(require,module,exports){
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @param {!RuntimeAgent.CallFrame} callFrame
 */
WebInspector.ProfileNode = function(callFrame)
{
    /** @type {!RuntimeAgent.CallFrame} */
    this.callFrame = callFrame;
    /** @type {string} */
    this.callUID = `${this.callFrame.functionName}@${this.callFrame.scriptId}:${this.callFrame.lineNumber}`;
    /** @type {number} */
    this.self = 0;
    /** @type {number} */
    this.total = 0;
    /** @type {number} */
    this.id = 0;
    /** @type {?WebInspector.ProfileNode} */
    this.parent = null;
    /** @type {!Array<!WebInspector.ProfileNode>} */
    this.children = [];
}

WebInspector.ProfileNode.prototype = {
    /**
     * @return {string}
     */
    get functionName()
    {
        return this.callFrame.functionName;
    },

    /**
     * @return {string}
     */
    get scriptId()
    {
        return this.callFrame.scriptId;
    },

    /**
     * @return {string}
     */
    get url()
    {
        return this.callFrame.url;
    },

    /**
     * @return {number}
     */
    get lineNumber()
    {
        return this.callFrame.lineNumber;
    },

    /**
     * @return {number}
     */
    get columnNumber()
    {
        return this.callFrame.columnNumber;
    }
}

/**
 * @constructor
 * @param {!WebInspector.ProfileNode} root
 */
WebInspector.ProfileTreeModel = function(root)
{
    this.root = root;
    this._assignDepthsAndParents();
    this.total = this._calculateTotals(this.root);
}

WebInspector.ProfileTreeModel.prototype = {
    _assignDepthsAndParents: function()
    {
        var root = this.root;
        root.depth = -1;
        root.parent = null;
        this.maxDepth = 0;
        var nodesToTraverse = [root];
        while (nodesToTraverse.length) {
            var parent = nodesToTraverse.pop();
            var depth = parent.depth + 1;
            if (depth > this.maxDepth)
                this.maxDepth = depth;
            var children = parent.children;
            var length = children.length;
            for (var i = 0; i < length; ++i) {
                var child = children[i];
                child.depth = depth;
                child.parent = parent;
                if (child.children.length)
                    nodesToTraverse.push(child);
            }
        }
    },

    /**
     * @param {!WebInspector.ProfileNode} root
     * @return {number}
     */
    _calculateTotals: function(root)
    {
        var nodesToTraverse = [root];
        var dfsList = [];
        while (nodesToTraverse.length) {
            var node = nodesToTraverse.pop();
            node.total = node.self;
            dfsList.push(node);
            nodesToTraverse.push(...node.children);
        }
        while (dfsList.length > 1) {
            var node = dfsList.pop();
            node.parent.total += node.total;
        }
        return root.total;
    }
}

},{}],222:[function(require,module,exports){
/*
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @constructor
 * @extends {Protocol.Agents}
 * @param {!WebInspector.TargetManager} targetManager
 * @param {string} name
 * @param {number} capabilitiesMask
 * @param {!InspectorBackendClass.Connection} connection
 * @param {?WebInspector.Target} parentTarget
 */
WebInspector.Target = function(targetManager, name, capabilitiesMask, connection, parentTarget)
{
    Protocol.Agents.call(this, connection.agentsMap());
    this._targetManager = targetManager;
    this._name = name;
    this._inspectedURL = "";
    this._capabilitiesMask = capabilitiesMask;
    this._connection = connection;
    this._parentTarget = parentTarget;
    connection.addEventListener(InspectorBackendClass.Connection.Events.Disconnected, this._onDisconnect, this);
    this._id = WebInspector.Target._nextId++;

    /** @type {!Map.<!Function, !WebInspector.SDKModel>} */
    this._modelByConstructor = new Map();
}

/**
 * @enum {number}
 */
WebInspector.Target.Capability = {
    Browser: 1,
    DOM: 2,
    JS: 4,
    Log: 8,
    Network: 16,
    Worker: 32
};

WebInspector.Target._nextId = 1;

WebInspector.Target.prototype = {
    /**
     * @return {number}
     */
    id: function()
    {
        return this._id;
    },

    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @return {!WebInspector.TargetManager}
     */
    targetManager: function()
    {
        return this._targetManager;
    },

    /**
     * @param {number} capabilitiesMask
     * @return {boolean}
     */
    hasAllCapabilities: function(capabilitiesMask)
    {
        return (this._capabilitiesMask & capabilitiesMask) === capabilitiesMask;
    },

    /**
     *
     * @return {!InspectorBackendClass.Connection}
     */
    connection: function()
    {
        return this._connection;
    },

    /**
     * @param {string} label
     * @return {string}
     */
    decorateLabel: function(label)
    {
        return !this.hasBrowserCapability() ? "\u2699 " + label : label;
    },

    /**
     * @override
     * @param {string} domain
     * @param {!Object} dispatcher
     */
    registerDispatcher: function(domain, dispatcher)
    {
        this._connection.registerDispatcher(domain, dispatcher);
    },

    /**
     * @return {boolean}
     */
    hasBrowserCapability: function()
    {
        return this.hasAllCapabilities(WebInspector.Target.Capability.Browser);
    },

    /**
     * @return {boolean}
     */
    hasJSCapability: function()
    {
        return this.hasAllCapabilities(WebInspector.Target.Capability.JS);
    },

    /**
     * @return {boolean}
     */
    hasLogCapability: function()
    {
        return this.hasAllCapabilities(WebInspector.Target.Capability.Log);
    },

    /**
     * @return {boolean}
     */
    hasNetworkCapability: function()
    {
        return this.hasAllCapabilities(WebInspector.Target.Capability.Network);
    },

    /**
     * @return {boolean}
     */
    hasWorkerCapability: function()
    {
        return this.hasAllCapabilities(WebInspector.Target.Capability.Worker);
    },

    /**
     * @return {boolean}
     */
    hasDOMCapability: function()
    {
        return this.hasAllCapabilities(WebInspector.Target.Capability.DOM);
    },

    /**
     * @return {?WebInspector.Target}
     */
    parentTarget: function()
    {
        return this._parentTarget;
    },

    _onDisconnect: function()
    {
        this._targetManager.removeTarget(this);
        this._dispose();
    },

    _dispose: function()
    {
        this._targetManager.dispatchEventToListeners(WebInspector.TargetManager.Events.TargetDisposed, this);
        if (this.workerManager)
            this.workerManager.dispose();
    },

    /**
     * @return {boolean}
     */
    isDetached: function()
    {
        return this._connection.isClosed();
    },

    /**
     * @param {!Function} modelClass
     * @return {?WebInspector.SDKModel}
     */
    model: function(modelClass)
    {
        return this._modelByConstructor.get(modelClass) || null;
    },

    /**
     * @return {!Array<!WebInspector.SDKModel>}
     */
    models: function()
    {
        return this._modelByConstructor.valuesArray();
    },

    /**
     * @return {string}
     */
    inspectedURL: function()
    {
        return this._inspectedURL;
    },

    /**
     * @param {string} inspectedURL
     */
    setInspectedURL: function(inspectedURL)
    {
        this._inspectedURL = inspectedURL;
        InspectorFrontendHost.inspectedURLChanged(inspectedURL || "");
        this._targetManager.dispatchEventToListeners(WebInspector.TargetManager.Events.InspectedURLChanged, this);
    },

    __proto__: Protocol.Agents.prototype
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {!WebInspector.Target} target
 */
WebInspector.SDKObject = function(target)
{
    WebInspector.Object.call(this);
    this._target = target;
}

WebInspector.SDKObject.prototype = {
    /**
     * @return {!WebInspector.Target}
     */
    target: function()
    {
        return this._target;
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @constructor
 * @extends {WebInspector.SDKObject}
 * @param {!Function} modelClass
 * @param {!WebInspector.Target} target
 */
WebInspector.SDKModel = function(modelClass, target)
{
    WebInspector.SDKObject.call(this, target);
    target._modelByConstructor.set(modelClass, this);
    WebInspector.targetManager.addEventListener(WebInspector.TargetManager.Events.TargetDisposed, this._targetDisposed, this);
}

WebInspector.SDKModel.prototype = {
    /**
     * @return {!Promise}
     */
    suspendModel: function()
    {
        return Promise.resolve();
    },

    /**
     * @return {!Promise}
     */
    resumeModel: function()
    {
        return Promise.resolve();
    },

    dispose: function() { },

    /**
     * @param {!WebInspector.Event} event
     */
    _targetDisposed: function(event)
    {
        var target = /** @type {!WebInspector.Target} */ (event.data);
        if (target !== this._target)
            return;
        this.dispose();
        WebInspector.targetManager.removeEventListener(WebInspector.TargetManager.Events.TargetDisposed, this._targetDisposed, this);
    },

    __proto__: WebInspector.SDKObject.prototype
}

},{}],223:[function(require,module,exports){
/*
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @constructor
 * @extends {WebInspector.Object}
 */
WebInspector.TargetManager = function()
{
    WebInspector.Object.call(this);
    /** @type {!Array.<!WebInspector.Target>} */
    this._targets = [];
    /** @type {!Array.<!WebInspector.TargetManager.Observer>} */
    this._observers = [];
    this._observerCapabiliesMaskSymbol = Symbol("observerCapabilitiesMask");
    /** @type {!Map<symbol, !Array<{modelClass: !Function, thisObject: (!Object|undefined), listener: function(!WebInspector.Event)}>>} */
    this._modelListeners = new Map();
    this._isSuspended = false;
}

/** @enum {symbol} */
WebInspector.TargetManager.Events = {
    InspectedURLChanged: Symbol("InspectedURLChanged"),
    MainFrameNavigated: Symbol("MainFrameNavigated"),
    Load: Symbol("Load"),
    PageReloadRequested: Symbol("PageReloadRequested"),
    WillReloadPage: Symbol("WillReloadPage"),
    TargetDisposed: Symbol("TargetDisposed"),
    SuspendStateChanged: Symbol("SuspendStateChanged")
}

WebInspector.TargetManager._listenersSymbol = Symbol("WebInspector.TargetManager.Listeners");

WebInspector.TargetManager.prototype = {
    suspendAllTargets: function()
    {
        if (this._isSuspended)
            return;
        this._isSuspended = true;
        this.dispatchEventToListeners(WebInspector.TargetManager.Events.SuspendStateChanged);

        for (var i = 0; i < this._targets.length; ++i) {
            for (var model of this._targets[i].models())
                model.suspendModel();
        }
    },

    /**
     * @return {!Promise}
     */
    resumeAllTargets: function()
    {
        if (!this._isSuspended)
            throw new Error("Not suspended");
        this._isSuspended = false;
        this.dispatchEventToListeners(WebInspector.TargetManager.Events.SuspendStateChanged);

        var promises = [];
        for (var i = 0; i < this._targets.length; ++i) {
            for (var model of this._targets[i].models())
                promises.push(model.resumeModel());
        }
        return Promise.all(promises);
    },

    suspendAndResumeAllTargets: function()
    {
        this.suspendAllTargets();
        this.resumeAllTargets();
    },

    /**
     * @return {boolean}
     */
    allTargetsSuspended: function()
    {
        return this._isSuspended;
    },

    /**
     * @return {string}
     */
    inspectedURL: function()
    {
        return this._targets[0] ? this._targets[0].inspectedURL() : "";
    },

    /**
     * @param {!WebInspector.TargetManager.Events} eventName
     * @param {!WebInspector.Event} event
     */
    _redispatchEvent: function(eventName, event)
    {
        this.dispatchEventToListeners(eventName, event.data);
    },

    /**
     * @param {boolean=} bypassCache
     * @param {string=} injectedScript
     */
    reloadPage: function(bypassCache, injectedScript)
    {
        if (!this._targets.length)
            return;

        var resourceTreeModel = WebInspector.ResourceTreeModel.fromTarget(this._targets[0]);
        if (!resourceTreeModel)
            return;

        resourceTreeModel.reloadPage(bypassCache, injectedScript);
    },

    /**
     * @param {!Function} modelClass
     * @param {symbol} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    addModelListener: function(modelClass, eventType, listener, thisObject)
    {
        for (var i = 0; i < this._targets.length; ++i) {
            var model = this._targets[i].model(modelClass);
            if (model)
                model.addEventListener(eventType, listener, thisObject);
        }
        if (!this._modelListeners.has(eventType))
            this._modelListeners.set(eventType, []);
        this._modelListeners.get(eventType).push({ modelClass: modelClass, thisObject: thisObject, listener: listener });
    },

    /**
     * @param {!Function} modelClass
     * @param {symbol} eventType
     * @param {function(!WebInspector.Event)} listener
     * @param {!Object=} thisObject
     */
    removeModelListener: function(modelClass, eventType, listener, thisObject)
    {
        if (!this._modelListeners.has(eventType))
            return;

        for (var i = 0; i < this._targets.length; ++i) {
            var model = this._targets[i].model(modelClass);
            if (model)
                model.removeEventListener(eventType, listener, thisObject);
        }

        var listeners = this._modelListeners.get(eventType);
        for (var i = 0; i < listeners.length; ++i) {
            if (listeners[i].modelClass === modelClass && listeners[i].listener === listener && listeners[i].thisObject === thisObject)
                listeners.splice(i--, 1);
        }
        if (!listeners.length)
            this._modelListeners.delete(eventType);
    },

    /**
     * @param {!WebInspector.TargetManager.Observer} targetObserver
     * @param {number=} capabilitiesMask
     */
    observeTargets: function(targetObserver, capabilitiesMask)
    {
        if (this._observerCapabiliesMaskSymbol in targetObserver)
            throw new Error("Observer can only be registered once");
        targetObserver[this._observerCapabiliesMaskSymbol] = capabilitiesMask || 0;
        this.targets(capabilitiesMask).forEach(targetObserver.targetAdded.bind(targetObserver));
        this._observers.push(targetObserver);
    },

    /**
     * @param {!WebInspector.TargetManager.Observer} targetObserver
     */
    unobserveTargets: function(targetObserver)
    {
        delete targetObserver[this._observerCapabiliesMaskSymbol];
        this._observers.remove(targetObserver);
    },

    /**
     * @param {string} name
     * @param {number} capabilitiesMask
     * @param {!InspectorBackendClass.Connection} connection
     * @param {?WebInspector.Target} parentTarget
     * @return {!WebInspector.Target}
     */
    createTarget: function(name, capabilitiesMask, connection, parentTarget)
    {
        var target = new WebInspector.Target(this, name, capabilitiesMask, connection, parentTarget);

        var logAgent = target.hasLogCapability() ? target.logAgent() : null;

        /** @type {!WebInspector.ConsoleModel} */
        target.consoleModel = new WebInspector.ConsoleModel(target, logAgent);
        /** @type {!WebInspector.RuntimeModel} */
        target.runtimeModel = new WebInspector.RuntimeModel(target);

        var networkManager = null;
        var resourceTreeModel = null;
        if (target.hasNetworkCapability())
            networkManager = new WebInspector.NetworkManager(target);
        if (networkManager && target.hasDOMCapability()) {
            resourceTreeModel = new WebInspector.ResourceTreeModel(target, networkManager, WebInspector.SecurityOriginManager.fromTarget(target));
            new WebInspector.NetworkLog(target, resourceTreeModel, networkManager);
        }

        if (target.hasJSCapability())
            new WebInspector.DebuggerModel(target);

        if (resourceTreeModel) {
            var domModel = new WebInspector.DOMModel(target);
            // TODO(eostroukhov) CSSModel should not depend on RTM
            new WebInspector.CSSModel(target, domModel);
        }

        /** @type {?WebInspector.WorkerManager} */
        target.workerManager = target.hasWorkerCapability() ? new WebInspector.WorkerManager(target) : null;
        /** @type {!WebInspector.CPUProfilerModel} */
        target.cpuProfilerModel = new WebInspector.CPUProfilerModel(target);
        /** @type {!WebInspector.HeapProfilerModel} */
        target.heapProfilerModel = new WebInspector.HeapProfilerModel(target);

        target.tracingManager = new WebInspector.TracingManager(target);

        if (target.hasBrowserCapability()) {
            target.subTargetsManager = new WebInspector.SubTargetsManager(target);
            target.serviceWorkerManager = new WebInspector.ServiceWorkerManager(target, target.subTargetsManager);
        }

        this.addTarget(target);
        return target;
    },

    /**
     * @param {!WebInspector.Target} target
     * @return {!Array<!WebInspector.TargetManager.Observer>}
     */
    _observersForTarget: function(target)
    {
        return this._observers.filter((observer) => target.hasAllCapabilities(observer[this._observerCapabiliesMaskSymbol] || 0));
    },

    /**
     * @param {!WebInspector.Target} target
     */
    addTarget: function(target)
    {
        this._targets.push(target);
        var resourceTreeModel = WebInspector.ResourceTreeModel.fromTarget(target);
        if (this._targets.length === 1 && resourceTreeModel) {
            resourceTreeModel[WebInspector.TargetManager._listenersSymbol] = [
                setupRedispatch.call(this, WebInspector.ResourceTreeModel.Events.MainFrameNavigated, WebInspector.TargetManager.Events.MainFrameNavigated),
                setupRedispatch.call(this, WebInspector.ResourceTreeModel.Events.Load, WebInspector.TargetManager.Events.Load),
                setupRedispatch.call(this, WebInspector.ResourceTreeModel.Events.PageReloadRequested, WebInspector.TargetManager.Events.PageReloadRequested),
                setupRedispatch.call(this, WebInspector.ResourceTreeModel.Events.WillReloadPage, WebInspector.TargetManager.Events.WillReloadPage)
            ];
        }
        var copy = this._observersForTarget(target);
        for (var i = 0; i < copy.length; ++i)
            copy[i].targetAdded(target);

        for (var pair of this._modelListeners) {
            var listeners = pair[1];
            for (var i = 0; i < listeners.length; ++i) {
                var model = target.model(listeners[i].modelClass);
                if (model)
                    model.addEventListener(/** @type {symbol} */ (pair[0]), listeners[i].listener, listeners[i].thisObject);
            }
        }

        /**
         * @param {!WebInspector.ResourceTreeModel.Events} sourceEvent
         * @param {!WebInspector.TargetManager.Events} targetEvent
         * @return {!WebInspector.EventTarget.EventDescriptor}
         * @this {WebInspector.TargetManager}
         */
        function setupRedispatch(sourceEvent, targetEvent)
        {
            return resourceTreeModel.addEventListener(sourceEvent, this._redispatchEvent.bind(this, targetEvent));
        }
    },

    /**
     * @param {!WebInspector.Target} target
     */
    removeTarget: function(target)
    {
        this._targets.remove(target);
        var resourceTreeModel = WebInspector.ResourceTreeModel.fromTarget(target);
        var treeModelListeners = resourceTreeModel && resourceTreeModel[WebInspector.TargetManager._listenersSymbol];
        if (treeModelListeners)
            WebInspector.EventTarget.removeEventListeners(treeModelListeners);

        var copy = this._observersForTarget(target);
        for (var i = 0; i < copy.length; ++i)
            copy[i].targetRemoved(target);

        for (var pair of this._modelListeners) {
            var listeners = pair[1];
            for (var i = 0; i < listeners.length; ++i) {
                var model = target.model(listeners[i].modelClass);
                if (model)
                    model.removeEventListener(/** @type {symbol} */ (pair[0]), listeners[i].listener, listeners[i].thisObject);
            }
        }
    },

    /**
     * @param {number=} capabilitiesMask
     * @return {!Array.<!WebInspector.Target>}
     */
    targets: function(capabilitiesMask)
    {
        if (!capabilitiesMask)
            return this._targets.slice();
        else
            return this._targets.filter((target) => target.hasAllCapabilities(capabilitiesMask || 0));
    },

    /**
     *
     * @param {number} id
     * @return {?WebInspector.Target}
     */
    targetById: function(id)
    {
        for (var i = 0; i < this._targets.length; ++i) {
            if (this._targets[i].id() === id)
                return this._targets[i];
        }
        return null;
    },

    /**
     * @return {?WebInspector.Target}
     */
    mainTarget: function()
    {
        return this._targets[0] || null;
    },

    /**
     * @param {!WebInspector.Target} target
     */
    suspendReload: function(target)
    {
        var resourceTreeModel = WebInspector.ResourceTreeModel.fromTarget(target);
        if (resourceTreeModel)
            resourceTreeModel.suspendReload();
    },

    /**
     * @param {!WebInspector.Target} target
     */
    resumeReload: function(target)
    {
        var resourceTreeModel = WebInspector.ResourceTreeModel.fromTarget(target);
        if (resourceTreeModel)
            setImmediate(resourceTreeModel.resumeReload.bind(resourceTreeModel));
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @interface
 */
WebInspector.TargetManager.Observer = function()
{
}

WebInspector.TargetManager.Observer.prototype = {
    /**
     * @param {!WebInspector.Target} target
     */
    targetAdded: function(target) { },

    /**
     * @param {!WebInspector.Target} target
     */
    targetRemoved: function(target) { },
}

/**
 * @type {!WebInspector.TargetManager}
 */
WebInspector.targetManager = new WebInspector.TargetManager();

},{}],224:[function(require,module,exports){
/*
 * Copyright 2014 The Chromium Authors. All rights reserved.
 * Use of this source code is governed by a BSD-style license that can be
 * found in the LICENSE file.
 */

/**
 * @constructor
 * @param {!WebInspector.BackingStorage} backingStorage
 */
WebInspector.TracingModel = function(backingStorage)
{
    this._backingStorage = backingStorage;
    // Avoid extra reset of the storage as it's expensive.
    this._firstWritePending = true;
    this.reset();
}

/**
 * @enum {string}
 */
WebInspector.TracingModel.Phase = {
    Begin: "B",
    End: "E",
    Complete: "X",
    Instant: "I",
    AsyncBegin: "S",
    AsyncStepInto: "T",
    AsyncStepPast: "p",
    AsyncEnd: "F",
    NestableAsyncBegin: "b",
    NestableAsyncEnd: "e",
    NestableAsyncInstant: "n",
    FlowBegin: "s",
    FlowStep: "t",
    FlowEnd: "f",
    Metadata: "M",
    Counter: "C",
    Sample: "P",
    CreateObject: "N",
    SnapshotObject: "O",
    DeleteObject: "D"
};

WebInspector.TracingModel.MetadataEvent = {
    ProcessSortIndex: "process_sort_index",
    ProcessName: "process_name",
    ThreadSortIndex: "thread_sort_index",
    ThreadName: "thread_name"
}

WebInspector.TracingModel.TopLevelEventCategory = "toplevel";
WebInspector.TracingModel.DevToolsMetadataEventCategory = "disabled-by-default-devtools.timeline";
WebInspector.TracingModel.DevToolsTimelineEventCategory = "disabled-by-default-devtools.timeline";

WebInspector.TracingModel.FrameLifecycleEventCategory = "cc,devtools";

/**
 * @param {string} phase
 * @return {boolean}
 */
WebInspector.TracingModel.isNestableAsyncPhase = function(phase)
{
    return phase === "b" || phase === "e" || phase === "n";
}

/**
 * @param {string} phase
 * @return {boolean}
 */
WebInspector.TracingModel.isAsyncBeginPhase = function(phase)
{
    return phase === "S" || phase === "b";
}

/**
 * @param {string} phase
 * @return {boolean}
 */
WebInspector.TracingModel.isAsyncPhase = function(phase)
{
    return WebInspector.TracingModel.isNestableAsyncPhase(phase) || phase === "S" || phase === "T" || phase === "F" || phase === "p";
}

/**
 * @param {string} phase
 * @return {boolean}
 */
WebInspector.TracingModel.isFlowPhase = function(phase)
{
    return phase === "s" || phase === "t" || phase === "f";
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {boolean}
 */
WebInspector.TracingModel.isTopLevelEvent = function(event)
{
    return event.hasCategory(WebInspector.TracingModel.TopLevelEventCategory) ||
        event.hasCategory(WebInspector.TracingModel.DevToolsMetadataEventCategory) && event.name === "Program"; // Older timelines may have this instead of toplevel.
}

/**
 * @param {!WebInspector.TracingManager.EventPayload} payload
 * @return {string|undefined}
 */
WebInspector.TracingModel._extractId = function(payload)
{
    var scope = payload.scope || "";
    if (typeof payload.id2 === "undefined")
        return scope && payload.id ? `${scope}@${payload.id}` : payload.id;
    var id2 = payload.id2;
    if (typeof id2 === "object" && ("global" in id2) !== ("local" in id2))
        return typeof id2["global"] !== "undefined" ? `:${scope}:${id2["global"]}` : `:${scope}:${payload.pid}:${id2["local"]}`;
    console.error(`Unexpected id2 field at ${payload.ts / 1000}, one and only one of 'local' and 'global' should be present.`);
}

/**
 * @param {!WebInspector.TracingModel} tracingModel
 * @return {?WebInspector.TracingModel.Thread}
 *
 * TODO: Move this to a better place. This is here just for convenience o
 * re-use between modules. This really belongs to a higher level, since it
 * is specific to chrome's usage of tracing.
 */
WebInspector.TracingModel.browserMainThread = function(tracingModel)
{
    var processes = tracingModel.sortedProcesses();
    var browserProcesses = [];
    var crRendererMainThreads = [];
    for (var process of processes) {
        if (process.name().toLowerCase().endsWith("browser"))
            browserProcesses.push(process);
        crRendererMainThreads.push(...process.sortedThreads().filter(t => t.name() === "CrBrowserMain"));
    }
    if (crRendererMainThreads.length === 1)
        return crRendererMainThreads[0];
    if (browserProcesses.length === 1)
        return browserProcesses[0].threadByName("CrBrowserMain");
    var tracingStartedInBrowser = tracingModel.devToolsMetadataEvents().filter(e => e.name === "TracingStartedInBrowser");
    if (tracingStartedInBrowser.length === 1)
        return tracingStartedInBrowser[0].thread;
    WebInspector.console.error("Failed to find browser main thread in trace, some timeline features may be unavailable");
    return null;
}

/**
 * @interface
 */
WebInspector.BackingStorage = function()
{
}

WebInspector.BackingStorage.prototype = {
    /**
     * @param {string} string
     */
    appendString: function(string) { },

    /**
     * @param {string} string
     * @return {function():!Promise.<?string>}
     */
    appendAccessibleString: function(string) { },

    finishWriting: function() { },

    reset: function() { },
}


WebInspector.TracingModel.prototype = {
    /**
     * @return {!Array.<!WebInspector.TracingModel.Event>}
     */
    devToolsMetadataEvents: function()
    {
        return this._devToolsMetadataEvents;
    },

    /**
     * @param {!Array.<!WebInspector.TracingManager.EventPayload>} events
     */
    setEventsForTest: function(events)
    {
        this.reset();
        this.addEvents(events);
        this.tracingComplete();
    },

    /**
     * @param {!Array.<!WebInspector.TracingManager.EventPayload>} events
     */
    addEvents: function(events)
    {
        for (var i = 0; i < events.length; ++i)
            this._addEvent(events[i]);
    },

    tracingComplete: function()
    {
        this._processPendingAsyncEvents();
        this._backingStorage.appendString(this._firstWritePending ? "[]" : "]");
        this._backingStorage.finishWriting();
        this._firstWritePending = false;
        for (var process of this._processById.values()) {
            for (var thread of process._threads.values())
                thread.tracingComplete();
        }
    },

    reset: function()
    {
        /** @type {!Map<(number|string), !WebInspector.TracingModel.Process>} */
        this._processById = new Map();
        this._processByName = new Map();
        this._minimumRecordTime = 0;
        this._maximumRecordTime = 0;
        this._devToolsMetadataEvents = [];
        if (!this._firstWritePending)
            this._backingStorage.reset();

        this._firstWritePending = true;
        /** @type {!Array<!WebInspector.TracingModel.Event>} */
        this._asyncEvents = [];
        /** @type {!Map<string, !WebInspector.TracingModel.AsyncEvent>} */
        this._openAsyncEvents = new Map();
        /** @type {!Map<string, !Array<!WebInspector.TracingModel.AsyncEvent>>} */
        this._openNestableAsyncEvents = new Map();
        /** @type {!Map<string, !Set<string>>} */
        this._parsedCategories = new Map();
    },

    /**
      * @param {!WebInspector.TracingManager.EventPayload} payload
      */
    _addEvent: function(payload)
    {
        var process = this._processById.get(payload.pid);
        if (!process) {
            process = new WebInspector.TracingModel.Process(this, payload.pid);
            this._processById.set(payload.pid, process);
        }

        var eventsDelimiter = ",\n";
        this._backingStorage.appendString(this._firstWritePending ? "[" : eventsDelimiter);
        this._firstWritePending = false;
        var stringPayload = JSON.stringify(payload);
        var isAccessible = payload.ph === WebInspector.TracingModel.Phase.SnapshotObject;
        var backingStorage = null;
        var keepStringsLessThan = 10000;
        if (isAccessible && stringPayload.length > keepStringsLessThan)
            backingStorage = this._backingStorage.appendAccessibleString(stringPayload);
        else
            this._backingStorage.appendString(stringPayload);

        var timestamp = payload.ts / 1000;
        // We do allow records for unrelated threads to arrive out-of-order,
        // so there's a chance we're getting records from the past.
        if (timestamp && (!this._minimumRecordTime || timestamp < this._minimumRecordTime))
            this._minimumRecordTime = timestamp;
        var endTimeStamp = (payload.ts + (payload.dur || 0)) / 1000;
        this._maximumRecordTime = Math.max(this._maximumRecordTime, endTimeStamp);
        var event = process._addEvent(payload);
        if (!event)
            return;
        // Build async event when we've got events from all threads & processes, so we can sort them and process in the
        // chronological order. However, also add individual async events to the thread flow (above), so we can easily
        // display them on the same chart as other events, should we choose so.
        if (WebInspector.TracingModel.isAsyncPhase(payload.ph))
            this._asyncEvents.push(event);
        event._setBackingStorage(backingStorage);
        if (event.hasCategory(WebInspector.TracingModel.DevToolsMetadataEventCategory))
            this._devToolsMetadataEvents.push(event);

        if (payload.ph !== WebInspector.TracingModel.Phase.Metadata)
            return;

        switch (payload.name) {
        case WebInspector.TracingModel.MetadataEvent.ProcessSortIndex:
            process._setSortIndex(payload.args["sort_index"]);
            break;
        case WebInspector.TracingModel.MetadataEvent.ProcessName:
            var processName = payload.args["name"];
            process._setName(processName);
            this._processByName.set(processName, process);
            break;
        case WebInspector.TracingModel.MetadataEvent.ThreadSortIndex:
            process.threadById(payload.tid)._setSortIndex(payload.args["sort_index"]);
            break;
        case WebInspector.TracingModel.MetadataEvent.ThreadName:
            process.threadById(payload.tid)._setName(payload.args["name"]);
            break;
        }
    },

    /**
     * @return {number}
     */
    minimumRecordTime: function()
    {
        return this._minimumRecordTime;
    },

    /**
     * @return {number}
     */
    maximumRecordTime: function()
    {
        return this._maximumRecordTime;
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.Process>}
     */
    sortedProcesses: function()
    {
        return WebInspector.TracingModel.NamedObject._sort(this._processById.valuesArray());
    },

    /**
     * @param {string} name
     * @return {?WebInspector.TracingModel.Process}
     */
    processByName: function(name)
    {
        return this._processByName.get(name);
    },

    /**
     * @param {string} processName
     * @param {string} threadName
     * @return {?WebInspector.TracingModel.Thread}
     */
    threadByName: function(processName, threadName)
    {
        var process = this.processByName(processName);
        return process && process.threadByName(threadName);
    },

    _processPendingAsyncEvents: function()
    {
        this._asyncEvents.stableSort(WebInspector.TracingModel.Event.compareStartTime);
        for (var i = 0; i < this._asyncEvents.length; ++i) {
            var event = this._asyncEvents[i];
            if (WebInspector.TracingModel.isNestableAsyncPhase(event.phase))
                this._addNestableAsyncEvent(event);
            else
                this._addAsyncEvent(event);
        }
        this._asyncEvents = [];
        this._closeOpenAsyncEvents();
    },

    _closeOpenAsyncEvents: function()
    {
        for (var event of this._openAsyncEvents.values()) {
            event.setEndTime(this._maximumRecordTime);
            // FIXME: remove this once we figure a better way to convert async console
            // events to sync [waterfall] timeline records.
            event.steps[0].setEndTime(this._maximumRecordTime);
        }
        this._openAsyncEvents.clear();

        for (var eventStack of this._openNestableAsyncEvents.values()) {
            while (eventStack.length)
                eventStack.pop().setEndTime(this._maximumRecordTime);
        }
        this._openNestableAsyncEvents.clear();
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addNestableAsyncEvent: function(event)
    {
        var phase = WebInspector.TracingModel.Phase;
        var key = event.categoriesString + "." + event.id;
        var openEventsStack = this._openNestableAsyncEvents.get(key);

        switch (event.phase) {
        case phase.NestableAsyncBegin:
            if (!openEventsStack) {
                openEventsStack = [];
                this._openNestableAsyncEvents.set(key, openEventsStack);
            }
            var asyncEvent = new WebInspector.TracingModel.AsyncEvent(event);
            openEventsStack.push(asyncEvent);
            event.thread._addAsyncEvent(asyncEvent);
            break;

        case phase.NestableAsyncInstant:
            if (openEventsStack && openEventsStack.length)
                openEventsStack.peekLast()._addStep(event);
            break;

        case phase.NestableAsyncEnd:
            if (!openEventsStack || !openEventsStack.length)
                break;
            var top = openEventsStack.pop();
            if (top.name !== event.name) {
                console.error(`Begin/end event mismatch for nestable async event, ${top.name} vs. ${event.name}, key: ${key}`);
                break;
            }
            top._addStep(event);
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addAsyncEvent: function(event)
    {
        var phase = WebInspector.TracingModel.Phase;
        var key = event.categoriesString + "." + event.name + "." + event.id;
        var asyncEvent = this._openAsyncEvents.get(key);

        if (event.phase === phase.AsyncBegin) {
            if (asyncEvent) {
                console.error(`Event ${event.name} has already been started`);
                return;
            }
            asyncEvent = new WebInspector.TracingModel.AsyncEvent(event);
            this._openAsyncEvents.set(key, asyncEvent);
            event.thread._addAsyncEvent(asyncEvent);
            return;
        }
        if (!asyncEvent) {
            // Quietly ignore stray async events, we're probably too late for the start.
            return;
        }
        if (event.phase === phase.AsyncEnd) {
            asyncEvent._addStep(event);
            this._openAsyncEvents.delete(key);
            return;
        }
        if (event.phase === phase.AsyncStepInto || event.phase === phase.AsyncStepPast) {
            var lastStep = asyncEvent.steps.peekLast();
            if (lastStep.phase !== phase.AsyncBegin && lastStep.phase !== event.phase) {
                console.assert(false, "Async event step phase mismatch: " + lastStep.phase + " at " + lastStep.startTime + " vs. " + event.phase + " at " + event.startTime);
                return;
            }
            asyncEvent._addStep(event);
            return;
        }
        console.assert(false, "Invalid async event phase");
    },

    /**
     * @param {string} str
     * @return {!Set<string>}
     */
    _parsedCategoriesForString: function(str)
    {
        var parsedCategories = this._parsedCategories.get(str);
        if (!parsedCategories) {
            parsedCategories = new Set(str.split(","));
            this._parsedCategories.set(str, parsedCategories);
        }
        return parsedCategories;
    }
}

/**
 * @constructor
 * @param {string} categories
 * @param {string} name
 * @param {!WebInspector.TracingModel.Phase} phase
 * @param {number} startTime
 * @param {!WebInspector.TracingModel.Thread} thread
 */
WebInspector.TracingModel.Event = function(categories, name, phase, startTime, thread)
{
    /** @type {string} */
    this.categoriesString = categories;
    /** @type {!Set<string>} */
    this._parsedCategories = thread._model._parsedCategoriesForString(categories);
    /** @type {string} */
    this.name = name;
    /** @type {!WebInspector.TracingModel.Phase} */
    this.phase = phase;
    /** @type {number} */
    this.startTime = startTime;
    /** @type {!WebInspector.TracingModel.Thread} */
    this.thread = thread;
    /** @type {!Object} */
    this.args = {};

    /** @type {?string} */
    this.warning = null;
    /** @type {?WebInspector.TracingModel.Event} */
    this.initiator = null;
    /** @type {?Array<!RuntimeAgent.CallFrame>} */
    this.stackTrace = null;
    /** @type {?Element} */
    this.previewElement = null;
    /** @type {?string} */
    this.url = null;
    /** @type {number} */
    this.backendNodeId = 0;

    /** @type {number} */
    this.selfTime = 0;
}

/**
 * @param {!WebInspector.TracingManager.EventPayload} payload
 * @param {!WebInspector.TracingModel.Thread} thread
 * @return {!WebInspector.TracingModel.Event}
 */
WebInspector.TracingModel.Event.fromPayload = function(payload, thread)
{
    var event = new WebInspector.TracingModel.Event(payload.cat, payload.name, /** @type {!WebInspector.TracingModel.Phase} */ (payload.ph), payload.ts / 1000, thread);
    if (payload.args)
        event.addArgs(payload.args);
    else
        console.error("Missing mandatory event argument 'args' at " + payload.ts / 1000);
    if (typeof payload.dur === "number")
        event.setEndTime((payload.ts + payload.dur) / 1000);
    var id = WebInspector.TracingModel._extractId(payload);
    if (typeof id !== "undefined")
        event.id = id;
    if (payload.bind_id)
        event.bind_id = payload.bind_id;

    return event;
}

WebInspector.TracingModel.Event.prototype = {
    /**
     * @param {string} categoryName
     * @return {boolean}
     */
    hasCategory: function(categoryName)
    {
        return this._parsedCategories.has(categoryName);
    },

    /**
     * @param {number} endTime
     */
    setEndTime: function(endTime)
    {
        if (endTime < this.startTime) {
            console.assert(false, "Event out of order: " + this.name);
            return;
        }
        this.endTime = endTime;
        this.duration = endTime - this.startTime;
    },

    /**
     * @param {!Object} args
     */
    addArgs: function(args)
    {
        // Shallow copy args to avoid modifying original payload which may be saved to file.
        for (var name in args) {
            if (name in this.args)
                console.error("Same argument name (" + name +  ") is used for begin and end phases of " + this.name);
            this.args[name] = args[name];
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} endEvent
     */
    _complete: function(endEvent)
    {
        if (endEvent.args)
            this.addArgs(endEvent.args);
        else
            console.error("Missing mandatory event argument 'args' at " + endEvent.startTime);
        this.setEndTime(endEvent.startTime);
    },

    /**
     * @param {?function():!Promise.<?string>} backingStorage
     */
    _setBackingStorage: function(backingStorage)
    {
    }
}

/**
 * @param {!WebInspector.TracingModel.Event} a
 * @param {!WebInspector.TracingModel.Event} b
 * @return {number}
 */
WebInspector.TracingModel.Event.compareStartTime = function(a, b)
{
    return a.startTime - b.startTime;
}

/**
 * @param {!WebInspector.TracingModel.Event} a
 * @param {!WebInspector.TracingModel.Event} b
 * @return {number}
 */
WebInspector.TracingModel.Event.compareStartAndEndTime = function(a, b)
{
    return a.startTime - b.startTime || (b.endTime !== undefined && a.endTime !== undefined && b.endTime - a.endTime) || 0;
}

/**
 * @param {!WebInspector.TracingModel.Event} a
 * @param {!WebInspector.TracingModel.Event} b
 * @return {number}
 */
WebInspector.TracingModel.Event.orderedCompareStartTime = function(a, b)
{
    // Array.mergeOrdered coalesces objects if comparator returns 0.
    // To change this behavior this comparator return -1 in the case events
    // startTime's are equal, so both events got placed into the result array.
    return a.startTime - b.startTime || a.ordinal - b.ordinal || -1;
}

/**
 * @constructor
 * @extends {WebInspector.TracingModel.Event}
 * @param {string} category
 * @param {string} name
 * @param {number} startTime
 * @param {!WebInspector.TracingModel.Thread} thread
 */
WebInspector.TracingModel.ObjectSnapshot = function(category, name, startTime, thread)
{
    WebInspector.TracingModel.Event.call(this, category, name, WebInspector.TracingModel.Phase.SnapshotObject, startTime, thread);
}

/**
 * @param {!WebInspector.TracingManager.EventPayload} payload
 * @param {!WebInspector.TracingModel.Thread} thread
 * @return {!WebInspector.TracingModel.ObjectSnapshot}
 */
WebInspector.TracingModel.ObjectSnapshot.fromPayload = function(payload, thread)
{
    var snapshot = new WebInspector.TracingModel.ObjectSnapshot(payload.cat, payload.name, payload.ts / 1000, thread);
    var id = WebInspector.TracingModel._extractId(payload);
    if (typeof id !== "undefined")
        snapshot.id = id;
    if (!payload.args || !payload.args["snapshot"]) {
        console.error("Missing mandatory 'snapshot' argument at " + payload.ts / 1000);
        return snapshot;
    }
    if (payload.args)
        snapshot.addArgs(payload.args);
    return snapshot;
}

WebInspector.TracingModel.ObjectSnapshot.prototype = {
    /**
     * @param {function(?)} callback
     */
    requestObject: function(callback)
    {
        var snapshot = this.args["snapshot"];
        if (snapshot) {
            callback(snapshot);
            return;
        }
        this._backingStorage().then(onRead, callback.bind(null, null));
        /**
         * @param {?string} result
         */
        function onRead(result)
        {
            if (!result) {
                callback(null);
                return;
            }
            try {
                var payload = JSON.parse(result);
                callback(payload["args"]["snapshot"]);
            } catch (e) {
                WebInspector.console.error("Malformed event data in backing storage");
                callback(null);
            }
        }
    },

    /**
     * @return {!Promise<?>}
     */
    objectPromise: function()
    {
        if (!this._objectPromise)
            this._objectPromise = new Promise(this.requestObject.bind(this));
        return this._objectPromise;
    },

    /**
     * @override
     * @param {?function():!Promise.<?>} backingStorage
     */
    _setBackingStorage: function(backingStorage)
    {
        if (!backingStorage)
            return;
        this._backingStorage = backingStorage;
        this.args = {};
    },

    __proto__: WebInspector.TracingModel.Event.prototype
}

/**
 * @constructor
 * @param {!WebInspector.TracingModel.Event} startEvent
 * @extends {WebInspector.TracingModel.Event}
 */
WebInspector.TracingModel.AsyncEvent = function(startEvent)
{
    WebInspector.TracingModel.Event.call(this, startEvent.categoriesString, startEvent.name, startEvent.phase, startEvent.startTime, startEvent.thread)
    this.addArgs(startEvent.args);
    this.steps = [startEvent];
}

WebInspector.TracingModel.AsyncEvent.prototype = {
    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addStep: function(event)
    {
        this.steps.push(event);
        if (event.phase === WebInspector.TracingModel.Phase.AsyncEnd || event.phase === WebInspector.TracingModel.Phase.NestableAsyncEnd) {
            this.setEndTime(event.startTime);
            // FIXME: ideally, we shouldn't do this, but this makes the logic of converting
            // async console events to sync ones much simpler.
            this.steps[0].setEndTime(event.startTime);
        }
    },

    __proto__: WebInspector.TracingModel.Event.prototype
}

/**
 * @constructor
 */
WebInspector.TracingModel.NamedObject = function()
{
}

WebInspector.TracingModel.NamedObject.prototype =
{
    /**
     * @param {string} name
     */
    _setName: function(name)
    {
        this._name = name;
    },

    /**
     * @return {string}
     */
    name: function()
    {
        return this._name;
    },

    /**
     * @param {number} sortIndex
     */
    _setSortIndex: function(sortIndex)
    {
        this._sortIndex = sortIndex;
    },
}

/**
 * @param {!Array.<!WebInspector.TracingModel.NamedObject>} array
 */
WebInspector.TracingModel.NamedObject._sort = function(array)
{
    /**
     * @param {!WebInspector.TracingModel.NamedObject} a
     * @param {!WebInspector.TracingModel.NamedObject} b
     */
    function comparator(a, b)
    {
        return a._sortIndex !== b._sortIndex ? a._sortIndex - b._sortIndex : a.name().localeCompare(b.name());
    }
    return array.sort(comparator);
}

/**
 * @constructor
 * @extends {WebInspector.TracingModel.NamedObject}
 * @param {!WebInspector.TracingModel} model
 * @param {number} id
 */
WebInspector.TracingModel.Process = function(model, id)
{
    WebInspector.TracingModel.NamedObject.call(this);
    this._setName("Process " + id);
    this._id = id;
    /** @type {!Map<number, !WebInspector.TracingModel.Thread>} */
    this._threads = new Map();
    this._threadByName = new Map();
    this._model = model;
}

WebInspector.TracingModel.Process.prototype = {
    /**
     * @return {number}
     */
    id: function()
    {
        return this._id;
    },

    /**
     * @param {number} id
     * @return {!WebInspector.TracingModel.Thread}
     */
    threadById: function(id)
    {
        var thread = this._threads.get(id);
        if (!thread) {
            thread = new WebInspector.TracingModel.Thread(this, id);
            this._threads.set(id, thread);
        }
        return thread;
    },

    /**
     * @param {string} name
     * @return {?WebInspector.TracingModel.Thread}
     */
    threadByName: function(name)
    {
        return this._threadByName.get(name) || null;
    },

    /**
     * @param {string} name
     * @param {!WebInspector.TracingModel.Thread} thread
     */
    _setThreadByName: function(name, thread)
    {
        this._threadByName.set(name, thread);
    },

    /**
     * @param {!WebInspector.TracingManager.EventPayload} payload
     * @return {?WebInspector.TracingModel.Event} event
     */
    _addEvent: function(payload)
    {
        return this.threadById(payload.tid)._addEvent(payload);
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.Thread>}
     */
    sortedThreads: function()
    {
        return WebInspector.TracingModel.NamedObject._sort(this._threads.valuesArray());
    },

    __proto__: WebInspector.TracingModel.NamedObject.prototype
}

/**
 * @constructor
 * @extends {WebInspector.TracingModel.NamedObject}
 * @param {!WebInspector.TracingModel.Process} process
 * @param {number} id
 */
WebInspector.TracingModel.Thread = function(process, id)
{
    WebInspector.TracingModel.NamedObject.call(this);
    this._process = process;
    this._setName("Thread " + id);
    this._events = [];
    this._asyncEvents = [];
    this._id = id;
    this._model = process._model;
}

WebInspector.TracingModel.Thread.prototype = {
    tracingComplete: function()
    {
        this._asyncEvents.stableSort(WebInspector.TracingModel.Event.compareStartAndEndTime);
        this._events.stableSort(WebInspector.TracingModel.Event.compareStartTime);
        var phases = WebInspector.TracingModel.Phase;
        var stack = [];
        for (var i = 0; i < this._events.length; ++i) {
            var e = this._events[i];
            e.ordinal = i;
            switch (e.phase) {
            case phases.End:
                this._events[i] = null;  // Mark for removal.
                // Quietly ignore unbalanced close events, they're legit (we could have missed start one).
                if (!stack.length)
                    continue;
                var top = stack.pop();
                if (top.name !== e.name || top.categoriesString !== e.categoriesString)
                    console.error("B/E events mismatch at " + top.startTime + " (" + top.name + ") vs. " + e.startTime + " (" + e.name + ")");
                else
                    top._complete(e);
                break;
            case phases.Begin:
                stack.push(e);
                break;
            }
        }
        while (stack.length)
            stack.pop().setEndTime(this._model.maximumRecordTime());
        this._events.remove(null, false);
    },

    /**
     * @param {!WebInspector.TracingManager.EventPayload} payload
     * @return {?WebInspector.TracingModel.Event} event
     */
    _addEvent: function(payload)
    {
        var event = payload.ph === WebInspector.TracingModel.Phase.SnapshotObject
            ? WebInspector.TracingModel.ObjectSnapshot.fromPayload(payload, this)
            : WebInspector.TracingModel.Event.fromPayload(payload, this);
        if (WebInspector.TracingModel.isTopLevelEvent(event)) {
            // Discard nested "top-level" events.
            if (this._lastTopLevelEvent && this._lastTopLevelEvent.endTime > event.startTime)
                return null;
            this._lastTopLevelEvent = event;
        }
        this._events.push(event);
        return event;
    },

    /**
     * @param {!WebInspector.TracingModel.AsyncEvent} asyncEvent
     */
    _addAsyncEvent: function(asyncEvent)
    {
        this._asyncEvents.push(asyncEvent);
    },

    /**
     * @override
     * @param {string} name
     */
    _setName: function(name)
    {
        WebInspector.TracingModel.NamedObject.prototype._setName.call(this, name);
        this._process._setThreadByName(name, this);
    },

    /**
     * @return {number}
     */
    id: function()
    {
        return this._id;
    },

    /**
     * @return {!WebInspector.TracingModel.Process}
     */
    process: function()
    {
        return this._process;
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.Event>}
     */
    events: function()
    {
        return this._events;
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.AsyncEvent>}
     */
    asyncEvents: function()
    {
        return this._asyncEvents;
    },

    __proto__: WebInspector.TracingModel.NamedObject.prototype
}

},{}],225:[function(require,module,exports){
// Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.VBox}
 * @param {!WebInspector.TimelineModel} model
 * @param {!Array<!WebInspector.TimelineModel.Filter>} filters
 */
WebInspector.TimelineTreeView = function(model, filters)
{
    WebInspector.VBox.call(this);
    this.element.classList.add("timeline-tree-view");

    this._model = model;
    this._linkifier = new WebInspector.Linkifier();

    this._filters = filters.slice();

    var columns = [];
    this._populateColumns(columns);

    var mainView = new WebInspector.VBox();
    this._populateToolbar(mainView.element);
    this._dataGrid = new WebInspector.SortableDataGrid(columns);
    this._dataGrid.addEventListener(WebInspector.DataGrid.Events.SortingChanged, this._sortingChanged, this);
    this._dataGrid.element.addEventListener("mousemove", this._onMouseMove.bind(this), true)
    this._dataGrid.setResizeMethod(WebInspector.DataGrid.ResizeMethod.Last);
    this._dataGrid.asWidget().show(mainView.element);

    this._splitWidget = new WebInspector.SplitWidget(true, true, "timelineTreeViewDetailsSplitWidget");
    this._splitWidget.show(this.element);
    this._splitWidget.setMainWidget(mainView);

    this._detailsView = new WebInspector.VBox();
    this._detailsView.element.classList.add("timeline-details-view", "timeline-details-view-body");
    this._splitWidget.setSidebarWidget(this._detailsView);
    this._dataGrid.addEventListener(WebInspector.DataGrid.Events.SelectedNode, this._updateDetailsForSelection, this);

    /** @type {?WebInspector.TimelineProfileTree.Node|undefined} */
    this._lastSelectedNode;
}

WebInspector.TimelineTreeView.prototype = {
    /**
     * @param {!WebInspector.TimelineSelection} selection
     */
    updateContents: function(selection)
    {
        this.setRange(selection.startTime(), selection.endTime());
    },

    /**
     * @param {number} startTime
     * @param {number} endTime
     */
    setRange: function(startTime, endTime)
    {
        this._startTime = startTime;
        this._endTime = endTime;
        this._refreshTree();
    },

    /**
     * @return {boolean}
     */
    _exposePercentages: function()
    {
        return false;
    },

    /**
     * @param {!Element} parent
     */
    _populateToolbar: function(parent) { },

    /**
     * @param {?WebInspector.TimelineProfileTree.Node} node
     */
    _onHover: function(node) { },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @return {?Element}
     */
    _linkifyLocation: function(event)
    {
        var target = this._model.targetByEvent(event);
        if (!target)
            return null;
        var frame = WebInspector.TimelineProfileTree.eventStackFrame(event);
        if (!frame)
            return null;
        return this._linkifier.maybeLinkifyConsoleCallFrame(target, frame);
    },

    /**
     * @param {!WebInspector.TimelineProfileTree.Node} treeNode
     * @param {boolean} suppressSelectedEvent
     */
    selectProfileNode: function(treeNode, suppressSelectedEvent)
    {
        var pathToRoot = [];
        for (var node = treeNode; node; node = node.parent)
            pathToRoot.push(node);
        for (var i = pathToRoot.length - 1; i > 0; --i) {
            var gridNode = this._dataGridNodeForTreeNode(pathToRoot[i]);
            if (gridNode && gridNode.dataGrid)
                gridNode.expand();
        }
        var gridNode = this._dataGridNodeForTreeNode(treeNode);
        if (gridNode.dataGrid) {
            gridNode.reveal();
            gridNode.select(suppressSelectedEvent);
        }
    },

    _refreshTree: function()
    {
        this._linkifier.reset();
        this._dataGrid.rootNode().removeChildren();
        var tree = this._buildTree();
        if (!tree.children)
            return;
        var maxSelfTime = 0;
        var maxTotalTime = 0;
        for (var child of tree.children.values()) {
            maxSelfTime = Math.max(maxSelfTime, child.selfTime);
            maxTotalTime = Math.max(maxTotalTime, child.totalTime);
        }
        for (var child of tree.children.values()) {
            // Exclude the idle time off the total calculation.
            var gridNode = new WebInspector.TimelineTreeView.TreeGridNode(child, tree.totalTime, maxSelfTime, maxTotalTime, this);
            this._dataGrid.insertChild(gridNode);
        }
        this._sortingChanged();
        this._updateDetailsForSelection();
    },

    /**
     * @return {!WebInspector.TimelineProfileTree.Node}
     */
    _buildTree: function()
    {
        throw new Error("Not Implemented");
    },

    /**
     * @param {function(!WebInspector.TracingModel.Event):(string|symbol)=} eventIdCallback
     * @return {!WebInspector.TimelineProfileTree.Node}
     */
    _buildTopDownTree: function(eventIdCallback)
    {
        return WebInspector.TimelineProfileTree.buildTopDown(this._model.mainThreadEvents(), this._filters, this._startTime, this._endTime, eventIdCallback)
    },

    /**
     * @param {!Array<!WebInspector.DataGrid.ColumnDescriptor>} columns
     */
    _populateColumns: function(columns)
    {
        columns.push({id: "self", title: WebInspector.UIString("Self Time"), width: "110px", fixedWidth: true, sortable: true});
        columns.push({id: "total", title: WebInspector.UIString("Total Time"), width: "110px", fixedWidth: true, sortable: true});
        columns.push({id: "activity", title: WebInspector.UIString("Activity"), disclosure: true, sortable: true});
    },

    _sortingChanged: function()
    {
        var columnIdentifier = this._dataGrid.sortColumnIdentifier();
        if (!columnIdentifier)
            return;
        var sortFunction;
        switch (columnIdentifier) {
        case "startTime":
            sortFunction = compareStartTime;
            break;
        case "self":
            sortFunction = compareNumericField.bind(null, "selfTime");
            break;
        case "total":
            sortFunction = compareNumericField.bind(null, "totalTime");
            break;
        case "activity":
            sortFunction = compareName;
            break;
        default:
            console.assert(false, "Unknown sort field: " + columnIdentifier);
            return;
        }
        this._dataGrid.sortNodes(sortFunction, !this._dataGrid.isSortOrderAscending());

        /**
         * @param {string} field
         * @param {!WebInspector.DataGridNode} a
         * @param {!WebInspector.DataGridNode} b
         * @return {number}
         */
        function compareNumericField(field, a, b)
        {
            var nodeA = /** @type {!WebInspector.TimelineTreeView.TreeGridNode} */ (a);
            var nodeB = /** @type {!WebInspector.TimelineTreeView.TreeGridNode} */ (b);
            return nodeA._profileNode[field] - nodeB._profileNode[field];
        }

        /**
         * @param {!WebInspector.DataGridNode} a
         * @param {!WebInspector.DataGridNode} b
         * @return {number}
         */
        function compareStartTime(a, b)
        {
            var nodeA = /** @type {!WebInspector.TimelineTreeView.TreeGridNode} */ (a);
            var nodeB = /** @type {!WebInspector.TimelineTreeView.TreeGridNode} */ (b);
            return nodeA._profileNode.event.startTime - nodeB._profileNode.event.startTime;
        }

        /**
         * @param {!WebInspector.DataGridNode} a
         * @param {!WebInspector.DataGridNode} b
         * @return {number}
         */
        function compareName(a, b)
        {
            var nodeA = /** @type {!WebInspector.TimelineTreeView.TreeGridNode} */ (a);
            var nodeB = /** @type {!WebInspector.TimelineTreeView.TreeGridNode} */ (b);
            var nameA = WebInspector.TimelineTreeView.eventNameForSorting(nodeA._profileNode.event);
            var nameB = WebInspector.TimelineTreeView.eventNameForSorting(nodeB._profileNode.event);
            return nameA.localeCompare(nameB);
        }
    },

    _updateDetailsForSelection: function()
    {
        var selectedNode = this._dataGrid.selectedNode ? /** @type {!WebInspector.TimelineTreeView.TreeGridNode} */ (this._dataGrid.selectedNode)._profileNode : null;
        if (selectedNode === this._lastSelectedNode)
            return;
        this._lastSelectedNode = selectedNode;
        this._detailsView.detachChildWidgets();
        this._detailsView.element.removeChildren();
        if (!selectedNode || !this._showDetailsForNode(selectedNode)) {
            var banner = this._detailsView.element.createChild("div", "full-widget-dimmed-banner");
            banner.createTextChild(WebInspector.UIString("Select item for details."));
        }
    },

    /**
     * @param {!WebInspector.TimelineProfileTree.Node} node
     * @return {boolean}
     */
    _showDetailsForNode: function(node)
    {
        return false;
    },

    /**
     * @param {!Event} event
     */
    _onMouseMove: function(event)
    {
        var gridNode = event.target && (event.target instanceof Node)
            ? /** @type {?WebInspector.TimelineTreeView.TreeGridNode} */ (this._dataGrid.dataGridNodeFromNode(/** @type {!Node} */ (event.target)))
            : null;
        var profileNode = gridNode && gridNode._profileNode;
        if (profileNode === this._lastHoveredProfileNode)
            return;
        this._lastHoveredProfileNode = profileNode;
        this._onHover(profileNode);
    },

    /**
     * @param {!WebInspector.TimelineProfileTree.Node} treeNode
     * @return {?WebInspector.TimelineTreeView.GridNode}
     */
    _dataGridNodeForTreeNode: function(treeNode)
    {
        return treeNode[WebInspector.TimelineTreeView.TreeGridNode._gridNodeSymbol] || null;
    },

    __proto__: WebInspector.VBox.prototype
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {string}
 */
WebInspector.TimelineTreeView.eventNameForSorting = function(event)
{
    if (event.name === WebInspector.TimelineModel.RecordType.JSFrame) {
        var data = event.args["data"];
        return  data["functionName"] + "@" + (data["scriptId"] || data["url"] || "");
    }
    return event.name + ":@" + WebInspector.TimelineProfileTree.eventURL(event);
}

/**
 * @constructor
 * @extends {WebInspector.SortableDataGridNode}
 * @param {!WebInspector.TimelineProfileTree.Node} profileNode
 * @param {number} grandTotalTime
 * @param {number} maxSelfTime
 * @param {number} maxTotalTime
 * @param {!WebInspector.TimelineTreeView} treeView
 */
WebInspector.TimelineTreeView.GridNode = function(profileNode, grandTotalTime, maxSelfTime, maxTotalTime, treeView)
{
    this._populated = false;
    this._profileNode = profileNode;
    this._treeView = treeView;
    this._grandTotalTime = grandTotalTime;
    this._maxSelfTime = maxSelfTime;
    this._maxTotalTime = maxTotalTime;
    WebInspector.SortableDataGridNode.call(this, null, false);
}

WebInspector.TimelineTreeView.GridNode.prototype = {
    /**
     * @override
     * @param {string} columnIdentifier
     * @return {!Element}
     */
    createCell: function(columnIdentifier)
    {
        if (columnIdentifier === "activity")
            return this._createNameCell(columnIdentifier);
        return this._createValueCell(columnIdentifier) || WebInspector.DataGridNode.prototype.createCell.call(this, columnIdentifier);
    },

    /**
     * @param {string} columnIdentifier
     * @return {!Element}
     */
    _createNameCell: function(columnIdentifier)
    {
        var cell = this.createTD(columnIdentifier);
        var container = cell.createChild("div", "name-container");
        var icon = container.createChild("div", "activity-icon");
        var name = container.createChild("div", "activity-name");
        var event = this._profileNode.event;
        if (this._profileNode.isGroupNode()) {
            var treeView = /** @type {!WebInspector.AggregatedTimelineTreeView} */ (this._treeView);
            var info = treeView._displayInfoForGroupNode(this._profileNode);
            name.textContent = info.name;
            icon.style.backgroundColor = info.color;
        } else if (event) {
            var data = event.args["data"];
            var deoptReason = data && data["deoptReason"];
            if (deoptReason)
                container.createChild("div", "activity-warning").title = WebInspector.UIString("Not optimized: %s", deoptReason);
            name.textContent = event.name === WebInspector.TimelineModel.RecordType.JSFrame
                ? WebInspector.beautifyFunctionName(event.args["data"]["functionName"])
                : WebInspector.TimelineUIUtils.eventTitle(event);
            var link = this._treeView._linkifyLocation(event);
            if (link)
                container.createChild("div", "activity-link").appendChild(link);
            icon.style.backgroundColor = WebInspector.TimelineUIUtils.eventColor(event);
        }
        return cell;
    },

    /**
     * @param {string} columnIdentifier
     * @return {?Element}
     */
    _createValueCell: function(columnIdentifier)
    {
        if (columnIdentifier !== "self" && columnIdentifier !== "total" && columnIdentifier !== "startTime")
            return null;

        var showPercents = false;
        var value;
        var maxTime;
        switch (columnIdentifier) {
        case "startTime":
            value = this._profileNode.event.startTime - this._treeView._model.minimumRecordTime();
            break;
        case "self":
            value = this._profileNode.selfTime;
            maxTime = this._maxSelfTime;
            showPercents = true;
            break;
        case "total":
            value = this._profileNode.totalTime;
            maxTime = this._maxTotalTime;
            showPercents = true;
            break;
        default:
            return null;
        }
        var cell = this.createTD(columnIdentifier);
        cell.className = "numeric-column";
        var textDiv = cell.createChild("div");
        textDiv.createChild("span").textContent = WebInspector.UIString("%.1f\u2009ms", value);

        if (showPercents && this._treeView._exposePercentages())
            textDiv.createChild("span", "percent-column").textContent = WebInspector.UIString("%.1f\u2009%%", value / this._grandTotalTime * 100);
        if (maxTime) {
            textDiv.classList.add("background-percent-bar");
            cell.createChild("div", "background-bar-container").createChild("div", "background-bar").style.width = (value * 100 / maxTime).toFixed(1) + "%";
        }
        return cell;
    },

    __proto__: WebInspector.SortableDataGridNode.prototype
}

/**
 * @constructor
 * @extends {WebInspector.TimelineTreeView.GridNode}
 * @param {!WebInspector.TimelineProfileTree.Node} profileNode
 * @param {number} grandTotalTime
 * @param {number} maxSelfTime
 * @param {number} maxTotalTime
 * @param {!WebInspector.TimelineTreeView} treeView
 */
WebInspector.TimelineTreeView.TreeGridNode = function(profileNode, grandTotalTime, maxSelfTime, maxTotalTime, treeView)
{
    WebInspector.TimelineTreeView.GridNode.call(this, profileNode, grandTotalTime, maxSelfTime, maxTotalTime, treeView);
    this.hasChildren = this._profileNode.children ? this._profileNode.children.size > 0 : false;
    profileNode[WebInspector.TimelineTreeView.TreeGridNode._gridNodeSymbol] = this;
}

WebInspector.TimelineTreeView.TreeGridNode._gridNodeSymbol = Symbol("treeGridNode");

WebInspector.TimelineTreeView.TreeGridNode.prototype = {
    /**
     * @override
     */
    populate: function()
    {
        if (this._populated)
            return;
        this._populated = true;
        if (!this._profileNode.children)
            return;
        for (var node of this._profileNode.children.values()) {
            var gridNode = new WebInspector.TimelineTreeView.TreeGridNode(node, this._grandTotalTime, this._maxSelfTime, this._maxTotalTime, this._treeView);
            this.insertChildOrdered(gridNode);
        }
    },

    __proto__: WebInspector.TimelineTreeView.GridNode.prototype
};


/**
 * @constructor
 * @extends {WebInspector.TimelineTreeView}
 * @param {!WebInspector.TimelineModel} model
 * @param {!Array<!WebInspector.TimelineModel.Filter>} filters
 */
WebInspector.AggregatedTimelineTreeView = function(model, filters)
{
    this._groupBySetting = WebInspector.settings.createSetting("timelineTreeGroupBy", WebInspector.TimelineAggregator.GroupBy.Category);
    WebInspector.TimelineTreeView.call(this, model, filters);
    var nonessentialEvents = [
        WebInspector.TimelineModel.RecordType.EventDispatch,
        WebInspector.TimelineModel.RecordType.FunctionCall,
        WebInspector.TimelineModel.RecordType.TimerFire
    ];
    this._filters.push(new WebInspector.ExclusiveNameFilter(nonessentialEvents));
    this._stackView = new WebInspector.TimelineStackView(this);
    this._stackView.addEventListener(WebInspector.TimelineStackView.Events.SelectionChanged, this._onStackViewSelectionChanged, this);
}

WebInspector.AggregatedTimelineTreeView.prototype = {
    /**
     * @override
     * @param {!WebInspector.TimelineSelection} selection
     */
    updateContents: function(selection)
    {
        this._updateExtensionResolver();
        WebInspector.TimelineTreeView.prototype.updateContents.call(this, selection);
        var rootNode = this._dataGrid.rootNode();
        if (rootNode.children.length)
            rootNode.children[0].revealAndSelect();
    },

    _updateExtensionResolver: function()
    {
        this._executionContextNamesByOrigin = new Map();
        for (var target of WebInspector.targetManager.targets()) {
            for (var context of target.runtimeModel.executionContexts())
                this._executionContextNamesByOrigin.set(context.origin, context.name);
        }
    },

    /**
     * @param {!WebInspector.TimelineProfileTree.Node} node
     * @return {!{name: string, color: string}}
     */
    _displayInfoForGroupNode: function(node)
    {
        var categories = WebInspector.TimelineUIUtils.categories();
        var color = node.id ? WebInspector.TimelineUIUtils.eventColor(node.event) : categories["other"].color;

        switch (this._groupBySetting.get()) {
        case WebInspector.TimelineAggregator.GroupBy.Category:
            var category = categories[node.id] || categories["other"];
            return {name: category.title, color: category.color};

        case WebInspector.TimelineAggregator.GroupBy.Domain:
        case WebInspector.TimelineAggregator.GroupBy.Subdomain:
            var name = node.id;
            if (WebInspector.TimelineAggregator.isExtensionInternalURL(name))
                name = WebInspector.UIString("[Chrome extensions overhead]");
            else if (name.startsWith("chrome-extension"))
                name = this._executionContextNamesByOrigin.get(name) || name;
            return {
                name: name || WebInspector.UIString("unattributed"),
                color: color
            };

        case WebInspector.TimelineAggregator.GroupBy.EventName:
            var name = node.event.name === WebInspector.TimelineModel.RecordType.JSFrame ?
                WebInspector.UIString("JavaScript") : WebInspector.TimelineUIUtils.eventTitle(node.event);
            return {
                name: name,
                color: node.event.name === WebInspector.TimelineModel.RecordType.JSFrame ?
                    WebInspector.TimelineUIUtils.eventStyle(node.event).category.color : color
            };

        case WebInspector.TimelineAggregator.GroupBy.URL:
            break;

        default:
            console.assert(false, "Unexpected aggregation type");
        }
        return {
            name: node.id || WebInspector.UIString("unattributed"),
            color: color
        };
    },

    /**
     * @override
     * @param {!Element} parent
     */
    _populateToolbar: function(parent)
    {
        var panelToolbar = new WebInspector.Toolbar("", parent);
        this._groupByCombobox = new WebInspector.ToolbarComboBox(this._onGroupByChanged.bind(this));
        /**
         * @param {string} name
         * @param {string} id
         * @this {WebInspector.TimelineTreeView}
         */
        function addGroupingOption(name, id)
        {
            var option = this._groupByCombobox.createOption(name, "", id);
            this._groupByCombobox.addOption(option);
            if (id === this._groupBySetting.get())
                this._groupByCombobox.select(option);
        }
        addGroupingOption.call(this, WebInspector.UIString("No Grouping"), WebInspector.TimelineAggregator.GroupBy.None);
        addGroupingOption.call(this, WebInspector.UIString("Group by Activity"), WebInspector.TimelineAggregator.GroupBy.EventName);
        addGroupingOption.call(this, WebInspector.UIString("Group by Category"), WebInspector.TimelineAggregator.GroupBy.Category);
        addGroupingOption.call(this, WebInspector.UIString("Group by Domain"), WebInspector.TimelineAggregator.GroupBy.Domain);
        addGroupingOption.call(this, WebInspector.UIString("Group by Subdomain"), WebInspector.TimelineAggregator.GroupBy.Subdomain);
        addGroupingOption.call(this, WebInspector.UIString("Group by URL"), WebInspector.TimelineAggregator.GroupBy.URL);
        panelToolbar.appendToolbarItem(this._groupByCombobox);
    },

    /**
     * @param {!WebInspector.TimelineProfileTree.Node} treeNode
     * @return {!Array<!WebInspector.TimelineProfileTree.Node>}
     */
    _buildHeaviestStack: function(treeNode)
    {
        console.assert(!!treeNode.parent, "Attempt to build stack for tree root");
        var result = [];
        // Do not add root to the stack, as it's the tree itself.
        for (var node = treeNode; node && node.parent; node = node.parent)
            result.push(node);
        result = result.reverse();
        for (node = treeNode; node && node.children && node.children.size;) {
            var children = Array.from(node.children.values());
            node = children.reduce((a, b) => a.totalTime > b.totalTime ? a : b);
            result.push(node);
        }
        return result;
    },

    /**
     * @override
     * @return {boolean}
     */
    _exposePercentages: function()
    {
        return true;
    },

    _onGroupByChanged: function()
    {
        this._groupBySetting.set(this._groupByCombobox.selectedOption().value);
        this._refreshTree();
    },

    _onStackViewSelectionChanged: function()
    {
        var treeNode = this._stackView.selectedTreeNode();
        if (treeNode)
            this.selectProfileNode(treeNode, true);
    },

    /**
     * @override
     * @param {!WebInspector.TimelineProfileTree.Node} node
     * @return {boolean}
     */
    _showDetailsForNode: function(node)
    {
        var stack = this._buildHeaviestStack(node);
        this._stackView.setStack(stack, node);
        this._stackView.show(this._detailsView.element);
        return true;
    },

    /**
     * @return {!WebInspector.TimelineAggregator}
     */
    _createAggregator: function()
    {
        return new WebInspector.TimelineAggregator(
            event => WebInspector.TimelineUIUtils.eventStyle(event).title,
            event => WebInspector.TimelineUIUtils.eventStyle(event).category.name
        );
    },

    __proto__: WebInspector.TimelineTreeView.prototype,
};

/**
 * @constructor
 * @extends {WebInspector.AggregatedTimelineTreeView}
 * @param {!WebInspector.TimelineModel} model
 * @param {!Array<!WebInspector.TimelineModel.Filter>} filters
 */
WebInspector.CallTreeTimelineTreeView = function(model, filters)
{
    WebInspector.AggregatedTimelineTreeView.call(this, model, filters);
    this._dataGrid.markColumnAsSortedBy("total", WebInspector.DataGrid.Order.Descending);
}

WebInspector.CallTreeTimelineTreeView.prototype = {
    /**
     * @override
     * @return {!WebInspector.TimelineProfileTree.Node}
     */
    _buildTree: function()
    {
        var topDown = this._buildTopDownTree(WebInspector.TimelineAggregator.eventId);
        return this._createAggregator().performGrouping(topDown, this._groupBySetting.get());
    },

    __proto__: WebInspector.AggregatedTimelineTreeView.prototype,
};

/**
 * @constructor
 * @extends {WebInspector.AggregatedTimelineTreeView}
 * @param {!WebInspector.TimelineModel} model
 * @param {!Array<!WebInspector.TimelineModel.Filter>} filters
 */
WebInspector.BottomUpTimelineTreeView = function(model, filters)
{
    WebInspector.AggregatedTimelineTreeView.call(this, model, filters);
    this._dataGrid.markColumnAsSortedBy("self", WebInspector.DataGrid.Order.Descending);
}

WebInspector.BottomUpTimelineTreeView.prototype = {
    /**
     * @override
     * @return {!WebInspector.TimelineProfileTree.Node}
     */
    _buildTree: function()
    {
        var topDown = this._buildTopDownTree(WebInspector.TimelineAggregator.eventId);
        return WebInspector.TimelineProfileTree.buildBottomUp(topDown, this._createAggregator().groupFunction(this._groupBySetting.get()));
    },

    __proto__: WebInspector.AggregatedTimelineTreeView.prototype
};

/**
 * @constructor
 * @extends {WebInspector.TimelineTreeView}
 * @param {!WebInspector.TimelineModel} model
 * @param {!Array<!WebInspector.TimelineModel.Filter>} filters
 * @param {!WebInspector.TimelineModeViewDelegate} delegate
 */
WebInspector.EventsTimelineTreeView = function(model, filters, delegate)
{
    this._filtersControl = new WebInspector.TimelineFilters();
    this._filtersControl.addEventListener(WebInspector.TimelineFilters.Events.FilterChanged, this._onFilterChanged, this);
    WebInspector.TimelineTreeView.call(this, model, filters);
    this._delegate = delegate;
    this._filters.push.apply(this._filters, this._filtersControl.filters());
    this._dataGrid.markColumnAsSortedBy("startTime", WebInspector.DataGrid.Order.Ascending);
}

WebInspector.EventsTimelineTreeView.prototype = {
    /**
     * @override
     * @param {!WebInspector.TimelineSelection} selection
     */
    updateContents: function(selection)
    {
        WebInspector.TimelineTreeView.prototype.updateContents.call(this, selection);
        if (selection.type() === WebInspector.TimelineSelection.Type.TraceEvent) {
            var event = /** @type {!WebInspector.TracingModel.Event} */ (selection.object());
            this._selectEvent(event, true);
        }
    },

    /**
     * @override
     * @return {!WebInspector.TimelineProfileTree.Node}
     */
    _buildTree: function()
    {
        this._currentTree = this._buildTopDownTree();
        return this._currentTree;
    },

    _onFilterChanged: function()
    {
        var selectedEvent = this._lastSelectedNode && this._lastSelectedNode.event;
        this._refreshTree();
        if (selectedEvent)
            this._selectEvent(selectedEvent, false);
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @return {?WebInspector.TimelineProfileTree.Node}
     */
    _findNodeWithEvent: function(event)
    {
        var iterators = [this._currentTree.children.values()];

        while (iterators.length) {
            var iterator = iterators.peekLast().next();
            if (iterator.done) {
                iterators.pop();
                continue;
            }
            var child = /** @type {!WebInspector.TimelineProfileTree.Node} */ (iterator.value);
            if (child.event === event)
                return child;
            if (child.children)
                iterators.push(child.children.values());
        }
        return null;
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @param {boolean=} expand
     */
    _selectEvent: function(event, expand)
    {
        var node = this._findNodeWithEvent(event);
        if (!node)
            return;
        this.selectProfileNode(node, false);
        if (expand)
            this._dataGridNodeForTreeNode(node).expand();
    },

    /**
     * @override
     * @param {!Array<!WebInspector.DataGrid.ColumnDescriptor>} columns
     */
    _populateColumns: function(columns)
    {
        columns.push({id: "startTime", title: WebInspector.UIString("Start Time"), width: "110px", fixedWidth: true, sortable: true});
        WebInspector.TimelineTreeView.prototype._populateColumns.call(this, columns);
    },

    /**
     * @override
     * @param {!Element} parent
     */
    _populateToolbar: function(parent)
    {
        var filtersWidget = this._filtersControl.filtersWidget();
        filtersWidget.forceShowFilterBar();
        filtersWidget.show(parent);
    },

    /**
     * @override
     * @param {!WebInspector.TimelineProfileTree.Node} node
     * @return {boolean}
     */
    _showDetailsForNode: function(node)
    {
        var traceEvent = node.event;
        if (!traceEvent)
            return false;
        WebInspector.TimelineUIUtils.buildTraceEventDetails(traceEvent, this._model, this._linkifier, false, showDetails.bind(this));
        return true;

        /**
         * @param {!DocumentFragment} fragment
         * @this {WebInspector.EventsTimelineTreeView}
         */
        function showDetails(fragment)
        {
            this._detailsView.element.appendChild(fragment);
        }
    },

    /**
     * @override
     * @param {?WebInspector.TimelineProfileTree.Node} node
     */
    _onHover: function(node)
    {
        this._delegate.highlightEvent(node && node.event);
    },

    __proto__: WebInspector.TimelineTreeView.prototype
}

/**
 * @constructor
 * @extends {WebInspector.VBox}
 */
WebInspector.TimelineStackView = function(treeView)
{
    WebInspector.VBox.call(this);
    var header = this.element.createChild("div", "timeline-stack-view-header");
    header.textContent = WebInspector.UIString("Heaviest stack");
    this._treeView = treeView;
    var columns = [
        {id: "total", title: WebInspector.UIString("Total Time"), fixedWidth: true, width: "110px"},
        {id: "activity", title: WebInspector.UIString("Activity")}
    ];
    this._dataGrid = new WebInspector.ViewportDataGrid(columns);
    this._dataGrid.setResizeMethod(WebInspector.DataGrid.ResizeMethod.Last);
    this._dataGrid.addEventListener(WebInspector.DataGrid.Events.SelectedNode, this._onSelectionChanged, this);
    this._dataGrid.asWidget().show(this.element);
}

/** @enum {symbol} */
WebInspector.TimelineStackView.Events = {
    SelectionChanged: Symbol("SelectionChanged")
}

WebInspector.TimelineStackView.prototype = {
    /**
     * @param {!Array<!WebInspector.TimelineProfileTree.Node>} stack
     * @param {!WebInspector.TimelineProfileTree.Node} selectedNode
     */
    setStack: function(stack, selectedNode)
    {
        var rootNode = this._dataGrid.rootNode();
        rootNode.removeChildren();
        var nodeToReveal = null;
        var totalTime = Math.max.apply(Math, stack.map(node => node.totalTime));
        for (var node of stack) {
            var gridNode = new WebInspector.TimelineTreeView.GridNode(node, totalTime, totalTime, totalTime, this._treeView);
            rootNode.appendChild(gridNode);
            if (node === selectedNode)
                nodeToReveal = gridNode;
        }
        nodeToReveal.revealAndSelect();
    },

    /**
     * @return {?WebInspector.TimelineProfileTree.Node}
     */
    selectedTreeNode: function()
    {
        var selectedNode = this._dataGrid.selectedNode;
        return selectedNode && /** @type {!WebInspector.TimelineTreeView.GridNode} */ (selectedNode)._profileNode;
    },

    _onSelectionChanged: function()
    {
        this.dispatchEventToListeners(WebInspector.TimelineStackView.Events.SelectionChanged);
    },

    __proto__: WebInspector.VBox.prototype
}

},{}],226:[function(require,module,exports){
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 * Copyright (C) 2012 Intel Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 */
WebInspector.TimelineUIUtils = function() { }

/**
 * @constructor
 * @param {string} title
 * @param {!WebInspector.TimelineCategory} category
 * @param {boolean=} hidden
 */
WebInspector.TimelineRecordStyle = function(title, category, hidden)
{
    this.title = title;
    this.category = category;
    this.hidden = !!hidden;
}

/**
 * @return {!Object.<string, !WebInspector.TimelineRecordStyle>}
 */
WebInspector.TimelineUIUtils._initEventStyles = function()
{
    if (WebInspector.TimelineUIUtils._eventStylesMap)
        return WebInspector.TimelineUIUtils._eventStylesMap;

    var recordTypes = WebInspector.TimelineModel.RecordType;
    var categories = WebInspector.TimelineUIUtils.categories();

    var eventStyles = {};
    eventStyles[recordTypes.Task] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Task"), categories["other"]);
    eventStyles[recordTypes.Program] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Other"), categories["other"]);
    eventStyles[recordTypes.Animation] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Animation"), categories["rendering"]);
    eventStyles[recordTypes.EventDispatch] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Event"), categories["scripting"]);
    eventStyles[recordTypes.RequestMainThreadFrame] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Request Main Thread Frame"), categories["rendering"], true);
    eventStyles[recordTypes.BeginFrame] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Frame Start"), categories["rendering"], true);
    eventStyles[recordTypes.BeginMainThreadFrame] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Frame Start (main thread)"), categories["rendering"], true);
    eventStyles[recordTypes.DrawFrame] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Draw Frame"), categories["rendering"], true);
    eventStyles[recordTypes.HitTest] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Hit Test"), categories["rendering"]);
    eventStyles[recordTypes.ScheduleStyleRecalculation] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Schedule Style Recalculation"), categories["rendering"], true);
    eventStyles[recordTypes.RecalculateStyles] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Recalculate Style"), categories["rendering"]);
    eventStyles[recordTypes.UpdateLayoutTree] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Recalculate Style"), categories["rendering"]);
    eventStyles[recordTypes.InvalidateLayout] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Invalidate Layout"), categories["rendering"], true);
    eventStyles[recordTypes.Layout] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Layout"), categories["rendering"]);
    eventStyles[recordTypes.PaintSetup] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Paint Setup"), categories["painting"]);
    eventStyles[recordTypes.PaintImage] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Paint Image"), categories["painting"], true);
    eventStyles[recordTypes.UpdateLayer] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Update Layer"), categories["painting"], true);
    eventStyles[recordTypes.UpdateLayerTree] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Update Layer Tree"), categories["rendering"]);
    eventStyles[recordTypes.Paint] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Paint"), categories["painting"]);
    eventStyles[recordTypes.RasterTask] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Rasterize Paint"), categories["painting"]);
    eventStyles[recordTypes.ScrollLayer] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Scroll"), categories["rendering"]);
    eventStyles[recordTypes.CompositeLayers] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Composite Layers"), categories["painting"]);
    eventStyles[recordTypes.ParseHTML] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Parse HTML"), categories["loading"]);
    eventStyles[recordTypes.ParseAuthorStyleSheet] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Parse Stylesheet"), categories["loading"]);
    eventStyles[recordTypes.TimerInstall] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Install Timer"), categories["scripting"]);
    eventStyles[recordTypes.TimerRemove] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Remove Timer"), categories["scripting"]);
    eventStyles[recordTypes.TimerFire] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Timer Fired"), categories["scripting"]);
    eventStyles[recordTypes.XHRReadyStateChange] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("XHR Ready State Change"), categories["scripting"]);
    eventStyles[recordTypes.XHRLoad] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("XHR Load"), categories["scripting"]);
    eventStyles[recordTypes.CompileScript] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Compile Script"), categories["scripting"]);
    eventStyles[recordTypes.EvaluateScript] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Evaluate Script"), categories["scripting"]);
    eventStyles[recordTypes.ParseScriptOnBackground] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Parse Script"), categories["scripting"]);
    eventStyles[recordTypes.MarkLoad] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Load event"), categories["scripting"], true);
    eventStyles[recordTypes.MarkDOMContent] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("DOMContentLoaded event"), categories["scripting"], true);
    eventStyles[recordTypes.MarkFirstPaint] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("First paint"), categories["painting"], true);
    eventStyles[recordTypes.TimeStamp] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Timestamp"), categories["scripting"]);
    eventStyles[recordTypes.ConsoleTime] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Console Time"), categories["scripting"]);
    eventStyles[recordTypes.UserTiming] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("User Timing"), categories["scripting"]);
    eventStyles[recordTypes.ResourceSendRequest] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Send Request"), categories["loading"]);
    eventStyles[recordTypes.ResourceReceiveResponse] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Receive Response"), categories["loading"]);
    eventStyles[recordTypes.ResourceFinish] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Finish Loading"), categories["loading"]);
    eventStyles[recordTypes.ResourceReceivedData] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Receive Data"), categories["loading"]);
    eventStyles[recordTypes.RunMicrotasks] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Run Microtasks"), categories["scripting"]);
    eventStyles[recordTypes.FunctionCall] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Function Call"), categories["scripting"]);
    eventStyles[recordTypes.GCEvent] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("GC Event"), categories["scripting"]);
    eventStyles[recordTypes.MajorGC] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Major GC"), categories["scripting"]);
    eventStyles[recordTypes.MinorGC] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Minor GC"), categories["scripting"]);
    eventStyles[recordTypes.JSFrame] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("JS Frame"), categories["scripting"]);
    eventStyles[recordTypes.RequestAnimationFrame] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Request Animation Frame"), categories["scripting"]);
    eventStyles[recordTypes.CancelAnimationFrame] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Cancel Animation Frame"), categories["scripting"]);
    eventStyles[recordTypes.FireAnimationFrame] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Animation Frame Fired"), categories["scripting"]);
    eventStyles[recordTypes.RequestIdleCallback] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Request Idle Callback"), categories["scripting"]);
    eventStyles[recordTypes.CancelIdleCallback] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Cancel Idle Callback"), categories["scripting"]);
    eventStyles[recordTypes.FireIdleCallback] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Fire Idle Callback"), categories["scripting"]);
    eventStyles[recordTypes.WebSocketCreate] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Create WebSocket"), categories["scripting"]);
    eventStyles[recordTypes.WebSocketSendHandshakeRequest] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Send WebSocket Handshake"), categories["scripting"]);
    eventStyles[recordTypes.WebSocketReceiveHandshakeResponse] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Receive WebSocket Handshake"), categories["scripting"]);
    eventStyles[recordTypes.WebSocketDestroy] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Destroy WebSocket"), categories["scripting"]);
    eventStyles[recordTypes.EmbedderCallback] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Embedder Callback"), categories["scripting"]);
    eventStyles[recordTypes.DecodeImage] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Image Decode"), categories["painting"]);
    eventStyles[recordTypes.ResizeImage] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Image Resize"), categories["painting"]);
    eventStyles[recordTypes.GPUTask] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("GPU"), categories["gpu"]);
    eventStyles[recordTypes.LatencyInfo] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("Input Latency"), categories["scripting"]);

    eventStyles[recordTypes.GCIdleLazySweep] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("DOM GC"), categories["scripting"]);
    eventStyles[recordTypes.GCCompleteSweep] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("DOM GC"), categories["scripting"]);
    eventStyles[recordTypes.GCCollectGarbage] = new WebInspector.TimelineRecordStyle(WebInspector.UIString("DOM GC"), categories["scripting"]);

    WebInspector.TimelineUIUtils._eventStylesMap = eventStyles;
    return eventStyles;
}

/**
 * @param {!WebInspector.TimelineIRModel.InputEvents} inputEventType
 * @return {?string}
 */
WebInspector.TimelineUIUtils.inputEventDisplayName = function(inputEventType)
{
    if (!WebInspector.TimelineUIUtils._inputEventToDisplayName) {
        var inputEvent = WebInspector.TimelineIRModel.InputEvents;

        /** @type {!Map<!WebInspector.TimelineIRModel.InputEvents, string>} */
        WebInspector.TimelineUIUtils._inputEventToDisplayName = new Map([
            [inputEvent.Char, WebInspector.UIString("Key Character")],
            [inputEvent.KeyDown, WebInspector.UIString("Key Down")],
            [inputEvent.KeyDownRaw, WebInspector.UIString("Key Down")],
            [inputEvent.KeyUp, WebInspector.UIString("Key Up")],
            [inputEvent.Click, WebInspector.UIString("Click")],
            [inputEvent.ContextMenu, WebInspector.UIString("Context Menu")],
            [inputEvent.MouseDown, WebInspector.UIString("Mouse Down")],
            [inputEvent.MouseMove, WebInspector.UIString("Mouse Move")],
            [inputEvent.MouseUp, WebInspector.UIString("Mouse Up")],
            [inputEvent.MouseWheel, WebInspector.UIString("Mouse Wheel")],
            [inputEvent.ScrollBegin, WebInspector.UIString("Scroll Begin")],
            [inputEvent.ScrollEnd, WebInspector.UIString("Scroll End")],
            [inputEvent.ScrollUpdate, WebInspector.UIString("Scroll Update")],
            [inputEvent.FlingStart, WebInspector.UIString("Fling Start")],
            [inputEvent.FlingCancel, WebInspector.UIString("Fling Halt")],
            [inputEvent.Tap, WebInspector.UIString("Tap")],
            [inputEvent.TapCancel, WebInspector.UIString("Tap Halt")],
            [inputEvent.ShowPress, WebInspector.UIString("Tap Begin")],
            [inputEvent.TapDown, WebInspector.UIString("Tap Down")],
            [inputEvent.TouchCancel, WebInspector.UIString("Touch Cancel")],
            [inputEvent.TouchEnd, WebInspector.UIString("Touch End")],
            [inputEvent.TouchMove, WebInspector.UIString("Touch Move")],
            [inputEvent.TouchStart, WebInspector.UIString("Touch Start")],
            [inputEvent.PinchBegin, WebInspector.UIString("Pinch Begin")],
            [inputEvent.PinchEnd, WebInspector.UIString("Pinch End")],
            [inputEvent.PinchUpdate, WebInspector.UIString("Pinch Update")]
        ]);
    }
    return WebInspector.TimelineUIUtils._inputEventToDisplayName.get(inputEventType) || null;
}

/**
 * @param {!WebInspector.TracingModel.Event} traceEvent
 * @param {!RegExp} regExp
 * @return {boolean}
 */
WebInspector.TimelineUIUtils.testContentMatching = function(traceEvent, regExp)
{
    var title = WebInspector.TimelineUIUtils.eventStyle(traceEvent).title;
    var tokens = [title];
    if (traceEvent.url)
        tokens.push(traceEvent.url);
    for (var argName in traceEvent.args) {
        var argValue = traceEvent.args[argName];
        for (var key in argValue)
            tokens.push(argValue[key]);
    }
    return regExp.test(tokens.join("|"));
}

/**
 * @param {!WebInspector.TimelineModel.Record} record
 * @return {!WebInspector.TimelineCategory}
 */
WebInspector.TimelineUIUtils.categoryForRecord = function(record)
{
    return WebInspector.TimelineUIUtils.eventStyle(record.traceEvent()).category;
}


/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {!{title: string, category: !WebInspector.TimelineCategory}}
 */
WebInspector.TimelineUIUtils.eventStyle = function(event)
{
    var eventStyles = WebInspector.TimelineUIUtils._initEventStyles();
    if (event.hasCategory(WebInspector.TimelineModel.Category.Console) || event.hasCategory(WebInspector.TimelineModel.Category.UserTiming))
        return { title: event.name, category: WebInspector.TimelineUIUtils.categories()["scripting"] };

    if (event.hasCategory(WebInspector.TimelineModel.Category.LatencyInfo)) {
        /** @const */
        var prefix = "InputLatency::";
        var inputEventType = event.name.startsWith(prefix) ? event.name.substr(prefix.length) : event.name;
        var displayName = WebInspector.TimelineUIUtils.inputEventDisplayName(/** @type {!WebInspector.TimelineIRModel.InputEvents} */ (inputEventType));
        return { title: displayName || inputEventType, category: WebInspector.TimelineUIUtils.categories()["scripting"] };
    }
    var result = eventStyles[event.name];
    if (!result) {
        result = new WebInspector.TimelineRecordStyle(event.name,  WebInspector.TimelineUIUtils.categories()["other"], true);
        eventStyles[event.name] = result;
    }
    return result;
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {string}
 */
WebInspector.TimelineUIUtils.eventColor = function(event)
{
    if (event.name === WebInspector.TimelineModel.RecordType.JSFrame) {
        var frame = event.args["data"];
        if (WebInspector.TimelineUIUtils.isUserFrame(frame))
            return WebInspector.TimelineUIUtils.colorForURL(frame.url);
    }
    return WebInspector.TimelineUIUtils.eventStyle(event).category.color;
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {string}
 */
WebInspector.TimelineUIUtils.eventTitle = function(event)
{
    var title = WebInspector.TimelineUIUtils.eventStyle(event).title;
    if (event.hasCategory(WebInspector.TimelineModel.Category.Console))
        return title;
    if (event.name === WebInspector.TimelineModel.RecordType.TimeStamp)
        return WebInspector.UIString("%s: %s", title, event.args["data"]["message"]);
    if (event.name === WebInspector.TimelineModel.RecordType.Animation && event.args["data"] && event.args["data"]["name"])
        return WebInspector.UIString("%s: %s", title, event.args["data"]["name"]);
    return title;
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {?string}
 */
WebInspector.TimelineUIUtils.eventURL = function(event)
{
    if (event.url)
        return event.url;
    var data = event.args["data"] || event.args["beginData"];
    return data && data.url || null;
}

/**
 * !Map<!WebInspector.TimelineIRModel.Phases, !{color: string, label: string}>
 */
WebInspector.TimelineUIUtils._interactionPhaseStyles = function()
{
    var map = WebInspector.TimelineUIUtils._interactionPhaseStylesMap;
    if (!map) {
        map = new Map([
            [WebInspector.TimelineIRModel.Phases.Idle, {color: "white", label: "Idle"}],
            [WebInspector.TimelineIRModel.Phases.Response, {color: "hsl(43, 83%, 64%)", label: WebInspector.UIString("Response")}],
            [WebInspector.TimelineIRModel.Phases.Scroll, {color: "hsl(256, 67%, 70%)", label: WebInspector.UIString("Scroll")}],
            [WebInspector.TimelineIRModel.Phases.Fling, {color: "hsl(256, 67%, 70%)", label: WebInspector.UIString("Fling")}],
            [WebInspector.TimelineIRModel.Phases.Drag, {color: "hsl(256, 67%, 70%)", label: WebInspector.UIString("Drag")}],
            [WebInspector.TimelineIRModel.Phases.Animation, {color: "hsl(256, 67%, 70%)", label: WebInspector.UIString("Animation")}],
            [WebInspector.TimelineIRModel.Phases.Uncategorized, {color: "hsl(0, 0%, 87%)", label: WebInspector.UIString("Uncategorized")}]
        ]);
        WebInspector.TimelineUIUtils._interactionPhaseStylesMap = map;
    }
    return map;
}

/**
 * @param {!WebInspector.TimelineIRModel.Phases} phase
 * @return {string}
 */
WebInspector.TimelineUIUtils.interactionPhaseColor = function(phase)
{
    return WebInspector.TimelineUIUtils._interactionPhaseStyles().get(phase).color;
}

/**
 * @param {!WebInspector.TimelineIRModel.Phases} phase
 * @return {string}
 */
WebInspector.TimelineUIUtils.interactionPhaseLabel = function(phase)
{
    return WebInspector.TimelineUIUtils._interactionPhaseStyles().get(phase).label;
}

/**
 * @param {!RuntimeAgent.CallFrame} frame
 * @return {boolean}
 */
WebInspector.TimelineUIUtils.isUserFrame = function(frame)
{
    return frame.scriptId !== "0" && !(frame.url && frame.url.startsWith("native "));
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {?RuntimeAgent.CallFrame}
 */
WebInspector.TimelineUIUtils.topStackFrame = function(event)
{
    var stackTrace = event.stackTrace || event.initiator && event.initiator.stackTrace;
    return stackTrace && stackTrace.length ? stackTrace[0] : null;
}

/**
 * @enum {symbol}
 */
WebInspector.TimelineUIUtils.NetworkCategory = {
    HTML: Symbol("HTML"),
    Script: Symbol("Script"),
    Style: Symbol("Style"),
    Media: Symbol("Media"),
    Other: Symbol("Other")
}

/**
 * @param {!WebInspector.TimelineModel.NetworkRequest} request
 * @return {!WebInspector.TimelineUIUtils.NetworkCategory}
 */
WebInspector.TimelineUIUtils.networkRequestCategory = function(request)
{
    var categories = WebInspector.TimelineUIUtils.NetworkCategory;
    switch (request.mimeType) {
    case "text/html":
        return categories.HTML;
    case "application/javascript":
    case "application/x-javascript":
    case "text/javascript":
        return categories.Script;
    case "text/css":
        return categories.Style;
    case "audio/ogg":
    case "image/gif":
    case "image/jpeg":
    case "image/png":
    case "image/svg+xml":
    case "image/webp":
    case "image/x-icon":
    case "font/opentype":
    case "font/woff2":
    case "application/font-woff":
        return categories.Media;
    default:
        return categories.Other;
    }
}

/**
 * @param {!WebInspector.TimelineUIUtils.NetworkCategory} category
 * @return {string}
 */
WebInspector.TimelineUIUtils.networkCategoryColor = function(category)
{
    var categories = WebInspector.TimelineUIUtils.NetworkCategory;
    switch (category) {
    case categories.HTML: return "hsl(214, 67%, 66%)";
    case categories.Script: return "hsl(43, 83%, 64%)";
    case categories.Style: return "hsl(256, 67%, 70%)";
    case categories.Media: return "hsl(109, 33%, 55%)";
    default: return "hsl(0, 0%, 70%)";
    }
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @param {?WebInspector.Target} target
 * @return {?string}
 */
WebInspector.TimelineUIUtils.buildDetailsTextForTraceEvent = function(event, target)
{
    var recordType = WebInspector.TimelineModel.RecordType;
    var detailsText;
    var eventData = event.args["data"];
    switch (event.name) {
    case recordType.GCEvent:
    case recordType.MajorGC:
    case recordType.MinorGC:
        var delta = event.args["usedHeapSizeBefore"] - event.args["usedHeapSizeAfter"];
        detailsText = WebInspector.UIString("%s collected", Number.bytesToString(delta));
        break;
    case recordType.FunctionCall:
        // Omit internally generated script names.
        if (eventData)
            detailsText = linkifyLocationAsText(eventData["scriptId"], eventData["lineNumber"], 0);
        break;
    case recordType.JSFrame:
        detailsText = WebInspector.beautifyFunctionName(eventData["functionName"]);
        break;
    case recordType.EventDispatch:
        detailsText = eventData ? eventData["type"] : null;
        break;
    case recordType.Paint:
        var width = WebInspector.TimelineUIUtils.quadWidth(eventData.clip);
        var height = WebInspector.TimelineUIUtils.quadHeight(eventData.clip);
        if (width && height)
            detailsText = WebInspector.UIString("%d\u2009\u00d7\u2009%d", width, height);
        break;
    case recordType.ParseHTML:
        var endLine = event.args["endData"] && event.args["endData"]["endLine"];
        var url = WebInspector.displayNameForURL(event.args["beginData"]["url"]);
        detailsText = WebInspector.UIString("%s [%s\u2026%s]", url, event.args["beginData"]["startLine"] + 1, endLine >= 0 ? endLine + 1 : "");
        break;

    case recordType.CompileScript:
    case recordType.EvaluateScript:
        var url = eventData["url"];
        if (url)
            detailsText = WebInspector.displayNameForURL(url) + ":" + (eventData["lineNumber"] + 1);
        break;
    case recordType.ParseScriptOnBackground:
    case recordType.XHRReadyStateChange:
    case recordType.XHRLoad:
        var url = eventData["url"];
        if (url)
            detailsText = WebInspector.displayNameForURL(url);
        break;
    case recordType.TimeStamp:
        detailsText = eventData["message"];
        break;

    case recordType.WebSocketCreate:
    case recordType.WebSocketSendHandshakeRequest:
    case recordType.WebSocketReceiveHandshakeResponse:
    case recordType.WebSocketDestroy:
    case recordType.ResourceSendRequest:
    case recordType.ResourceReceivedData:
    case recordType.ResourceReceiveResponse:
    case recordType.ResourceFinish:
    case recordType.PaintImage:
    case recordType.DecodeImage:
    case recordType.ResizeImage:
    case recordType.DecodeLazyPixelRef:
        if (event.url)
            detailsText = WebInspector.displayNameForURL(event.url);
        break;

    case recordType.EmbedderCallback:
        detailsText = eventData["callbackName"];
        break;

    case recordType.Animation:
        detailsText = eventData && eventData["name"];
        break;

    case recordType.GCIdleLazySweep:
        detailsText = WebInspector.UIString("idle sweep");
        break;

    case recordType.GCCompleteSweep:
        detailsText = WebInspector.UIString("complete sweep");
        break;

    case recordType.GCCollectGarbage:
        detailsText = WebInspector.UIString("collect");
        break;

    default:
        if (event.hasCategory(WebInspector.TimelineModel.Category.Console))
            detailsText = null;
        else
            detailsText = linkifyTopCallFrameAsText();
        break;
    }

    return detailsText;

    /**
     * @param {string} scriptId
     * @param {number} lineNumber
     * @param {number} columnNumber
     * @return {?string}
     */
    function linkifyLocationAsText(scriptId, lineNumber, columnNumber)
    {
        var debuggerModel = WebInspector.DebuggerModel.fromTarget(target);
        if (!target || target.isDetached() || !scriptId || !debuggerModel)
            return null;
        var rawLocation = debuggerModel.createRawLocationByScriptId(scriptId, lineNumber, columnNumber);
        if (!rawLocation)
            return null;
        var uiLocation = WebInspector.debuggerWorkspaceBinding.rawLocationToUILocation(rawLocation);
        return uiLocation.linkText();
    }

    /**
     * @return {?string}
     */
    function linkifyTopCallFrameAsText()
    {
        var frame = WebInspector.TimelineUIUtils.topStackFrame(event);
        if (!frame)
            return null;
        var text = linkifyLocationAsText(frame.scriptId, frame.lineNumber, frame.columnNumber);
        if (!text) {
            text = frame.url;
            if (typeof frame.lineNumber === "number")
                text += ":" + (frame.lineNumber + 1);
        }
        return text;
    }
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @param {?WebInspector.Target} target
 * @param {!WebInspector.Linkifier} linkifier
 * @return {?Node}
 */
WebInspector.TimelineUIUtils.buildDetailsNodeForTraceEvent = function(event, target, linkifier)
{
    var recordType = WebInspector.TimelineModel.RecordType;
    var details = null;
    var detailsText;
    var eventData = event.args["data"];
    switch (event.name) {
    case recordType.GCEvent:
    case recordType.MajorGC:
    case recordType.MinorGC:
    case recordType.EventDispatch:
    case recordType.Paint:
    case recordType.Animation:
    case recordType.EmbedderCallback:
    case recordType.ParseHTML:
    case recordType.WebSocketCreate:
    case recordType.WebSocketSendHandshakeRequest:
    case recordType.WebSocketReceiveHandshakeResponse:
    case recordType.WebSocketDestroy:
    case recordType.GCIdleLazySweep:
    case recordType.GCCompleteSweep:
    case recordType.GCCollectGarbage:
        detailsText = WebInspector.TimelineUIUtils.buildDetailsTextForTraceEvent(event, target);
        break;
    case recordType.PaintImage:
    case recordType.DecodeImage:
    case recordType.ResizeImage:
    case recordType.DecodeLazyPixelRef:
    case recordType.XHRReadyStateChange:
    case recordType.XHRLoad:
    case recordType.ResourceSendRequest:
    case recordType.ResourceReceivedData:
    case recordType.ResourceReceiveResponse:
    case recordType.ResourceFinish:
        if (event.url)
            details = WebInspector.linkifyResourceAsNode(event.url);
        break;
    case recordType.FunctionCall:
    case recordType.JSFrame:
        details = createElement("span");
        details.createTextChild(WebInspector.beautifyFunctionName(eventData["functionName"]));
        var location = linkifyLocation(eventData["scriptId"], eventData["url"], eventData["lineNumber"], eventData["columnNumber"]);
        if (location) {
            details.createTextChild(" @ ");
            details.appendChild(location);
        }
        break;
    case recordType.CompileScript:
    case recordType.EvaluateScript:
        var url = eventData["url"];
        if (url)
            details = linkifyLocation("", url, eventData["lineNumber"], 0);
        break;
    case recordType.ParseScriptOnBackground:
        var url = eventData["url"];
        if (url)
            details = linkifyLocation("", url, 0, 0);
        break;
    default:
        if (event.hasCategory(WebInspector.TimelineModel.Category.Console))
            detailsText = null;
        else
            details = linkifyTopCallFrame();
        break;
    }

    if (!details && detailsText)
        details = createTextNode(detailsText);
    return details;

    /**
     * @param {string} scriptId
     * @param {string} url
     * @param {number} lineNumber
     * @param {number=} columnNumber
     * @return {?Element}
     */
    function linkifyLocation(scriptId, url, lineNumber, columnNumber)
    {
        return linkifier.linkifyScriptLocation(target, scriptId, url, lineNumber, columnNumber, "timeline-details");
    }

    /**
     * @return {?Element}
     */
    function linkifyTopCallFrame()
    {
        var frame = WebInspector.TimelineUIUtils.topStackFrame(event);
        return frame ? linkifier.maybeLinkifyConsoleCallFrame(target, frame, "timeline-details") : null;
    }
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @param {!WebInspector.TimelineModel} model
 * @param {!WebInspector.Linkifier} linkifier
 * @param {boolean} detailed
 * @param {function(!DocumentFragment)} callback
 */
WebInspector.TimelineUIUtils.buildTraceEventDetails = function(event, model, linkifier, detailed, callback)
{
    var target = model.targetByEvent(event);
    if (!target) {
        callbackWrapper();
        return;
    }
    var relatedNodes = null;
    var barrier = new CallbackBarrier();
    if (!event.previewElement) {
        if (event.url)
            WebInspector.DOMPresentationUtils.buildImagePreviewContents(target, event.url, false, barrier.createCallback(saveImage));
        else if (event.picture)
            WebInspector.TimelineUIUtils.buildPicturePreviewContent(event, target, barrier.createCallback(saveImage));
    }
    var nodeIdsToResolve = new Set();
    if (event.backendNodeId)
        nodeIdsToResolve.add(event.backendNodeId);
    if (event.invalidationTrackingEvents)
        WebInspector.TimelineUIUtils._collectInvalidationNodeIds(nodeIdsToResolve, event.invalidationTrackingEvents);
    if (nodeIdsToResolve.size) {
        var domModel = WebInspector.DOMModel.fromTarget(target);
        if (domModel)
            domModel.pushNodesByBackendIdsToFrontend(nodeIdsToResolve, barrier.createCallback(setRelatedNodeMap));
    }
    barrier.callWhenDone(callbackWrapper);

    /**
     * @param {!Element=} element
     */
    function saveImage(element)
    {
        event.previewElement = element || null;
    }

    /**
     * @param {?Map<number, ?WebInspector.DOMNode>} nodeMap
     */
    function setRelatedNodeMap(nodeMap)
    {
        relatedNodes = nodeMap;
    }

    function callbackWrapper()
    {
        callback(WebInspector.TimelineUIUtils._buildTraceEventDetailsSynchronously(event, model, linkifier, detailed, relatedNodes));
    }
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @param {!WebInspector.TimelineModel} model
 * @param {!WebInspector.Linkifier} linkifier
 * @param {boolean} detailed
 * @param {?Map<number, ?WebInspector.DOMNode>} relatedNodesMap
 * @return {!DocumentFragment}
 */
WebInspector.TimelineUIUtils._buildTraceEventDetailsSynchronously = function(event, model, linkifier, detailed, relatedNodesMap)
{
    var stats = {};
    var recordTypes = WebInspector.TimelineModel.RecordType;

    // This message may vary per event.name;
    var relatedNodeLabel;

    var contentHelper = new WebInspector.TimelineDetailsContentHelper(model.targetByEvent(event), linkifier);
    contentHelper.addSection(WebInspector.TimelineUIUtils.eventTitle(event), WebInspector.TimelineUIUtils.eventStyle(event).category);

    var eventData = event.args["data"];
    var initiator = event.initiator;

    if (event.warning)
        contentHelper.appendWarningRow(event);
    if (event.name === recordTypes.JSFrame && eventData["deoptReason"])
        contentHelper.appendWarningRow(event, WebInspector.TimelineModel.WarningType.V8Deopt);

    if (detailed) {
        contentHelper.appendTextRow(WebInspector.UIString("Self Time"), Number.millisToString(event.selfTime, true));
        contentHelper.appendTextRow(WebInspector.UIString("Total Time"), Number.millisToString(event.duration || 0, true));
    }

    switch (event.name) {
    case recordTypes.GCEvent:
    case recordTypes.MajorGC:
    case recordTypes.MinorGC:
        var delta = event.args["usedHeapSizeBefore"] - event.args["usedHeapSizeAfter"];
        contentHelper.appendTextRow(WebInspector.UIString("Collected"), Number.bytesToString(delta));
        break;
    case recordTypes.JSFrame:
    case recordTypes.FunctionCall:
        var detailsNode = WebInspector.TimelineUIUtils.buildDetailsNodeForTraceEvent(event, model.targetByEvent(event), linkifier);
        if (detailsNode)
            contentHelper.appendElementRow(WebInspector.UIString("Function"), detailsNode);
        break;
    case recordTypes.TimerFire:
    case recordTypes.TimerInstall:
    case recordTypes.TimerRemove:
        contentHelper.appendTextRow(WebInspector.UIString("Timer ID"), eventData["timerId"]);
        if (event.name === recordTypes.TimerInstall) {
            contentHelper.appendTextRow(WebInspector.UIString("Timeout"), Number.millisToString(eventData["timeout"]));
            contentHelper.appendTextRow(WebInspector.UIString("Repeats"), !eventData["singleShot"]);
        }
        break;
    case recordTypes.FireAnimationFrame:
        contentHelper.appendTextRow(WebInspector.UIString("Callback ID"), eventData["id"]);
        break;
    case recordTypes.ResourceSendRequest:
    case recordTypes.ResourceReceiveResponse:
    case recordTypes.ResourceReceivedData:
    case recordTypes.ResourceFinish:
        var url = (event.name === recordTypes.ResourceSendRequest) ? eventData["url"] : initiator && initiator.args["data"]["url"];
        if (url)
            contentHelper.appendElementRow(WebInspector.UIString("Resource"), WebInspector.linkifyResourceAsNode(url));
        if (eventData["requestMethod"])
            contentHelper.appendTextRow(WebInspector.UIString("Request Method"), eventData["requestMethod"]);
        if (typeof eventData["statusCode"] === "number")
            contentHelper.appendTextRow(WebInspector.UIString("Status Code"), eventData["statusCode"]);
        if (eventData["mimeType"])
            contentHelper.appendTextRow(WebInspector.UIString("MIME Type"), eventData["mimeType"]);
        if ("priority" in eventData) {
            var priority = WebInspector.uiLabelForPriority(eventData["priority"]);
            contentHelper.appendTextRow(WebInspector.UIString("Priority"), priority);
        }
        if (eventData["encodedDataLength"])
            contentHelper.appendTextRow(WebInspector.UIString("Encoded Data Length"), WebInspector.UIString("%d Bytes", eventData["encodedDataLength"]));
        break;
    case recordTypes.CompileScript:
    case recordTypes.EvaluateScript:
        var url = eventData["url"];
        if (url)
            contentHelper.appendLocationRow(WebInspector.UIString("Script"), url, eventData["lineNumber"], eventData["columnNumber"]);
        break;
    case recordTypes.Paint:
        var clip = eventData["clip"];
        contentHelper.appendTextRow(WebInspector.UIString("Location"), WebInspector.UIString("(%d, %d)", clip[0], clip[1]));
        var clipWidth = WebInspector.TimelineUIUtils.quadWidth(clip);
        var clipHeight = WebInspector.TimelineUIUtils.quadHeight(clip);
        contentHelper.appendTextRow(WebInspector.UIString("Dimensions"), WebInspector.UIString("%d × %d", clipWidth, clipHeight));
        // Fall-through intended.

    case recordTypes.PaintSetup:
    case recordTypes.Rasterize:
    case recordTypes.ScrollLayer:
        relatedNodeLabel = WebInspector.UIString("Layer Root");
        break;
    case recordTypes.PaintImage:
    case recordTypes.DecodeLazyPixelRef:
    case recordTypes.DecodeImage:
    case recordTypes.ResizeImage:
    case recordTypes.DrawLazyPixelRef:
        relatedNodeLabel = WebInspector.UIString("Owner Element");
        if (event.url)
            contentHelper.appendElementRow(WebInspector.UIString("Image URL"), WebInspector.linkifyResourceAsNode(event.url));
        break;
    case recordTypes.ParseAuthorStyleSheet:
        var url = eventData["styleSheetUrl"];
        if (url)
            contentHelper.appendElementRow(WebInspector.UIString("Stylesheet URL"), WebInspector.linkifyResourceAsNode(url));
        break;
    case recordTypes.UpdateLayoutTree: // We don't want to see default details.
    case recordTypes.RecalculateStyles:
        contentHelper.appendTextRow(WebInspector.UIString("Elements Affected"), event.args["elementCount"]);
        break;
    case recordTypes.Layout:
        var beginData = event.args["beginData"];
        contentHelper.appendTextRow(WebInspector.UIString("Nodes That Need Layout"), WebInspector.UIString("%s of %s", beginData["dirtyObjects"], beginData["totalObjects"]));
        relatedNodeLabel = WebInspector.UIString("Layout root");
        break;
    case recordTypes.ConsoleTime:
        contentHelper.appendTextRow(WebInspector.UIString("Message"), event.name);
        break;
    case recordTypes.WebSocketCreate:
    case recordTypes.WebSocketSendHandshakeRequest:
    case recordTypes.WebSocketReceiveHandshakeResponse:
    case recordTypes.WebSocketDestroy:
        var initiatorData = initiator ? initiator.args["data"] : eventData;
        if (typeof initiatorData["webSocketURL"] !== "undefined")
            contentHelper.appendTextRow(WebInspector.UIString("URL"), initiatorData["webSocketURL"]);
        if (typeof initiatorData["webSocketProtocol"] !== "undefined")
            contentHelper.appendTextRow(WebInspector.UIString("WebSocket Protocol"), initiatorData["webSocketProtocol"]);
        if (typeof eventData["message"] !== "undefined")
            contentHelper.appendTextRow(WebInspector.UIString("Message"), eventData["message"]);
        break;
    case recordTypes.EmbedderCallback:
        contentHelper.appendTextRow(WebInspector.UIString("Callback Function"), eventData["callbackName"]);
        break;
    case recordTypes.Animation:
        if (event.phase === WebInspector.TracingModel.Phase.NestableAsyncInstant)
            contentHelper.appendTextRow(WebInspector.UIString("State"), eventData["state"]);
        break;
    case recordTypes.ParseHTML:
        var beginData = event.args["beginData"];
        var url = beginData["url"];
        var startLine = beginData["startLine"] - 1;
        var endLine = event.args["endData"] ? event.args["endData"]["endLine"] - 1 : undefined;
        if (url)
            contentHelper.appendLocationRange(WebInspector.UIString("Range"), url, startLine, endLine);
        break;

    case recordTypes.FireIdleCallback:
        contentHelper.appendTextRow(WebInspector.UIString("Allotted Time"), Number.millisToString(eventData["allottedMilliseconds"]));
        contentHelper.appendTextRow(WebInspector.UIString("Invoked by Timeout"), eventData["timedOut"]);
        // Fall-through intended.

    case recordTypes.RequestIdleCallback:
    case recordTypes.CancelIdleCallback:
        contentHelper.appendTextRow(WebInspector.UIString("Callback ID"), eventData["id"]);
        break;
    case recordTypes.EventDispatch:
        contentHelper.appendTextRow(WebInspector.UIString("Type"), eventData["type"]);
        break;

    default:
        var detailsNode = WebInspector.TimelineUIUtils.buildDetailsNodeForTraceEvent(event, model.targetByEvent(event), linkifier);
        if (detailsNode)
            contentHelper.appendElementRow(WebInspector.UIString("Details"), detailsNode);
        break;
    }

    if (event.timeWaitingForMainThread)
        contentHelper.appendTextRow(WebInspector.UIString("Time Waiting for Main Thread"), Number.millisToString(event.timeWaitingForMainThread, true));

    var relatedNode = relatedNodesMap && relatedNodesMap.get(event.backendNodeId);
    if (relatedNode)
        contentHelper.appendElementRow(relatedNodeLabel || WebInspector.UIString("Related Node"), WebInspector.DOMPresentationUtils.linkifyNodeReference(relatedNode));

    if (event.previewElement) {
        contentHelper.addSection(WebInspector.UIString("Preview"));
        contentHelper.appendElementRow("", event.previewElement);
    }

    if (event.stackTrace || (event.initiator && event.initiator.stackTrace) || event.invalidationTrackingEvents)
        WebInspector.TimelineUIUtils._generateCauses(event, model.targetByEvent(event), relatedNodesMap, contentHelper);

    var showPieChart = detailed && WebInspector.TimelineUIUtils._aggregatedStatsForTraceEvent(stats, model, event);
    if (showPieChart) {
        contentHelper.addSection(WebInspector.UIString("Aggregated Time"));
        var pieChart = WebInspector.TimelineUIUtils.generatePieChart(stats, WebInspector.TimelineUIUtils.eventStyle(event).category, event.selfTime);
        contentHelper.appendElementRow("", pieChart);
    }

    return contentHelper.fragment;
}

WebInspector.TimelineUIUtils._aggregatedStatsKey = Symbol("aggregatedStats");

/**
 * @param {!WebInspector.TimelineModel} model
 * @param {number} startTime
 * @param {number} endTime
 * @return {!DocumentFragment}
 */
WebInspector.TimelineUIUtils.buildRangeStats = function(model, startTime, endTime)
{
    var aggregatedStats = {};

    /**
     * @param {number} value
     * @param {!WebInspector.TimelineModel.Record} task
     * @return {number}
     */
    function compareEndTime(value, task)
    {
        return value < task.endTime() ? -1 : 1;
    }
    var mainThreadTasks = model.mainThreadTasks();
    var taskIndex = mainThreadTasks.lowerBound(startTime, compareEndTime);
    for (; taskIndex < mainThreadTasks.length; ++taskIndex) {
        var task = mainThreadTasks[taskIndex];
        if (task.startTime() > endTime)
            break;
        if (task.startTime() > startTime && task.endTime() < endTime) {
            // cache stats for top-level entries that fit the range entirely.
            var taskStats = task[WebInspector.TimelineUIUtils._aggregatedStatsKey];
            if (!taskStats) {
                taskStats = {};
                WebInspector.TimelineUIUtils._collectAggregatedStatsForRecord(task, startTime, endTime, taskStats);
                task[WebInspector.TimelineUIUtils._aggregatedStatsKey] = taskStats;
            }
            for (var key in taskStats)
                aggregatedStats[key] = (aggregatedStats[key] || 0) + taskStats[key];
            continue;
        }
        WebInspector.TimelineUIUtils._collectAggregatedStatsForRecord(task, startTime, endTime, aggregatedStats);
    }

    var aggregatedTotal = 0;
    for (var categoryName in aggregatedStats)
        aggregatedTotal += aggregatedStats[categoryName];
    aggregatedStats["idle"] = Math.max(0, endTime - startTime - aggregatedTotal);

    var startOffset = startTime - model.minimumRecordTime();
    var endOffset = endTime - model.minimumRecordTime();

    var contentHelper = new WebInspector.TimelineDetailsContentHelper(null, null);
    contentHelper.addSection(WebInspector.UIString("Range:  %s \u2013 %s", Number.millisToString(startOffset), Number.millisToString(endOffset)));
    var pieChart = WebInspector.TimelineUIUtils.generatePieChart(aggregatedStats);
    contentHelper.appendElementRow("", pieChart);
    return contentHelper.fragment;
}

/**
 * @param {!WebInspector.TimelineModel.Record} record
 * @param {number} startTime
 * @param {number} endTime
 * @param {!Object} aggregatedStats
 */
WebInspector.TimelineUIUtils._collectAggregatedStatsForRecord = function(record, startTime, endTime, aggregatedStats)
{
    var records = [];

    if (!record.endTime() || record.endTime() < startTime || record.startTime() > endTime)
        return;

    var childrenTime = 0;
    var children = record.children() || [];
    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (!child.endTime() || child.endTime() < startTime || child.startTime() > endTime)
            continue;
        childrenTime += Math.min(endTime, child.endTime()) - Math.max(startTime, child.startTime());
        WebInspector.TimelineUIUtils._collectAggregatedStatsForRecord(child, startTime, endTime, aggregatedStats);
    }
    var categoryName = WebInspector.TimelineUIUtils.categoryForRecord(record).name;
    var ownTime = Math.min(endTime, record.endTime()) - Math.max(startTime, record.startTime()) - childrenTime;
    aggregatedStats[categoryName] = (aggregatedStats[categoryName] || 0) + ownTime;
}

/**
 * @param {!WebInspector.TimelineModel.NetworkRequest} request
 * @param {!WebInspector.TimelineModel} model
 * @param {!WebInspector.Linkifier} linkifier
 * @return {!Promise<!DocumentFragment>}
 */
WebInspector.TimelineUIUtils.buildNetworkRequestDetails = function(request, model, linkifier)
{
    var target = model.targetByEvent(request.children[0]);
    var contentHelper = new WebInspector.TimelineDetailsContentHelper(target, linkifier);

    var duration = request.endTime - (request.startTime || -Infinity);
    var items = [];
    if (request.url)
        contentHelper.appendElementRow(WebInspector.UIString("URL"), WebInspector.linkifyURLAsNode(request.url));
    if (isFinite(duration))
        contentHelper.appendTextRow(WebInspector.UIString("Duration"), Number.millisToString(duration, true));
    if (request.requestMethod)
        contentHelper.appendTextRow(WebInspector.UIString("Request Method"), request.requestMethod);
    if (typeof request.priority === "string") {
        var priority = WebInspector.uiLabelForPriority(/** @type {!NetworkAgent.ResourcePriority} */ (request.priority));
        contentHelper.appendTextRow(WebInspector.UIString("Priority"), priority);
    }
    if (request.mimeType)
        contentHelper.appendTextRow(WebInspector.UIString("Mime Type"), request.mimeType);

    var title = WebInspector.UIString("Initiator");
    var sendRequest = request.children[0];
    var topFrame = WebInspector.TimelineUIUtils.topStackFrame(sendRequest);
    if (topFrame) {
        var link = linkifier.maybeLinkifyConsoleCallFrame(target, topFrame);
        if (link)
            contentHelper.appendElementRow(title, link);
    } else if (sendRequest.initiator) {
        var initiatorURL = WebInspector.TimelineUIUtils.eventURL(sendRequest.initiator);
        if (initiatorURL) {
            var link = linkifier.maybeLinkifyScriptLocation(target, null, initiatorURL, 0);
            if (link)
                contentHelper.appendElementRow(title, link);
        }
    }

    /**
     * @param {function(?Element)} fulfill
     */
    function action(fulfill)
    {
        WebInspector.DOMPresentationUtils.buildImagePreviewContents(/** @type {!WebInspector.Target} */(target), request.url, false, saveImage);
        /**
         * @param {!Element=} element
         */
        function saveImage(element)
        {
            request.previewElement = element || null;
            fulfill(request.previewElement);
        }
    }
    var previewPromise;
    if (request.previewElement)
        previewPromise = Promise.resolve(request.previewElement);
    else
        previewPromise = request.url && target ? new Promise(action) : Promise.resolve(null);
    /**
     * @param {?Element} element
     * @return {!DocumentFragment}
     */
    function appendPreview(element)
    {
        if (element)
            contentHelper.appendElementRow(WebInspector.UIString("Preview"), request.previewElement);
        return contentHelper.fragment;
    }
    return previewPromise.then(appendPreview);
}

/**
 * @param {!Array<!RuntimeAgent.CallFrame>} callFrames
 * @return {!RuntimeAgent.StackTrace}
 */
WebInspector.TimelineUIUtils._stackTraceFromCallFrames = function(callFrames)
{
    return /** @type {!RuntimeAgent.StackTrace} */ ({ callFrames: callFrames });
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @param {?WebInspector.Target} target
 * @param {?Map<number, ?WebInspector.DOMNode>} relatedNodesMap
 * @param {!WebInspector.TimelineDetailsContentHelper} contentHelper
 */
WebInspector.TimelineUIUtils._generateCauses = function(event, target, relatedNodesMap, contentHelper)
{
    var recordTypes = WebInspector.TimelineModel.RecordType;

    var callSiteStackLabel;
    var stackLabel;
    var initiator = event.initiator;

    switch (event.name) {
    case recordTypes.TimerFire:
        callSiteStackLabel = WebInspector.UIString("Timer Installed");
        break;
    case recordTypes.FireAnimationFrame:
        callSiteStackLabel = WebInspector.UIString("Animation Frame Requested");
        break;
    case recordTypes.FireIdleCallback:
        callSiteStackLabel = WebInspector.UIString("Idle Callback Requested");
        break;
    case recordTypes.UpdateLayoutTree:
    case recordTypes.RecalculateStyles:
        stackLabel = WebInspector.UIString("Recalculation Forced");
        break;
    case recordTypes.Layout:
        callSiteStackLabel = WebInspector.UIString("First Layout Invalidation");
        stackLabel = WebInspector.UIString("Layout Forced");
        break;
    }

    // Direct cause.
    if (event.stackTrace && event.stackTrace.length) {
        contentHelper.addSection(WebInspector.UIString("Call Stacks"));
        contentHelper.appendStackTrace(stackLabel || WebInspector.UIString("Stack Trace"), WebInspector.TimelineUIUtils._stackTraceFromCallFrames(event.stackTrace));
    }

    // Indirect causes.
    if (event.invalidationTrackingEvents && target) { // Full invalidation tracking (experimental).
        contentHelper.addSection(WebInspector.UIString("Invalidations"));
        WebInspector.TimelineUIUtils._generateInvalidations(event, target, relatedNodesMap, contentHelper);
    } else if (initiator && initiator.stackTrace) { // Partial invalidation tracking.
        contentHelper.appendStackTrace(callSiteStackLabel || WebInspector.UIString("First Invalidated"), WebInspector.TimelineUIUtils._stackTraceFromCallFrames(initiator.stackTrace));
    }
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @param {!WebInspector.Target} target
 * @param {?Map<number, ?WebInspector.DOMNode>} relatedNodesMap
 * @param {!WebInspector.TimelineDetailsContentHelper} contentHelper
 */
WebInspector.TimelineUIUtils._generateInvalidations = function(event, target, relatedNodesMap, contentHelper)
{
    if (!event.invalidationTrackingEvents)
        return;

    var invalidations = {};
    event.invalidationTrackingEvents.forEach(function(invalidation) {
        if (!invalidations[invalidation.type])
            invalidations[invalidation.type] = [invalidation];
        else
            invalidations[invalidation.type].push(invalidation);
    });

    Object.keys(invalidations).forEach(function(type) {
        WebInspector.TimelineUIUtils._generateInvalidationsForType(
            type, target, invalidations[type], relatedNodesMap, contentHelper);
    });
}

/**
 * @param {string} type
 * @param {!WebInspector.Target} target
 * @param {!Array.<!WebInspector.InvalidationTrackingEvent>} invalidations
 * @param {?Map<number, ?WebInspector.DOMNode>} relatedNodesMap
 * @param {!WebInspector.TimelineDetailsContentHelper} contentHelper
 */
WebInspector.TimelineUIUtils._generateInvalidationsForType = function(type, target, invalidations, relatedNodesMap, contentHelper)
{
    var title;
    switch (type) {
    case WebInspector.TimelineModel.RecordType.StyleRecalcInvalidationTracking:
        title = WebInspector.UIString("Style Invalidations");
        break;
    case WebInspector.TimelineModel.RecordType.LayoutInvalidationTracking:
        title = WebInspector.UIString("Layout Invalidations");
        break;
    default:
        title = WebInspector.UIString("Other Invalidations");
        break;
    }

    var invalidationsTreeOutline = new TreeOutlineInShadow();
    invalidationsTreeOutline.registerRequiredCSS("timeline/invalidationsTree.css");
    invalidationsTreeOutline.element.classList.add("invalidations-tree");

    var invalidationGroups = groupInvalidationsByCause(invalidations);
    invalidationGroups.forEach(function(group) {
        var groupElement = new WebInspector.TimelineUIUtils.InvalidationsGroupElement(target, relatedNodesMap, contentHelper, group);
        invalidationsTreeOutline.appendChild(groupElement);
    });
    contentHelper.appendElementRow(title, invalidationsTreeOutline.element, false, true);

    /**
     * @param {!Array<!WebInspector.InvalidationTrackingEvent>} invalidations
     * @return {!Array<!Array<!WebInspector.InvalidationTrackingEvent>>}
     */
    function groupInvalidationsByCause(invalidations)
    {
        /** @type {!Map<string, !Array<!WebInspector.InvalidationTrackingEvent>>} */
        var causeToInvalidationMap = new Map();
        for (var index = 0; index < invalidations.length; index++) {
            var invalidation = invalidations[index];
            var causeKey = "";
            if (invalidation.cause.reason)
                causeKey += invalidation.cause.reason + ".";
            if (invalidation.cause.stackTrace) {
                invalidation.cause.stackTrace.forEach(function(stackFrame) {
                    causeKey += stackFrame["functionName"] + ".";
                    causeKey += stackFrame["scriptId"] + ".";
                    causeKey += stackFrame["url"] + ".";
                    causeKey += stackFrame["lineNumber"] + ".";
                    causeKey += stackFrame["columnNumber"] + ".";
                });
            }

            if (causeToInvalidationMap.has(causeKey))
                causeToInvalidationMap.get(causeKey).push(invalidation);
            else
                causeToInvalidationMap.set(causeKey, [ invalidation ]);
        }
        return causeToInvalidationMap.valuesArray();
    }
}

/**
 * @param {!Set<number>} nodeIds
 * @param {!WebInspector.InvalidationTrackingEvent} invalidations
 */
WebInspector.TimelineUIUtils._collectInvalidationNodeIds = function(nodeIds, invalidations)
{
    for (var i = 0; i < invalidations.length; ++i) {
        if (invalidations[i].nodeId)
            nodeIds.add(invalidations[i].nodeId);
    }
}

/**
  * @constructor
  * @param {!WebInspector.Target} target
  * @param {?Map<number, ?WebInspector.DOMNode>} relatedNodesMap
  * @param {!WebInspector.TimelineDetailsContentHelper} contentHelper
  * @param {!Array.<!WebInspector.InvalidationTrackingEvent>} invalidations
  * @extends {TreeElement}
  */
WebInspector.TimelineUIUtils.InvalidationsGroupElement = function(target, relatedNodesMap, contentHelper, invalidations)
{
    TreeElement.call(this, "", true);

    this.listItemElement.classList.add("header");
    this.selectable = false;
    this.toggleOnClick = true;

    this._relatedNodesMap = relatedNodesMap;
    this._contentHelper = contentHelper;
    this._invalidations = invalidations;
    this.title = this._createTitle(target);
}

WebInspector.TimelineUIUtils.InvalidationsGroupElement.prototype = {

    /**
     * @param {!WebInspector.Target} target
     * @return {!Element}
     */
    _createTitle: function(target)
    {
        var first = this._invalidations[0];
        var reason = first.cause.reason;
        var topFrame = first.cause.stackTrace && first.cause.stackTrace[0];

        var title = createElement("span");
        if (reason)
            title.createTextChild(WebInspector.UIString("%s for ", reason));
        else
            title.createTextChild(WebInspector.UIString("Unknown cause for "));

        this._appendTruncatedNodeList(title, this._invalidations);

        if (topFrame && this._contentHelper.linkifier()) {
            title.createTextChild(WebInspector.UIString(". "));
            var stack = title.createChild("span", "monospace");
            stack.createChild("span").textContent = WebInspector.beautifyFunctionName(topFrame.functionName);
            var link = this._contentHelper.linkifier().maybeLinkifyConsoleCallFrame(target, topFrame);
            if (link) {
                stack.createChild("span").textContent = " @ ";
                stack.createChild("span").appendChild(link);
            }
        }

        return title;
    },

    /**
     * @override
     */
    onpopulate: function()
    {
        var content = createElementWithClass("div", "content");

        var first = this._invalidations[0];
        if (first.cause.stackTrace) {
            var stack = content.createChild("div");
            stack.createTextChild(WebInspector.UIString("Stack trace:"));
            this._contentHelper.createChildStackTraceElement(stack, WebInspector.TimelineUIUtils._stackTraceFromCallFrames(first.cause.stackTrace));
        }

        content.createTextChild(this._invalidations.length > 1 ? WebInspector.UIString("Nodes:") : WebInspector.UIString("Node:"));
        var nodeList = content.createChild("div", "node-list");
        var firstNode = true;
        for (var i = 0; i < this._invalidations.length; i++) {
            var invalidation = this._invalidations[i];
            var invalidationNode = this._createInvalidationNode(invalidation, true);
            if (invalidationNode) {
                if (!firstNode)
                    nodeList.createTextChild(WebInspector.UIString(", "));
                firstNode = false;

                nodeList.appendChild(invalidationNode);

                var extraData = invalidation.extraData ? ", " + invalidation.extraData : "";
                if (invalidation.changedId)
                    nodeList.createTextChild(WebInspector.UIString("(changed id to \"%s\"%s)", invalidation.changedId, extraData));
                else if (invalidation.changedClass)
                    nodeList.createTextChild(WebInspector.UIString("(changed class to \"%s\"%s)", invalidation.changedClass, extraData));
                else if (invalidation.changedAttribute)
                    nodeList.createTextChild(WebInspector.UIString("(changed attribute to \"%s\"%s)", invalidation.changedAttribute, extraData));
                else if (invalidation.changedPseudo)
                    nodeList.createTextChild(WebInspector.UIString("(changed pesudo to \"%s\"%s)", invalidation.changedPseudo, extraData));
                else if (invalidation.selectorPart)
                    nodeList.createTextChild(WebInspector.UIString("(changed \"%s\"%s)", invalidation.selectorPart, extraData));
            }
        }

        var contentTreeElement = new TreeElement(content, false);
        contentTreeElement.selectable = false;
        this.appendChild(contentTreeElement);
    },

    /**
     * @param {!Element} parentElement
     * @param {!Array.<!WebInspector.InvalidationTrackingEvent>} invalidations
     */
    _appendTruncatedNodeList: function(parentElement, invalidations)
    {
        var invalidationNodes = [];
        var invalidationNodeIdMap = {};
        for (var i = 0; i < invalidations.length; i++) {
            var invalidation = invalidations[i];
            var invalidationNode = this._createInvalidationNode(invalidation, false);
            invalidationNode.addEventListener("click", consumeEvent, false);
            if (invalidationNode && !invalidationNodeIdMap[invalidation.nodeId]) {
                invalidationNodes.push(invalidationNode);
                invalidationNodeIdMap[invalidation.nodeId] = true;
            }
        }

        if (invalidationNodes.length === 1) {
            parentElement.appendChild(invalidationNodes[0]);
        } else if (invalidationNodes.length === 2) {
            parentElement.appendChild(invalidationNodes[0]);
            parentElement.createTextChild(WebInspector.UIString(" and "));
            parentElement.appendChild(invalidationNodes[1]);
        } else if (invalidationNodes.length >= 3) {
            parentElement.appendChild(invalidationNodes[0]);
            parentElement.createTextChild(WebInspector.UIString(", "));
            parentElement.appendChild(invalidationNodes[1]);
            parentElement.createTextChild(WebInspector.UIString(", and %s others", invalidationNodes.length - 2));
        }
    },

    /**
     * @param {!WebInspector.InvalidationTrackingEvent} invalidation
     * @param {boolean} showUnknownNodes
     */
    _createInvalidationNode: function(invalidation, showUnknownNodes)
    {
        var node = (invalidation.nodeId && this._relatedNodesMap) ? this._relatedNodesMap.get(invalidation.nodeId) : null;
        if (node)
            return WebInspector.DOMPresentationUtils.linkifyNodeReference(node);
        if (invalidation.nodeName) {
            var nodeSpan = createElement("span");
            nodeSpan.textContent = WebInspector.UIString("[ %s ]", invalidation.nodeName);
            return nodeSpan;
        }
        if (showUnknownNodes) {
            var nodeSpan = createElement("span");
            return nodeSpan.createTextChild(WebInspector.UIString("[ unknown node ]"));
        }
    },

    __proto__: TreeElement.prototype
}

/**
 * @param {!Object} total
 * @param {!WebInspector.TimelineModel} model
 * @param {!WebInspector.TracingModel.Event} event
 * @return {boolean}
 */
WebInspector.TimelineUIUtils._aggregatedStatsForTraceEvent = function(total, model, event)
{
    var events = model.inspectedTargetEvents();
    /**
     * @param {number} startTime
     * @param {!WebInspector.TracingModel.Event} e
     * @return {number}
     */
    function eventComparator(startTime, e)
    {
        return startTime - e.startTime;
    }
    var index = events.binaryIndexOf(event.startTime, eventComparator);
    // Not a main thread event?
    if (index < 0)
        return false;
    var hasChildren = false;
    var endTime = event.endTime;
    if (endTime) {
        for (var i = index; i < events.length; i++) {
            var nextEvent = events[i];
            if (nextEvent.startTime >= endTime)
                break;
            if (!nextEvent.selfTime)
                continue;
            if (nextEvent.thread !== event.thread)
                continue;
            if (i > index)
                hasChildren = true;
            var categoryName = WebInspector.TimelineUIUtils.eventStyle(nextEvent).category.name;
            total[categoryName] = (total[categoryName] || 0) + nextEvent.selfTime;
        }
    }
    if (WebInspector.TracingModel.isAsyncPhase(event.phase)) {
        if (event.endTime) {
            var aggregatedTotal = 0;
            for (var categoryName in total)
                aggregatedTotal += total[categoryName];
            total["idle"] = Math.max(0, event.endTime - event.startTime - aggregatedTotal);
        }
        return false;
    }
    return hasChildren;
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @param {!WebInspector.Target} target
 * @param {function(!Element=)} callback
 */
WebInspector.TimelineUIUtils.buildPicturePreviewContent = function(event, target, callback)
{
    new WebInspector.LayerPaintEvent(event, target).loadSnapshot(onSnapshotLoaded);
    /**
     * @param {?Array.<number>} rect
     * @param {?WebInspector.PaintProfilerSnapshot} snapshot
     */
    function onSnapshotLoaded(rect, snapshot)
    {
        if (!snapshot) {
            callback();
            return;
        }
        snapshot.requestImage(null, null, 1, onGotImage);
        snapshot.dispose();
    }

    /**
     * @param {string=} imageURL
     */
    function onGotImage(imageURL)
    {
        if (!imageURL) {
            callback();
            return;
        }
        var container = createElement("div");
        container.classList.add("image-preview-container", "vbox", "link");
        var img = container.createChild("img");
        img.src = imageURL;
        var paintProfilerButton = container.createChild("a");
        paintProfilerButton.textContent = WebInspector.UIString("Paint Profiler");
        container.addEventListener("click", showPaintProfiler, false);
        callback(container);
    }

    function showPaintProfiler()
    {
        WebInspector.TimelinePanel.instance().select(WebInspector.TimelineSelection.fromTraceEvent(event), WebInspector.TimelinePanel.DetailsTab.PaintProfiler);
    }
}

/**
 * @param {!WebInspector.TimelineModel.RecordType} recordType
 * @param {?string} title
 * @param {number} position
 * @return {!Element}
 */
WebInspector.TimelineUIUtils.createEventDivider = function(recordType, title, position)
{
    var eventDivider = createElement("div");
    eventDivider.className = "resources-event-divider";
    var recordTypes = WebInspector.TimelineModel.RecordType;

    if (recordType === recordTypes.MarkDOMContent)
        eventDivider.className += " resources-blue-divider";
    else if (recordType === recordTypes.MarkLoad)
        eventDivider.className += " resources-red-divider";
    else if (recordType === recordTypes.MarkFirstPaint)
        eventDivider.className += " resources-green-divider";
    else if (recordType === recordTypes.TimeStamp || recordType === recordTypes.ConsoleTime || recordType === recordTypes.UserTiming)
        eventDivider.className += " resources-orange-divider";
    else if (recordType === recordTypes.BeginFrame)
        eventDivider.className += " timeline-frame-divider";

    if (title)
        eventDivider.title = title;
    eventDivider.style.left = position + "px";
    return eventDivider;
}

/**
 * @param {!WebInspector.TimelineModel.Record} record
 * @param {number} zeroTime
 * @param {number} position
 * @return {!Element}
 */
WebInspector.TimelineUIUtils.createDividerForRecord = function(record, zeroTime, position)
{
    var startTime = Number.millisToString(record.startTime() - zeroTime);
    var title = WebInspector.UIString("%s at %s", WebInspector.TimelineUIUtils.eventTitle(record.traceEvent()), startTime);
    return WebInspector.TimelineUIUtils.createEventDivider(record.type(), title, position);
}

/**
 * @return {!Array.<string>}
 */
WebInspector.TimelineUIUtils._visibleTypes = function()
{
    var eventStyles = WebInspector.TimelineUIUtils._initEventStyles();
    var result = [];
    for (var name in eventStyles) {
        if (!eventStyles[name].hidden)
            result.push(name);
    }
    return result;
}

/**
 * @return {!WebInspector.TimelineModel.Filter}
 */
WebInspector.TimelineUIUtils.visibleEventsFilter = function()
{
    return new WebInspector.TimelineVisibleEventsFilter(WebInspector.TimelineUIUtils._visibleTypes());
}

/**
 * @return {!Object.<string, !WebInspector.TimelineCategory>}
 */
WebInspector.TimelineUIUtils.categories = function()
{
    if (WebInspector.TimelineUIUtils._categories)
        return WebInspector.TimelineUIUtils._categories;
    WebInspector.TimelineUIUtils._categories = {
        loading: new WebInspector.TimelineCategory("loading", WebInspector.UIString("Loading"), true, "hsl(214, 67%, 74%)", "hsl(214, 67%, 66%)"),
        scripting: new WebInspector.TimelineCategory("scripting", WebInspector.UIString("Scripting"), true, "hsl(43, 83%, 72%)", "hsl(43, 83%, 64%) "),
        rendering: new WebInspector.TimelineCategory("rendering", WebInspector.UIString("Rendering"), true, "hsl(256, 67%, 76%)", "hsl(256, 67%, 70%)"),
        painting: new WebInspector.TimelineCategory("painting", WebInspector.UIString("Painting"), true, "hsl(109, 33%, 64%)", "hsl(109, 33%, 55%)"),
        gpu: new WebInspector.TimelineCategory("gpu", WebInspector.UIString("GPU"), false, "hsl(109, 33%, 64%)", "hsl(109, 33%, 55%)"),
        other: new WebInspector.TimelineCategory("other", WebInspector.UIString("Other"), false, "hsl(0, 0%, 87%)", "hsl(0, 0%, 79%)"),
        idle: new WebInspector.TimelineCategory("idle", WebInspector.UIString("Idle"), false, "hsl(0, 100%, 100%)", "hsl(0, 100%, 100%)")
    };
    return WebInspector.TimelineUIUtils._categories;
};

/**
 * @param {!WebInspector.TimelineModel.AsyncEventGroup} group
 * @return {string}
 */
WebInspector.TimelineUIUtils.titleForAsyncEventGroup = function(group)
{
    if (!WebInspector.TimelineUIUtils._titleForAsyncEventGroupMap) {
        var groups = WebInspector.TimelineModel.AsyncEventGroup;
        WebInspector.TimelineUIUtils._titleForAsyncEventGroupMap = new Map([
            [groups.animation, WebInspector.UIString("Animation")],
            [groups.console, WebInspector.UIString("Console")],
            [groups.userTiming, WebInspector.UIString("User Timing")],
            [groups.input, WebInspector.UIString("Input")]
        ]);
    }
    return WebInspector.TimelineUIUtils._titleForAsyncEventGroupMap.get(group) || "";
}

/**
 * @param {!Object} aggregatedStats
 * @param {!WebInspector.TimelineCategory=} selfCategory
 * @param {number=} selfTime
 * @return {!Element}
 */
WebInspector.TimelineUIUtils.generatePieChart = function(aggregatedStats, selfCategory, selfTime)
{
    var total = 0;
    for (var categoryName in aggregatedStats)
        total += aggregatedStats[categoryName];

    var element = createElementWithClass("div", "timeline-details-view-pie-chart-wrapper hbox");
    var pieChart = new WebInspector.PieChart(100);
    pieChart.element.classList.add("timeline-details-view-pie-chart");
    pieChart.setTotal(total);
    var pieChartContainer = element.createChild("div", "vbox");
    pieChartContainer.appendChild(pieChart.element);
    pieChartContainer.createChild("div", "timeline-details-view-pie-chart-total").textContent = WebInspector.UIString("Total: %s", Number.millisToString(total, true));
    var footerElement = element.createChild("div", "timeline-aggregated-info-legend");

    /**
     * @param {string} name
     * @param {string} title
     * @param {number} value
     * @param {string} color
     */
    function appendLegendRow(name, title, value, color)
    {
        if (!value)
            return;
        pieChart.addSlice(value, color);
        var rowElement = footerElement.createChild("div");
        rowElement.createChild("span", "timeline-aggregated-legend-value").textContent = Number.preciseMillisToString(value, 1);
        rowElement.createChild("span", "timeline-aggregated-legend-swatch").style.backgroundColor = color;
        rowElement.createChild("span", "timeline-aggregated-legend-title").textContent = title;
    }

    // In case of self time, first add self, then children of the same category.
    if (selfCategory) {
        if (selfTime)
            appendLegendRow(selfCategory.name, WebInspector.UIString("%s (self)", selfCategory.title), selfTime, selfCategory.color);
        // Children of the same category.
        var categoryTime = aggregatedStats[selfCategory.name];
        var value = categoryTime - selfTime;
        if (value > 0)
            appendLegendRow(selfCategory.name, WebInspector.UIString("%s (children)", selfCategory.title), value, selfCategory.childColor);
    }

    // Add other categories.
    for (var categoryName in WebInspector.TimelineUIUtils.categories()) {
        var category = WebInspector.TimelineUIUtils.categories()[categoryName];
        if (category === selfCategory)
            continue;
        appendLegendRow(category.name, category.title, aggregatedStats[category.name], category.childColor);
    }
    return element;
}

/**
 * @param {!WebInspector.TimelineFrameModel} frameModel
 * @param {!WebInspector.TimelineFrame} frame
 * @param {?WebInspector.FilmStripModel.Frame} filmStripFrame
 * @return {!Element}
 */
WebInspector.TimelineUIUtils.generateDetailsContentForFrame = function(frameModel, frame, filmStripFrame)
{
    var pieChart = WebInspector.TimelineUIUtils.generatePieChart(frame.timeByCategory);
    var contentHelper = new WebInspector.TimelineDetailsContentHelper(null, null);
    contentHelper.addSection(WebInspector.UIString("Frame"));

    var duration = WebInspector.TimelineUIUtils.frameDuration(frame);
    contentHelper.appendElementRow(WebInspector.UIString("Duration"), duration, frame.hasWarnings());
    if (filmStripFrame) {
        var filmStripPreview = createElementWithClass("img", "timeline-filmstrip-preview");
        filmStripFrame.imageDataPromise().then(onGotImageData.bind(null, filmStripPreview));
        contentHelper.appendElementRow("", filmStripPreview);
        filmStripPreview.addEventListener("click", frameClicked.bind(null, filmStripFrame), false);
    }
    var durationInMillis = frame.endTime - frame.startTime;
    contentHelper.appendTextRow(WebInspector.UIString("FPS"), Math.floor(1000 / durationInMillis));
    contentHelper.appendTextRow(WebInspector.UIString("CPU time"), Number.millisToString(frame.cpuTime, true));

    if (Runtime.experiments.isEnabled("layersPanel") && frame.layerTree) {
        contentHelper.appendElementRow(WebInspector.UIString("Layer tree"),
                                       WebInspector.Linkifier.linkifyUsingRevealer(frame.layerTree, WebInspector.UIString("show")));
    }

    /**
     * @param {!Element} image
     * @param {?string} data
     */
    function onGotImageData(image, data)
    {
        if (data)
            image.src = "data:image/jpg;base64," + data;
    }

    /**
     * @param {!WebInspector.FilmStripModel.Frame} filmStripFrame
     */
    function frameClicked(filmStripFrame)
    {
        new WebInspector.FilmStripView.Dialog(filmStripFrame, 0);
    }

    return contentHelper.fragment;
}

/**
 * @param {!WebInspector.TimelineFrame} frame
 * @return {!Element}
 */
WebInspector.TimelineUIUtils.frameDuration = function(frame)
{
    var durationText = WebInspector.UIString("%s (at %s)", Number.millisToString(frame.endTime - frame.startTime, true),
        Number.millisToString(frame.startTimeOffset, true));
    var element = createElement("span");
    element.createTextChild(durationText);
    if (!frame.hasWarnings())
        return element;
    element.createTextChild(WebInspector.UIString(". Long frame times are an indication of "));
    element.appendChild(WebInspector.linkifyURLAsNode("https://developers.google.com/web/fundamentals/performance/rendering/",
                                                      WebInspector.UIString("jank"), undefined, true));
    element.createTextChild(".");
    return element;
}

/**
 * @param {!CanvasRenderingContext2D} context
 * @param {number} width
 * @param {number} height
 * @param {string} color0
 * @param {string} color1
 * @param {string} color2
 * @return {!CanvasGradient}
 */
WebInspector.TimelineUIUtils.createFillStyle = function(context, width, height, color0, color1, color2)
{
    var gradient = context.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, color0);
    gradient.addColorStop(0.25, color1);
    gradient.addColorStop(0.75, color1);
    gradient.addColorStop(1, color2);
    return gradient;
}

/**
 * @param {!Array.<number>} quad
 * @return {number}
 */
WebInspector.TimelineUIUtils.quadWidth = function(quad)
{
    return Math.round(Math.sqrt(Math.pow(quad[0] - quad[2], 2) + Math.pow(quad[1] - quad[3], 2)));
}

/**
 * @param {!Array.<number>} quad
 * @return {number}
 */
WebInspector.TimelineUIUtils.quadHeight = function(quad)
{
    return Math.round(Math.sqrt(Math.pow(quad[0] - quad[6], 2) + Math.pow(quad[1] - quad[7], 2)));
}

/**
 * @constructor
 * @param {number} priority
 * @param {string} color
 * @param {!Array.<string>} eventTypes
 */
WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor = function(priority, color, eventTypes)
{
    this.priority = priority;
    this.color = color;
    this.eventTypes = eventTypes;
}

/**
 * @return {!Array.<!WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor>}
 */
WebInspector.TimelineUIUtils.eventDispatchDesciptors = function()
{
    if (WebInspector.TimelineUIUtils._eventDispatchDesciptors)
        return WebInspector.TimelineUIUtils._eventDispatchDesciptors;
    var lightOrange = "hsl(40,100%,80%)";
    var orange = "hsl(40,100%,50%)";
    var green = "hsl(90,100%,40%)";
    var purple = "hsl(256,100%,75%)";
    WebInspector.TimelineUIUtils._eventDispatchDesciptors = [
        new WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor(1, lightOrange, ["mousemove", "mouseenter", "mouseleave", "mouseout", "mouseover"]),
        new WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor(1, lightOrange, ["pointerover", "pointerout", "pointerenter", "pointerleave", "pointermove"]),
        new WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor(2, green, ["wheel"]),
        new WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor(3, orange, ["click", "mousedown", "mouseup"]),
        new WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor(3, orange, ["touchstart", "touchend", "touchmove", "touchcancel"]),
        new WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor(3, orange, ["pointerdown", "pointerup", "pointercancel", "gotpointercapture", "lostpointercapture"]),
        new WebInspector.TimelineUIUtils.EventDispatchTypeDescriptor(3, purple, ["keydown", "keyup", "keypress"])
    ];
    return WebInspector.TimelineUIUtils._eventDispatchDesciptors;
}

/**
 * @constructor
 * @extends {WebInspector.Object}
 * @param {string} name
 * @param {string} title
 * @param {boolean} visible
 * @param {string} childColor
 * @param {string} color
 */
WebInspector.TimelineCategory = function(name, title, visible, childColor, color)
{
    this.name = name;
    this.title = title;
    this.visible = visible;
    this.childColor = childColor;
    this.color = color;
    this.hidden = false;
}

/** @enum {symbol} */
WebInspector.TimelineCategory.Events = {
    VisibilityChanged: Symbol("VisibilityChanged")
};

WebInspector.TimelineCategory.prototype = {
    /**
     * @return {boolean}
     */
    get hidden()
    {
        return this._hidden;
    },

    set hidden(hidden)
    {
        this._hidden = hidden;
        this.dispatchEventToListeners(WebInspector.TimelineCategory.Events.VisibilityChanged, this);
    },

    __proto__: WebInspector.Object.prototype
}

/**
 * @typedef {!{
 *     title: string,
 *     color: string,
 *     lineWidth: number,
 *     dashStyle: !Array.<number>,
 *     tall: boolean,
 *     lowPriority: boolean
 * }}
 */
WebInspector.TimelineMarkerStyle;

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {!WebInspector.TimelineMarkerStyle}
 */
WebInspector.TimelineUIUtils.markerStyleForEvent = function(event)
{
    var red = "rgb(255, 0, 0)";
    var blue = "rgb(0, 0, 255)";
    var orange = "rgb(255, 178, 23)";
    var green = "rgb(0, 130, 0)";
    var tallMarkerDashStyle = [10, 5];

    var title = WebInspector.TimelineUIUtils.eventTitle(event)

    if (event.hasCategory(WebInspector.TimelineModel.Category.Console) || event.hasCategory(WebInspector.TimelineModel.Category.UserTiming)) {
        return {
            title: title,
            dashStyle: tallMarkerDashStyle,
            lineWidth: 0.5,
            color: orange,
            tall: false,
            lowPriority: false,
        };
    }
    var recordTypes = WebInspector.TimelineModel.RecordType;
    var tall = false;
    var color = green;
    switch (event.name) {
    case recordTypes.MarkDOMContent:
        color = blue;
        tall = true;
        break;
    case recordTypes.MarkLoad:
        color = red;
        tall = true;
        break;
    case recordTypes.MarkFirstPaint:
        color = green;
        tall = true;
        break;
    case recordTypes.TimeStamp:
        color = orange;
        break;
    }
    return {
        title: title,
        dashStyle: tallMarkerDashStyle,
        lineWidth: 0.5,
        color: color,
        tall: tall,
        lowPriority: false,
    };
}

/**
 * @return {!WebInspector.TimelineMarkerStyle}
 */
WebInspector.TimelineUIUtils.markerStyleForFrame = function()
{
    return {
        title: WebInspector.UIString("Frame"),
        color: "rgba(100, 100, 100, 0.4)",
        lineWidth: 3,
        dashStyle: [3],
        tall: true,
        lowPriority: true
    };
}

/**
 * @param {string} url
 * @return {string}
 */
WebInspector.TimelineUIUtils.colorForURL = function(url)
{
    if (!WebInspector.TimelineUIUtils.colorForURL._colorGenerator) {
        WebInspector.TimelineUIUtils.colorForURL._colorGenerator = new WebInspector.FlameChart.ColorGenerator(
            { min: 30, max: 330 },
            { min: 50, max: 80, count: 3 },
            85);
    }
    return WebInspector.TimelineUIUtils.colorForURL._colorGenerator.colorForID(url);
}

/**
 * @constructor
 * @param {string} title
 */
WebInspector.TimelinePopupContentHelper = function(title)
{
    this._contentTable = createElement("table");
    var titleCell = this._createCell(WebInspector.UIString("%s - Details", title), "timeline-details-title");
    titleCell.colSpan = 2;
    var titleRow = createElement("tr");
    titleRow.appendChild(titleCell);
    this._contentTable.appendChild(titleRow);
}

WebInspector.TimelinePopupContentHelper.prototype = {
    /**
     * @return {!Element}
     */
    contentTable: function()
    {
        return this._contentTable;
    },

    /**
     * @param {string|number} content
     * @param {string=} styleName
     */
    _createCell: function(content, styleName)
    {
        var text = createElement("label");
        text.createTextChild(String(content));
        var cell = createElement("td");
        cell.className = "timeline-details";
        if (styleName)
            cell.className += " " + styleName;
        cell.textContent = content;
        return cell;
    },

    /**
     * @param {string} title
     * @param {string|number} content
     */
    appendTextRow: function(title, content)
    {
        var row = createElement("tr");
        row.appendChild(this._createCell(title, "timeline-details-row-title"));
        row.appendChild(this._createCell(content, "timeline-details-row-data"));
        this._contentTable.appendChild(row);
    },

    /**
     * @param {string} title
     * @param {!Node|string} content
     */
    appendElementRow: function(title, content)
    {
        var row = createElement("tr");
        var titleCell = this._createCell(title, "timeline-details-row-title");
        row.appendChild(titleCell);
        var cell = createElement("td");
        cell.className = "details";
        if (content instanceof Node)
            cell.appendChild(content);
        else
            cell.createTextChild(content || "");
        row.appendChild(cell);
        this._contentTable.appendChild(row);
    }
}

/**
 * @constructor
 * @param {?WebInspector.Target} target
 * @param {?WebInspector.Linkifier} linkifier
 */
WebInspector.TimelineDetailsContentHelper = function(target, linkifier)
{
    this.fragment = createDocumentFragment();

    this._linkifier = linkifier;
    this._target = target;

    this.element = createElementWithClass("div", "timeline-details-view-block");
    this._tableElement = this.element.createChild("div", "vbox timeline-details-chip-body");
    this.fragment.appendChild(this.element);
}

WebInspector.TimelineDetailsContentHelper.prototype = {
    /**
     * @param {string} title
     * @param {!WebInspector.TimelineCategory=} category
     */
    addSection: function(title, category)
    {
        if (!this._tableElement.hasChildNodes()) {
            this.element.removeChildren();
        } else {
            this.element = createElementWithClass("div", "timeline-details-view-block");
            this.fragment.appendChild(this.element);
        }

        if (title) {
            var titleElement = this.element.createChild("div", "timeline-details-chip-title");
            if (category)
                titleElement.createChild("div").style.backgroundColor = category.color;
            titleElement.createTextChild(title);
        }

        this._tableElement = this.element.createChild("div", "vbox timeline-details-chip-body");
        this.fragment.appendChild(this.element);
    },

    /**
     * @return {?WebInspector.Linkifier}
     */
    linkifier: function()
    {
        return this._linkifier;
    },

    /**
     * @param {string} title
     * @param {string|number|boolean} value
     */
    appendTextRow: function(title, value)
    {
        var rowElement = this._tableElement.createChild("div", "timeline-details-view-row");
        rowElement.createChild("div", "timeline-details-view-row-title").textContent = title;
        rowElement.createChild("div", "timeline-details-view-row-value").textContent = value;
    },

    /**
     * @param {string} title
     * @param {!Node|string} content
     * @param {boolean=} isWarning
     * @param {boolean=} isStacked
     */
    appendElementRow: function(title, content, isWarning, isStacked)
    {
        var rowElement = this._tableElement.createChild("div", "timeline-details-view-row");
        if (isWarning)
            rowElement.classList.add("timeline-details-warning");
        if (isStacked)
            rowElement.classList.add("timeline-details-stack-values");
        var titleElement = rowElement.createChild("div", "timeline-details-view-row-title");
        titleElement.textContent = title;
        var valueElement = rowElement.createChild("div", "timeline-details-view-row-value");
        if (content instanceof Node)
            valueElement.appendChild(content);
        else
            valueElement.createTextChild(content || "");
    },

    /**
     * @param {string} title
     * @param {string} url
     * @param {number} startLine
     * @param {number=} startColumn
     */
    appendLocationRow: function(title, url, startLine, startColumn)
    {
        if (!this._linkifier || !this._target)
            return;
        var link = this._linkifier.maybeLinkifyScriptLocation(this._target, null, url, startLine, startColumn);
        if (!link)
            return;
        this.appendElementRow(title, link);
    },

    /**
     * @param {string} title
     * @param {string} url
     * @param {number} startLine
     * @param {number=} endLine
     */
    appendLocationRange: function(title, url, startLine, endLine)
    {
        if (!this._linkifier || !this._target)
            return;
        var locationContent = createElement("span");
        var link = this._linkifier.maybeLinkifyScriptLocation(this._target, null, url, startLine);
        if (!link)
            return;
        locationContent.appendChild(link);
        locationContent.createTextChild(String.sprintf(" [%s\u2026%s]", startLine + 1, endLine + 1 || ""));
        this.appendElementRow(title, locationContent);
    },

    /**
     * @param {string} title
     * @param {!RuntimeAgent.StackTrace} stackTrace
     */
    appendStackTrace: function(title, stackTrace)
    {
        if (!this._linkifier || !this._target)
            return;

        var rowElement = this._tableElement.createChild("div", "timeline-details-view-row");
        rowElement.createChild("div", "timeline-details-view-row-title").textContent = title;
        this.createChildStackTraceElement(rowElement, stackTrace);
    },

    /**
     * @param {!Element} parentElement
     * @param {!RuntimeAgent.StackTrace} stackTrace
     */
    createChildStackTraceElement: function(parentElement, stackTrace)
    {
        if (!this._linkifier || !this._target)
            return;
        parentElement.classList.add("timeline-details-stack-values");
        var stackTraceElement = parentElement.createChild("div", "timeline-details-view-row-value timeline-details-view-row-stack-trace");
        var callFrameElem = WebInspector.DOMPresentationUtils.buildStackTracePreviewContents(this._target, this._linkifier, stackTrace);
        stackTraceElement.appendChild(callFrameElem);
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @param {string=} warningType
     */
    appendWarningRow: function(event, warningType)
    {
        var warning = WebInspector.TimelineUIUtils.eventWarning(event, warningType);
        if (warning)
            this.appendElementRow(WebInspector.UIString("Warning"), warning, true);
    }
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @param {string=} warningType
 * @return {?Element}
 */
WebInspector.TimelineUIUtils.eventWarning = function(event, warningType)
{
    var warning = warningType || event.warning;
    if (!warning)
        return null;
    var warnings = WebInspector.TimelineModel.WarningType;
    var span = createElement("span");
    var eventData = event.args["data"];

    switch (warning) {
    case warnings.ForcedStyle:
    case warnings.ForcedLayout:
        span.appendChild(WebInspector.linkifyDocumentationURLAsNode("../../fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid-forced-synchronous-layouts",
            WebInspector.UIString("Forced reflow")));
        span.createTextChild(WebInspector.UIString(" is a likely performance bottleneck."));
        break;
    case warnings.IdleDeadlineExceeded:
        span.textContent = WebInspector.UIString("Idle callback execution extended beyond deadline by " +
            Number.millisToString(event.duration - eventData["allottedMilliseconds"], true));
        break;
    case warnings.V8Deopt:
        span.appendChild(WebInspector.linkifyURLAsNode("https://github.com/GoogleChrome/devtools-docs/issues/53",
            WebInspector.UIString("Not optimized"), undefined, true));
        span.createTextChild(WebInspector.UIString(": %s", eventData["deoptReason"]));
        break;
    default:
        console.assert(false, "Unhandled TimelineModel.WarningType");
    }
    return span;
}

},{}],227:[function(require,module,exports){
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/** @typedef {!{
        bounds: {height: number, width: number},
        children: Array.<!WebInspector.TracingLayerPayload>,
        layer_id: number,
        position: Array.<number>,
        scroll_offset: Array.<number>,
        layer_quad: Array.<number>,
        draws_content: number,
        gpu_memory_usage: number,
        transform: Array.<number>,
        owner_node: number,
        compositing_reasons: Array.<string>
    }}
*/
WebInspector.TracingLayerPayload;

/** @typedef {!{
        id: string,
        layer_id: number,
        gpu_memory_usage: number,
        content_rect: !Array.<number>
    }}
*/
WebInspector.TracingLayerTile;

/**
  * @constructor
  * @extends {WebInspector.SDKModel}
  */
WebInspector.LayerTreeModel = function(target)
{
    WebInspector.SDKModel.call(this, WebInspector.LayerTreeModel, target);
    target.registerLayerTreeDispatcher(new WebInspector.LayerTreeDispatcher(this));
    WebInspector.targetManager.addEventListener(WebInspector.TargetManager.Events.MainFrameNavigated, this._onMainFrameNavigated, this);
    /** @type {?WebInspector.LayerTreeBase} */
    this._layerTree = null;
}

/** @enum {symbol} */
WebInspector.LayerTreeModel.Events = {
    LayerTreeChanged: Symbol("LayerTreeChanged"),
    LayerPainted: Symbol("LayerPainted"),
}

WebInspector.LayerTreeModel.ScrollRectType = {
    NonFastScrollable: {name: "NonFastScrollable", description: "Non fast scrollable"},
    TouchEventHandler: {name: "TouchEventHandler", description: "Touch event handler"},
    WheelEventHandler: {name: "WheelEventHandler", description: "Wheel event handler"},
    RepaintsOnScroll: {name: "RepaintsOnScroll", description: "Repaints on scroll"}
}

WebInspector.LayerTreeModel.prototype = {
    disable: function()
    {
        if (!this._enabled)
            return;
        this._enabled = false;
        this._layerTree = null;
        this.target().layerTreeAgent().disable();
    },

    enable: function()
    {
        if (this._enabled)
            return;
        this._enabled = true;
        this._forceEnable();
    },

    _forceEnable: function()
    {
        this._layerTree = new WebInspector.AgentLayerTree(this.target());
        this._lastPaintRectByLayerId = {};
        this.target().layerTreeAgent().enable();
    },

    /**
     * @param {!WebInspector.LayerTreeBase} layerTree
     */
    setLayerTree: function(layerTree)
    {
        this.disable();
        this._layerTree = layerTree;
        this.dispatchEventToListeners(WebInspector.LayerTreeModel.Events.LayerTreeChanged);
    },

    /**
     * @return {?WebInspector.LayerTreeBase}
     */
    layerTree: function()
    {
        return this._layerTree;
    },

    /**
     * @param {?Array.<!LayerTreeAgent.Layer>} layers
     */
    _layerTreeChanged: function(layers)
    {
        if (!this._enabled)
            return;
        var layerTree = /** @type {!WebInspector.AgentLayerTree} */ (this._layerTree);
        layerTree.setLayers(layers, onLayersSet.bind(this));

        /**
         * @this {WebInspector.LayerTreeModel}
         */
        function onLayersSet()
        {
            for (var layerId in this._lastPaintRectByLayerId) {
                var lastPaintRect = this._lastPaintRectByLayerId[layerId];
                var layer = layerTree.layerById(layerId);
                if (layer)
                    layer._lastPaintRect = lastPaintRect;
            }
            this._lastPaintRectByLayerId = {};

            this.dispatchEventToListeners(WebInspector.LayerTreeModel.Events.LayerTreeChanged);
        }
    },

    /**
     * @param {!LayerTreeAgent.LayerId} layerId
     * @param {!DOMAgent.Rect} clipRect
     */
    _layerPainted: function(layerId, clipRect)
    {
        if (!this._enabled)
            return;
        var layerTree = /** @type {!WebInspector.AgentLayerTree} */ (this._layerTree);
        var layer = layerTree.layerById(layerId);
        if (!layer) {
            this._lastPaintRectByLayerId[layerId] = clipRect;
            return;
        }
        layer._didPaint(clipRect);
        this.dispatchEventToListeners(WebInspector.LayerTreeModel.Events.LayerPainted, layer);
    },

    _onMainFrameNavigated: function()
    {
        if (this._enabled)
            this._forceEnable();
    },

    __proto__: WebInspector.SDKModel.prototype
}

/**
  * @constructor
  * @param {?WebInspector.Target} target
  */
WebInspector.LayerTreeBase = function(target)
{
    this._target = target;
    this._domModel = target ? WebInspector.DOMModel.fromTarget(target) : null;
    this._layersById = {};
    /** @type Map<number, ?WebInspector.DOMNode> */
    this._backendNodeIdToNode = new Map();
    this._reset();
}

WebInspector.LayerTreeBase.prototype = {
    _reset: function()
    {
        this._root = null;
        this._contentRoot = null;
        this._layers = null;
    },

    /**
     * @return {?WebInspector.Target}
     */
    target: function()
    {
        return this._target;
    },

    /**
     * @return {?WebInspector.Layer}
     */
    root: function()
    {
        return this._root;
    },

    /**
     * @return {?WebInspector.Layer}
     */
    contentRoot: function()
    {
        return this._contentRoot;
    },

    /**
     * @return {!Array.<!WebInspector.Layer>}
     */
    layers: function()
    {
        return this._layers;
    },

    /**
     * @param {function(!WebInspector.Layer)} callback
     * @param {?WebInspector.Layer=} root
     * @return {boolean}
     */
    forEachLayer: function(callback, root)
    {
        if (!root) {
            root = this.root();
            if (!root)
                return false;
        }
        return callback(root) || root.children().some(this.forEachLayer.bind(this, callback));
    },

    /**
     * @param {string} id
     * @return {?WebInspector.Layer}
     */
    layerById: function(id)
    {
        return this._layersById[id] || null;
    },

    /**
     * @param {!Set<number>} requestedNodeIds
     * @param {function()} callback
     */
    _resolveBackendNodeIds: function(requestedNodeIds, callback)
    {
        if (!requestedNodeIds.size || !this._domModel) {
            callback();
            return;
        }
        if (this._domModel)
            this._domModel.pushNodesByBackendIdsToFrontend(requestedNodeIds, populateBackendNodeMap.bind(this));

        /**
         * @this {WebInspector.LayerTreeBase}
         * @param {?Map<number, ?WebInspector.DOMNode>} nodesMap
         */
        function populateBackendNodeMap(nodesMap)
        {
            if (nodesMap) {
                for (var nodeId of nodesMap.keysArray())
                    this._backendNodeIdToNode.set(nodeId, nodesMap.get(nodeId) || null);
            }
            callback();
        }
    },

    /**
     * @param {!Object} viewportSize
     */
    setViewportSize: function(viewportSize)
    {
        this._viewportSize = viewportSize;
    },

    /**
     * @return {!Object | undefined}
     */
    viewportSize: function()
    {
        return this._viewportSize;
    },

    /**
     * @param {number} id
     * @return {?WebInspector.DOMNode}
     */
    _nodeForId: function(id)
    {
        return this._domModel ? this._domModel.nodeForId(id) : null;
    }
}

/**
  * @constructor
  * @extends {WebInspector.LayerTreeBase}
  * @param {?WebInspector.Target} target
  */
WebInspector.TracingLayerTree = function(target)
{
    WebInspector.LayerTreeBase.call(this, target);
    /** @type {!Map.<string, !WebInspector.TracingLayerTile>} */
    this._tileById = new Map();
}

WebInspector.TracingLayerTree.prototype = {
    /**
     * @param {!WebInspector.TracingLayerPayload} root
     * @param {?Array.<!WebInspector.TracingLayerPayload>} layers
     * @param {function()} callback
     */
    setLayers: function(root, layers, callback)
    {
        var idsToResolve = new Set();
        if (root) {
            // This is a legacy code path for compatibility, as cc is removing
            // layer tree hierarchy, this code will eventually be removed.
            this._extractNodeIdsToResolve(idsToResolve, {}, root);
        } else {
            for (var i = 0; i < layers.length; ++i)
                this._extractNodeIdsToResolve(idsToResolve, {}, layers[i]);
        }
        this._resolveBackendNodeIds(idsToResolve, onBackendNodeIdsResolved.bind(this));

        /**
         * @this {WebInspector.TracingLayerTree}
         */
        function onBackendNodeIdsResolved()
        {
            var oldLayersById = this._layersById;
            this._layersById = {};
            this._contentRoot = null;
            if (root) {
                this._root = this._innerSetLayers(oldLayersById, root);
            } else {
                this._layers = layers.map(this._innerSetLayers.bind(this, oldLayersById));
                this._root = this._contentRoot;
                for (var i = 0; i < this._layers.length; ++i) {
                    if (this._layers[i].id() !== this._contentRoot.id()) {
                        this._contentRoot.addChild(this._layers[i]);
                    }
                }
            }
            callback();
        }
    },

    /**
     * @param {!Array.<!WebInspector.TracingLayerTile>} tiles
     */
    setTiles: function(tiles)
    {
        this._tileById = new Map();
        for (var tile of tiles)
            this._tileById.set(tile.id, tile);
    },

    /**
     * @param {string} id
     * @return {?WebInspector.TracingLayerTile}
     */
    tileById: function(id)
    {
        return this._tileById.get(id) || null;
    },

    /**
     * @param {!Object.<(string|number), !WebInspector.Layer>} oldLayersById
     * @param {!WebInspector.TracingLayerPayload} payload
     * @return {!WebInspector.TracingLayer}
     */
    _innerSetLayers: function(oldLayersById, payload)
    {
        var layer = /** @type {?WebInspector.TracingLayer} */ (oldLayersById[payload.layer_id]);
        if (layer)
            layer._reset(payload);
        else
            layer = new WebInspector.TracingLayer(payload);
        this._layersById[payload.layer_id] = layer;
        if (payload.owner_node)
            layer._setNode(this._backendNodeIdToNode.get(payload.owner_node) || null);
        if (!this._contentRoot && layer.drawsContent())
            this._contentRoot = layer;
        for (var i = 0; payload.children && i < payload.children.length; ++i)
            layer.addChild(this._innerSetLayers(oldLayersById, payload.children[i]));
        return layer;
    },

    /**
     * @param {!Set<number>} nodeIdsToResolve
     * @param {!Object} seenNodeIds
     * @param {!WebInspector.TracingLayerPayload} payload
     */
    _extractNodeIdsToResolve: function(nodeIdsToResolve, seenNodeIds, payload)
    {
        var backendNodeId = payload.owner_node;
        if (backendNodeId && !this._backendNodeIdToNode.has(backendNodeId))
            nodeIdsToResolve.add(backendNodeId);
        for (var i = 0; payload.children && i < payload.children.length; ++i)
            this._extractNodeIdsToResolve(nodeIdsToResolve, seenNodeIds, payload.children[i]);
    },

    __proto__: WebInspector.LayerTreeBase.prototype
}

/**
  * @constructor
  * @param {?WebInspector.Target} target
  * @extends {WebInspector.LayerTreeBase}
  */
WebInspector.AgentLayerTree = function(target)
{
    WebInspector.LayerTreeBase.call(this, target);
}

WebInspector.AgentLayerTree.prototype = {
    /**
     * @param {?Array.<!LayerTreeAgent.Layer>} payload
     * @param {function()} callback
     */
    setLayers: function(payload, callback)
    {
        if (!payload) {
            onBackendNodeIdsResolved.call(this);
            return;
        }

        var idsToResolve = new Set();
        for (var i = 0; i < payload.length; ++i) {
            var backendNodeId = payload[i].backendNodeId;
            if (!backendNodeId || this._backendNodeIdToNode.has(backendNodeId))
                continue;
            idsToResolve.add(backendNodeId);
        }
        this._resolveBackendNodeIds(idsToResolve, onBackendNodeIdsResolved.bind(this));

        /**
         * @this {WebInspector.AgentLayerTree}
         */
        function onBackendNodeIdsResolved()
        {
            this._innerSetLayers(payload);
            callback();
        }
    },

    /**
     * @param {?Array.<!LayerTreeAgent.Layer>} layers
     */
    _innerSetLayers: function(layers)
    {
        this._reset();
        // Payload will be null when not in the composited mode.
        if (!layers)
            return;
        var oldLayersById = this._layersById;
        this._layersById = {};
        for (var i = 0; i < layers.length; ++i) {
            var layerId = layers[i].layerId;
            var layer = oldLayersById[layerId];
            if (layer)
                layer._reset(layers[i]);
            else
                layer = new WebInspector.AgentLayer(this._target, layers[i]);
            this._layersById[layerId] = layer;
            var backendNodeId = layers[i].backendNodeId;
            if (backendNodeId)
                layer._setNode(this._backendNodeIdToNode.get(backendNodeId));
            if (!this._contentRoot && layer.drawsContent())
                this._contentRoot = layer;
            var parentId = layer.parentId();
            if (parentId) {
                var parent = this._layersById[parentId];
                if (!parent)
                    console.assert(parent, "missing parent " + parentId + " for layer " + layerId);
                parent.addChild(layer);
            } else {
                if (this._root)
                    console.assert(false, "Multiple root layers");
                this._root = layer;
            }
        }
        if (this._root)
            this._root._calculateQuad(new WebKitCSSMatrix());
    },

    __proto__: WebInspector.LayerTreeBase.prototype
}

/**
 * @interface
 */
WebInspector.Layer = function()
{
}

WebInspector.Layer.prototype = {
    /**
     * @return {string}
     */
    id: function() { },

    /**
     * @return {?string}
     */
    parentId: function() { },

    /**
     * @return {?WebInspector.Layer}
     */
    parent: function() { },

    /**
     * @return {boolean}
     */
    isRoot: function() { },

    /**
     * @return {!Array.<!WebInspector.Layer>}
     */
    children: function() { },

    /**
     * @param {!WebInspector.Layer} child
     */
    addChild: function(child) { },

    /**
     * @return {?WebInspector.DOMNode}
     */
    node: function() { },

    /**
     * @return {?WebInspector.DOMNode}
     */
    nodeForSelfOrAncestor: function() { },

    /**
     * @return {number}
     */
    offsetX: function() { },

    /**
     * @return {number}
     */
    offsetY: function() { },

    /**
     * @return {number}
     */
    width: function() { },

    /**
     * @return {number}
     */
    height: function() { },

    /**
     * @return {?Array.<number>}
     */
    transform: function() { },

    /**
     * @return {!Array.<number>}
     */
    quad: function() { },

    /**
     * @return {!Array.<number>}
     */
    anchorPoint: function() { },

    /**
     * @return {boolean}
     */
    invisible: function() { },

    /**
     * @return {number}
     */
    paintCount: function() { },

    /**
     * @return {?DOMAgent.Rect}
     */
    lastPaintRect: function() { },

    /**
     * @return {!Array.<!LayerTreeAgent.ScrollRect>}
     */
    scrollRects: function() { },

    /**
     * @return {number}
     */
    gpuMemoryUsage: function() { },

    /**
     * @param {function(!Array.<string>)} callback
     */
    requestCompositingReasons: function(callback) { },

    /**
     * @return {boolean}
     */
    drawsContent: function() { }
}

/**
 * @constructor
 * @implements {WebInspector.Layer}
 * @param {?WebInspector.Target} target
 * @param {!LayerTreeAgent.Layer} layerPayload
 */
WebInspector.AgentLayer = function(target, layerPayload)
{
    this._target = target;
    this._reset(layerPayload);
}

WebInspector.AgentLayer.prototype = {
    /**
     * @override
     * @return {string}
     */
    id: function()
    {
        return this._layerPayload.layerId;
    },

    /**
     * @override
     * @return {?string}
     */
    parentId: function()
    {
        return this._layerPayload.parentLayerId;
    },

    /**
     * @override
     * @return {?WebInspector.Layer}
     */
    parent: function()
    {
        return this._parent;
    },

    /**
     * @override
     * @return {boolean}
     */
    isRoot: function()
    {
        return !this.parentId();
    },

    /**
     * @override
     * @return {!Array.<!WebInspector.Layer>}
     */
    children: function()
    {
        return this._children;
    },

    /**
     * @override
     * @param {!WebInspector.Layer} child
     */
    addChild: function(child)
    {
        if (child._parent)
            console.assert(false, "Child already has a parent");
        this._children.push(child);
        child._parent = this;
    },

    /**
     * @param {?WebInspector.DOMNode} node
     */
    _setNode: function(node)
    {
        this._node = node;
    },

    /**
     * @override
     * @return {?WebInspector.DOMNode}
     */
    node: function()
    {
        return this._node;
    },

    /**
     * @override
     * @return {?WebInspector.DOMNode}
     */
    nodeForSelfOrAncestor: function()
    {
        for (var layer = this; layer; layer = layer._parent) {
            if (layer._node)
                return layer._node;
        }
        return null;
    },

    /**
     * @override
     * @return {number}
     */
    offsetX: function()
    {
        return this._layerPayload.offsetX;
    },

    /**
     * @override
     * @return {number}
     */
    offsetY: function()
    {
        return this._layerPayload.offsetY;
    },

    /**
     * @override
     * @return {number}
     */
    width: function()
    {
        return this._layerPayload.width;
    },

    /**
     * @override
     * @return {number}
     */
    height: function()
    {
        return this._layerPayload.height;
    },

    /**
     * @override
     * @return {?Array.<number>}
     */
    transform: function()
    {
        return this._layerPayload.transform;
    },

    /**
     * @override
     * @return {!Array.<number>}
     */
    quad: function()
    {
        return this._quad;
    },

    /**
     * @override
     * @return {!Array.<number>}
     */
    anchorPoint: function()
    {
        return [
            this._layerPayload.anchorX || 0,
            this._layerPayload.anchorY || 0,
            this._layerPayload.anchorZ || 0,
        ];
    },

    /**
     * @override
     * @return {boolean}
     */
    invisible: function()
    {
        return this._layerPayload.invisible;
    },

    /**
     * @override
     * @return {number}
     */
    paintCount: function()
    {
        return this._paintCount || this._layerPayload.paintCount;
    },

    /**
     * @override
     * @return {?DOMAgent.Rect}
     */
    lastPaintRect: function()
    {
        return this._lastPaintRect;
    },

    /**
     * @override
     * @return {!Array.<!LayerTreeAgent.ScrollRect>}
     */
    scrollRects: function()
    {
        return this._scrollRects;
    },

    /**
     * @override
     * @param {function(!Array.<string>)} callback
     */
    requestCompositingReasons: function(callback)
    {
        if (!this._target) {
            callback([]);
            return;
        }

        var wrappedCallback = InspectorBackend.wrapClientCallback(callback, "LayerTreeAgent.reasonsForCompositingLayer(): ", undefined, []);
        this._target.layerTreeAgent().compositingReasons(this.id(), wrappedCallback);
    },

    /**
     * @override
     * @return {boolean}
     */
    drawsContent: function()
    {
        return this._layerPayload.drawsContent;
    },

    /**
     * @override
     * @return {number}
     */
    gpuMemoryUsage: function()
    {
        /**
         * @const
         */
        var bytesPerPixel = 4;
        return this.drawsContent() ? this.width() * this.height() * bytesPerPixel : 0;
    },

    /**
     * @param {function(!WebInspector.PaintProfilerSnapshot=)} callback
     */
    requestSnapshot: function(callback)
    {
        if (!this._target) {
            callback();
            return;
        }

        var wrappedCallback = InspectorBackend.wrapClientCallback(callback, "LayerTreeAgent.makeSnapshot(): ", WebInspector.PaintProfilerSnapshot.bind(null, this._target));
        this._target.layerTreeAgent().makeSnapshot(this.id(), wrappedCallback);
    },

    /**
     * @param {!DOMAgent.Rect} rect
     */
    _didPaint: function(rect)
    {
        this._lastPaintRect = rect;
        this._paintCount = this.paintCount() + 1;
        this._image = null;
    },

    /**
     * @param {!LayerTreeAgent.Layer} layerPayload
     */
    _reset: function(layerPayload)
    {
        /** @type {?WebInspector.DOMNode} */
        this._node = null;
        this._children = [];
        this._parent = null;
        this._paintCount = 0;
        this._layerPayload = layerPayload;
        this._image = null;
        this._scrollRects = this._layerPayload.scrollRects || [];
    },

    /**
     * @param {!Array.<number>} a
     * @return {!CSSMatrix}
     */
    _matrixFromArray: function(a)
    {
        function toFixed9(x) { return x.toFixed(9); }
        return new WebKitCSSMatrix("matrix3d(" + a.map(toFixed9).join(",") + ")");
    },

    /**
     * @param {!CSSMatrix} parentTransform
     * @return {!CSSMatrix}
     */
    _calculateTransformToViewport: function(parentTransform)
    {
        var offsetMatrix = new WebKitCSSMatrix().translate(this._layerPayload.offsetX, this._layerPayload.offsetY);
        var matrix = offsetMatrix;

        if (this._layerPayload.transform) {
            var transformMatrix = this._matrixFromArray(this._layerPayload.transform);
            var anchorVector = new WebInspector.Geometry.Vector(this._layerPayload.width * this.anchorPoint()[0], this._layerPayload.height * this.anchorPoint()[1], this.anchorPoint()[2]);
            var anchorPoint = WebInspector.Geometry.multiplyVectorByMatrixAndNormalize(anchorVector, matrix);
            var anchorMatrix = new WebKitCSSMatrix().translate(-anchorPoint.x, -anchorPoint.y, -anchorPoint.z);
            matrix = anchorMatrix.inverse().multiply(transformMatrix.multiply(anchorMatrix.multiply(matrix)));
        }

        matrix = parentTransform.multiply(matrix);
        return matrix;
    },

    /**
     * @param {number} width
     * @param {number} height
     * @return {!Array.<number>}
     */
    _createVertexArrayForRect: function(width, height)
    {
        return [0, 0, 0, width, 0, 0, width, height, 0, 0, height, 0];
    },

    /**
     * @param {!CSSMatrix} parentTransform
     */
    _calculateQuad: function(parentTransform)
    {
        var matrix = this._calculateTransformToViewport(parentTransform);
        this._quad = [];
        var vertices = this._createVertexArrayForRect(this._layerPayload.width, this._layerPayload.height);
        for (var i = 0; i < 4; ++i) {
            var point = WebInspector.Geometry.multiplyVectorByMatrixAndNormalize(new WebInspector.Geometry.Vector(vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]), matrix);
            this._quad.push(point.x, point.y);
        }

        function calculateQuadForLayer(layer)
        {
            layer._calculateQuad(matrix);
        }

        this._children.forEach(calculateQuadForLayer);
    }
}

/**
 * @constructor
 * @param {!WebInspector.TracingLayerPayload} payload
 * @implements {WebInspector.Layer}
 */
WebInspector.TracingLayer = function(payload)
{
    this._reset(payload);
}

WebInspector.TracingLayer.prototype = {
    /**
     * @param {!WebInspector.TracingLayerPayload} payload
     */
    _reset: function(payload)
    {
        /** @type {?WebInspector.DOMNode} */
        this._node = null;
        this._layerId = String(payload.layer_id);
        this._offsetX = payload.position[0];
        this._offsetY = payload.position[1];
        this._width = payload.bounds.width;
        this._height = payload.bounds.height;
        this._children = [];
        this._parentLayerId = null;
        this._parent = null;
        this._quad = payload.layer_quad || [];
        this._createScrollRects(payload);
        this._compositingReasons = payload.compositing_reasons || [];
        this._drawsContent = !!payload.draws_content;
        this._gpuMemoryUsage = payload.gpu_memory_usage;
    },

    /**
     * @override
     * @return {string}
     */
    id: function()
    {
        return this._layerId;
    },

    /**
     * @override
     * @return {?string}
     */
    parentId: function()
    {
        return this._parentLayerId;
    },

    /**
     * @override
     * @return {?WebInspector.Layer}
     */
    parent: function()
    {
        return this._parent;
    },

    /**
     * @override
     * @return {boolean}
     */
    isRoot: function()
    {
        return !this.parentId();
    },

    /**
     * @override
     * @return {!Array.<!WebInspector.Layer>}
     */
    children: function()
    {
        return this._children;
    },

    /**
     * @override
     * @param {!WebInspector.Layer} child
     */
    addChild: function(child)
    {
        if (child._parent)
            console.assert(false, "Child already has a parent");
        this._children.push(child);
        child._parent = this;
        child._parentLayerId = this._layerId;
    },


    /**
     * @param {?WebInspector.DOMNode} node
     */
    _setNode: function(node)
    {
        this._node = node;
    },

    /**
     * @override
     * @return {?WebInspector.DOMNode}
     */
    node: function()
    {
        return this._node;
    },

    /**
     * @override
     * @return {?WebInspector.DOMNode}
     */
    nodeForSelfOrAncestor: function()
    {
        for (var layer = this; layer; layer = layer._parent) {
            if (layer._node)
                return layer._node;
        }
        return null;
    },

    /**
     * @override
     * @return {number}
     */
    offsetX: function()
    {
        return this._offsetX;
    },

    /**
     * @override
     * @return {number}
     */
    offsetY: function()
    {
        return this._offsetY;
    },

    /**
     * @override
     * @return {number}
     */
    width: function()
    {
        return this._width;
    },

    /**
     * @override
     * @return {number}
     */
    height: function()
    {
        return this._height;
    },

    /**
     * @override
     * @return {?Array.<number>}
     */
    transform: function()
    {
        return null;
    },

    /**
     * @override
     * @return {!Array.<number>}
     */
    quad: function()
    {
        return this._quad;
    },

    /**
     * @override
     * @return {!Array.<number>}
     */
    anchorPoint: function()
    {
        return [0.5, 0.5, 0];
    },

    /**
     * @override
     * @return {boolean}
     */
    invisible: function()
    {
        return false;
    },

    /**
     * @override
     * @return {number}
     */
    paintCount: function()
    {
        return 0;
    },

    /**
     * @override
     * @return {?DOMAgent.Rect}
     */
    lastPaintRect: function()
    {
        return null;
    },

    /**
     * @override
     * @return {!Array.<!LayerTreeAgent.ScrollRect>}
     */
    scrollRects: function()
    {
        return this._scrollRects;
    },

    /**
     * @override
     * @return {number}
     */
    gpuMemoryUsage: function()
    {
        return this._gpuMemoryUsage;
    },

    /**
     * @param {!Array.<number>} params
     * @param {string} type
     * @return {!Object}
     */
    _scrollRectsFromParams: function(params, type)
    {
        return {rect: {x: params[0], y: params[1], width: params[2], height: params[3]}, type: type};
    },

    /**
     * @param {!WebInspector.TracingLayerPayload} payload
     */
    _createScrollRects: function(payload)
    {
        this._scrollRects = [];
        if (payload.non_fast_scrollable_region)
            this._scrollRects.push(this._scrollRectsFromParams(payload.non_fast_scrollable_region, WebInspector.LayerTreeModel.ScrollRectType.NonFastScrollable.name));
        if (payload.touch_event_handler_region)
            this._scrollRects.push(this._scrollRectsFromParams(payload.touch_event_handler_region, WebInspector.LayerTreeModel.ScrollRectType.TouchEventHandler.name));
        if (payload.wheel_event_handler_region)
            this._scrollRects.push(this._scrollRectsFromParams(payload.wheel_event_handler_region, WebInspector.LayerTreeModel.ScrollRectType.WheelEventHandler.name));
        if (payload.scroll_event_handler_region)
            this._scrollRects.push(this._scrollRectsFromParams(payload.scroll_event_handler_region, WebInspector.LayerTreeModel.ScrollRectType.RepaintsOnScroll.name));
    },

    /**
     * @override
     * @param {function(!Array.<string>)} callback
     */
    requestCompositingReasons: function(callback)
    {
        callback(this._compositingReasons);
    },

    /**
     * @override
     * @return {boolean}
     */
    drawsContent: function()
    {
        return this._drawsContent;
    }
}

/**
 * @constructor
 * @param {?WebInspector.Target} target
 */
WebInspector.DeferredLayerTree = function(target)
{
    this._target = target;
}

WebInspector.DeferredLayerTree.prototype = {
    /**
     * @param {function(!WebInspector.LayerTreeBase)} callback
     */
    resolve: function(callback) { },

    /**
     * @return {?WebInspector.Target}
     */
    target: function()
    {
        return this._target;
    }
};

/**
 * @constructor
 * @implements {LayerTreeAgent.Dispatcher}
 * @param {!WebInspector.LayerTreeModel} layerTreeModel
 */
WebInspector.LayerTreeDispatcher = function(layerTreeModel)
{
    this._layerTreeModel = layerTreeModel;
}

WebInspector.LayerTreeDispatcher.prototype = {
    /**
     * @override
     * @param {!Array.<!LayerTreeAgent.Layer>=} layers
     */
    layerTreeDidChange: function(layers)
    {
        this._layerTreeModel._layerTreeChanged(layers || null);
    },

    /**
     * @override
     * @param {!LayerTreeAgent.LayerId} layerId
     * @param {!DOMAgent.Rect} clipRect
     */
    layerPainted: function(layerId, clipRect)
    {
        this._layerTreeModel._layerPainted(layerId, clipRect);
    }
}

/**
 * @param {!WebInspector.Target} target
 * @return {?WebInspector.LayerTreeModel}
 */
WebInspector.LayerTreeModel.fromTarget = function(target)
{
    if (!target.hasDOMCapability())
        return null;

    var model = /** @type {?WebInspector.LayerTreeModel} */ (target.model(WebInspector.LayerTreeModel));
    if (!model)
        model = new WebInspector.LayerTreeModel(target);
    return model;
}

},{}],228:[function(require,module,exports){
/*
 * Copyright (C) 2013 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {function(!WebInspector.TracingModel.Event):string} categoryMapper
 */
WebInspector.TimelineFrameModel = function(categoryMapper)
{
    this._categoryMapper = categoryMapper;
    this.reset();
}

WebInspector.TimelineFrameModel._mainFrameMarkers = [
    WebInspector.TimelineModel.RecordType.ScheduleStyleRecalculation,
    WebInspector.TimelineModel.RecordType.InvalidateLayout,
    WebInspector.TimelineModel.RecordType.BeginMainThreadFrame,
    WebInspector.TimelineModel.RecordType.ScrollLayer
];

WebInspector.TimelineFrameModel.prototype = {
    /**
     * @return {!Array.<!WebInspector.TimelineFrame>}
     */
    frames: function()
    {
        return this._frames;
    },

    /**
     * @param {number} startTime
     * @param {number} endTime
     * @return {!Array.<!WebInspector.TimelineFrame>}
     */
    filteredFrames: function(startTime, endTime)
    {
        /**
         * @param {number} value
         * @param {!WebInspector.TimelineFrame} object
         * @return {number}
         */
        function compareStartTime(value, object)
        {
            return value - object.startTime;
        }
        /**
         * @param {number} value
         * @param {!WebInspector.TimelineFrame} object
         * @return {number}
         */
        function compareEndTime(value, object)
        {
            return value - object.endTime;
        }
        var frames = this._frames;
        var firstFrame = frames.lowerBound(startTime, compareEndTime);
        var lastFrame = frames.lowerBound(endTime, compareStartTime);
        return frames.slice(firstFrame, lastFrame);
    },

    /**
     * @param {!WebInspector.TracingModel.Event} rasterTask
     * @return {boolean}
     */
    hasRasterTile: function(rasterTask)
    {
        var data = rasterTask.args["tileData"];
        if (!data)
            return false;
        var frameId = data["sourceFrameNumber"];
        var frame = frameId && this._frameById[frameId];
        if (!frame || !frame.layerTree)
            return false;
        return true;
    },

    /**
     * @param {!WebInspector.TracingModel.Event} rasterTask
     * @param {function(?DOMAgent.Rect, ?WebInspector.PaintProfilerSnapshot)} callback
     */
    requestRasterTile: function(rasterTask, callback)
    {
        var target = this._target;
        if (!target) {
            callback(null, null);
            return;
        }
        var data = rasterTask.args["tileData"];
        var frameId = data["sourceFrameNumber"];
        var frame = frameId && this._frameById[frameId];
        if (!frame || !frame.layerTree) {
            callback(null, null);
            return;
        }

        var tileId = data["tileId"] && data["tileId"]["id_ref"];
        /** @type {!Array.<!WebInspector.PictureFragment>}> */
        var fragments = [];
        /** @type {?WebInspector.TracingLayerTile} */
        var tile = null;
        var x0 = Infinity;
        var y0 = Infinity;

        frame.layerTree.resolve(layerTreeResolved);
        /**
         * @param {!WebInspector.LayerTreeBase} layerTree
         */
        function layerTreeResolved(layerTree)
        {
            tile = tileId && (/** @type {!WebInspector.TracingLayerTree} */ (layerTree)).tileById("cc::Tile/" + tileId);
            if (!tile) {
                console.error("Tile " + tileId + " missing in frame " + frameId);
                callback(null, null);
                return;
            }
            var fetchPictureFragmentsBarrier = new CallbackBarrier();
            for (var paint of frame.paints) {
                if (tile.layer_id === paint.layerId())
                    paint.loadPicture(fetchPictureFragmentsBarrier.createCallback(pictureLoaded));
            }
            fetchPictureFragmentsBarrier.callWhenDone(allPicturesLoaded);
        }

        /**
         * @param {number} a1
         * @param {number} a2
         * @param {number} b1
         * @param {number} b2
         * @return {boolean}
         */
        function segmentsOverlap(a1, a2, b1, b2)
        {
            console.assert(a1 <= a2 && b1 <= b2, "segments should be specified as ordered pairs");
            return a2 > b1 && a1 < b2;
        }
        /**
         * @param {!Array.<number>} a
         * @param {!Array.<number>} b
         * @return {boolean}
         */
        function rectsOverlap(a, b)
        {
            return segmentsOverlap(a[0], a[0] + a[2], b[0], b[0] + b[2]) && segmentsOverlap(a[1], a[1] + a[3], b[1], b[1] + b[3]);
        }

        /**
         * @param {?Array.<number>} rect
         * @param {?string} picture
         */
        function pictureLoaded(rect, picture)
        {
            if (!rect || !picture)
                return;
            if (!rectsOverlap(rect, tile.content_rect))
                return;
            var x = rect[0];
            var y = rect[1];
            x0 = Math.min(x0, x);
            y0 = Math.min(y0, y);
            fragments.push({x: x, y: y, picture: picture});
        }

        function allPicturesLoaded()
        {
            if (!fragments.length) {
                callback(null, null);
                return;
            }
            var rectArray = tile.content_rect;
            // Rect is in layer content coordinates, make it relative to picture by offsetting to the top left corner.
            var rect = {x: rectArray[0] - x0, y: rectArray[1] - y0, width: rectArray[2], height: rectArray[3]};
            WebInspector.PaintProfilerSnapshot.loadFromFragments(target, fragments, callback.bind(null, rect));
        }
    },

    reset: function()
    {
        this._minimumRecordTime = Infinity;
        this._frames = [];
        this._frameById = {};
        this._lastFrame = null;
        this._lastLayerTree = null;
        this._mainFrameCommitted = false;
        this._mainFrameRequested = false;
        this._framePendingCommit = null;
        this._lastBeginFrame = null;
        this._lastNeedsBeginFrame = null;
        this._framePendingActivation = null;
        this._lastTaskBeginTime = null;
        this._target = null;
        this._sessionId = null;
        this._currentTaskTimeByCategory = {};
    },

    /**
     * @param {number} startTime
     */
    handleBeginFrame: function(startTime)
    {
        if (!this._lastFrame)
            this._startFrame(startTime);
        this._lastBeginFrame = startTime;
    },

    /**
     * @param {number} startTime
     */
    handleDrawFrame: function(startTime)
    {
        if (!this._lastFrame) {
            this._startFrame(startTime);
            return;
        }

        // - if it wasn't drawn, it didn't happen!
        // - only show frames that either did not wait for the main thread frame or had one committed.
        if (this._mainFrameCommitted || !this._mainFrameRequested) {
            if (this._lastNeedsBeginFrame) {
                var idleTimeEnd = this._framePendingActivation ? this._framePendingActivation.triggerTime : (this._lastBeginFrame || this._lastNeedsBeginFrame);
                if (idleTimeEnd > this._lastFrame.startTime) {
                    this._lastFrame.idle = true;
                    this._startFrame(idleTimeEnd);
                    if (this._framePendingActivation)
                        this._commitPendingFrame();
                    this._lastBeginFrame = null;
                }
                this._lastNeedsBeginFrame = null;
            }
            this._startFrame(startTime);
        }
        this._mainFrameCommitted = false;
    },

    handleActivateLayerTree: function()
    {
        if (!this._lastFrame)
            return;
        if (this._framePendingActivation && !this._lastNeedsBeginFrame)
            this._commitPendingFrame();
    },

    handleRequestMainThreadFrame: function()
    {
        if (!this._lastFrame)
            return;
        this._mainFrameRequested = true;
    },

    handleCompositeLayers: function()
    {
        if (!this._framePendingCommit)
            return;
        this._framePendingActivation = this._framePendingCommit;
        this._framePendingCommit = null;
        this._mainFrameRequested = false;
        this._mainFrameCommitted = true;
    },

    /**
     * @param {!WebInspector.DeferredLayerTree} layerTree
     */
    handleLayerTreeSnapshot: function(layerTree)
    {
        this._lastLayerTree = layerTree;
    },

    /**
     * @param {number} startTime
     * @param {boolean} needsBeginFrame
     */
    handleNeedFrameChanged: function(startTime, needsBeginFrame)
    {
        if (needsBeginFrame)
            this._lastNeedsBeginFrame = startTime;
    },

    /**
     * @param {number} startTime
     */
    _startFrame: function(startTime)
    {
        if (this._lastFrame)
            this._flushFrame(this._lastFrame, startTime);
        this._lastFrame = new WebInspector.TimelineFrame(startTime, startTime - this._minimumRecordTime);
    },

    /**
     * @param {!WebInspector.TimelineFrame} frame
     * @param {number} endTime
     */
    _flushFrame: function(frame, endTime)
    {
        frame._setLayerTree(this._lastLayerTree);
        frame._setEndTime(endTime);
        if (this._frames.length && (frame.startTime !== this._frames.peekLast().endTime || frame.startTime > frame.endTime))
            console.assert(false, `Inconsistent frame time for frame ${this._frames.length} (${frame.startTime} - ${frame.endTime})`);
        this._frames.push(frame);
        if (typeof frame._mainFrameId === "number")
            this._frameById[frame._mainFrameId] = frame;
    },

    _commitPendingFrame: function()
    {
        this._lastFrame._addTimeForCategories(this._framePendingActivation.timeByCategory);
        this._lastFrame.paints = this._framePendingActivation.paints;
        this._lastFrame._mainFrameId = this._framePendingActivation.mainFrameId;
        this._framePendingActivation = null;
    },

    /**
     * @param {!Array.<string>} types
     * @param {!WebInspector.TimelineModel.Record} record
     * @return {?WebInspector.TimelineModel.Record} record
     */
    _findRecordRecursively: function(types, record)
    {
        if (types.indexOf(record.type()) >= 0)
            return record;
        if (!record.children())
            return null;
        for (var i = 0; i < record.children().length; ++i) {
            var result = this._findRecordRecursively(types, record.children()[i]);
            if (result)
                return result;
        }
        return null;
    },

    /**
     * @param {?WebInspector.Target} target
     * @param {!Array.<!WebInspector.TracingModel.Event>} events
     * @param {string} sessionId
     */
    addTraceEvents: function(target, events, sessionId)
    {
        this._target = target;
        this._sessionId = sessionId;
        if (!events.length)
            return;
        if (events[0].startTime < this._minimumRecordTime)
            this._minimumRecordTime = events[0].startTime;
        for (var i = 0; i < events.length; ++i)
            this._addTraceEvent(events[i]);
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addTraceEvent: function(event)
    {
        var eventNames = WebInspector.TimelineModel.RecordType;

        if (event.name === eventNames.SetLayerTreeId) {
            var sessionId = event.args["sessionId"] || event.args["data"]["sessionId"];
            if (this._sessionId === sessionId)
                this._layerTreeId = event.args["layerTreeId"] || event.args["data"]["layerTreeId"];
        } else if (event.name === eventNames.TracingStartedInPage) {
            this._mainThread = event.thread;
        } else if (event.phase === WebInspector.TracingModel.Phase.SnapshotObject && event.name === eventNames.LayerTreeHostImplSnapshot && parseInt(event.id, 0) === this._layerTreeId) {
            var snapshot = /** @type {!WebInspector.TracingModel.ObjectSnapshot} */ (event);
            this.handleLayerTreeSnapshot(new WebInspector.DeferredTracingLayerTree(snapshot, this._target));
        } else {
            this._processCompositorEvents(event);
            if (event.thread === this._mainThread)
                this._addMainThreadTraceEvent(event);
            else if (this._lastFrame && event.selfTime && !WebInspector.TracingModel.isTopLevelEvent(event))
                this._lastFrame._addTimeForCategory(this._categoryMapper(event), event.selfTime);
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _processCompositorEvents: function(event)
    {
        var eventNames = WebInspector.TimelineModel.RecordType;

        if (event.args["layerTreeId"] !== this._layerTreeId)
            return;

        var timestamp = event.startTime;
        if (event.name === eventNames.BeginFrame)
            this.handleBeginFrame(timestamp);
        else if (event.name === eventNames.DrawFrame)
            this.handleDrawFrame(timestamp);
        else if (event.name === eventNames.ActivateLayerTree)
            this.handleActivateLayerTree();
        else if (event.name === eventNames.RequestMainThreadFrame)
            this.handleRequestMainThreadFrame();
        else if (event.name === eventNames.NeedsBeginFrameChanged)
            this.handleNeedFrameChanged(timestamp, event.args["data"] && event.args["data"]["needsBeginFrame"]);
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addMainThreadTraceEvent: function(event)
    {
        var eventNames = WebInspector.TimelineModel.RecordType;
        var timestamp = event.startTime;
        var selfTime = event.selfTime || 0;

        if (WebInspector.TracingModel.isTopLevelEvent(event)) {
            this._currentTaskTimeByCategory = {};
            this._lastTaskBeginTime = event.startTime;
        }
        if (!this._framePendingCommit && WebInspector.TimelineFrameModel._mainFrameMarkers.indexOf(event.name) >= 0)
            this._framePendingCommit = new WebInspector.PendingFrame(this._lastTaskBeginTime || event.startTime, this._currentTaskTimeByCategory);
        if (!this._framePendingCommit) {
            this._addTimeForCategory(this._currentTaskTimeByCategory, event);
            return;
        }
        this._addTimeForCategory(this._framePendingCommit.timeByCategory, event);

        if (event.name === eventNames.BeginMainThreadFrame && event.args["data"] && event.args["data"]["frameId"])
            this._framePendingCommit.mainFrameId = event.args["data"]["frameId"];
        if (event.name === eventNames.Paint && event.args["data"]["layerId"] && event.picture && this._target)
            this._framePendingCommit.paints.push(new WebInspector.LayerPaintEvent(event, this._target));
        if (event.name === eventNames.CompositeLayers && event.args["layerTreeId"] === this._layerTreeId)
            this.handleCompositeLayers();
    },

    /**
     * @param {!Object.<string, number>} timeByCategory
     * @param {!WebInspector.TracingModel.Event} event
     */
    _addTimeForCategory: function(timeByCategory, event)
    {
        if (!event.selfTime)
            return;
        var categoryName = this._categoryMapper(event);
        timeByCategory[categoryName] = (timeByCategory[categoryName] || 0) + event.selfTime;
    },
}

/**
 * @constructor
 * @extends {WebInspector.DeferredLayerTree}
 * @param {!WebInspector.TracingModel.ObjectSnapshot} snapshot
 * @param {?WebInspector.Target} target
 */
WebInspector.DeferredTracingLayerTree = function(snapshot, target)
{
    WebInspector.DeferredLayerTree.call(this, target);
    this._snapshot = snapshot;
}

WebInspector.DeferredTracingLayerTree.prototype = {
    /**
     * @override
     * @param {function(!WebInspector.LayerTreeBase)} callback
     */
    resolve: function(callback)
    {
        this._snapshot.requestObject(onGotObject.bind(this));
        /**
         * @this {WebInspector.DeferredTracingLayerTree}
         * @param {?Object} result
         */
        function onGotObject(result)
        {
            if (!result)
                return;
            var viewport = result["device_viewport_size"];
            var tiles = result["active_tiles"];
            var rootLayer = result["active_tree"]["root_layer"];
            var layers = result["active_tree"]["layers"];
            var layerTree = new WebInspector.TracingLayerTree(this._target);
            layerTree.setViewportSize(viewport);
            layerTree.setTiles(tiles);
            layerTree.setLayers(rootLayer, layers, callback.bind(null, layerTree));
        }
    },

    __proto__: WebInspector.DeferredLayerTree.prototype
};


/**
 * @constructor
 * @param {number} startTime
 * @param {number} startTimeOffset
 */
WebInspector.TimelineFrame = function(startTime, startTimeOffset)
{
    this.startTime = startTime;
    this.startTimeOffset = startTimeOffset;
    this.endTime = this.startTime;
    this.duration = 0;
    this.timeByCategory = {};
    this.cpuTime = 0;
    this.idle = false;
    /** @type {?WebInspector.DeferredLayerTree} */
    this.layerTree = null;
    /** @type {!Array.<!WebInspector.LayerPaintEvent>} */
    this.paints = [];
    /** @type {number|undefined} */
    this._mainFrameId = undefined;
}

WebInspector.TimelineFrame.prototype = {
    /**
     * @return {boolean}
     */
    hasWarnings: function()
    {
        var /** @const */ longFrameDurationThresholdMs = 22;
        return !this.idle && this.duration > longFrameDurationThresholdMs;
    },

    /**
     * @param {number} endTime
     */
    _setEndTime: function(endTime)
    {
        this.endTime = endTime;
        this.duration = this.endTime - this.startTime;
    },

    /**
     * @param {?WebInspector.DeferredLayerTree} layerTree
     */
    _setLayerTree: function(layerTree)
    {
        this.layerTree = layerTree;
    },

    /**
     * @param {!Object} timeByCategory
     */
    _addTimeForCategories: function(timeByCategory)
    {
        for (var category in timeByCategory)
            this._addTimeForCategory(category, timeByCategory[category]);
    },

    /**
     * @param {string} category
     * @param {number} time
     */
    _addTimeForCategory: function(category, time)
    {
        this.timeByCategory[category] = (this.timeByCategory[category] || 0) + time;
        this.cpuTime += time;
    },
}

/**
 * @constructor
 * @param {!WebInspector.TracingModel.Event} event
 * @param {?WebInspector.Target} target
 */
WebInspector.LayerPaintEvent = function(event, target)
{
    this._event = event;
    this._target = target;
}

WebInspector.LayerPaintEvent.prototype = {
    /**
     * @return {string}
     */
    layerId: function()
    {
        return this._event.args["data"]["layerId"];
    },

    /**
     * @return {!WebInspector.TracingModel.Event}
     */
    event: function()
    {
        return this._event;
    },

    /**
     * @param {function(?Array.<number>, ?string)} callback
     */
    loadPicture: function(callback)
    {
        this._event.picture.requestObject(onGotObject);
        /**
         * @param {?Object} result
         */
        function onGotObject(result)
        {
            if (!result || !result["skp64"]) {
                callback(null, null);
                return;
            }
            var rect = result["params"] && result["params"]["layer_rect"];
            callback(rect, result["skp64"]);
        }
    },

    /**
     * @param {function(?Array.<number>, ?WebInspector.PaintProfilerSnapshot)} callback
     */
    loadSnapshot: function(callback)
    {
        this.loadPicture(onGotPicture.bind(this));
        /**
         * @param {?Array.<number>} rect
         * @param {?string} picture
         * @this {WebInspector.LayerPaintEvent}
         */
        function onGotPicture(rect, picture)
        {
            if (!rect || !picture || !this._target) {
                callback(null, null);
                return;
            }
            WebInspector.PaintProfilerSnapshot.load(this._target, picture, callback.bind(null, rect));
        }
    }
};

/**
 * @constructor
 * @param {number} triggerTime
 * @param {!Object.<string, number>} timeByCategory
 */
WebInspector.PendingFrame = function(triggerTime, timeByCategory)
{
    /** @type {!Object.<string, number>} */
    this.timeByCategory = timeByCategory;
    /** @type {!Array.<!WebInspector.LayerPaintEvent>} */
    this.paints = [];
    /** @type {number|undefined} */
    this.mainFrameId = undefined;
    this.triggerTime = triggerTime;
}

},{}],229:[function(require,module,exports){
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 */
WebInspector.TimelineIRModel = function()
{
    this.reset();
}

/**
 * @enum {string}
 */
WebInspector.TimelineIRModel.Phases = {
    Idle: "Idle",
    Response: "Response",
    Scroll: "Scroll",
    Fling: "Fling",
    Drag: "Drag",
    Animation: "Animation",
    Uncategorized: "Uncategorized"
};

/**
 * @enum {string}
 */
WebInspector.TimelineIRModel.InputEvents = {
    Char: "Char",
    Click: "GestureClick",
    ContextMenu: "ContextMenu",
    FlingCancel: "GestureFlingCancel",
    FlingStart: "GestureFlingStart",
    ImplSideFling: WebInspector.TimelineModel.RecordType.ImplSideFling,
    KeyDown: "KeyDown",
    KeyDownRaw: "RawKeyDown",
    KeyUp: "KeyUp",
    LatencyScrollUpdate: "ScrollUpdate",
    MouseDown: "MouseDown",
    MouseMove: "MouseMove",
    MouseUp: "MouseUp",
    MouseWheel: "MouseWheel",
    PinchBegin: "GesturePinchBegin",
    PinchEnd: "GesturePinchEnd",
    PinchUpdate: "GesturePinchUpdate",
    ScrollBegin: "GestureScrollBegin",
    ScrollEnd: "GestureScrollEnd",
    ScrollUpdate: "GestureScrollUpdate",
    ScrollUpdateRenderer: "ScrollUpdate",
    ShowPress: "GestureShowPress",
    Tap: "GestureTap",
    TapCancel: "GestureTapCancel",
    TapDown: "GestureTapDown",
    TouchCancel: "TouchCancel",
    TouchEnd: "TouchEnd",
    TouchMove: "TouchMove",
    TouchStart: "TouchStart"
};

WebInspector.TimelineIRModel._mergeThresholdsMs = {
    animation: 1,
    mouse: 40,
};

WebInspector.TimelineIRModel._eventIRPhase = Symbol("eventIRPhase");

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {!WebInspector.TimelineIRModel.Phases}
 */
WebInspector.TimelineIRModel.phaseForEvent = function(event)
{
    return event[WebInspector.TimelineIRModel._eventIRPhase];
}

WebInspector.TimelineIRModel.prototype = {
    /**
     * @param {?Array<!WebInspector.TracingModel.AsyncEvent>} inputLatencies
     * @param {?Array<!WebInspector.TracingModel.AsyncEvent>} animations
     */
    populate: function(inputLatencies, animations)
    {
        var eventTypes = WebInspector.TimelineIRModel.InputEvents;
        var phases = WebInspector.TimelineIRModel.Phases;

        this.reset();
        if (!inputLatencies)
            return;
        this._processInputLatencies(inputLatencies);
        if (animations)
            this._processAnimations(animations);
        var range = new WebInspector.SegmentedRange();
        range.appendRange(this._drags); // Drags take lower precedence than animation, as we can't detect them reliably.
        range.appendRange(this._cssAnimations);
        range.appendRange(this._scrolls);
        range.appendRange(this._responses);
        this._segments = range.segments();
    },

    /**
     * @param {!Array<!WebInspector.TracingModel.AsyncEvent>} events
     */
    _processInputLatencies: function(events)
    {
        var eventTypes = WebInspector.TimelineIRModel.InputEvents;
        var phases = WebInspector.TimelineIRModel.Phases;
        var thresholdsMs = WebInspector.TimelineIRModel._mergeThresholdsMs;

        var scrollStart;
        var flingStart;
        var touchStart;
        var firstTouchMove;
        var mouseWheel;
        var mouseDown;
        var mouseMove;

        for (var i = 0; i < events.length; ++i) {
            var event = events[i];
            if (i > 0 && events[i].startTime < events[i - 1].startTime)
                console.assert(false, "Unordered input events");
            var type = this._inputEventType(event.name);
            switch (type) {

            case eventTypes.ScrollBegin:
                this._scrolls.append(this._segmentForEvent(event, phases.Scroll));
                scrollStart = event;
                break;

            case eventTypes.ScrollEnd:
                if (scrollStart)
                    this._scrolls.append(this._segmentForEventRange(scrollStart, event, phases.Scroll));
                else
                    this._scrolls.append(this._segmentForEvent(event, phases.Scroll));
                scrollStart = null;
                break;

            case eventTypes.ScrollUpdate:
                touchStart = null; // Since we're scrolling now, disregard other touch gestures.
                this._scrolls.append(this._segmentForEvent(event, phases.Scroll));
                break;

            case eventTypes.FlingStart:
                if (flingStart) {
                    WebInspector.console.error(WebInspector.UIString("Two flings at the same time? %s vs %s", flingStart.startTime, event.startTime));
                    break;
                }
                flingStart = event;
                break;

            case eventTypes.FlingCancel:
                // FIXME: also process renderer fling events.
                if (!flingStart)
                    break;
                this._scrolls.append(this._segmentForEventRange(flingStart, event, phases.Fling));
                flingStart = null;
                break;

            case eventTypes.ImplSideFling:
                this._scrolls.append(this._segmentForEvent(event, phases.Fling));
                break;

            case eventTypes.ShowPress:
            case eventTypes.Tap:
            case eventTypes.KeyDown:
            case eventTypes.KeyDownRaw:
            case eventTypes.KeyUp:
            case eventTypes.Char:
            case eventTypes.Click:
            case eventTypes.ContextMenu:
                this._responses.append(this._segmentForEvent(event, phases.Response));
                break;

            case eventTypes.TouchStart:
                // We do not produce any response segment for TouchStart -- there's either going to be one upon
                // TouchMove for drag, or one for GestureTap.
                if (touchStart) {
                    WebInspector.console.error(WebInspector.UIString("Two touches at the same time? %s vs %s", touchStart.startTime, event.startTime));
                    break;
                }
                touchStart = event;
                event.steps[0][WebInspector.TimelineIRModel._eventIRPhase] = phases.Response;
                firstTouchMove = null;
                break;

            case eventTypes.TouchCancel:
                touchStart = null;
                break;

            case eventTypes.TouchMove:
                if (firstTouchMove) {
                    this._drags.append(this._segmentForEvent(event, phases.Drag));
                } else if (touchStart) {
                    firstTouchMove = event;
                    this._responses.append(this._segmentForEventRange(touchStart, event, phases.Response));
                }
                break;

            case eventTypes.TouchEnd:
                touchStart = null;
                break;

            case eventTypes.MouseDown:
                mouseDown = event;
                mouseMove = null;
                break;

            case eventTypes.MouseMove:
                if (mouseDown && !mouseMove && mouseDown.startTime + thresholdsMs.mouse > event.startTime) {
                    this._responses.append(this._segmentForEvent(mouseDown, phases.Response));
                    this._responses.append(this._segmentForEvent(event, phases.Response));
                } else if (mouseDown) {
                    this._drags.append(this._segmentForEvent(event, phases.Drag));
                }
                mouseMove = event;
                break;

            case eventTypes.MouseUp:
                this._responses.append(this._segmentForEvent(event, phases.Response));
                mouseDown = null;
                break;

            case eventTypes.MouseWheel:
                // Do not consider first MouseWheel as trace viewer's implementation does -- in case of MouseWheel it's not really special.
                if (mouseWheel && canMerge(thresholdsMs.mouse, mouseWheel, event))
                    this._scrolls.append(this._segmentForEventRange(mouseWheel, event, phases.Scroll));
                else
                    this._scrolls.append(this._segmentForEvent(event, phases.Scroll));
                mouseWheel = event;
                break;
            }
        }

        /**
         * @param {number} threshold
         * @param {!WebInspector.TracingModel.AsyncEvent} first
         * @param {!WebInspector.TracingModel.AsyncEvent} second
         * @return {boolean}
         */
        function canMerge(threshold, first, second)
        {
            return first.endTime < second.startTime && second.startTime < first.endTime + threshold;
        }
    },

    /**
     * @param {!Array<!WebInspector.TracingModel.AsyncEvent>} events
     */
    _processAnimations: function(events)
    {
        for (var i = 0; i < events.length; ++i)
            this._cssAnimations.append(this._segmentForEvent(events[i], WebInspector.TimelineIRModel.Phases.Animation));
    },

    /**
     * @param {!WebInspector.TracingModel.AsyncEvent} event
     * @param {!WebInspector.TimelineIRModel.Phases} phase
     * @return {!WebInspector.Segment}
     */
    _segmentForEvent: function(event, phase)
    {
        this._setPhaseForEvent(event, phase);
        return new WebInspector.Segment(event.startTime, event.endTime, phase);
    },

    /**
     * @param {!WebInspector.TracingModel.AsyncEvent} startEvent
     * @param {!WebInspector.TracingModel.AsyncEvent} endEvent
     * @param {!WebInspector.TimelineIRModel.Phases} phase
     * @return {!WebInspector.Segment}
     */
    _segmentForEventRange: function(startEvent, endEvent, phase)
    {
        this._setPhaseForEvent(startEvent, phase);
        this._setPhaseForEvent(endEvent, phase);
        return new WebInspector.Segment(startEvent.startTime, endEvent.endTime, phase);
    },

    /**
     * @param {!WebInspector.TracingModel.AsyncEvent} asyncEvent
     * @param {!WebInspector.TimelineIRModel.Phases} phase
     */
    _setPhaseForEvent: function(asyncEvent, phase)
    {
        asyncEvent.steps[0][WebInspector.TimelineIRModel._eventIRPhase] = phase;
    },

    /**
     * @return {!Array<!WebInspector.Segment>}
     */
    interactionRecords: function()
    {
        return this._segments;
    },

    reset: function()
    {
        var thresholdsMs = WebInspector.TimelineIRModel._mergeThresholdsMs;

        this._segments = [];
        this._drags = new WebInspector.SegmentedRange(merge.bind(null, thresholdsMs.mouse));
        this._cssAnimations = new WebInspector.SegmentedRange(merge.bind(null, thresholdsMs.animation));
        this._responses = new WebInspector.SegmentedRange(merge.bind(null, 0));
        this._scrolls = new WebInspector.SegmentedRange(merge.bind(null, thresholdsMs.animation));

        /**
         * @param {number} threshold
         * @param {!WebInspector.Segment} first
         * @param {!WebInspector.Segment} second
         */
        function merge(threshold, first, second)
        {
            return first.end + threshold >= second.begin && first.data === second.data ? first : null;
        }
    },

    /**
     * @param {string} eventName
     * @return {?WebInspector.TimelineIRModel.InputEvents}
     */
    _inputEventType: function(eventName)
    {
        var prefix = "InputLatency::";
        if (!eventName.startsWith(prefix)) {
            if (eventName === WebInspector.TimelineIRModel.InputEvents.ImplSideFling)
                return /** @type {!WebInspector.TimelineIRModel.InputEvents} */ (eventName);
            console.error("Unrecognized input latency event: " + eventName);
            return null;
        }
        return /** @type {!WebInspector.TimelineIRModel.InputEvents} */ (eventName.substr(prefix.length));
    }
};


},{}],230:[function(require,module,exports){
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


WebInspector.TimelineJSProfileProcessor = { };

/**
 * @param {!WebInspector.CPUProfileDataModel} jsProfileModel
 * @param {!WebInspector.TracingModel.Thread} thread
 * @return {!Array<!WebInspector.TracingModel.Event>}
 */
WebInspector.TimelineJSProfileProcessor.generateTracingEventsFromCpuProfile = function(jsProfileModel, thread)
{
    var idleNode = jsProfileModel.idleNode;
    var programNode = jsProfileModel.programNode;
    var gcNode = jsProfileModel.gcNode;
    var samples = jsProfileModel.samples;
    var timestamps = jsProfileModel.timestamps;
    var jsEvents = [];
    /** @type {!Map<!Object, !Array<!RuntimeAgent.CallFrame>>} */
    var nodeToStackMap = new Map();
    nodeToStackMap.set(programNode, []);
    for (var i = 0; i < samples.length; ++i) {
        var node = jsProfileModel.nodeByIndex(i);
        if (!node) {
            console.error(`Node with unknown id ${samples[i]} at index ${i}`);
            continue;
        }
        if (node === gcNode || node === idleNode)
            continue;
        var callFrames = nodeToStackMap.get(node);
        if (!callFrames) {
            callFrames = /** @type {!Array<!RuntimeAgent.CallFrame>} */ (new Array(node.depth + 1));
            nodeToStackMap.set(node, callFrames);
            for (var j = 0; node.parent; node = node.parent)
                callFrames[j++] = /** @type {!RuntimeAgent.CallFrame} */ (node);
        }
        var jsSampleEvent = new WebInspector.TracingModel.Event(WebInspector.TracingModel.DevToolsTimelineEventCategory,
            WebInspector.TimelineModel.RecordType.JSSample,
            WebInspector.TracingModel.Phase.Instant, timestamps[i], thread);
        jsSampleEvent.args["data"] = { stackTrace: callFrames };
        jsEvents.push(jsSampleEvent);
    }
    return jsEvents;
}

/**
 * @param {!Array<!WebInspector.TracingModel.Event>} events
 * @return {!Array<!WebInspector.TracingModel.Event>}
 */
WebInspector.TimelineJSProfileProcessor.generateJSFrameEvents = function(events)
{
    /**
     * @param {!RuntimeAgent.CallFrame} frame1
     * @param {!RuntimeAgent.CallFrame} frame2
     * @return {boolean}
     */
    function equalFrames(frame1, frame2)
    {
        return frame1.scriptId === frame2.scriptId && frame1.functionName === frame2.functionName;
    }

    /**
     * @param {!WebInspector.TracingModel.Event} e
     * @return {number}
     */
    function eventEndTime(e)
    {
        return e.endTime || e.startTime;
    }

    /**
     * @param {!WebInspector.TracingModel.Event} e
     * @return {boolean}
     */
    function isJSInvocationEvent(e)
    {
        switch (e.name) {
        case WebInspector.TimelineModel.RecordType.RunMicrotasks:
        case WebInspector.TimelineModel.RecordType.FunctionCall:
        case WebInspector.TimelineModel.RecordType.EvaluateScript:
            return true;
        }
        return false;
    }

    var jsFrameEvents = [];
    var jsFramesStack = [];
    var lockedJsStackDepth = [];
    var ordinal = 0;
    var filterNativeFunctions = !WebInspector.moduleSetting("showNativeFunctionsInJSProfile").get();

    /**
     * @param {!WebInspector.TracingModel.Event} e
     */
    function onStartEvent(e)
    {
        e.ordinal = ++ordinal;
        extractStackTrace(e);
        // For the duration of the event we cannot go beyond the stack associated with it.
        lockedJsStackDepth.push(jsFramesStack.length);
    }

    /**
     * @param {!WebInspector.TracingModel.Event} e
     * @param {?WebInspector.TracingModel.Event} parent
     */
    function onInstantEvent(e, parent)
    {
        e.ordinal = ++ordinal;
        if (parent && isJSInvocationEvent(parent))
            extractStackTrace(e);
    }

    /**
     * @param {!WebInspector.TracingModel.Event} e
     */
    function onEndEvent(e)
    {
        truncateJSStack(lockedJsStackDepth.pop(), e.endTime);
    }

    /**
     * @param {number} depth
     * @param {number} time
     */
    function truncateJSStack(depth, time)
    {
        if (lockedJsStackDepth.length) {
            var lockedDepth = lockedJsStackDepth.peekLast();
            if (depth < lockedDepth) {
                console.error("Child stack is shallower (" + depth + ") than the parent stack (" + lockedDepth + ") at " + time);
                depth = lockedDepth;
            }
        }
        if (jsFramesStack.length < depth) {
            console.error("Trying to truncate higher than the current stack size at " + time);
            depth = jsFramesStack.length;
        }
        for (var k = 0; k < jsFramesStack.length; ++k)
            jsFramesStack[k].setEndTime(time);
        jsFramesStack.length = depth;
    }

    /**
     * @param {!Array<!RuntimeAgent.CallFrame>} stack
     */
    function filterStackFrames(stack)
    {
        for (var i = 0, j = 0; i < stack.length; ++i) {
            var url = stack[i].url;
            if (url && url.startsWith("native "))
                continue;
            stack[j++] = stack[i];
        }
        stack.length = j;
    }

    /**
     * @param {!WebInspector.TracingModel.Event} e
     */
    function extractStackTrace(e)
    {
        var recordTypes = WebInspector.TimelineModel.RecordType;
        var callFrames;
        if (e.name === recordTypes.JSSample) {
            var eventData = e.args["data"] || e.args["beginData"];
            callFrames = /** @type {!Array<!RuntimeAgent.CallFrame>} */ (eventData && eventData["stackTrace"]);
        } else {
            callFrames = /** @type {!Array<!RuntimeAgent.CallFrame>} */ (jsFramesStack.map(frameEvent => frameEvent.args["data"]).reverse());
        }
        if (filterNativeFunctions)
            filterStackFrames(callFrames);
        var endTime = eventEndTime(e);
        var numFrames = callFrames.length;
        var minFrames = Math.min(numFrames, jsFramesStack.length);
        var i;
        for (i = lockedJsStackDepth.peekLast() || 0; i < minFrames; ++i) {
            var newFrame = callFrames[numFrames - 1 - i];
            var oldFrame = jsFramesStack[i].args["data"];
            if (!equalFrames(newFrame, oldFrame))
                break;
            jsFramesStack[i].setEndTime(Math.max(jsFramesStack[i].endTime, endTime));
        }
        truncateJSStack(i, e.startTime);
        for (; i < numFrames; ++i) {
            var frame = callFrames[numFrames - 1 - i];
            var jsFrameEvent = new WebInspector.TracingModel.Event(WebInspector.TracingModel.DevToolsTimelineEventCategory, recordTypes.JSFrame,
                WebInspector.TracingModel.Phase.Complete, e.startTime, e.thread);
            jsFrameEvent.ordinal = e.ordinal;
            jsFrameEvent.addArgs({ data: frame });
            jsFrameEvent.setEndTime(endTime);
            jsFramesStack.push(jsFrameEvent);
            jsFrameEvents.push(jsFrameEvent);
        }
    }

    /**
     * @param {!Array<!WebInspector.TracingModel.Event>} events
     * @return {?WebInspector.TracingModel.Event}
     */
    function findFirstTopLevelEvent(events)
    {
        for (var i = 0; i < events.length; ++i) {
            if (WebInspector.TracingModel.isTopLevelEvent(events[i]))
                return events[i];
        }
        return null;
    }

    var firstTopLevelEvent = findFirstTopLevelEvent(events);
    if (firstTopLevelEvent)
        WebInspector.TimelineModel.forEachEvent(events, onStartEvent, onEndEvent, onInstantEvent, firstTopLevelEvent.startTime);
    return jsFrameEvents;
}

/**
 * @constructor
 */
WebInspector.TimelineJSProfileProcessor.CodeMap = function()
{
    /** @type {!Map<string, !WebInspector.TimelineJSProfileProcessor.CodeMap.Bank>} */
    this._banks = new Map();
}

/**
 * @constructor
 * @param {number} address
 * @param {number} size
 * @param {!RuntimeAgent.CallFrame} callFrame
 */
WebInspector.TimelineJSProfileProcessor.CodeMap.Entry = function(address, size, callFrame)
{
    this.address = address;
    this.size = size;
    this.callFrame = callFrame;
}

/**
 * @param {number} address
 * @param {!WebInspector.TimelineJSProfileProcessor.CodeMap.Entry} entry
 * @return {number}
 */
WebInspector.TimelineJSProfileProcessor.CodeMap.comparator = function(address, entry)
{
    return address - entry.address;
}

WebInspector.TimelineJSProfileProcessor.CodeMap.prototype = {
    /**
     * @param {string} addressHex
     * @param {number} size
     * @param {!RuntimeAgent.CallFrame} callFrame
     */
    addEntry: function(addressHex, size, callFrame)
    {
        var entry = new WebInspector.TimelineJSProfileProcessor.CodeMap.Entry(this._getAddress(addressHex), size, callFrame);
        this._addEntry(addressHex, entry);
    },

    /**
     * @param {string} oldAddressHex
     * @param {string} newAddressHex
     * @param {number} size
     */
    moveEntry: function(oldAddressHex, newAddressHex, size)
    {
        var entry = this._getBank(oldAddressHex).removeEntry(this._getAddress(oldAddressHex));
        if (!entry) {
            console.error("Entry at address " + oldAddressHex + " not found");
            return;
        }
        entry.address = this._getAddress(newAddressHex);
        entry.size = size;
        this._addEntry(newAddressHex, entry);
    },

    /**
     * @param {string} addressHex
     * @return {?RuntimeAgent.CallFrame}
     */
    lookupEntry: function(addressHex)
    {
        return this._getBank(addressHex).lookupEntry(this._getAddress(addressHex));
    },

    /**
     * @param {string} addressHex
     * @param {!WebInspector.TimelineJSProfileProcessor.CodeMap.Entry} entry
     */
    _addEntry: function(addressHex, entry)
    {
        // FIXME: deal with entries that span across [multiple] banks.
        this._getBank(addressHex).addEntry(entry);
    },

    /**
     * @param {string} addressHex
     * @return {!WebInspector.TimelineJSProfileProcessor.CodeMap.Bank}
     */
    _getBank: function(addressHex)
    {
        addressHex = addressHex.slice(2);  // cut 0x prefix.
        // 13 hex digits == 52 bits, double mantissa fits 53 bits.
        var /** @const */ bankSizeHexDigits = 13;
        var /** @const */ maxHexDigits = 16;
        var bankName = addressHex.slice(-maxHexDigits, -bankSizeHexDigits);
        var bank = this._banks.get(bankName);
        if (!bank) {
            bank = new WebInspector.TimelineJSProfileProcessor.CodeMap.Bank();
            this._banks.set(bankName, bank);
        }
        return bank;
    },

    /**
     * @param {string} addressHex
     * @return {number}
     */
    _getAddress: function(addressHex)
    {
        // 13 hex digits == 52 bits, double mantissa fits 53 bits.
        var /** @const */ bankSizeHexDigits = 13;
        addressHex = addressHex.slice(2);  // cut 0x prefix.
        return parseInt(addressHex.slice(-bankSizeHexDigits), 16);
    }
}

/**
 * @constructor
 */
WebInspector.TimelineJSProfileProcessor.CodeMap.Bank = function()
{
    /** @type {!Array<!WebInspector.TimelineJSProfileProcessor.CodeMap.Entry>} */
    this._entries = [];
}

WebInspector.TimelineJSProfileProcessor.CodeMap.Bank.prototype = {
    /**
     * @param {number} address
     * @return {?WebInspector.TimelineJSProfileProcessor.CodeMap.Entry}
     */
    removeEntry: function(address)
    {
        var index = this._entries.lowerBound(address, WebInspector.TimelineJSProfileProcessor.CodeMap.comparator);
        var entry = this._entries[index];
        if (!entry || entry.address !== address)
            return null;
        this._entries.splice(index, 1);
        return entry;
    },

    /**
     * @param {number} address
     * @return {?RuntimeAgent.CallFrame}
     */
    lookupEntry: function(address)
    {
        var index = this._entries.upperBound(address, WebInspector.TimelineJSProfileProcessor.CodeMap.comparator) - 1;
        var entry = this._entries[index];
        return entry && address < entry.address + entry.size ? entry.callFrame : null;
    },

    /**
     * @param {!WebInspector.TimelineJSProfileProcessor.CodeMap.Entry} newEntry
     */
    addEntry: function(newEntry)
    {
        var endAddress = newEntry.address + newEntry.size;
        var lastIndex = this._entries.lowerBound(endAddress, WebInspector.TimelineJSProfileProcessor.CodeMap.comparator);
        var index;
        for (index = lastIndex - 1; index >= 0; --index) {
            var entry = this._entries[index];
            var entryEndAddress = entry.address + entry.size;
            if (entryEndAddress <= newEntry.address)
                break;
        }
        ++index;
        this._entries.splice(index, lastIndex - index, newEntry);
    }
}

/**
 * @param {string} name
 * @param {number} scriptId
 * @return {!RuntimeAgent.CallFrame}
 */
WebInspector.TimelineJSProfileProcessor._buildCallFrame = function(name, scriptId)
{
    /**
     * @param {string} functionName
     * @param {string=} url
     * @param {string=} scriptId
     * @param {number=} line
     * @param {number=} column
     * @param {boolean=} isNative
     * @return {!RuntimeAgent.CallFrame}
     */
    function createFrame(functionName, url, scriptId, line, column, isNative)
    {
        return /** @type {!RuntimeAgent.CallFrame} */ ({
            "functionName": functionName,
            "url": url || "",
            "scriptId": scriptId || "0",
            "lineNumber": line || 0,
            "columnNumber": column || 0,
            "isNative": isNative || false
        });
    }

    // Code states:
    // (empty) -> compiled
    //    ~    -> optimizable
    //    *    -> optimized
    var rePrefix = /^(\w*:)?[*~]?(.*)$/m;
    var tokens = rePrefix.exec(name);
    var prefix = tokens[1];
    var body = tokens[2];
    var rawName;
    var rawUrl;
    if (prefix === "Script:") {
        rawName = "";
        rawUrl = body;
    } else {
        var spacePos = body.lastIndexOf(" ");
        rawName = spacePos !== -1 ? body.substr(0, spacePos) : body;
        rawUrl = spacePos !== -1 ? body.substr(spacePos + 1) : "";
    }
    var nativeSuffix = " native";
    var isNative = rawName.endsWith(nativeSuffix);
    var functionName = isNative ? rawName.slice(0, -nativeSuffix.length) : rawName;
    var urlData = WebInspector.ParsedURL.splitLineAndColumn(rawUrl);
    var url = urlData.url || "";
    var line = urlData.lineNumber || 0;
    var column = urlData.columnNumber || 0;
    return createFrame(functionName, url, String(scriptId), line, column, isNative);
}

/**
 * @param {!Array<!WebInspector.TracingModel.Event>} events
 * @return {!Array<!WebInspector.TracingModel.Event>}
 */
WebInspector.TimelineJSProfileProcessor.processRawV8Samples = function(events)
{
    var missingAddesses = new Set();

    /**
     * @param {string} address
     * @return {?RuntimeAgent.CallFrame}
     */
    function convertRawFrame(address)
    {
        var entry = codeMap.lookupEntry(address);
        if (entry)
            return entry.isNative ? null : entry;
        if (!missingAddesses.has(address)) {
            missingAddesses.add(address);
            console.error("Address " + address + " has missing code entry");
        }
        return null;
    }

    var recordTypes = WebInspector.TimelineModel.RecordType;
    var samples = [];
    var codeMap = new WebInspector.TimelineJSProfileProcessor.CodeMap();
    for (var i = 0; i < events.length; ++i) {
        var e = events[i];
        var data = e.args["data"];
        switch (e.name) {
        case recordTypes.JitCodeAdded:
            var frame = WebInspector.TimelineJSProfileProcessor._buildCallFrame(data["name"], data["script_id"]);
            codeMap.addEntry(data["code_start"], data["code_len"], frame);
            break;
        case recordTypes.JitCodeMoved:
            codeMap.moveEntry(data["code_start"], data["new_code_start"], data["code_len"]);
            break;
        case recordTypes.V8Sample:
            var rawStack = data["stack"];
            // Sometimes backend fails to collect a stack and returns an empty stack.
            // Skip these bogus samples.
            if (data["vm_state"] === "js" && !rawStack.length)
                break;
            var stack = rawStack.map(convertRawFrame);
            stack.remove(null);
            var sampleEvent = new WebInspector.TracingModel.Event(
                WebInspector.TracingModel.DevToolsTimelineEventCategory,
                WebInspector.TimelineModel.RecordType.JSSample,
                WebInspector.TracingModel.Phase.Instant, e.startTime, e.thread);
            sampleEvent.ordinal = e.ordinal;
            sampleEvent.args = {"data": {"stackTrace": stack }};
            samples.push(sampleEvent);
            break;
        }
    }

    return samples;
}

},{}],231:[function(require,module,exports){
/*
 * Copyright (C) 2012 Google Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * @constructor
 * @param {!WebInspector.TimelineModel.Filter} eventFilter
 */
WebInspector.TimelineModel = function(eventFilter)
{
    this._eventFilter = eventFilter;
    this.reset();
}

/**
 * @enum {string}
 */
WebInspector.TimelineModel.RecordType = {
    Task: "Task",
    Program: "Program",
    EventDispatch: "EventDispatch",

    GPUTask: "GPUTask",

    Animation: "Animation",
    RequestMainThreadFrame: "RequestMainThreadFrame",
    BeginFrame: "BeginFrame",
    NeedsBeginFrameChanged: "NeedsBeginFrameChanged",
    BeginMainThreadFrame: "BeginMainThreadFrame",
    ActivateLayerTree: "ActivateLayerTree",
    DrawFrame: "DrawFrame",
    HitTest: "HitTest",
    ScheduleStyleRecalculation: "ScheduleStyleRecalculation",
    RecalculateStyles: "RecalculateStyles", // For backwards compatibility only, now replaced by UpdateLayoutTree.
    UpdateLayoutTree: "UpdateLayoutTree",
    InvalidateLayout: "InvalidateLayout",
    Layout: "Layout",
    UpdateLayer: "UpdateLayer",
    UpdateLayerTree: "UpdateLayerTree",
    PaintSetup: "PaintSetup",
    Paint: "Paint",
    PaintImage: "PaintImage",
    Rasterize: "Rasterize",
    RasterTask: "RasterTask",
    ScrollLayer: "ScrollLayer",
    CompositeLayers: "CompositeLayers",

    ScheduleStyleInvalidationTracking: "ScheduleStyleInvalidationTracking",
    StyleRecalcInvalidationTracking: "StyleRecalcInvalidationTracking",
    StyleInvalidatorInvalidationTracking: "StyleInvalidatorInvalidationTracking",
    LayoutInvalidationTracking: "LayoutInvalidationTracking",
    LayerInvalidationTracking: "LayerInvalidationTracking",
    PaintInvalidationTracking: "PaintInvalidationTracking",
    ScrollInvalidationTracking: "ScrollInvalidationTracking",

    ParseHTML: "ParseHTML",
    ParseAuthorStyleSheet: "ParseAuthorStyleSheet",

    TimerInstall: "TimerInstall",
    TimerRemove: "TimerRemove",
    TimerFire: "TimerFire",

    XHRReadyStateChange: "XHRReadyStateChange",
    XHRLoad: "XHRLoad",
    CompileScript: "v8.compile",
    EvaluateScript: "EvaluateScript",

    CommitLoad: "CommitLoad",
    MarkLoad: "MarkLoad",
    MarkDOMContent: "MarkDOMContent",
    MarkFirstPaint: "MarkFirstPaint",

    TimeStamp: "TimeStamp",
    ConsoleTime: "ConsoleTime",
    UserTiming: "UserTiming",

    ResourceSendRequest: "ResourceSendRequest",
    ResourceReceiveResponse: "ResourceReceiveResponse",
    ResourceReceivedData: "ResourceReceivedData",
    ResourceFinish: "ResourceFinish",

    RunMicrotasks: "RunMicrotasks",
    FunctionCall: "FunctionCall",
    GCEvent: "GCEvent", // For backwards compatibility only, now replaced by MinorGC/MajorGC.
    MajorGC: "MajorGC",
    MinorGC: "MinorGC",
    JSFrame: "JSFrame",
    JSSample: "JSSample",
    // V8Sample events are coming from tracing and contain raw stacks with function addresses.
    // After being processed with help of JitCodeAdded and JitCodeMoved events they
    // get translated into function infos and stored as stacks in JSSample events.
    V8Sample: "V8Sample",
    JitCodeAdded: "JitCodeAdded",
    JitCodeMoved: "JitCodeMoved",
    ParseScriptOnBackground: "v8.parseOnBackground",

    UpdateCounters: "UpdateCounters",

    RequestAnimationFrame: "RequestAnimationFrame",
    CancelAnimationFrame: "CancelAnimationFrame",
    FireAnimationFrame: "FireAnimationFrame",

    RequestIdleCallback: "RequestIdleCallback",
    CancelIdleCallback: "CancelIdleCallback",
    FireIdleCallback: "FireIdleCallback",

    WebSocketCreate : "WebSocketCreate",
    WebSocketSendHandshakeRequest : "WebSocketSendHandshakeRequest",
    WebSocketReceiveHandshakeResponse : "WebSocketReceiveHandshakeResponse",
    WebSocketDestroy : "WebSocketDestroy",

    EmbedderCallback : "EmbedderCallback",

    SetLayerTreeId: "SetLayerTreeId",
    TracingStartedInPage: "TracingStartedInPage",
    TracingSessionIdForWorker: "TracingSessionIdForWorker",

    DecodeImage: "Decode Image",
    ResizeImage: "Resize Image",
    DrawLazyPixelRef: "Draw LazyPixelRef",
    DecodeLazyPixelRef: "Decode LazyPixelRef",

    LazyPixelRef: "LazyPixelRef",
    LayerTreeHostImplSnapshot: "cc::LayerTreeHostImpl",
    PictureSnapshot: "cc::Picture",
    DisplayItemListSnapshot: "cc::DisplayItemList",
    LatencyInfo: "LatencyInfo",
    LatencyInfoFlow: "LatencyInfo.Flow",
    InputLatencyMouseMove: "InputLatency::MouseMove",
    InputLatencyMouseWheel: "InputLatency::MouseWheel",
    ImplSideFling: "InputHandlerProxy::HandleGestureFling::started",
    GCIdleLazySweep: "ThreadState::performIdleLazySweep",
    GCCompleteSweep: "ThreadState::completeSweep",
    GCCollectGarbage: "BlinkGCMarking",

    // CpuProfile is a virtual event created on frontend to support
    // serialization of CPU Profiles within tracing timeline data.
    CpuProfile: "CpuProfile"
}

WebInspector.TimelineModel.Category = {
    Console: "blink.console",
    UserTiming: "blink.user_timing",
    LatencyInfo: "latencyInfo"
};

/**
 * @enum {string}
 */
WebInspector.TimelineModel.WarningType = {
    ForcedStyle: "ForcedStyle",
    ForcedLayout: "ForcedLayout",
    IdleDeadlineExceeded: "IdleDeadlineExceeded",
    V8Deopt: "V8Deopt"
}

WebInspector.TimelineModel.MainThreadName = "main";
WebInspector.TimelineModel.WorkerThreadName = "DedicatedWorker Thread";
WebInspector.TimelineModel.RendererMainThreadName = "CrRendererMain";

/**
 * @enum {symbol}
 */
WebInspector.TimelineModel.AsyncEventGroup = {
    animation: Symbol("animation"),
    console: Symbol("console"),
    userTiming: Symbol("userTiming"),
    input: Symbol("input")
};

/**
 * @param {!Array.<!WebInspector.TracingModel.Event>} events
 * @param {function(!WebInspector.TracingModel.Event)} onStartEvent
 * @param {function(!WebInspector.TracingModel.Event)} onEndEvent
 * @param {function(!WebInspector.TracingModel.Event,?WebInspector.TracingModel.Event)|undefined=} onInstantEvent
 * @param {number=} startTime
 * @param {number=} endTime
 */
WebInspector.TimelineModel.forEachEvent = function(events, onStartEvent, onEndEvent, onInstantEvent, startTime, endTime)
{
    startTime = startTime || 0;
    endTime = endTime || Infinity;
    var stack = [];
    for (var i = 0; i < events.length; ++i) {
        var e = events[i];
        if ((e.endTime || e.startTime) < startTime)
            continue;
        if (e.startTime >= endTime)
            break;
        if (WebInspector.TracingModel.isAsyncPhase(e.phase) || WebInspector.TracingModel.isFlowPhase(e.phase))
            continue;
        while (stack.length && stack.peekLast().endTime <= e.startTime)
            onEndEvent(stack.pop());
        if (e.duration) {
            onStartEvent(e);
            stack.push(e);
        } else {
            onInstantEvent && onInstantEvent(e, stack.peekLast() || null);
        }
    }
    while (stack.length)
        onEndEvent(stack.pop());
}

WebInspector.TimelineModel.DevToolsMetadataEvent = {
    TracingStartedInBrowser: "TracingStartedInBrowser",
    TracingStartedInPage: "TracingStartedInPage",
    TracingSessionIdForWorker: "TracingSessionIdForWorker",
};

/**
 * @constructor
 * @param {string} name
 */
WebInspector.TimelineModel.VirtualThread = function(name)
{
    this.name = name;
    /** @type {!Array<!WebInspector.TracingModel.Event>} */
    this.events = [];
    /** @type {!Map<!WebInspector.TimelineModel.AsyncEventGroup, !Array<!WebInspector.TracingModel.AsyncEvent>>} */
    this.asyncEventsByGroup = new Map();
}

WebInspector.TimelineModel.VirtualThread.prototype = {
    /**
     * @return {boolean}
     */
    isWorker: function()
    {
        return this.name === WebInspector.TimelineModel.WorkerThreadName;
    }
}

/**
 * @constructor
 * @param {!WebInspector.TracingModel.Event} traceEvent
 */
WebInspector.TimelineModel.Record = function(traceEvent)
{
    this._event = traceEvent;
    this._children = [];
}

/**
 * @param {!WebInspector.TimelineModel.Record} a
 * @param {!WebInspector.TimelineModel.Record} b
 * @return {number}
 */
WebInspector.TimelineModel.Record._compareStartTime = function(a, b)
{
    // Never return 0 as otherwise equal records would be merged.
    return a.startTime() <= b.startTime() ? -1 : 1;
}

WebInspector.TimelineModel.Record.prototype = {
    /**
     * @return {?WebInspector.Target}
     */
    target: function()
    {
        var threadName = this._event.thread.name();
        // FIXME: correctly specify target
        return threadName === WebInspector.TimelineModel.RendererMainThreadName ? WebInspector.targetManager.targets()[0] || null : null;
    },

    /**
     * @return {!Array.<!WebInspector.TimelineModel.Record>}
     */
    children: function()
    {
        return this._children;
    },

    /**
     * @return {number}
     */
    startTime: function()
    {
        return this._event.startTime;
    },

    /**
     * @return {number}
     */
    endTime: function()
    {
        return this._event.endTime || this._event.startTime;
    },

    /**
     * @return {string}
     */
    thread: function()
    {
        if (this._event.thread.name() === WebInspector.TimelineModel.RendererMainThreadName)
            return WebInspector.TimelineModel.MainThreadName;
        return this._event.thread.name();
    },

    /**
     * @return {!WebInspector.TimelineModel.RecordType}
     */
    type: function()
    {
        return WebInspector.TimelineModel._eventType(this._event);
    },

    /**
     * @param {string} key
     * @return {?Object}
     */
    getUserObject: function(key)
    {
        if (key === "TimelineUIUtils::preview-element")
            return this._event.previewElement;
        throw new Error("Unexpected key: " + key);
    },

    /**
     * @param {string} key
     * @param {?Object|undefined} value
     */
    setUserObject: function(key, value)
    {
        if (key !== "TimelineUIUtils::preview-element")
            throw new Error("Unexpected key: " + key);
        this._event.previewElement = /** @type {?Element} */ (value);
    },

    /**
     * @return {!WebInspector.TracingModel.Event}
     */
    traceEvent: function()
    {
        return this._event;
    },

    /**
     * @param {!WebInspector.TimelineModel.Record} child
     */
    _addChild: function(child)
    {
        this._children.push(child);
        child.parent = this;
    }
}

/** @typedef {!{page: !Array<!WebInspector.TracingModel.Event>, workers: !Array<!WebInspector.TracingModel.Event>}} */
WebInspector.TimelineModel.MetadataEvents;

/**
 * @return {!WebInspector.TimelineModel.RecordType}
 */
WebInspector.TimelineModel._eventType = function(event)
{
    if (event.hasCategory(WebInspector.TimelineModel.Category.Console))
        return WebInspector.TimelineModel.RecordType.ConsoleTime;
    if (event.hasCategory(WebInspector.TimelineModel.Category.UserTiming))
        return WebInspector.TimelineModel.RecordType.UserTiming;
    if (event.hasCategory(WebInspector.TimelineModel.Category.LatencyInfo))
        return WebInspector.TimelineModel.RecordType.LatencyInfo;
    return /** @type !WebInspector.TimelineModel.RecordType */ (event.name);
}

WebInspector.TimelineModel.prototype = {
    /**
     * @deprecated Test use only!
     * @param {?function(!WebInspector.TimelineModel.Record)|?function(!WebInspector.TimelineModel.Record,number)} preOrderCallback
     * @param {function(!WebInspector.TimelineModel.Record)|function(!WebInspector.TimelineModel.Record,number)=} postOrderCallback
     * @return {boolean}
     */
    forAllRecords: function(preOrderCallback, postOrderCallback)
    {
        /**
         * @param {!Array.<!WebInspector.TimelineModel.Record>} records
         * @param {number} depth
         * @return {boolean}
         */
        function processRecords(records, depth)
        {
            for (var i = 0; i < records.length; ++i) {
                var record = records[i];
                if (preOrderCallback && preOrderCallback(record, depth))
                    return true;
                if (processRecords(record.children(), depth + 1))
                    return true;
                if (postOrderCallback && postOrderCallback(record, depth))
                    return true;
            }
            return false;
        }
        return processRecords(this._records, 0);
    },

    /**
     * @param {!Array<!WebInspector.TimelineModel.Filter>} filters
     * @param {function(!WebInspector.TimelineModel.Record)|function(!WebInspector.TimelineModel.Record,number)} callback
     */
    forAllFilteredRecords: function(filters, callback)
    {
        /**
         * @param {!WebInspector.TimelineModel.Record} record
         * @param {number} depth
         * @this {WebInspector.TimelineModel}
         * @return {boolean}
         */
        function processRecord(record, depth)
        {
            var visible = WebInspector.TimelineModel.isVisible(filters, record.traceEvent());
            if (visible && callback(record, depth))
                return true;

            for (var i = 0; i < record.children().length; ++i) {
                if (processRecord.call(this, record.children()[i], visible ? depth + 1 : depth))
                    return true;
            }
            return false;
        }

        for (var i = 0; i < this._records.length; ++i)
            processRecord.call(this, this._records[i], 0);
    },

    /**
     * @return {!Array.<!WebInspector.TimelineModel.Record>}
     */
    records: function()
    {
        return this._records;
    },

    /**
     * @return {!Array<!WebInspector.CPUProfileDataModel>}
     */
    cpuProfiles: function()
    {
        return this._cpuProfiles;
    },

    /**
     * @return {?string}
     */
    sessionId: function()
    {
        return this._sessionId;
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @return {?WebInspector.Target}
     */
    targetByEvent: function(event)
    {
        // FIXME: Consider returning null for loaded traces.
        var workerId = this._workerIdByThread.get(event.thread);
        var mainTarget = WebInspector.targetManager.mainTarget();
        return workerId ? mainTarget.workerManager.targetByWorkerId(workerId) : mainTarget;
    },

    /**
     * @param {!WebInspector.TracingModel} tracingModel
     * @param {boolean=} produceTraceStartedInPage
     */
    setEvents: function(tracingModel, produceTraceStartedInPage)
    {
        this.reset();
        this._resetProcessingState();

        this._minimumRecordTime = tracingModel.minimumRecordTime();
        this._maximumRecordTime = tracingModel.maximumRecordTime();

        var metadataEvents = this._processMetadataEvents(tracingModel, !!produceTraceStartedInPage);
        if (Runtime.experiments.isEnabled("timelineShowAllProcesses")) {
            var lastPageMetaEvent = metadataEvents.page.peekLast();
            for (var process of tracingModel.sortedProcesses()) {
                for (var thread of process.sortedThreads())
                    this._processThreadEvents(0, Infinity, thread, thread === lastPageMetaEvent.thread);
            }
        } else {
            var startTime = 0;
            for (var i = 0, length = metadataEvents.page.length; i < length; i++) {
                var metaEvent = metadataEvents.page[i];
                var process = metaEvent.thread.process();
                var endTime = i + 1 < length ? metadataEvents.page[i + 1].startTime : Infinity;
                this._currentPage = metaEvent.args["data"] && metaEvent.args["data"]["page"];
                for (var thread of process.sortedThreads()) {
                    if (thread.name() === WebInspector.TimelineModel.WorkerThreadName) {
                        var workerMetaEvent = metadataEvents.workers.find(e => e.args["data"]["workerThreadId"] === thread.id());
                        if (!workerMetaEvent)
                            continue;
                        var workerId = workerMetaEvent.args["data"]["workerId"];
                        if (workerId)
                            this._workerIdByThread.set(thread, workerId);
                    }
                    this._processThreadEvents(startTime, endTime, thread, thread === metaEvent.thread);
                }
                startTime = endTime;
            }
        }
        this._inspectedTargetEvents.sort(WebInspector.TracingModel.Event.compareStartTime);

        this._processBrowserEvents(tracingModel);
        this._buildTimelineRecords();
        this._buildGPUEvents(tracingModel);
        this._insertFirstPaintEvent();
        this._resetProcessingState();
    },

    /**
     * @param {!WebInspector.TracingModel} tracingModel
     * @param {boolean} produceTraceStartedInPage
     * @return {!WebInspector.TimelineModel.MetadataEvents}
     */
    _processMetadataEvents: function(tracingModel, produceTraceStartedInPage)
    {
        var metadataEvents = tracingModel.devToolsMetadataEvents();

        var pageDevToolsMetadataEvents = [];
        var workersDevToolsMetadataEvents = [];
        for (var event of metadataEvents) {
            if (event.name === WebInspector.TimelineModel.DevToolsMetadataEvent.TracingStartedInPage) {
                pageDevToolsMetadataEvents.push(event);
            } else if (event.name === WebInspector.TimelineModel.DevToolsMetadataEvent.TracingSessionIdForWorker) {
                workersDevToolsMetadataEvents.push(event);
            } else if (event.name === WebInspector.TimelineModel.DevToolsMetadataEvent.TracingStartedInBrowser) {
                console.assert(!this._mainFrameNodeId, "Multiple sessions in trace");
                this._mainFrameNodeId = event.args["frameTreeNodeId"];
            }
        }
        if (!pageDevToolsMetadataEvents.length) {
            // The trace is probably coming not from DevTools. Make a mock Metadata event.
            var pageMetaEvent = produceTraceStartedInPage ? this._makeMockPageMetadataEvent(tracingModel) : null;
            if (!pageMetaEvent) {
                console.error(WebInspector.TimelineModel.DevToolsMetadataEvent.TracingStartedInPage + " event not found.");
                return {page: [], workers: []};
            }
            pageDevToolsMetadataEvents.push(pageMetaEvent);
        }
        var sessionId = pageDevToolsMetadataEvents[0].args["sessionId"] || pageDevToolsMetadataEvents[0].args["data"]["sessionId"];
        this._sessionId = sessionId;

        var mismatchingIds = new Set();
        /**
         * @param {!WebInspector.TracingModel.Event} event
         * @return {boolean}
         */
        function checkSessionId(event)
        {
            var args = event.args;
            // FIXME: put sessionId into args["data"] for TracingStartedInPage event.
            if (args["data"])
                args = args["data"];
            var id = args["sessionId"];
            if (id === sessionId)
                return true;
            mismatchingIds.add(id);
            return false;
        }
        var result = {
            page: pageDevToolsMetadataEvents.filter(checkSessionId).sort(WebInspector.TracingModel.Event.compareStartTime),
            workers: workersDevToolsMetadataEvents.filter(checkSessionId).sort(WebInspector.TracingModel.Event.compareStartTime)
        };
        if (mismatchingIds.size)
            WebInspector.console.error("Timeline recording was started in more than one page simultaneously. Session id mismatch: " + this._sessionId + " and " + mismatchingIds.valuesArray() + ".");
        return result;
    },

    /**
     * @param {!WebInspector.TracingModel} tracingModel
     * @return {?WebInspector.TracingModel.Event}
     */
    _makeMockPageMetadataEvent: function(tracingModel)
    {
        var rendererMainThreadName = WebInspector.TimelineModel.RendererMainThreadName;
        // FIXME: pick up the first renderer process for now.
        var process = tracingModel.sortedProcesses().filter(function(p) { return p.threadByName(rendererMainThreadName); })[0];
        var thread = process && process.threadByName(rendererMainThreadName);
        if (!thread)
            return null;
        var pageMetaEvent = new WebInspector.TracingModel.Event(
            WebInspector.TracingModel.DevToolsMetadataEventCategory,
            WebInspector.TimelineModel.DevToolsMetadataEvent.TracingStartedInPage,
            WebInspector.TracingModel.Phase.Metadata,
            tracingModel.minimumRecordTime(), thread);
        pageMetaEvent.addArgs({"data": {"sessionId": "mockSessionId"}});
        return pageMetaEvent;
    },

    _insertFirstPaintEvent: function()
    {
        if (!this._firstCompositeLayers)
            return;

        // First Paint is actually a DrawFrame that happened after first CompositeLayers following last CommitLoadEvent.
        var recordTypes = WebInspector.TimelineModel.RecordType;
        var i = this._inspectedTargetEvents.lowerBound(this._firstCompositeLayers, WebInspector.TracingModel.Event.compareStartTime);
        for (; i < this._inspectedTargetEvents.length && this._inspectedTargetEvents[i].name !== recordTypes.DrawFrame; ++i) { }
        if (i >= this._inspectedTargetEvents.length)
            return;
        var drawFrameEvent = this._inspectedTargetEvents[i];
        var firstPaintEvent = new WebInspector.TracingModel.Event(drawFrameEvent.categoriesString, recordTypes.MarkFirstPaint, WebInspector.TracingModel.Phase.Instant, drawFrameEvent.startTime, drawFrameEvent.thread);
        this._mainThreadEvents.splice(this._mainThreadEvents.lowerBound(firstPaintEvent, WebInspector.TracingModel.Event.compareStartTime), 0, firstPaintEvent);
        var firstPaintRecord = new WebInspector.TimelineModel.Record(firstPaintEvent);
        this._eventDividerRecords.splice(this._eventDividerRecords.lowerBound(firstPaintRecord, WebInspector.TimelineModel.Record._compareStartTime), 0, firstPaintRecord);
    },

    /**
     * @param {!WebInspector.TracingModel} tracingModel
     */
    _processBrowserEvents: function(tracingModel)
    {
        var browserMain = WebInspector.TracingModel.browserMainThread(tracingModel);
        if (!browserMain)
            return;

        // Disregard regular events, we don't need them yet, but still process to get proper metadata.
        browserMain.events().forEach(this._processBrowserEvent, this);
        /** @type {!Map<!WebInspector.TimelineModel.AsyncEventGroup, !Array<!WebInspector.TracingModel.AsyncEvent>>} */
        var asyncEventsByGroup = new Map();
        this._processAsyncEvents(asyncEventsByGroup, browserMain.asyncEvents());
        this._mergeAsyncEvents(this._mainThreadAsyncEventsByGroup, asyncEventsByGroup);
    },

    _buildTimelineRecords: function()
    {
        var topLevelRecords = this._buildTimelineRecordsForThread(this.mainThreadEvents());
        for (var i = 0; i < topLevelRecords.length; i++) {
            var record = topLevelRecords[i];
            if (WebInspector.TracingModel.isTopLevelEvent(record.traceEvent()))
                this._mainThreadTasks.push(record);
        }

        /**
         * @param {!WebInspector.TimelineModel.VirtualThread} virtualThread
         * @this {!WebInspector.TimelineModel}
         */
        function processVirtualThreadEvents(virtualThread)
        {
            var threadRecords = this._buildTimelineRecordsForThread(virtualThread.events);
            topLevelRecords = topLevelRecords.mergeOrdered(threadRecords, WebInspector.TimelineModel.Record._compareStartTime);
        }
        this.virtualThreads().forEach(processVirtualThreadEvents.bind(this));
        this._records = topLevelRecords;
    },

    /**
     * @param {!WebInspector.TracingModel} tracingModel
     */
    _buildGPUEvents: function(tracingModel)
    {
        var thread = tracingModel.threadByName("GPU Process", "CrGpuMain");
        if (!thread)
            return;
        var gpuEventName = WebInspector.TimelineModel.RecordType.GPUTask;
        this._gpuEvents = thread.events().filter(event => event.name === gpuEventName);
    },

    /**
     * @param {!Array.<!WebInspector.TracingModel.Event>} threadEvents
     * @return {!Array.<!WebInspector.TimelineModel.Record>}
     */
    _buildTimelineRecordsForThread: function(threadEvents)
    {
        var recordStack = [];
        var topLevelRecords = [];

        for (var i = 0, size = threadEvents.length; i < size; ++i) {
            var event = threadEvents[i];
            for (var top = recordStack.peekLast(); top && top._event.endTime <= event.startTime; top = recordStack.peekLast())
                recordStack.pop();
            if (event.phase === WebInspector.TracingModel.Phase.AsyncEnd || event.phase === WebInspector.TracingModel.Phase.NestableAsyncEnd)
                continue;
            var parentRecord = recordStack.peekLast();
            // Maintain the back-end logic of old timeline, skip console.time() / console.timeEnd() that are not properly nested.
            if (WebInspector.TracingModel.isAsyncBeginPhase(event.phase) && parentRecord && event.endTime > parentRecord._event.endTime)
                continue;
            var record = new WebInspector.TimelineModel.Record(event);
            if (WebInspector.TimelineModel.isMarkerEvent(event))
                this._eventDividerRecords.push(record);
            if (!this._eventFilter.accept(event) && !WebInspector.TracingModel.isTopLevelEvent(event))
                continue;
            if (parentRecord)
                parentRecord._addChild(record);
            else
                topLevelRecords.push(record);
            if (event.endTime)
                recordStack.push(record);
        }

        return topLevelRecords;
    },

    _resetProcessingState: function()
    {
        this._asyncEventTracker = new WebInspector.TimelineAsyncEventTracker();
        this._invalidationTracker = new WebInspector.InvalidationTracker();
        this._layoutInvalidate = {};
        this._lastScheduleStyleRecalculation = {};
        this._paintImageEventByPixelRefId = {};
        this._lastPaintForLayer = {};
        this._lastRecalculateStylesEvent = null;
        this._currentScriptEvent = null;
        this._eventStack = [];
        this._hadCommitLoad = false;
        this._firstCompositeLayers = null;
        /** @type {!Set<string>} */
        this._knownInputEvents = new Set();
        this._currentPage = null;
    },

    /**
     * @param {number} startTime
     * @param {number} endTime
     * @param {!WebInspector.TracingModel.Thread} thread
     * @param {boolean} isMainThread
     */
    _processThreadEvents: function(startTime, endTime, thread, isMainThread)
    {
        var events = thread.events();
        var asyncEvents = thread.asyncEvents();

        var jsSamples;
        if (Runtime.experiments.isEnabled("timelineTracingJSProfile")) {
            jsSamples = WebInspector.TimelineJSProfileProcessor.processRawV8Samples(events);
        } else {
            var cpuProfileEvent = events.peekLast();
            if (cpuProfileEvent && cpuProfileEvent.name === WebInspector.TimelineModel.RecordType.CpuProfile) {
                var cpuProfile = cpuProfileEvent.args["data"]["cpuProfile"];
                if (cpuProfile) {
                    var jsProfileModel = new WebInspector.CPUProfileDataModel(cpuProfile);
                    this._cpuProfiles.push(jsProfileModel);
                    jsSamples = WebInspector.TimelineJSProfileProcessor.generateTracingEventsFromCpuProfile(jsProfileModel, thread);
                }
            }
        }

        if (jsSamples && jsSamples.length)
            events = events.mergeOrdered(jsSamples, WebInspector.TracingModel.Event.orderedCompareStartTime);
        if (jsSamples || events.some(function(e) { return e.name === WebInspector.TimelineModel.RecordType.JSSample; })) {
            var jsFrameEvents = WebInspector.TimelineJSProfileProcessor.generateJSFrameEvents(events);
            if (jsFrameEvents && jsFrameEvents.length)
                events = jsFrameEvents.mergeOrdered(events, WebInspector.TracingModel.Event.orderedCompareStartTime);
        }

        var threadEvents;
        var threadAsyncEventsByGroup;
        if (isMainThread) {
            threadEvents = this._mainThreadEvents;
            threadAsyncEventsByGroup = this._mainThreadAsyncEventsByGroup;
        } else {
            var virtualThread = new WebInspector.TimelineModel.VirtualThread(thread.name());
            this._virtualThreads.push(virtualThread);
            threadEvents = virtualThread.events;
            threadAsyncEventsByGroup = virtualThread.asyncEventsByGroup;
        }

        this._eventStack = [];
        var i = events.lowerBound(startTime, function(time, event) { return time - event.startTime });
        var length = events.length;
        for (; i < length; i++) {
            var event = events[i];
            if (endTime && event.startTime >= endTime)
                break;
            if (!this._processEvent(event))
                continue;
            threadEvents.push(event);
            this._inspectedTargetEvents.push(event);
        }
        this._processAsyncEvents(threadAsyncEventsByGroup, asyncEvents, startTime, endTime);
        // Pretend the compositor's async events are on the main thread.
        if (thread.name() === "Compositor") {
            this._mergeAsyncEvents(this._mainThreadAsyncEventsByGroup, threadAsyncEventsByGroup);
            threadAsyncEventsByGroup.clear();
        }
    },

    /**
     * @param {!Map<!WebInspector.TimelineModel.AsyncEventGroup, !Array<!WebInspector.TracingModel.AsyncEvent>>} asyncEventsByGroup
     * @param {!Array<!WebInspector.TracingModel.AsyncEvent>} asyncEvents
     * @param {number=} startTime
     * @param {number=} endTime
     */
    _processAsyncEvents: function(asyncEventsByGroup, asyncEvents, startTime, endTime)
    {
        var i = startTime ? asyncEvents.lowerBound(startTime, function(time, asyncEvent) { return time - asyncEvent.startTime }) : 0;
        for (; i < asyncEvents.length; ++i) {
            var asyncEvent = asyncEvents[i];
            if (endTime && asyncEvent.startTime >= endTime)
                break;
            var asyncGroup = this._processAsyncEvent(asyncEvent);
            if (!asyncGroup)
                continue;
            var groupAsyncEvents = asyncEventsByGroup.get(asyncGroup);
            if (!groupAsyncEvents) {
                groupAsyncEvents = [];
                asyncEventsByGroup.set(asyncGroup, groupAsyncEvents);
            }
            groupAsyncEvents.push(asyncEvent);
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @return {boolean}
     */
    _processEvent: function(event)
    {
        var eventStack = this._eventStack;
        while (eventStack.length && eventStack.peekLast().endTime <= event.startTime)
            eventStack.pop();

        var recordTypes = WebInspector.TimelineModel.RecordType;

        if (this._currentScriptEvent && event.startTime > this._currentScriptEvent.endTime)
            this._currentScriptEvent = null;

        var eventData = event.args["data"] || event.args["beginData"] || {};
        if (eventData["stackTrace"])
            event.stackTrace = eventData["stackTrace"];
        if (event.stackTrace && event.name !== recordTypes.JSSample) {
            // TraceEvents come with 1-based line & column numbers. The frontend code
            // requires 0-based ones. Adjust the values.
            for (var i = 0; i < event.stackTrace.length; ++i) {
                --event.stackTrace[i].lineNumber;
                --event.stackTrace[i].columnNumber;
            }
        }

        if (eventStack.length && eventStack.peekLast().name === recordTypes.EventDispatch)
            eventStack.peekLast().hasChildren = true;
        this._asyncEventTracker.processEvent(event);
        if (event.initiator && event.initiator.url)
            event.url = event.initiator.url;
        switch (event.name) {
        case recordTypes.ResourceSendRequest:
        case recordTypes.WebSocketCreate:
            event.url = eventData["url"];
            event.initiator = eventStack.peekLast() || null;
            break;

        case recordTypes.ScheduleStyleRecalculation:
            this._lastScheduleStyleRecalculation[eventData["frame"]] = event;
            break;

        case recordTypes.UpdateLayoutTree:
        case recordTypes.RecalculateStyles:
            this._invalidationTracker.didRecalcStyle(event);
            if (event.args["beginData"])
                event.initiator = this._lastScheduleStyleRecalculation[event.args["beginData"]["frame"]];
            this._lastRecalculateStylesEvent = event;
            if (this._currentScriptEvent)
                event.warning = WebInspector.TimelineModel.WarningType.ForcedStyle;
            break;

        case recordTypes.ScheduleStyleInvalidationTracking:
        case recordTypes.StyleRecalcInvalidationTracking:
        case recordTypes.StyleInvalidatorInvalidationTracking:
        case recordTypes.LayoutInvalidationTracking:
        case recordTypes.LayerInvalidationTracking:
        case recordTypes.PaintInvalidationTracking:
        case recordTypes.ScrollInvalidationTracking:
            this._invalidationTracker.addInvalidation(new WebInspector.InvalidationTrackingEvent(event));
            break;

        case recordTypes.InvalidateLayout:
            // Consider style recalculation as a reason for layout invalidation,
            // but only if we had no earlier layout invalidation records.
            var layoutInitator = event;
            var frameId = eventData["frame"];
            if (!this._layoutInvalidate[frameId] && this._lastRecalculateStylesEvent && this._lastRecalculateStylesEvent.endTime >  event.startTime)
                layoutInitator = this._lastRecalculateStylesEvent.initiator;
            this._layoutInvalidate[frameId] = layoutInitator;
            break;

        case recordTypes.Layout:
            this._invalidationTracker.didLayout(event);
            var frameId = event.args["beginData"]["frame"];
            event.initiator = this._layoutInvalidate[frameId];
            // In case we have no closing Layout event, endData is not available.
            if (event.args["endData"]) {
                event.backendNodeId = event.args["endData"]["rootNode"];
                event.highlightQuad =  event.args["endData"]["root"];
            }
            this._layoutInvalidate[frameId] = null;
            if (this._currentScriptEvent)
                event.warning = WebInspector.TimelineModel.WarningType.ForcedLayout;
            break;

        case recordTypes.FunctionCall:
            // Compatibility with old format.
            if (typeof eventData["scriptName"] === "string")
                eventData["url"] = eventData["scriptName"];
            if (typeof eventData["scriptLine"] === "number")
                eventData["lineNumber"] = eventData["scriptLine"];
            // Fallthrough.
        case recordTypes.EvaluateScript:
        case recordTypes.CompileScript:
            if (typeof eventData["lineNumber"] === "number")
                --eventData["lineNumber"];
            if (typeof eventData["columnNumber"] === "number")
                --eventData["columnNumber"];
            if (!this._currentScriptEvent)
                this._currentScriptEvent = event;
            break;

        case recordTypes.SetLayerTreeId:
            this._inspectedTargetLayerTreeId = event.args["layerTreeId"] || event.args["data"]["layerTreeId"];
            break;

        case recordTypes.Paint:
            this._invalidationTracker.didPaint(event);
            event.highlightQuad = eventData["clip"];
            event.backendNodeId = eventData["nodeId"];
            // Only keep layer paint events, skip paints for subframes that get painted to the same layer as parent.
            if (!eventData["layerId"])
                break;
            var layerId = eventData["layerId"];
            this._lastPaintForLayer[layerId] = event;
            break;

        case recordTypes.DisplayItemListSnapshot:
        case recordTypes.PictureSnapshot:
            var layerUpdateEvent = this._findAncestorEvent(recordTypes.UpdateLayer);
            if (!layerUpdateEvent || layerUpdateEvent.args["layerTreeId"] !== this._inspectedTargetLayerTreeId)
                break;
            var paintEvent = this._lastPaintForLayer[layerUpdateEvent.args["layerId"]];
            if (paintEvent)
                paintEvent.picture = event;
            break;

        case recordTypes.ScrollLayer:
            event.backendNodeId = eventData["nodeId"];
            break;

        case recordTypes.PaintImage:
            event.backendNodeId = eventData["nodeId"];
            event.url = eventData["url"];
            break;

        case recordTypes.DecodeImage:
        case recordTypes.ResizeImage:
            var paintImageEvent = this._findAncestorEvent(recordTypes.PaintImage);
            if (!paintImageEvent) {
                var decodeLazyPixelRefEvent = this._findAncestorEvent(recordTypes.DecodeLazyPixelRef);
                paintImageEvent = decodeLazyPixelRefEvent && this._paintImageEventByPixelRefId[decodeLazyPixelRefEvent.args["LazyPixelRef"]];
            }
            if (!paintImageEvent)
                break;
            event.backendNodeId = paintImageEvent.backendNodeId;
            event.url = paintImageEvent.url;
            break;

        case recordTypes.DrawLazyPixelRef:
            var paintImageEvent = this._findAncestorEvent(recordTypes.PaintImage);
            if (!paintImageEvent)
                break;
            this._paintImageEventByPixelRefId[event.args["LazyPixelRef"]] = paintImageEvent;
            event.backendNodeId = paintImageEvent.backendNodeId;
            event.url = paintImageEvent.url;
            break;

        case recordTypes.MarkDOMContent:
        case recordTypes.MarkLoad:
            var page = eventData["page"];
            if (page && page !== this._currentPage)
                return false;
            break;

        case recordTypes.CommitLoad:
            var page = eventData["page"];
            if (page && page !== this._currentPage)
                return false;
            if (!eventData["isMainFrame"])
                break;
            this._hadCommitLoad = true;
            this._firstCompositeLayers = null;
            break;

        case recordTypes.CompositeLayers:
            if (!this._firstCompositeLayers && this._hadCommitLoad)
                this._firstCompositeLayers = event;
            break;

        case recordTypes.FireIdleCallback:
            if (event.duration > eventData["allottedMilliseconds"]) {
                event.warning = WebInspector.TimelineModel.WarningType.IdleDeadlineExceeded;
            }
            break;
        }
        if (WebInspector.TracingModel.isAsyncPhase(event.phase))
            return true;
        var duration = event.duration;
        if (!duration)
            return true;
        if (eventStack.length) {
            var parent = eventStack.peekLast();
            parent.selfTime -= duration;
            if (parent.selfTime < 0) {
                var epsilon = 1e-3;
                if (parent.selfTime < -epsilon)
                    console.error("Children are longer than parent at " + event.startTime + " (" + (event.startTime - this.minimumRecordTime()).toFixed(3) + ") by " + parent.selfTime.toFixed(3));
                parent.selfTime = 0;
            }
        }
        event.selfTime = duration;
        eventStack.push(event);
        return true;
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    _processBrowserEvent: function(event)
    {
        if (event.name !== WebInspector.TimelineModel.RecordType.LatencyInfoFlow)
            return;
        var frameId = event.args["frameTreeNodeId"];
        if (typeof frameId === "number" && frameId === this._mainFrameNodeId)
            this._knownInputEvents.add(event.bind_id);
    },

    /**
     * @param {!WebInspector.TracingModel.AsyncEvent} asyncEvent
     * @return {?WebInspector.TimelineModel.AsyncEventGroup}
     */
    _processAsyncEvent: function(asyncEvent)
    {
        var groups = WebInspector.TimelineModel.AsyncEventGroup;
        if (asyncEvent.hasCategory(WebInspector.TimelineModel.Category.Console))
            return groups.console;
        if (asyncEvent.hasCategory(WebInspector.TimelineModel.Category.UserTiming))
            return groups.userTiming;
        if (asyncEvent.name === WebInspector.TimelineModel.RecordType.Animation)
            return groups.animation;
        if (asyncEvent.hasCategory(WebInspector.TimelineModel.Category.LatencyInfo) || asyncEvent.name === WebInspector.TimelineModel.RecordType.ImplSideFling) {
            var lastStep = asyncEvent.steps.peekLast();
            // FIXME: fix event termination on the back-end instead.
            if (lastStep.phase !== WebInspector.TracingModel.Phase.AsyncEnd)
                return null;
            var data = lastStep.args["data"];
            asyncEvent.causedFrame = !!(data && data["INPUT_EVENT_LATENCY_RENDERER_SWAP_COMPONENT"]);
            if (asyncEvent.hasCategory(WebInspector.TimelineModel.Category.LatencyInfo)) {
                if (!this._knownInputEvents.has(lastStep.id))
                    return null;
                if (asyncEvent.name === WebInspector.TimelineModel.RecordType.InputLatencyMouseMove && !asyncEvent.causedFrame)
                    return null;
                var rendererMain = data["INPUT_EVENT_LATENCY_RENDERER_MAIN_COMPONENT"];
                if (rendererMain) {
                    var time = rendererMain["time"] / 1000;
                    asyncEvent.steps[0].timeWaitingForMainThread = time - asyncEvent.steps[0].startTime;
                }
            }
            return groups.input;
        }
        return null;
    },

    /**
     * @param {string} name
     * @return {?WebInspector.TracingModel.Event}
     */
    _findAncestorEvent: function(name)
    {
        for (var i = this._eventStack.length - 1; i >= 0; --i) {
            var event = this._eventStack[i];
            if (event.name === name)
                return event;
        }
        return null;
    },

    /**
     * @param {!Map<!WebInspector.TimelineModel.AsyncEventGroup, !Array<!WebInspector.TracingModel.AsyncEvent>>} target
     * @param {!Map<!WebInspector.TimelineModel.AsyncEventGroup, !Array<!WebInspector.TracingModel.AsyncEvent>>} source
     */
    _mergeAsyncEvents: function(target, source)
    {
        for (var group of source.keys()) {
            var events = target.get(group) || [];
            events = events.mergeOrdered(source.get(group) || [], WebInspector.TracingModel.Event.compareStartAndEndTime);
            target.set(group, events);
        }
    },

    reset: function()
    {
        this._virtualThreads = [];
        /** @type {!Array<!WebInspector.TracingModel.Event>} */
        this._mainThreadEvents = [];
        /** @type {!Map<!WebInspector.TimelineModel.AsyncEventGroup, !Array<!WebInspector.TracingModel.AsyncEvent>>} */
        this._mainThreadAsyncEventsByGroup = new Map();
        /** @type {!Array<!WebInspector.TracingModel.Event>} */
        this._inspectedTargetEvents = [];
        /** @type {!Array<!WebInspector.TimelineModel.Record>} */
        this._records = [];
        /** @type {!Array<!WebInspector.TimelineModel.Record>} */
        this._mainThreadTasks = [];
        /** @type {!Array<!WebInspector.TracingModel.Event>} */
        this._gpuEvents = [];
        /** @type {!Array<!WebInspector.TimelineModel.Record>} */
        this._eventDividerRecords = [];
        /** @type {?string} */
        this._sessionId = null;
        /** @type {?number} */
        this._mainFrameNodeId = null;
        /** @type {!Array<!WebInspector.CPUProfileDataModel>} */
        this._cpuProfiles = [];
        /** @type {!WeakMap<!WebInspector.TracingModel.Thread, string>} */
        this._workerIdByThread = new WeakMap();
        this._minimumRecordTime = 0;
        this._maximumRecordTime = 0;
    },

    /**
     * @return {number}
     */
    minimumRecordTime: function()
    {
        return this._minimumRecordTime;
    },

    /**
     * @return {number}
     */
    maximumRecordTime: function()
    {
        return this._maximumRecordTime;
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.Event>}
     */
    inspectedTargetEvents: function()
    {
        return this._inspectedTargetEvents;
    },

    /**
     * @return {!Array.<!WebInspector.TracingModel.Event>}
     */
    mainThreadEvents: function()
    {
        return this._mainThreadEvents;
    },

    /**
     * @param {!Array.<!WebInspector.TracingModel.Event>} events
     */
    _setMainThreadEvents: function(events)
    {
        this._mainThreadEvents = events;
    },

    /**
     * @return {!Map<!WebInspector.TimelineModel.AsyncEventGroup, !Array.<!WebInspector.TracingModel.AsyncEvent>>}
     */
    mainThreadAsyncEvents: function()
    {
        return this._mainThreadAsyncEventsByGroup;
    },

    /**
     * @return {!Array.<!WebInspector.TimelineModel.VirtualThread>}
     */
    virtualThreads: function()
    {
        return this._virtualThreads;
    },

    /**
     * @return {boolean}
     */
    isEmpty: function()
    {
        return this.minimumRecordTime() === 0 && this.maximumRecordTime() === 0;
    },

    /**
     * @return {!Array.<!WebInspector.TimelineModel.Record>}
     */
    mainThreadTasks: function()
    {
        return this._mainThreadTasks;
    },

    /**
     * @return {!Array<!WebInspector.TracingModel.Event>}
     */
    gpuEvents: function()
    {
        return this._gpuEvents;
    },

    /**
     * @return {!Array.<!WebInspector.TimelineModel.Record>}
     */
    eventDividerRecords: function()
    {
        return this._eventDividerRecords;
    },

    /**
     * @return {!Array<!WebInspector.TimelineModel.NetworkRequest>}
     */
    networkRequests: function()
    {
        /** @type {!Map<string,!WebInspector.TimelineModel.NetworkRequest>} */
        var requests = new Map();
        /** @type {!Array<!WebInspector.TimelineModel.NetworkRequest>} */
        var requestsList = [];
        /** @type {!Array<!WebInspector.TimelineModel.NetworkRequest>} */
        var zeroStartRequestsList = [];
        var types = WebInspector.TimelineModel.RecordType;
        var resourceTypes = new Set([
            types.ResourceSendRequest,
            types.ResourceReceiveResponse,
            types.ResourceReceivedData,
            types.ResourceFinish
        ]);
        var events = this.mainThreadEvents();
        for (var i = 0; i < events.length; ++i) {
            var e = events[i];
            if (!resourceTypes.has(e.name))
                continue;
            var id = e.args["data"]["requestId"];
            var request = requests.get(id);
            if (request) {
                request.addEvent(e);
            } else {
                request = new WebInspector.TimelineModel.NetworkRequest(e);
                requests.set(id, request);
                if (request.startTime)
                    requestsList.push(request);
                else
                    zeroStartRequestsList.push(request);
            }
        }
        return zeroStartRequestsList.concat(requestsList);
    },
}

/**
 * @param {!Array<!WebInspector.TimelineModel.Filter>} filters
 * @param {!WebInspector.TracingModel.Event} event
 * @return {boolean}
 */
WebInspector.TimelineModel.isVisible = function(filters, event)
{
    for (var i = 0; i < filters.length; ++i) {
        if (!filters[i].accept(event))
            return false;
    }
    return true;
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {boolean}
 */
WebInspector.TimelineModel.isMarkerEvent = function(event)
{
    var recordTypes = WebInspector.TimelineModel.RecordType;
    switch (event.name) {
    case recordTypes.TimeStamp:
    case recordTypes.MarkFirstPaint:
        return true;
    case recordTypes.MarkDOMContent:
    case recordTypes.MarkLoad:
        return event.args["data"]["isMainFrame"];
    default:
        return false;
    }
}

/**
 * @constructor
 * @param {!WebInspector.TracingModel.Event} event
 */
WebInspector.TimelineModel.NetworkRequest = function(event)
{
    this.startTime = event.name === WebInspector.TimelineModel.RecordType.ResourceSendRequest ? event.startTime : 0;
    this.endTime = Infinity;
    /** @type {!Array<!WebInspector.TracingModel.Event>} */
    this.children = [];
    this.addEvent(event);
}

WebInspector.TimelineModel.NetworkRequest.prototype = {
    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    addEvent: function(event)
    {
        this.children.push(event);
        var recordType = WebInspector.TimelineModel.RecordType;
        this.startTime = Math.min(this.startTime, event.startTime);
        var eventData = event.args["data"];
        if (eventData["mimeType"])
            this.mimeType = eventData["mimeType"];
        if ("priority" in eventData)
            this.priority = eventData["priority"];
        if (event.name === recordType.ResourceFinish)
            this.endTime = event.startTime;
        if (!this.responseTime && (event.name === recordType.ResourceReceiveResponse || event.name === recordType.ResourceReceivedData))
            this.responseTime = event.startTime;
        if (!this.url)
            this.url = eventData["url"];
        if (!this.requestMethod)
            this.requestMethod = eventData["requestMethod"];
    }
}

/**
 * @constructor
 */
WebInspector.TimelineModel.Filter = function()
{
}

WebInspector.TimelineModel.Filter.prototype = {
    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @return {boolean}
     */
    accept: function(event)
    {
        return true;
    }
}

/**
 * @constructor
 * @extends {WebInspector.TimelineModel.Filter}
 * @param {!Array.<string>} visibleTypes
 */
WebInspector.TimelineVisibleEventsFilter = function(visibleTypes)
{
    WebInspector.TimelineModel.Filter.call(this);
    this._visibleTypes = new Set(visibleTypes);
}

WebInspector.TimelineVisibleEventsFilter.prototype = {
    /**
     * @override
     * @param {!WebInspector.TracingModel.Event} event
     * @return {boolean}
     */
    accept: function(event)
    {
        return this._visibleTypes.has(WebInspector.TimelineModel._eventType(event));
    },

    __proto__: WebInspector.TimelineModel.Filter.prototype
}

/**
 * @constructor
 * @extends {WebInspector.TimelineModel.Filter}
 * @param {!Array<string>} excludeNames
 */
WebInspector.ExclusiveNameFilter = function(excludeNames)
{
    WebInspector.TimelineModel.Filter.call(this);
    this._excludeNames = new Set(excludeNames);
}

WebInspector.ExclusiveNameFilter.prototype = {
    /**
     * @override
     * @param {!WebInspector.TracingModel.Event} event
     * @return {boolean}
     */
    accept: function(event)
    {
        return !this._excludeNames.has(event.name);
    },

    __proto__: WebInspector.TimelineModel.Filter.prototype
}

/**
 * @constructor
 * @extends {WebInspector.TimelineModel.Filter}
 */
WebInspector.ExcludeTopLevelFilter = function()
{
    WebInspector.TimelineModel.Filter.call(this);
}

WebInspector.ExcludeTopLevelFilter.prototype = {
    /**
     * @override
     * @param {!WebInspector.TracingModel.Event} event
     * @return {boolean}
     */
    accept: function(event)
    {
        return !WebInspector.TracingModel.isTopLevelEvent(event);
    },

    __proto__: WebInspector.TimelineModel.Filter.prototype
}

/**
 * @constructor
 * @param {!WebInspector.TracingModel.Event} event
 */
WebInspector.InvalidationTrackingEvent = function(event)
{
    /** @type {string} */
    this.type = event.name;
    /** @type {number} */
    this.startTime = event.startTime;
    /** @type {!WebInspector.TracingModel.Event} */
    this._tracingEvent = event;

    var eventData = event.args["data"];

    /** @type {number} */
    this.frame = eventData["frame"];
    /** @type {?number} */
    this.nodeId = eventData["nodeId"];
    /** @type {?string} */
    this.nodeName = eventData["nodeName"];
    /** @type {?number} */
    this.paintId = eventData["paintId"];
    /** @type {?number} */
    this.invalidationSet = eventData["invalidationSet"];
    /** @type {?string} */
    this.invalidatedSelectorId = eventData["invalidatedSelectorId"];
    /** @type {?string} */
    this.changedId = eventData["changedId"];
    /** @type {?string} */
    this.changedClass = eventData["changedClass"];
    /** @type {?string} */
    this.changedAttribute = eventData["changedAttribute"];
    /** @type {?string} */
    this.changedPseudo = eventData["changedPseudo"];
    /** @type {?string} */
    this.selectorPart = eventData["selectorPart"];
    /** @type {?string} */
    this.extraData = eventData["extraData"];
    /** @type {?Array.<!Object.<string, number>>} */
    this.invalidationList = eventData["invalidationList"];
    /** @type {!WebInspector.InvalidationCause} */
    this.cause = {reason: eventData["reason"], stackTrace: eventData["stackTrace"]};

    // FIXME: Move this to TimelineUIUtils.js.
    if (!this.cause.reason && this.cause.stackTrace && this.type === WebInspector.TimelineModel.RecordType.LayoutInvalidationTracking)
        this.cause.reason = "Layout forced";
}

/** @typedef {{reason: string, stackTrace: ?Array<!RuntimeAgent.CallFrame>}} */
WebInspector.InvalidationCause;

/**
 * @constructor
 */
WebInspector.InvalidationTracker = function()
{
    this._initializePerFrameState();
}

WebInspector.InvalidationTracker.prototype = {
    /**
     * @param {!WebInspector.InvalidationTrackingEvent} invalidation
     */
    addInvalidation: function(invalidation)
    {
        this._startNewFrameIfNeeded();

        if (!invalidation.nodeId && !invalidation.paintId) {
            console.error("Invalidation lacks node information.");
            console.error(invalidation);
            return;
        }

        // PaintInvalidationTracking events provide a paintId and a nodeId which
        // we can use to update the paintId for all other invalidation tracking
        // events.
        var recordTypes = WebInspector.TimelineModel.RecordType;
        if (invalidation.type === recordTypes.PaintInvalidationTracking && invalidation.nodeId) {
            var invalidations = this._invalidationsByNodeId[invalidation.nodeId] || [];
            for (var i = 0; i < invalidations.length; ++i)
                invalidations[i].paintId = invalidation.paintId;

            // PaintInvalidationTracking is only used for updating paintIds.
            return;
        }

        // Suppress StyleInvalidator StyleRecalcInvalidationTracking invalidations because they
        // will be handled by StyleInvalidatorInvalidationTracking.
        // FIXME: Investigate if we can remove StyleInvalidator invalidations entirely.
        if (invalidation.type === recordTypes.StyleRecalcInvalidationTracking && invalidation.cause.reason === "StyleInvalidator")
            return;

        // Style invalidation events can occur before and during recalc style. didRecalcStyle
        // handles style invalidations that occur before the recalc style event but we need to
        // handle style recalc invalidations during recalc style here.
        var styleRecalcInvalidation = (invalidation.type === recordTypes.ScheduleStyleInvalidationTracking
            || invalidation.type === recordTypes.StyleInvalidatorInvalidationTracking
            || invalidation.type === recordTypes.StyleRecalcInvalidationTracking);
        if (styleRecalcInvalidation) {
            var duringRecalcStyle = invalidation.startTime && this._lastRecalcStyle
                && invalidation.startTime >= this._lastRecalcStyle.startTime
                && invalidation.startTime <= this._lastRecalcStyle.endTime;
            if (duringRecalcStyle)
                this._associateWithLastRecalcStyleEvent(invalidation);
        }

        // Record the invalidation so later events can look it up.
        if (this._invalidations[invalidation.type])
            this._invalidations[invalidation.type].push(invalidation);
        else
            this._invalidations[invalidation.type] = [ invalidation ];
        if (invalidation.nodeId) {
            if (this._invalidationsByNodeId[invalidation.nodeId])
                this._invalidationsByNodeId[invalidation.nodeId].push(invalidation);
            else
                this._invalidationsByNodeId[invalidation.nodeId] = [ invalidation ];
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} recalcStyleEvent
     */
    didRecalcStyle: function(recalcStyleEvent)
    {
        this._lastRecalcStyle = recalcStyleEvent;
        var types = [WebInspector.TimelineModel.RecordType.ScheduleStyleInvalidationTracking,
                WebInspector.TimelineModel.RecordType.StyleInvalidatorInvalidationTracking,
                WebInspector.TimelineModel.RecordType.StyleRecalcInvalidationTracking];
        for (var invalidation of this._invalidationsOfTypes(types))
            this._associateWithLastRecalcStyleEvent(invalidation);
    },

    /**
     * @param {!WebInspector.InvalidationTrackingEvent} invalidation
     */
    _associateWithLastRecalcStyleEvent: function(invalidation)
    {
        if (invalidation.linkedRecalcStyleEvent)
            return;

        var recordTypes = WebInspector.TimelineModel.RecordType;
        var recalcStyleFrameId = this._lastRecalcStyle.args["beginData"]["frame"];
        if (invalidation.type === recordTypes.StyleInvalidatorInvalidationTracking) {
            // Instead of calling _addInvalidationToEvent directly, we create synthetic
            // StyleRecalcInvalidationTracking events which will be added in _addInvalidationToEvent.
            this._addSyntheticStyleRecalcInvalidations(this._lastRecalcStyle, recalcStyleFrameId, invalidation);
        } else if (invalidation.type === recordTypes.ScheduleStyleInvalidationTracking) {
            // ScheduleStyleInvalidationTracking events are only used for adding information to
            // StyleInvalidatorInvalidationTracking events. See: _addSyntheticStyleRecalcInvalidations.
        } else {
            this._addInvalidationToEvent(this._lastRecalcStyle, recalcStyleFrameId, invalidation);
        }

        invalidation.linkedRecalcStyleEvent = true;
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @param {number} frameId
     * @param {!WebInspector.InvalidationTrackingEvent} styleInvalidatorInvalidation
     */
    _addSyntheticStyleRecalcInvalidations: function(event, frameId, styleInvalidatorInvalidation)
    {
        if (!styleInvalidatorInvalidation.invalidationList) {
            this._addSyntheticStyleRecalcInvalidation(styleInvalidatorInvalidation._tracingEvent, styleInvalidatorInvalidation);
            return;
        }
        if (!styleInvalidatorInvalidation.nodeId) {
            console.error("Invalidation lacks node information.");
            console.error(invalidation);
            return;
        }
        for (var i = 0; i < styleInvalidatorInvalidation.invalidationList.length; i++) {
            var setId = styleInvalidatorInvalidation.invalidationList[i]["id"];
            var lastScheduleStyleRecalculation;
            var nodeInvalidations = this._invalidationsByNodeId[styleInvalidatorInvalidation.nodeId] || [];
            for (var j = 0; j < nodeInvalidations.length; j++) {
                var invalidation = nodeInvalidations[j];
                if (invalidation.frame !== frameId || invalidation.invalidationSet !== setId || invalidation.type !== WebInspector.TimelineModel.RecordType.ScheduleStyleInvalidationTracking)
                    continue;
                lastScheduleStyleRecalculation = invalidation;
            }
            if (!lastScheduleStyleRecalculation) {
                console.error("Failed to lookup the event that scheduled a style invalidator invalidation.");
                continue;
            }
            this._addSyntheticStyleRecalcInvalidation(lastScheduleStyleRecalculation._tracingEvent, styleInvalidatorInvalidation);
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} baseEvent
     * @param {!WebInspector.InvalidationTrackingEvent} styleInvalidatorInvalidation
     */
    _addSyntheticStyleRecalcInvalidation: function(baseEvent, styleInvalidatorInvalidation)
    {
        var invalidation = new WebInspector.InvalidationTrackingEvent(baseEvent);
        invalidation.type = WebInspector.TimelineModel.RecordType.StyleRecalcInvalidationTracking;
        invalidation.synthetic = true;
        if (styleInvalidatorInvalidation.cause.reason)
            invalidation.cause.reason = styleInvalidatorInvalidation.cause.reason;
        if (styleInvalidatorInvalidation.selectorPart)
            invalidation.selectorPart = styleInvalidatorInvalidation.selectorPart;

        this.addInvalidation(invalidation);
        if (!invalidation.linkedRecalcStyleEvent)
            this._associateWithLastRecalcStyleEvent(invalidation);
    },

    /**
     * @param {!WebInspector.TracingModel.Event} layoutEvent
     */
    didLayout: function(layoutEvent)
    {
        var layoutFrameId = layoutEvent.args["beginData"]["frame"];
        for (var invalidation of this._invalidationsOfTypes([WebInspector.TimelineModel.RecordType.LayoutInvalidationTracking])) {
            if (invalidation.linkedLayoutEvent)
                continue;
            this._addInvalidationToEvent(layoutEvent, layoutFrameId, invalidation);
            invalidation.linkedLayoutEvent = true;
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} paintEvent
     */
    didPaint: function(paintEvent)
    {
        this._didPaint = true;

        // If a paint doesn't have a corresponding graphics layer id, it paints
        // into its parent so add an effectivePaintId to these events.
        var layerId = paintEvent.args["data"]["layerId"];
        if (layerId)
            this._lastPaintWithLayer = paintEvent;
        // Quietly discard top-level paints without layerId, as these are likely
        // to come from overlay.
        if (!this._lastPaintWithLayer)
            return;

        var effectivePaintId = this._lastPaintWithLayer.args["data"]["nodeId"];
        var paintFrameId = paintEvent.args["data"]["frame"];
        var types = [WebInspector.TimelineModel.RecordType.StyleRecalcInvalidationTracking,
            WebInspector.TimelineModel.RecordType.LayoutInvalidationTracking,
            WebInspector.TimelineModel.RecordType.PaintInvalidationTracking,
            WebInspector.TimelineModel.RecordType.ScrollInvalidationTracking];
        for (var invalidation of this._invalidationsOfTypes(types)) {
            if (invalidation.paintId === effectivePaintId)
                this._addInvalidationToEvent(paintEvent, paintFrameId, invalidation);
        }
    },

    /**
     * @param {!WebInspector.TracingModel.Event} event
     * @param {number} eventFrameId
     * @param {!WebInspector.InvalidationTrackingEvent} invalidation
     */
    _addInvalidationToEvent: function(event, eventFrameId, invalidation)
    {
        if (eventFrameId !== invalidation.frame)
            return;
        if (!event.invalidationTrackingEvents)
            event.invalidationTrackingEvents = [ invalidation ];
        else
            event.invalidationTrackingEvents.push(invalidation);
    },

    /**
     * @param {!Array.<string>=} types
     * @return {!Iterator.<!WebInspector.InvalidationTrackingEvent>}
     */
    _invalidationsOfTypes: function(types)
    {
        var invalidations = this._invalidations;
        if (!types)
            types = Object.keys(invalidations);
        function* generator()
        {
            for (var i = 0; i < types.length; ++i) {
                var invalidationList = invalidations[types[i]] || [];
                for (var j = 0; j < invalidationList.length; ++j)
                    yield invalidationList[j];
            }
        }
        return generator();
    },

    _startNewFrameIfNeeded: function()
    {
        if (!this._didPaint)
            return;

        this._initializePerFrameState();
    },

    _initializePerFrameState: function()
    {
        /** @type {!Object.<string, !Array.<!WebInspector.InvalidationTrackingEvent>>} */
        this._invalidations = {};
        /** @type {!Object.<number, !Array.<!WebInspector.InvalidationTrackingEvent>>} */
        this._invalidationsByNodeId = {};

        this._lastRecalcStyle = undefined;
        this._lastPaintWithLayer = undefined;
        this._didPaint = false;
    }
}

/**
 * @constructor
 */
WebInspector.TimelineAsyncEventTracker = function()
{
    WebInspector.TimelineAsyncEventTracker._initialize();
    /** @type {!Map<!WebInspector.TimelineModel.RecordType, !Map<string, !WebInspector.TracingModel.Event>>} */
    this._initiatorByType = new Map();
    for (var initiator of WebInspector.TimelineAsyncEventTracker._asyncEvents.keys())
        this._initiatorByType.set(initiator, new Map());
}

WebInspector.TimelineAsyncEventTracker._initialize = function()
{
    if (WebInspector.TimelineAsyncEventTracker._asyncEvents)
        return;
    var events = new Map();
    var type = WebInspector.TimelineModel.RecordType;

    events.set(type.TimerInstall, {causes: [type.TimerFire], joinBy: "timerId"});
    events.set(type.ResourceSendRequest, {causes: [type.ResourceReceiveResponse, type.ResourceReceivedData, type.ResourceFinish], joinBy: "requestId"});
    events.set(type.RequestAnimationFrame, {causes: [type.FireAnimationFrame], joinBy: "id"});
    events.set(type.RequestIdleCallback, {causes: [type.FireIdleCallback], joinBy: "id"});
    events.set(type.WebSocketCreate, {causes: [type.WebSocketSendHandshakeRequest, type.WebSocketReceiveHandshakeResponse, type.WebSocketDestroy], joinBy: "identifier"});

    WebInspector.TimelineAsyncEventTracker._asyncEvents = events;
    /** @type {!Map<!WebInspector.TimelineModel.RecordType, !WebInspector.TimelineModel.RecordType>} */
    WebInspector.TimelineAsyncEventTracker._typeToInitiator = new Map();
    for (var entry of events) {
        var types = entry[1].causes;
        for (type of types)
            WebInspector.TimelineAsyncEventTracker._typeToInitiator.set(type, entry[0]);
    }
}

WebInspector.TimelineAsyncEventTracker.prototype = {
    /**
     * @param {!WebInspector.TracingModel.Event} event
     */
    processEvent: function(event)
    {
        var initiatorType = WebInspector.TimelineAsyncEventTracker._typeToInitiator.get(/** @type {!WebInspector.TimelineModel.RecordType} */ (event.name));
        var isInitiator = !initiatorType;
        if (!initiatorType)
            initiatorType = /** @type {!WebInspector.TimelineModel.RecordType} */ (event.name);
        var initiatorInfo = WebInspector.TimelineAsyncEventTracker._asyncEvents.get(initiatorType);
        if (!initiatorInfo)
            return;
        var id = event.args["data"][initiatorInfo.joinBy];
        if (!id)
            return;
        /** @type {!Map<string, !WebInspector.TracingModel.Event>|undefined} */
        var initiatorMap = this._initiatorByType.get(initiatorType);
        if (isInitiator)
            initiatorMap.set(id, event);
        else
            event.initiator = initiatorMap.get(id) || null;
    }
}

},{}],232:[function(require,module,exports){
// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

WebInspector.TimelineProfileTree = { };

/**
 * @constructor
 */
WebInspector.TimelineProfileTree.Node = function()
{
    /** @type {number} */
    this.totalTime;
    /** @type {number} */
    this.selfTime;
    /** @type {string} */
    this.id;
    /** @type {!WebInspector.TracingModel.Event} */
    this.event;
    /** @type {?Map<string|symbol,!WebInspector.TimelineProfileTree.Node>} */
    this.children;
    /** @type {?WebInspector.TimelineProfileTree.Node} */
    this.parent;
    this._isGroupNode = false;
}

WebInspector.TimelineProfileTree.Node.prototype = {
    /**
     * @return {boolean}
     */
    isGroupNode: function()
    {
        return this._isGroupNode;
    }
}

/**
 * @param {!Array<!WebInspector.TracingModel.Event>} events
 * @param {!Array<!WebInspector.TimelineModel.Filter>} filters
 * @param {number} startTime
 * @param {number} endTime
 * @param {function(!WebInspector.TracingModel.Event):(string|symbol)=} eventIdCallback
 * @return {!WebInspector.TimelineProfileTree.Node}
 */
WebInspector.TimelineProfileTree.buildTopDown = function(events, filters, startTime, endTime, eventIdCallback)
{
    // Temporarily deposit a big enough value that exceeds the max recording time.
    var /** @const */ initialTime = 1e7;
    var root = new WebInspector.TimelineProfileTree.Node();
    root.totalTime = initialTime;
    root.selfTime = initialTime;
    root.children = /** @type {!Map<string, !WebInspector.TimelineProfileTree.Node>} */ (new Map());
    var parent = root;

    /**
     * @param {!WebInspector.TracingModel.Event} e
     */
    function onStartEvent(e)
    {
        if (!WebInspector.TimelineModel.isVisible(filters, e))
            return;
        var time = e.endTime ? Math.min(endTime, e.endTime) - Math.max(startTime, e.startTime) : 0;
        var id = eventIdCallback ? eventIdCallback(e) : Symbol("uniqueEventId");
        if (!parent.children)
            parent.children = /** @type {!Map<string,!WebInspector.TimelineProfileTree.Node>} */ (new Map());
        var node = parent.children.get(id);
        if (node) {
            node.selfTime += time;
            node.totalTime += time;
        } else {
            node = new WebInspector.TimelineProfileTree.Node();
            node.totalTime = time;
            node.selfTime = time;
            node.parent = parent;
            node.id = id;
            node.event = e;
            parent.children.set(id, node);
        }
        parent.selfTime -= time;
        if (parent.selfTime < 0) {
            console.log("Error: Negative self of " + parent.selfTime, e);
            parent.selfTime = 0;
        }
        if (e.endTime)
            parent = node;
    }

    /**
     * @param {!WebInspector.TracingModel.Event} e
     */
    function onEndEvent(e)
    {
        if (!WebInspector.TimelineModel.isVisible(filters, e))
            return;
        parent = parent.parent;
    }

    var instantEventCallback = eventIdCallback ? undefined : onStartEvent; // Ignore instant events when aggregating.
    WebInspector.TimelineModel.forEachEvent(events, onStartEvent, onEndEvent, instantEventCallback, startTime, endTime);
    root.totalTime -= root.selfTime;
    root.selfTime = 0;
    return root;
}

/**
 * @param {!WebInspector.TimelineProfileTree.Node} topDownTree
 * @param {?function(!WebInspector.TimelineProfileTree.Node):!WebInspector.TimelineProfileTree.Node=} groupingCallback
 * @return {!WebInspector.TimelineProfileTree.Node}
 */
WebInspector.TimelineProfileTree.buildBottomUp = function(topDownTree, groupingCallback)
{
    var buRoot = new WebInspector.TimelineProfileTree.Node();
    buRoot.selfTime = 0;
    buRoot.totalTime = 0;
    /** @type {!Map<string, !WebInspector.TimelineProfileTree.Node>} */
    buRoot.children = new Map();
    var nodesOnStack = /** @type {!Set<string>} */ (new Set());
    if (topDownTree.children)
        topDownTree.children.forEach(processNode);
    buRoot.totalTime = topDownTree.totalTime;

    /**
     * @param {!WebInspector.TimelineProfileTree.Node} tdNode
     */
    function processNode(tdNode)
    {
        var buParent = groupingCallback && groupingCallback(tdNode) || buRoot;
        if (buParent !== buRoot) {
            buRoot.children.set(buParent.id, buParent);
            buParent.parent = buRoot;
        }
        appendNode(tdNode, buParent);
        var hadNode = nodesOnStack.has(tdNode.id);
        if (!hadNode)
            nodesOnStack.add(tdNode.id);
        if (tdNode.children)
            tdNode.children.forEach(processNode);
        if (!hadNode)
            nodesOnStack.delete(tdNode.id);
    }

    /**
     * @param {!WebInspector.TimelineProfileTree.Node} tdNode
     * @param {!WebInspector.TimelineProfileTree.Node} buParent
     */
    function appendNode(tdNode, buParent)
    {
        var selfTime = tdNode.selfTime;
        var totalTime = tdNode.totalTime;
        buParent.selfTime += selfTime;
        buParent.totalTime += selfTime;
        while (tdNode.parent) {
            if (!buParent.children)
                buParent.children = /** @type {!Map<string,!WebInspector.TimelineProfileTree.Node>} */ (new Map());
            var id = tdNode.id;
            var buNode = buParent.children.get(id);
            if (!buNode) {
                buNode = new WebInspector.TimelineProfileTree.Node();
                buNode.selfTime = selfTime;
                buNode.totalTime = totalTime;
                buNode.event = tdNode.event;
                buNode.id = id;
                buNode.parent = buParent;
                buParent.children.set(id, buNode);
            } else {
                buNode.selfTime += selfTime;
                if (!nodesOnStack.has(id))
                    buNode.totalTime += totalTime;
            }
            tdNode = tdNode.parent;
            buParent = buNode;
        }
    }

    // Purge zero self time nodes.
    var rootChildren = buRoot.children;
    for (var item of rootChildren.entries()) {
        if (item[1].selfTime === 0)
            rootChildren.delete(/** @type {string} */(item[0]));
    }

    return buRoot;
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {?string}
 */
WebInspector.TimelineProfileTree.eventURL = function(event)
{
    var data = event.args["data"] || event.args["beginData"];
    if (data && data["url"])
        return data["url"];
    var frame = WebInspector.TimelineProfileTree.eventStackFrame(event);
    while (frame) {
        var url = frame["url"];
        if (url)
            return url;
        frame = frame.parent;
    }
    return null;
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {?RuntimeAgent.CallFrame}
 */
WebInspector.TimelineProfileTree.eventStackFrame = function(event)
{
    if (event.name === WebInspector.TimelineModel.RecordType.JSFrame)
        return /** @type {?RuntimeAgent.CallFrame} */ (event.args["data"] || null);
    var topFrame = event.stackTrace && event.stackTrace[0];
    if (topFrame)
        return /** @type {!RuntimeAgent.CallFrame} */ (topFrame);
    var initiator = event.initiator;
    return /** @type {?RuntimeAgent.CallFrame} */ (initiator && initiator.stackTrace && initiator.stackTrace[0] || null);
}

/**
 * @constructor
 * @param {function(!WebInspector.TracingModel.Event):string} titleMapper
 * @param {function(!WebInspector.TracingModel.Event):string} categoryMapper
 */
WebInspector.TimelineAggregator = function(titleMapper, categoryMapper)
{
    this._titleMapper = titleMapper;
    this._categoryMapper = categoryMapper;
    /** @type {!Map<string, !WebInspector.TimelineProfileTree.Node>} */
    this._groupNodes = new Map();
}

/**
 * @enum {string}
 */
WebInspector.TimelineAggregator.GroupBy = {
    None: "None",
    EventName: "EventName",
    Category: "Category",
    Domain: "Domain",
    Subdomain: "Subdomain",
    URL: "URL"
}

/**
 * @param {!WebInspector.TracingModel.Event} event
 * @return {string}
 */
WebInspector.TimelineAggregator.eventId = function(event)
{
    if (event.name === WebInspector.TimelineModel.RecordType.JSFrame) {
        var data = event.args["data"];
        return "f:" + data["functionName"] + "@" + (data["scriptId"] || data["url"] || "");
    }
    return event.name + ":@" + WebInspector.TimelineProfileTree.eventURL(event);
}

WebInspector.TimelineAggregator._extensionInternalPrefix = "extensions::";
WebInspector.TimelineAggregator._groupNodeFlag = Symbol("groupNode");

/**
 * @param {string} url
 * @return {boolean}
 */
WebInspector.TimelineAggregator.isExtensionInternalURL = function(url)
{
    return url.startsWith(WebInspector.TimelineAggregator._extensionInternalPrefix);
}

WebInspector.TimelineAggregator.prototype = {
    /**
     * @param {!WebInspector.TimelineAggregator.GroupBy} groupBy
     * @return {?function(!WebInspector.TimelineProfileTree.Node):!WebInspector.TimelineProfileTree.Node}
     */
    groupFunction: function(groupBy)
    {
        var idMapper = this._nodeToGroupIdFunction(groupBy);
        return idMapper && this._nodeToGroupNode.bind(this, idMapper);
    },

    /**
     * @param {!WebInspector.TimelineProfileTree.Node} root
     * @param {!WebInspector.TimelineAggregator.GroupBy} groupBy
     * @return {!WebInspector.TimelineProfileTree.Node}
     */
    performGrouping: function(root, groupBy)
    {
        var nodeMapper = this.groupFunction(groupBy);
        if (!nodeMapper)
            return root;
        for (var node of root.children.values()) {
            var groupNode = nodeMapper(node);
            groupNode.parent = root;
            groupNode.selfTime += node.selfTime;
            groupNode.totalTime += node.totalTime;
            groupNode.children.set(node.id, node);
            node.parent = root;
        }
        root.children = this._groupNodes;
        return root;
    },

    /**
     * @param {!WebInspector.TimelineAggregator.GroupBy} groupBy
     * @return {?function(!WebInspector.TimelineProfileTree.Node):string}
     */
    _nodeToGroupIdFunction: function(groupBy)
    {
        /**
         * @param {!WebInspector.TimelineProfileTree.Node} node
         * @return {string}
         */
        function groupByURL(node)
        {
            return WebInspector.TimelineProfileTree.eventURL(node.event) || "";
        }

        /**
         * @param {boolean} groupSubdomains
         * @param {!WebInspector.TimelineProfileTree.Node} node
         * @return {string}
         */
        function groupByDomain(groupSubdomains, node)
        {
            var url = WebInspector.TimelineProfileTree.eventURL(node.event) || "";
            if (WebInspector.TimelineAggregator.isExtensionInternalURL(url))
                return WebInspector.TimelineAggregator._extensionInternalPrefix;
            var parsedURL = url.asParsedURL();
            if (!parsedURL)
                return "";
            if (parsedURL.scheme === "chrome-extension")
                return parsedURL.scheme + "://" + parsedURL.host;
            if (!groupSubdomains)
                return parsedURL.host;
            if (/^[.0-9]+$/.test(parsedURL.host))
                return parsedURL.host;
            var domainMatch = /([^.]*\.)?[^.]*$/.exec(parsedURL.host);
            return domainMatch && domainMatch[0] || "";
        }

        switch (groupBy) {
        case WebInspector.TimelineAggregator.GroupBy.None: return null;
        case WebInspector.TimelineAggregator.GroupBy.EventName: return node => node.event ? this._titleMapper(node.event) : "";
        case WebInspector.TimelineAggregator.GroupBy.Category: return node => node.event ? this._categoryMapper(node.event) : "";
        case WebInspector.TimelineAggregator.GroupBy.Subdomain: return groupByDomain.bind(null, false);
        case WebInspector.TimelineAggregator.GroupBy.Domain: return groupByDomain.bind(null, true);
        case WebInspector.TimelineAggregator.GroupBy.URL: return groupByURL;
        default: return null;
        }
    },

    /**
     * @param {string} id
     * @param {!WebInspector.TracingModel.Event} event
     * @return {!WebInspector.TimelineProfileTree.Node}
     */
    _buildGroupNode: function(id, event)
    {
        var groupNode = new WebInspector.TimelineProfileTree.Node();
        groupNode.id = id;
        groupNode.selfTime = 0;
        groupNode.totalTime = 0;
        groupNode.children = new Map();
        groupNode.event = event;
        groupNode._isGroupNode = true;
        this._groupNodes.set(id, groupNode);
        return groupNode;
    },

    /**
     * @param {function(!WebInspector.TimelineProfileTree.Node):string} nodeToGroupId
     * @param {!WebInspector.TimelineProfileTree.Node} node
     * @return {!WebInspector.TimelineProfileTree.Node}
     */
    _nodeToGroupNode: function(nodeToGroupId, node)
    {
        var id = nodeToGroupId(node);
        return this._groupNodes.get(id) || this._buildGroupNode(id, node.event);
    },
}

},{}],233:[function(require,module,exports){
// Copyright 2014 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @constructor
 * @extends {WebInspector.ViewportDataGrid}
 * @param {!Array.<!WebInspector.DataGrid.ColumnDescriptor>} columnsArray
 * @param {function(!WebInspector.DataGridNode, string, string, string)=} editCallback
 * @param {function(!WebInspector.DataGridNode)=} deleteCallback
 * @param {function()=} refreshCallback
 * @param {function(!WebInspector.ContextMenu, !WebInspector.DataGridNode)=} contextMenuCallback
 */
WebInspector.SortableDataGrid = function(columnsArray, editCallback, deleteCallback, refreshCallback, contextMenuCallback)
{
    WebInspector.ViewportDataGrid.call(this, columnsArray, editCallback, deleteCallback, refreshCallback, contextMenuCallback);
    /** @type {!WebInspector.SortableDataGrid.NodeComparator} */
    this._sortingFunction = WebInspector.SortableDataGrid.TrivialComparator;
    this.setRootNode(new WebInspector.SortableDataGridNode());
}

/** @typedef {function(!WebInspector.DataGridNode, !WebInspector.DataGridNode):number} */
WebInspector.SortableDataGrid.NodeComparator;

/**
 * @param {!WebInspector.DataGridNode} a
 * @param {!WebInspector.DataGridNode} b
 * @return {number}
 */
WebInspector.SortableDataGrid.TrivialComparator = function(a, b)
{
    return 0;
}

/**
 * @param {string} columnIdentifier
 * @param {!WebInspector.DataGridNode} a
 * @param {!WebInspector.DataGridNode} b
 * @return {number}
 */
WebInspector.SortableDataGrid.NumericComparator = function(columnIdentifier, a, b)
{
    var aValue = a.data[columnIdentifier];
    var bValue = b.data[columnIdentifier];
    var aNumber = Number(aValue instanceof Node ? aValue.textContent : aValue);
    var bNumber = Number(bValue instanceof Node ? bValue.textContent : bValue);
    return aNumber < bNumber ? -1 : (aNumber > bNumber ? 1 : 0);
}

/**
 * @param {string} columnIdentifier
 * @param {!WebInspector.DataGridNode} a
 * @param {!WebInspector.DataGridNode} b
 * @return {number}
 */
WebInspector.SortableDataGrid.StringComparator = function(columnIdentifier, a, b)
{
    var aValue = a.data[columnIdentifier];
    var bValue = b.data[columnIdentifier];
    var aString = aValue instanceof Node ? aValue.textContent : String(aValue);
    var bString = bValue instanceof Node ? bValue.textContent : String(bValue);
    return aString < bString ? -1 : (aString > bString ? 1 : 0);
}

/**
 * @param {!WebInspector.SortableDataGrid.NodeComparator} comparator
 * @param {boolean} reverseMode
 * @param {!WebInspector.DataGridNode} a
 * @param {!WebInspector.DataGridNode} b
 * @return {number}
 */
WebInspector.SortableDataGrid.Comparator = function(comparator, reverseMode, a, b)
{
    return reverseMode ? comparator(b, a) : comparator(a, b);
}

/**
 * @param {!Array.<string>} columnNames
 * @param {!Array.<string>} values
 * @return {?WebInspector.SortableDataGrid}
 */
WebInspector.SortableDataGrid.create = function(columnNames, values)
{
    var numColumns = columnNames.length;
    if (!numColumns)
        return null;

    var columns = [];
    for (var i = 0; i < columnNames.length; ++i)
        columns.push({ title: columnNames[i], width: columnNames[i].length, sortable: true });

    var nodes = [];
    for (var i = 0; i < values.length / numColumns; ++i) {
        var data = {};
        for (var j = 0; j < columnNames.length; ++j)
            data[j] = values[numColumns * i + j];

        var node = new WebInspector.SortableDataGridNode(data);
        node.selectable = false;
        nodes.push(node);
    }

    var dataGrid = new WebInspector.SortableDataGrid(columns);
    var length = nodes.length;
    var rootNode = dataGrid.rootNode();
    for (var i = 0; i < length; ++i)
        rootNode.appendChild(nodes[i]);

    dataGrid.addEventListener(WebInspector.DataGrid.Events.SortingChanged, sortDataGrid);

    function sortDataGrid()
    {
        var nodes = dataGrid.rootNode().children;
        var sortColumnIdentifier = dataGrid.sortColumnIdentifier();
        if (!sortColumnIdentifier)
            return;

        var columnIsNumeric = true;
        for (var i = 0; i < nodes.length; i++) {
            var value = nodes[i].data[sortColumnIdentifier];
            if (isNaN(value instanceof Node ? value.textContent : value)) {
                columnIsNumeric = false;
                break;
            }
        }

        var comparator = columnIsNumeric ? WebInspector.SortableDataGrid.NumericComparator : WebInspector.SortableDataGrid.StringComparator;
        dataGrid.sortNodes(comparator.bind(null, sortColumnIdentifier), !dataGrid.isSortOrderAscending());
    }
    return dataGrid;
}

WebInspector.SortableDataGrid.prototype = {
    /**
     * @param {!WebInspector.DataGridNode} node
     */
    insertChild: function(node)
    {
        var root = /** @type {!WebInspector.SortableDataGridNode} */ (this.rootNode());
        root.insertChildOrdered(node);
    },

    /**
     * @param {!WebInspector.SortableDataGrid.NodeComparator} comparator
     * @param {boolean} reverseMode
     */
    sortNodes: function(comparator, reverseMode)
    {
        this._sortingFunction = WebInspector.SortableDataGrid.Comparator.bind(null, comparator, reverseMode);
        this._rootNode._sortChildren(reverseMode);
        this.scheduleUpdateStructure();
    },

    __proto__: WebInspector.ViewportDataGrid.prototype
}

/**
 * @constructor
 * @extends {WebInspector.ViewportDataGridNode}
 * @param {?Object.<string, *>=} data
 * @param {boolean=} hasChildren
 */
WebInspector.SortableDataGridNode = function(data, hasChildren)
{
    WebInspector.ViewportDataGridNode.call(this, data, hasChildren);
}

WebInspector.SortableDataGridNode.prototype = {
    /**
     * @param {!WebInspector.DataGridNode} node
     */
    insertChildOrdered: function(node)
    {
        this.insertChild(node, this.children.upperBound(node, this.dataGrid._sortingFunction));
    },

    _sortChildren: function()
    {
        this.children.sort(this.dataGrid._sortingFunction);
        for (var i = 0; i < this.children.length; ++i)
            this.children[i].recalculateSiblings(i);
        for (var child of this.children)
            child._sortChildren();
    },

    __proto__: WebInspector.ViewportDataGridNode.prototype
}

},{}],234:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":235}],235:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":252}],236:[function(require,module,exports){

// this duplicates some work inside of TimelineTreeView, SortedDataGrid and beyond.
// It's pretty difficult to extract, so we forked.

module.exports = function(WebInspector) {

  function TimelineModelTreeView(model) {
    this._rootNode = model;
  }

  TimelineModelTreeView.prototype.sortingChanged = function(sortItem, sortOrder) {
    if (!sortItem)
      return;
    var sortFunction;
    switch (sortItem) {
      case 'startTime':
        sortFunction = compareStartTime;
        break;
      case 'self':
        sortFunction = compareNumericField.bind(null, 'selfTime');
        break;
      case 'total':
        sortFunction = compareNumericField.bind(null, 'totalTime');
        break;
      case 'activity':
        sortFunction = compareName;
        break;
      default:
        console.assert(false, 'Unknown sort field: ' + sortItem);
        return;
    }
    return this.sortNodes(sortFunction, sortOrder !== 'asc');

    function compareNumericField(field, a, b) {
      var nodeA = (a[1]);
      var nodeB = (b[1]);
      return nodeA[field] - nodeB[field];
    }

    function compareStartTime(a, b) {
      var nodeA = (a[1]);
      var nodeB = (b[1]);
      return nodeA.event.startTime - nodeB.event.startTime;
    }

    function compareName(a, b) {
      var nodeA = (a[1]);
      var nodeB = (b[1]);
      var nameA = WebInspector.TimelineTreeView.eventNameForSorting(nodeA.event);
      var nameB = WebInspector.TimelineTreeView.eventNameForSorting(nodeB.event);
      return nameA.localeCompare(nameB);
    }
  };

  TimelineModelTreeView.prototype.sortNodes = function(comparator, reverseMode) {
    this._sortingFunction = WebInspector.SortableDataGrid.Comparator.bind(null, comparator, reverseMode);
    sortChildren(this._rootNode, this._sortingFunction, reverseMode);
  };

  /**
   * sortChildren has major changes, as it now works on Maps rather than Arrays
   * @param  {WebInspector.TimelineProfileTree.Node} parent
   * @param  {any} sortingFunction
   */
  function sortChildren(parent, sortingFunction) {
    if (!parent.children) return;
    parent.children = new Map([...parent.children.entries()].sort(sortingFunction));
    for (var i = 0; i < parent.children.length; ++i)
      recalculateSiblings(parent.children[i], i);
    for (var child of parent.children.values())
      sortChildren(child, sortingFunction);
  }

  /**
   * @param  {WebInspector.TimelineProfileTree.Node} node
   * @param  {any} myIndex
   */
  function recalculateSiblings(node, myIndex) {
    if (!node.parent)
      return;

    var previousChild = node.parent.children[myIndex - 1] || null;
    if (previousChild)
      previousChild.nextSibling = node;
    node.previousSibling = previousChild;

    var nextChild = node.parent.children[myIndex + 1] || null;
    if (nextChild)
      nextChild.previousSibling = node;
    node.nextSibling = nextChild;
  }

  return TimelineModelTreeView;

};

},{}],237:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":238,"./gl-matrix/mat2.js":239,"./gl-matrix/mat2d.js":240,"./gl-matrix/mat3.js":241,"./gl-matrix/mat4.js":242,"./gl-matrix/quat.js":243,"./gl-matrix/vec2.js":244,"./gl-matrix/vec3.js":245,"./gl-matrix/vec4.js":246}],238:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;
glMatrix.ENABLE_SIMD = false;

// Capability detection
glMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);
glMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

module.exports = glMatrix;

},{}],239:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
mat2.fromValues = function(m00, m01, m10, m11) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
mat2.set = function(out, m00, m01, m10, m11) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m10;
    out[3] = m11;
    return out;
};


/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
mat2.sub = mat2.subtract;

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
mat2.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
mat2.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

module.exports = mat2;

},{"./common.js":238}],240:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
mat2d.fromValues = function(a, b, c, d, tx, ty) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
mat2d.set = function(out, a, b, c, d, tx, ty) {
    out[0] = a;
    out[1] = b;
    out[2] = c;
    out[3] = d;
    out[4] = tx;
    out[5] = ty;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    return out;
};

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
mat2d.sub = mat2d.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
mat2d.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    return out;
};

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
mat2d.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat2d.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));
};

module.exports = mat2d;

},{"./common.js":238}],241:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/*
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && 
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


module.exports = mat3;

},{"./common.js":238}],242:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {
  scalar: {},
  SIMD: {},
};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Transpose the values of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.transpose = function(out, a) {
    var a0, a1, a2, a3,
        tmp01, tmp23,
        out0, out1, out2, out3;

    a0 = SIMD.Float32x4.load(a, 0);
    a1 = SIMD.Float32x4.load(a, 4);
    a2 = SIMD.Float32x4.load(a, 8);
    a3 = SIMD.Float32x4.load(a, 12);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 0,  out0);
    SIMD.Float32x4.store(out, 4,  out1);

    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);
    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);
    SIMD.Float32x4.store(out, 8,  out2);
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Transpse a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Inverts a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.invert = function(out, a) {
  var row0, row1, row2, row3,
      tmp1,
      minor0, minor1, minor2, minor3,
      det,
      a0 = SIMD.Float32x4.load(a, 0),
      a1 = SIMD.Float32x4.load(a, 4),
      a2 = SIMD.Float32x4.load(a, 8),
      a3 = SIMD.Float32x4.load(a, 12);

  // Compute matrix adjugate
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  // Compute matrix determinant
  det   = SIMD.Float32x4.mul(row0, minor0);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);
  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);
  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);
  det   = SIMD.Float32x4.sub(
               SIMD.Float32x4.add(tmp1, tmp1),
               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));
  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);
  if (!det) {
      return null;
  }

  // Compute matrix inverse
  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));
  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));
  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));
  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));
  return out;
}

/**
 * Inverts a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.scalar.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.SIMD.adjoint = function(out, a) {
  var a0, a1, a2, a3;
  var row0, row1, row2, row3;
  var tmp1;
  var minor0, minor1, minor2, minor3;

  var a0 = SIMD.Float32x4.load(a, 0);
  var a1 = SIMD.Float32x4.load(a, 4);
  var a2 = SIMD.Float32x4.load(a, 8);
  var a3 = SIMD.Float32x4.load(a, 12);

  // Transpose the source matrix.  Sort of.  Not a true transpose operation
  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);
  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);
  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);
  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);

  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);
  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);
  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);
  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);

  tmp1   = SIMD.Float32x4.mul(row2, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.mul(row1, tmp1);
  minor1 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);
  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);
  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row1, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);
  minor3 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);
  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);
  minor2 = SIMD.Float32x4.mul(row0, tmp1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);
  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);

  tmp1   = SIMD.Float32x4.mul(row0, row1);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row3);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));
  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);
  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));

  tmp1   = SIMD.Float32x4.mul(row0, row2);
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);
  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);
  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));
  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);
  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));
  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);

  SIMD.Float32x4.store(out, 0,  minor0);
  SIMD.Float32x4.store(out, 4,  minor1);
  SIMD.Float32x4.store(out, 8,  minor2);
  SIMD.Float32x4.store(out, 12, minor3);
  return out;
};

/**
 * Calculates the adjugate of a mat4 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
 mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand, must be a Float32Array
 * @param {mat4} b the second operand, must be a Float32Array
 * @returns {mat4} out
 */
mat4.SIMD.multiply = function (out, a, b) {
    var a0 = SIMD.Float32x4.load(a, 0);
    var a1 = SIMD.Float32x4.load(a, 4);
    var a2 = SIMD.Float32x4.load(a, 8);
    var a3 = SIMD.Float32x4.load(a, 12);

    var b0 = SIMD.Float32x4.load(b, 0);
    var out0 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 0, out0);

    var b1 = SIMD.Float32x4.load(b, 4);
    var out1 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),
                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 4, out1);

    var b2 = SIMD.Float32x4.load(b, 8);
    var out2 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),
                       SIMD.Float32x4.add(
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),
                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 8, out2);

    var b3 = SIMD.Float32x4.load(b, 12);
    var out3 = SIMD.Float32x4.add(
                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),
                   SIMD.Float32x4.add(
                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),
                        SIMD.Float32x4.add(
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),
                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));
    SIMD.Float32x4.store(out, 12, out3);

    return out;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.scalar.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Multiplies two mat4's using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.scalar.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.SIMD.translate = function (out, a, v) {
    var a0 = SIMD.Float32x4.load(a, 0),
        a1 = SIMD.Float32x4.load(a, 4),
        a2 = SIMD.Float32x4.load(a, 8),
        a3 = SIMD.Float32x4.load(a, 12),
        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);

    if (a !== out) {
        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
    }

    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));
    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));
    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));

    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));
    SIMD.Float32x4.store(out, 12, t0);

    return out;
};

/**
 * Translates a mat4 by the given vector using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scalar.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.SIMD.scale = function(out, a, v) {
    var a0, a1, a2;
    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);

    a0 = SIMD.Float32x4.load(a, 0);
    SIMD.Float32x4.store(
        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));

    a1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(
        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));

    a2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(
        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));

    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 */
mat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateX = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
      out[0]  = a[0];
      out[1]  = a[1];
      out[2]  = a[2];
      out[3]  = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_1 = SIMD.Float32x4.load(a, 4);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateY = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_2 = SIMD.Float32x4.load(a, 8);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));
    SIMD.Float32x4.store(out, 8,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.scalar.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.SIMD.rotateZ = function (out, a, rad) {
    var s = SIMD.Float32x4.splat(Math.sin(rad)),
        c = SIMD.Float32x4.splat(Math.cos(rad));

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    var a_0 = SIMD.Float32x4.load(a, 0);
    var a_1 = SIMD.Float32x4.load(a, 4);
    SIMD.Float32x4.store(out, 0,
                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));
    SIMD.Float32x4.store(out, 4,
                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
 mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};



module.exports = mat4;

},{"./common.js":238}],243:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;

module.exports = quat;

},{"./common.js":238,"./mat3.js":241,"./vec3.js":245,"./vec4.js":246}],244:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

module.exports = vec2;

},{"./common.js":238}],245:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

module.exports = vec3;

},{"./common.js":238}],246:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

module.exports = vec4;

},{"./common.js":238}],247:[function(require,module,exports){
/**
 * @preserve
 * Copyright 2015 Igor Bezkrovny
 * All rights reserved. (MIT Licensed)
 *
 * ssim.ts - part of Image Quantization Library
 */
/**
 * - Original TypeScript implementation:
 *   https://github.com/igor-bezkrovny/image-quantization/blob/9f62764ac047c3e53accdf1d7e4e424b0ef2fb60/src/quality/ssim.ts
 * - Based on Java implementation: https://github.com/rhys-e/structural-similarity
 * - For more information see: http://en.wikipedia.org/wiki/Structural_similarity
 */
var ImageSSIM;
(function (ImageSSIM) {
    'use strict';
    /**
     * Grey = 1, GreyAlpha = 2, RGB = 3, RGBAlpha = 4
     */
    (function (Channels) {
        Channels[Channels["Grey"] = 1] = "Grey";
        Channels[Channels["GreyAlpha"] = 2] = "GreyAlpha";
        Channels[Channels["RGB"] = 3] = "RGB";
        Channels[Channels["RGBAlpha"] = 4] = "RGBAlpha";
    })(ImageSSIM.Channels || (ImageSSIM.Channels = {}));
    var Channels = ImageSSIM.Channels;
    /**
     * Entry point.
     * @throws new Error('Images have different sizes!')
     */
    function compare(image1, image2, windowSize, K1, K2, luminance, bitsPerComponent) {
        if (windowSize === void 0) { windowSize = 8; }
        if (K1 === void 0) { K1 = 0.01; }
        if (K2 === void 0) { K2 = 0.03; }
        if (luminance === void 0) { luminance = true; }
        if (bitsPerComponent === void 0) { bitsPerComponent = 8; }
        if (image1.width !== image2.width || image1.height !== image2.height) {
            throw new Error('Images have different sizes!');
        }
        /* tslint:disable:no-bitwise */
        var L = (1 << bitsPerComponent) - 1;
        /* tslint:enable:no-bitwise */
        var c1 = Math.pow((K1 * L), 2), c2 = Math.pow((K2 * L), 2), numWindows = 0, mssim = 0.0;
        var mcs = 0.0;
        function iteration(lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {
            // calculate variance and covariance
            var sigxy, sigsqx, sigsqy;
            sigxy = sigsqx = sigsqy = 0.0;
            for (var i = 0; i < lumaValues1.length; i++) {
                sigsqx += Math.pow((lumaValues1[i] - averageLumaValue1), 2);
                sigsqy += Math.pow((lumaValues2[i] - averageLumaValue2), 2);
                sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
            }
            var numPixelsInWin = lumaValues1.length - 1;
            sigsqx /= numPixelsInWin;
            sigsqy /= numPixelsInWin;
            sigxy /= numPixelsInWin;
            // perform ssim calculation on window
            var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);
            var denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2);
            mssim += numerator / denominator;
            mcs += (2 * sigxy + c2) / (sigsqx + sigsqy + c2);
            numWindows++;
        }
        // calculate SSIM for each window
        Internals._iterate(image1, image2, windowSize, luminance, iteration);
        return { ssim: mssim / numWindows, mcs: mcs / numWindows };
    }
    ImageSSIM.compare = compare;
    /**
     * Internal functions.
     */
    var Internals;
    (function (Internals) {
        function _iterate(image1, image2, windowSize, luminance, callback) {
            var width = image1.width, height = image1.height;
            for (var y = 0; y < height; y += windowSize) {
                for (var x = 0; x < width; x += windowSize) {
                    // avoid out-of-width/height
                    var windowWidth = Math.min(windowSize, width - x), windowHeight = Math.min(windowSize, height - y);
                    var lumaValues1 = _lumaValuesForWindow(image1, x, y, windowWidth, windowHeight, luminance), lumaValues2 = _lumaValuesForWindow(image2, x, y, windowWidth, windowHeight, luminance), averageLuma1 = _averageLuma(lumaValues1), averageLuma2 = _averageLuma(lumaValues2);
                    callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
                }
            }
        }
        Internals._iterate = _iterate;
        function _lumaValuesForWindow(image, x, y, width, height, luminance) {
            var array = image.data, lumaValues = new Float32Array(new ArrayBuffer(width * height * 4)), counter = 0;
            var maxj = y + height;
            for (var j = y; j < maxj; j++) {
                var offset = j * image.width;
                var i = (offset + x) * image.channels;
                var maxi = (offset + x + width) * image.channels;
                switch (image.channels) {
                    case 1 /* Grey */:
                        while (i < maxi) {
                            // (0.212655 +  0.715158 + 0.072187) === 1
                            lumaValues[counter++] = array[i++];
                        }
                        break;
                    case 2 /* GreyAlpha */:
                        while (i < maxi) {
                            lumaValues[counter++] = array[i++] * (array[i++] / 255);
                        }
                        break;
                    case 3 /* RGB */:
                        if (luminance) {
                            while (i < maxi) {
                                lumaValues[counter++] = (array[i++] * 0.212655 + array[i++] * 0.715158 + array[i++] * 0.072187);
                            }
                        }
                        else {
                            while (i < maxi) {
                                lumaValues[counter++] = (array[i++] + array[i++] + array[i++]);
                            }
                        }
                        break;
                    case 4 /* RGBAlpha */:
                        if (luminance) {
                            while (i < maxi) {
                                lumaValues[counter++] = (array[i++] * 0.212655 + array[i++] * 0.715158 + array[i++] * 0.072187) * (array[i++] / 255);
                            }
                        }
                        else {
                            while (i < maxi) {
                                lumaValues[counter++] = (array[i++] + array[i++] + array[i++]) * (array[i++] / 255);
                            }
                        }
                        break;
                }
            }
            return lumaValues;
        }
        function _averageLuma(lumaValues) {
            var sumLuma = 0.0;
            for (var i = 0; i < lumaValues.length; i++) {
                sumLuma += lumaValues[i];
            }
            return sumLuma / lumaValues.length;
        }
    })(Internals || (Internals = {}));
})(ImageSSIM || (ImageSSIM = {}));
module.exports = ImageSSIM;

},{}],248:[function(require,module,exports){
var encode = require('./lib/encoder'),
    decode = require('./lib/decoder');

module.exports = {
  encode: encode,
  decode: decode
};

},{"./lib/decoder":249,"./lib/encoder":250}],249:[function(require,module,exports){
(function (Buffer){
/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /
/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */
/*
   Copyright 2011 notmasteryet

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

// - The JPEG specification can be found in the ITU CCITT Recommendation T.81
//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)
// - The JFIF specification can be found in the JPEG File Interchange Format
//   (www.w3.org/Graphics/JPEG/jfif3.pdf)
// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters
//   in PostScript Level 2, Technical Note #5116
//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)

var JpegImage = (function jpegImage() {
  "use strict";
  var dctZigZag = new Int32Array([
     0,
     1,  8,
    16,  9,  2,
     3, 10, 17, 24,
    32, 25, 18, 11, 4,
     5, 12, 19, 26, 33, 40,
    48, 41, 34, 27, 20, 13,  6,
     7, 14, 21, 28, 35, 42, 49, 56,
    57, 50, 43, 36, 29, 22, 15,
    23, 30, 37, 44, 51, 58,
    59, 52, 45, 38, 31,
    39, 46, 53, 60,
    61, 54, 47,
    55, 62,
    63
  ]);

  var dctCos1  =  4017   // cos(pi/16)
  var dctSin1  =   799   // sin(pi/16)
  var dctCos3  =  3406   // cos(3*pi/16)
  var dctSin3  =  2276   // sin(3*pi/16)
  var dctCos6  =  1567   // cos(6*pi/16)
  var dctSin6  =  3784   // sin(6*pi/16)
  var dctSqrt2 =  5793   // sqrt(2)
  var dctSqrt1d2 = 2896  // sqrt(2) / 2

  function constructor() {
  }

  function buildHuffmanTable(codeLengths, values) {
    var k = 0, code = [], i, j, length = 16;
    while (length > 0 && !codeLengths[length - 1])
      length--;
    code.push({children: [], index: 0});
    var p = code[0], q;
    for (i = 0; i < length; i++) {
      for (j = 0; j < codeLengths[i]; j++) {
        p = code.pop();
        p.children[p.index] = values[k];
        while (p.index > 0) {
          p = code.pop();
        }
        p.index++;
        code.push(p);
        while (code.length <= i) {
          code.push(q = {children: [], index: 0});
          p.children[p.index] = q.children;
          p = q;
        }
        k++;
      }
      if (i + 1 < length) {
        // p here points to last code
        code.push(q = {children: [], index: 0});
        p.children[p.index] = q.children;
        p = q;
      }
    }
    return code[0].children;
  }

  function decodeScan(data, offset,
                      frame, components, resetInterval,
                      spectralStart, spectralEnd,
                      successivePrev, successive) {
    var precision = frame.precision;
    var samplesPerLine = frame.samplesPerLine;
    var scanLines = frame.scanLines;
    var mcusPerLine = frame.mcusPerLine;
    var progressive = frame.progressive;
    var maxH = frame.maxH, maxV = frame.maxV;

    var startOffset = offset, bitsData = 0, bitsCount = 0;
    function readBit() {
      if (bitsCount > 0) {
        bitsCount--;
        return (bitsData >> bitsCount) & 1;
      }
      bitsData = data[offset++];
      if (bitsData == 0xFF) {
        var nextByte = data[offset++];
        if (nextByte) {
          throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);
        }
        // unstuff 0
      }
      bitsCount = 7;
      return bitsData >>> 7;
    }
    function decodeHuffman(tree) {
      var node = tree, bit;
      while ((bit = readBit()) !== null) {
        node = node[bit];
        if (typeof node === 'number')
          return node;
        if (typeof node !== 'object')
          throw "invalid huffman sequence";
      }
      return null;
    }
    function receive(length) {
      var n = 0;
      while (length > 0) {
        var bit = readBit();
        if (bit === null) return;
        n = (n << 1) | bit;
        length--;
      }
      return n;
    }
    function receiveAndExtend(length) {
      var n = receive(length);
      if (n >= 1 << (length - 1))
        return n;
      return n + (-1 << length) + 1;
    }
    function decodeBaseline(component, zz) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : receiveAndExtend(t);
      zz[0]= (component.pred += diff);
      var k = 1;
      while (k < 64) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15)
            break;
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        zz[z] = receiveAndExtend(s);
        k++;
      }
    }
    function decodeDCFirst(component, zz) {
      var t = decodeHuffman(component.huffmanTableDC);
      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);
      zz[0] = (component.pred += diff);
    }
    function decodeDCSuccessive(component, zz) {
      zz[0] |= readBit() << successive;
    }
    var eobrun = 0;
    function decodeACFirst(component, zz) {
      if (eobrun > 0) {
        eobrun--;
        return;
      }
      var k = spectralStart, e = spectralEnd;
      while (k <= e) {
        var rs = decodeHuffman(component.huffmanTableAC);
        var s = rs & 15, r = rs >> 4;
        if (s === 0) {
          if (r < 15) {
            eobrun = receive(r) + (1 << r) - 1;
            break;
          }
          k += 16;
          continue;
        }
        k += r;
        var z = dctZigZag[k];
        zz[z] = receiveAndExtend(s) * (1 << successive);
        k++;
      }
    }
    var successiveACState = 0, successiveACNextValue;
    function decodeACSuccessive(component, zz) {
      var k = spectralStart, e = spectralEnd, r = 0;
      while (k <= e) {
        var z = dctZigZag[k];
        switch (successiveACState) {
        case 0: // initial state
          var rs = decodeHuffman(component.huffmanTableAC);
          var s = rs & 15, r = rs >> 4;
          if (s === 0) {
            if (r < 15) {
              eobrun = receive(r) + (1 << r);
              successiveACState = 4;
            } else {
              r = 16;
              successiveACState = 1;
            }
          } else {
            if (s !== 1)
              throw "invalid ACn encoding";
            successiveACNextValue = receiveAndExtend(s);
            successiveACState = r ? 2 : 3;
          }
          continue;
        case 1: // skipping r zero items
        case 2:
          if (zz[z])
            zz[z] += (readBit() << successive);
          else {
            r--;
            if (r === 0)
              successiveACState = successiveACState == 2 ? 3 : 0;
          }
          break;
        case 3: // set value for a zero item
          if (zz[z])
            zz[z] += (readBit() << successive);
          else {
            zz[z] = successiveACNextValue << successive;
            successiveACState = 0;
          }
          break;
        case 4: // eob
          if (zz[z])
            zz[z] += (readBit() << successive);
          break;
        }
        k++;
      }
      if (successiveACState === 4) {
        eobrun--;
        if (eobrun === 0)
          successiveACState = 0;
      }
    }
    function decodeMcu(component, decode, mcu, row, col) {
      var mcuRow = (mcu / mcusPerLine) | 0;
      var mcuCol = mcu % mcusPerLine;
      var blockRow = mcuRow * component.v + row;
      var blockCol = mcuCol * component.h + col;
      decode(component, component.blocks[blockRow][blockCol]);
    }
    function decodeBlock(component, decode, mcu) {
      var blockRow = (mcu / component.blocksPerLine) | 0;
      var blockCol = mcu % component.blocksPerLine;
      decode(component, component.blocks[blockRow][blockCol]);
    }

    var componentsLength = components.length;
    var component, i, j, k, n;
    var decodeFn;
    if (progressive) {
      if (spectralStart === 0)
        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
      else
        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
    } else {
      decodeFn = decodeBaseline;
    }

    var mcu = 0, marker;
    var mcuExpected;
    if (componentsLength == 1) {
      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
    } else {
      mcuExpected = mcusPerLine * frame.mcusPerColumn;
    }
    if (!resetInterval) resetInterval = mcuExpected;

    var h, v;
    while (mcu < mcuExpected) {
      // reset interval stuff
      for (i = 0; i < componentsLength; i++)
        components[i].pred = 0;
      eobrun = 0;

      if (componentsLength == 1) {
        component = components[0];
        for (n = 0; n < resetInterval; n++) {
          decodeBlock(component, decodeFn, mcu);
          mcu++;
        }
      } else {
        for (n = 0; n < resetInterval; n++) {
          for (i = 0; i < componentsLength; i++) {
            component = components[i];
            h = component.h;
            v = component.v;
            for (j = 0; j < v; j++) {
              for (k = 0; k < h; k++) {
                decodeMcu(component, decodeFn, mcu, j, k);
              }
            }
          }
          mcu++;

          // If we've reached our expected MCU's, stop decoding
          if (mcu === mcuExpected) break;
        }
      }

      // find marker
      bitsCount = 0;
      marker = (data[offset] << 8) | data[offset + 1];
      if (marker < 0xFF00) {
        throw "marker was not found";
      }

      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx
        offset += 2;
      }
      else
        break;
    }

    return offset - startOffset;
  }

  function buildComponentData(frame, component) {
    var lines = [];
    var blocksPerLine = component.blocksPerLine;
    var blocksPerColumn = component.blocksPerColumn;
    var samplesPerLine = blocksPerLine << 3;
    var R = new Int32Array(64), r = new Uint8Array(64);

    // A port of poppler's IDCT method which in turn is taken from:
    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,
    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",
    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,
    //   988-991.
    function quantizeAndInverse(zz, dataOut, dataIn) {
      var qt = component.quantizationTable;
      var v0, v1, v2, v3, v4, v5, v6, v7, t;
      var p = dataIn;
      var i;

      // dequant
      for (i = 0; i < 64; i++)
        p[i] = zz[i] * qt[i];

      // inverse DCT on rows
      for (i = 0; i < 8; ++i) {
        var row = 8 * i;

        // check for all-zero AC coefficients
        if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 &&
            p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 &&
            p[7 + row] == 0) {
          t = (dctSqrt2 * p[0 + row] + 512) >> 10;
          p[0 + row] = t;
          p[1 + row] = t;
          p[2 + row] = t;
          p[3 + row] = t;
          p[4 + row] = t;
          p[5 + row] = t;
          p[6 + row] = t;
          p[7 + row] = t;
          continue;
        }

        // stage 4
        v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;
        v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;
        v2 = p[2 + row];
        v3 = p[6 + row];
        v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;
        v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;
        v5 = p[3 + row] << 4;
        v6 = p[5 + row] << 4;

        // stage 3
        t = (v0 - v1+ 1) >> 1;
        v0 = (v0 + v1 + 1) >> 1;
        v1 = t;
        t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;
        v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;
        v3 = t;
        t = (v4 - v6 + 1) >> 1;
        v4 = (v4 + v6 + 1) >> 1;
        v6 = t;
        t = (v7 + v5 + 1) >> 1;
        v5 = (v7 - v5 + 1) >> 1;
        v7 = t;

        // stage 2
        t = (v0 - v3 + 1) >> 1;
        v0 = (v0 + v3 + 1) >> 1;
        v3 = t;
        t = (v1 - v2 + 1) >> 1;
        v1 = (v1 + v2 + 1) >> 1;
        v2 = t;
        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
        v7 = t;
        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
        v6 = t;

        // stage 1
        p[0 + row] = v0 + v7;
        p[7 + row] = v0 - v7;
        p[1 + row] = v1 + v6;
        p[6 + row] = v1 - v6;
        p[2 + row] = v2 + v5;
        p[5 + row] = v2 - v5;
        p[3 + row] = v3 + v4;
        p[4 + row] = v3 - v4;
      }

      // inverse DCT on columns
      for (i = 0; i < 8; ++i) {
        var col = i;

        // check for all-zero AC coefficients
        if (p[1*8 + col] == 0 && p[2*8 + col] == 0 && p[3*8 + col] == 0 &&
            p[4*8 + col] == 0 && p[5*8 + col] == 0 && p[6*8 + col] == 0 &&
            p[7*8 + col] == 0) {
          t = (dctSqrt2 * dataIn[i+0] + 8192) >> 14;
          p[0*8 + col] = t;
          p[1*8 + col] = t;
          p[2*8 + col] = t;
          p[3*8 + col] = t;
          p[4*8 + col] = t;
          p[5*8 + col] = t;
          p[6*8 + col] = t;
          p[7*8 + col] = t;
          continue;
        }

        // stage 4
        v0 = (dctSqrt2 * p[0*8 + col] + 2048) >> 12;
        v1 = (dctSqrt2 * p[4*8 + col] + 2048) >> 12;
        v2 = p[2*8 + col];
        v3 = p[6*8 + col];
        v4 = (dctSqrt1d2 * (p[1*8 + col] - p[7*8 + col]) + 2048) >> 12;
        v7 = (dctSqrt1d2 * (p[1*8 + col] + p[7*8 + col]) + 2048) >> 12;
        v5 = p[3*8 + col];
        v6 = p[5*8 + col];

        // stage 3
        t = (v0 - v1 + 1) >> 1;
        v0 = (v0 + v1 + 1) >> 1;
        v1 = t;
        t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;
        v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;
        v3 = t;
        t = (v4 - v6 + 1) >> 1;
        v4 = (v4 + v6 + 1) >> 1;
        v6 = t;
        t = (v7 + v5 + 1) >> 1;
        v5 = (v7 - v5 + 1) >> 1;
        v7 = t;

        // stage 2
        t = (v0 - v3 + 1) >> 1;
        v0 = (v0 + v3 + 1) >> 1;
        v3 = t;
        t = (v1 - v2 + 1) >> 1;
        v1 = (v1 + v2 + 1) >> 1;
        v2 = t;
        t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;
        v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;
        v7 = t;
        t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;
        v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;
        v6 = t;

        // stage 1
        p[0*8 + col] = v0 + v7;
        p[7*8 + col] = v0 - v7;
        p[1*8 + col] = v1 + v6;
        p[6*8 + col] = v1 - v6;
        p[2*8 + col] = v2 + v5;
        p[5*8 + col] = v2 - v5;
        p[3*8 + col] = v3 + v4;
        p[4*8 + col] = v3 - v4;
      }

      // convert to 8-bit integers
      for (i = 0; i < 64; ++i) {
        var sample = 128 + ((p[i] + 8) >> 4);
        dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
      }
    }

    var i, j;
    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
      var scanLine = blockRow << 3;
      for (i = 0; i < 8; i++)
        lines.push(new Uint8Array(samplesPerLine));
      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
        quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);

        var offset = 0, sample = blockCol << 3;
        for (j = 0; j < 8; j++) {
          var line = lines[scanLine + j];
          for (i = 0; i < 8; i++)
            line[sample + i] = r[offset++];
        }
      }
    }
    return lines;
  }

  function clampTo8bit(a) {
    return a < 0 ? 0 : a > 255 ? 255 : a;
  }

  constructor.prototype = {
    load: function load(path) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", path, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = (function() {
        // TODO catch parse error
        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
        this.parse(data);
        if (this.onload)
          this.onload();
      }).bind(this);
      xhr.send(null);
    },
    parse: function parse(data) {
      var offset = 0, length = data.length;
      function readUint16() {
        var value = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        return value;
      }
      function readDataBlock() {
        var length = readUint16();
        var array = data.subarray(offset, offset + length - 2);
        offset += array.length;
        return array;
      }
      function prepareComponents(frame) {
        var maxH = 0, maxV = 0;
        var component, componentId;
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            if (maxH < component.h) maxH = component.h;
            if (maxV < component.v) maxV = component.v;
          }
        }
        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);
        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
        for (componentId in frame.components) {
          if (frame.components.hasOwnProperty(componentId)) {
            component = frame.components[componentId];
            var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);
            var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) * component.v / maxV);
            var blocksPerLineForMcu = mcusPerLine * component.h;
            var blocksPerColumnForMcu = mcusPerColumn * component.v;
            var blocks = [];
            for (var i = 0; i < blocksPerColumnForMcu; i++) {
              var row = [];
              for (var j = 0; j < blocksPerLineForMcu; j++)
                row.push(new Int32Array(64));
              blocks.push(row);
            }
            component.blocksPerLine = blocksPerLine;
            component.blocksPerColumn = blocksPerColumn;
            component.blocks = blocks;
          }
        }
        frame.maxH = maxH;
        frame.maxV = maxV;
        frame.mcusPerLine = mcusPerLine;
        frame.mcusPerColumn = mcusPerColumn;
      }
      var jfif = null;
      var adobe = null;
      var pixels = null;
      var frame, resetInterval;
      var quantizationTables = [], frames = [];
      var huffmanTablesAC = [], huffmanTablesDC = [];
      var fileMarker = readUint16();
      if (fileMarker != 0xFFD8) { // SOI (Start of Image)
        throw "SOI not found";
      }

      fileMarker = readUint16();
      while (fileMarker != 0xFFD9) { // EOI (End of image)
        var i, j, l;
        switch(fileMarker) {
          case 0xFF00: break;
          case 0xFFE0: // APP0 (Application Specific)
          case 0xFFE1: // APP1
          case 0xFFE2: // APP2
          case 0xFFE3: // APP3
          case 0xFFE4: // APP4
          case 0xFFE5: // APP5
          case 0xFFE6: // APP6
          case 0xFFE7: // APP7
          case 0xFFE8: // APP8
          case 0xFFE9: // APP9
          case 0xFFEA: // APP10
          case 0xFFEB: // APP11
          case 0xFFEC: // APP12
          case 0xFFED: // APP13
          case 0xFFEE: // APP14
          case 0xFFEF: // APP15
          case 0xFFFE: // COM (Comment)
            var appData = readDataBlock();

            if (fileMarker === 0xFFE0) {
              if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&
                appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\x00'
                jfif = {
                  version: { major: appData[5], minor: appData[6] },
                  densityUnits: appData[7],
                  xDensity: (appData[8] << 8) | appData[9],
                  yDensity: (appData[10] << 8) | appData[11],
                  thumbWidth: appData[12],
                  thumbHeight: appData[13],
                  thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                };
              }
            }
            // TODO APP1 - Exif
            if (fileMarker === 0xFFEE) {
              if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&
                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\x00'
                adobe = {
                  version: appData[6],
                  flags0: (appData[7] << 8) | appData[8],
                  flags1: (appData[9] << 8) | appData[10],
                  transformCode: appData[11]
                };
              }
            }
            break;

          case 0xFFDB: // DQT (Define Quantization Tables)
            var quantizationTablesLength = readUint16();
            var quantizationTablesEnd = quantizationTablesLength + offset - 2;
            while (offset < quantizationTablesEnd) {
              var quantizationTableSpec = data[offset++];
              var tableData = new Int32Array(64);
              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = data[offset++];
                }
              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit
                for (j = 0; j < 64; j++) {
                  var z = dctZigZag[j];
                  tableData[z] = readUint16();
                }
              } else
                throw "DQT: invalid table spec";
              quantizationTables[quantizationTableSpec & 15] = tableData;
            }
            break;

          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)
          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)
          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)
            readUint16(); // skip data length
            frame = {};
            frame.extended = (fileMarker === 0xFFC1);
            frame.progressive = (fileMarker === 0xFFC2);
            frame.precision = data[offset++];
            frame.scanLines = readUint16();
            frame.samplesPerLine = readUint16();
            frame.components = {};
            frame.componentsOrder = [];
            var componentsCount = data[offset++], componentId;
            var maxH = 0, maxV = 0;
            for (i = 0; i < componentsCount; i++) {
              componentId = data[offset];
              var h = data[offset + 1] >> 4;
              var v = data[offset + 1] & 15;
              var qId = data[offset + 2];
              frame.componentsOrder.push(componentId);
              frame.components[componentId] = {
                h: h,
                v: v,
                quantizationIdx: qId
              };
              offset += 3;
            }
            prepareComponents(frame);
            frames.push(frame);
            break;

          case 0xFFC4: // DHT (Define Huffman Tables)
            var huffmanLength = readUint16();
            for (i = 2; i < huffmanLength;) {
              var huffmanTableSpec = data[offset++];
              var codeLengths = new Uint8Array(16);
              var codeLengthSum = 0;
              for (j = 0; j < 16; j++, offset++)
                codeLengthSum += (codeLengths[j] = data[offset]);
              var huffmanValues = new Uint8Array(codeLengthSum);
              for (j = 0; j < codeLengthSum; j++, offset++)
                huffmanValues[j] = data[offset];
              i += 17 + codeLengthSum;

              ((huffmanTableSpec >> 4) === 0 ? 
                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =
                buildHuffmanTable(codeLengths, huffmanValues);
            }
            break;

          case 0xFFDD: // DRI (Define Restart Interval)
            readUint16(); // skip data length
            resetInterval = readUint16();
            break;

          case 0xFFDA: // SOS (Start of Scan)
            var scanLength = readUint16();
            var selectorsCount = data[offset++];
            var components = [], component;
            for (i = 0; i < selectorsCount; i++) {
              component = frame.components[data[offset++]];
              var tableSpec = data[offset++];
              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
              components.push(component);
            }
            var spectralStart = data[offset++];
            var spectralEnd = data[offset++];
            var successiveApproximation = data[offset++];
            var processed = decodeScan(data, offset,
              frame, components, resetInterval,
              spectralStart, spectralEnd,
              successiveApproximation >> 4, successiveApproximation & 15);
            offset += processed;
            break;
          default:
            if (data[offset - 3] == 0xFF &&
                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
              // could be incorrect encoding -- last 0xFF byte of the previous
              // block was eaten by the encoder
              offset -= 3;
              break;
            }
            throw "unknown JPEG marker " + fileMarker.toString(16);
        }
        fileMarker = readUint16();
      }
      if (frames.length != 1)
        throw "only single frame JPEGs supported";

      // set each frame's components quantization table
      for (var i = 0; i < frames.length; i++) {
        var cp = frames[i].components;
        for (var j in cp) {
          cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
          delete cp[j].quantizationIdx;
        }
      }

      this.width = frame.samplesPerLine;
      this.height = frame.scanLines;
      this.jfif = jfif;
      this.adobe = adobe;
      this.components = [];
      for (var i = 0; i < frame.componentsOrder.length; i++) {
        var component = frame.components[frame.componentsOrder[i]];
        this.components.push({
          lines: buildComponentData(frame, component),
          scaleX: component.h / frame.maxH,
          scaleY: component.v / frame.maxV
        });
      }
    },
    getData: function getData(width, height) {
      var scaleX = this.width / width, scaleY = this.height / height;

      var component1, component2, component3, component4;
      var component1Line, component2Line, component3Line, component4Line;
      var x, y;
      var offset = 0;
      var Y, Cb, Cr, K, C, M, Ye, R, G, B;
      var colorTransform;
      var dataLength = width * height * this.components.length;
      var data = new Uint8Array(dataLength);
      switch (this.components.length) {
        case 1:
          component1 = this.components[0];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              Y = component1Line[0 | (x * component1.scaleX * scaleX)];

              data[offset++] = Y;
            }
          }
          break;
        case 2:
          // PDF might compress two component data in custom colorspace
          component1 = this.components[0];
          component2 = this.components[1];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              Y = component1Line[0 | (x * component1.scaleX * scaleX)];
              data[offset++] = Y;
              Y = component2Line[0 | (x * component2.scaleX * scaleX)];
              data[offset++] = Y;
            }
          }
          break;
        case 3:
          // The default transform for three components is true
          colorTransform = true;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          component1 = this.components[0];
          component2 = this.components[1];
          component3 = this.components[2];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              if (!colorTransform) {
                R = component1Line[0 | (x * component1.scaleX * scaleX)];
                G = component2Line[0 | (x * component2.scaleX * scaleX)];
                B = component3Line[0 | (x * component3.scaleX * scaleX)];
              } else {
                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];

                R = clampTo8bit(Y + 1.402 * (Cr - 128));
                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                B = clampTo8bit(Y + 1.772 * (Cb - 128));
              }

              data[offset++] = R;
              data[offset++] = G;
              data[offset++] = B;
            }
          }
          break;
        case 4:
          if (!this.adobe)
            throw 'Unsupported color mode (4 components)';
          // The default transform for four components is false
          colorTransform = false;
          // The adobe transform marker overrides any previous setting
          if (this.adobe && this.adobe.transformCode)
            colorTransform = true;
          else if (typeof this.colorTransform !== 'undefined')
            colorTransform = !!this.colorTransform;

          component1 = this.components[0];
          component2 = this.components[1];
          component3 = this.components[2];
          component4 = this.components[3];
          for (y = 0; y < height; y++) {
            component1Line = component1.lines[0 | (y * component1.scaleY * scaleY)];
            component2Line = component2.lines[0 | (y * component2.scaleY * scaleY)];
            component3Line = component3.lines[0 | (y * component3.scaleY * scaleY)];
            component4Line = component4.lines[0 | (y * component4.scaleY * scaleY)];
            for (x = 0; x < width; x++) {
              if (!colorTransform) {
                C = component1Line[0 | (x * component1.scaleX * scaleX)];
                M = component2Line[0 | (x * component2.scaleX * scaleX)];
                Ye = component3Line[0 | (x * component3.scaleX * scaleX)];
                K = component4Line[0 | (x * component4.scaleX * scaleX)];
              } else {
                Y = component1Line[0 | (x * component1.scaleX * scaleX)];
                Cb = component2Line[0 | (x * component2.scaleX * scaleX)];
                Cr = component3Line[0 | (x * component3.scaleX * scaleX)];
                K = component4Line[0 | (x * component4.scaleX * scaleX)];

                C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
              }
              data[offset++] = 255-C;
              data[offset++] = 255-M;
              data[offset++] = 255-Ye;
              data[offset++] = 255-K;
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
      return data;
    },
    copyToImageData: function copyToImageData(imageData) {
      var width = imageData.width, height = imageData.height;
      var imageDataArray = imageData.data;
      var data = this.getData(width, height);
      var i = 0, j = 0, x, y;
      var Y, K, C, M, R, G, B;
      switch (this.components.length) {
        case 1:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              Y = data[i++];

              imageDataArray[j++] = Y;
              imageDataArray[j++] = Y;
              imageDataArray[j++] = Y;
              imageDataArray[j++] = 255;
            }
          }
          break;
        case 3:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              R = data[i++];
              G = data[i++];
              B = data[i++];

              imageDataArray[j++] = R;
              imageDataArray[j++] = G;
              imageDataArray[j++] = B;
              imageDataArray[j++] = 255;
            }
          }
          break;
        case 4:
          for (y = 0; y < height; y++) {
            for (x = 0; x < width; x++) {
              C = data[i++];
              M = data[i++];
              Y = data[i++];
              K = data[i++];

              R = 255 - clampTo8bit(C * (1 - K / 255) + K);
              G = 255 - clampTo8bit(M * (1 - K / 255) + K);
              B = 255 - clampTo8bit(Y * (1 - K / 255) + K);

              imageDataArray[j++] = R;
              imageDataArray[j++] = G;
              imageDataArray[j++] = B;
              imageDataArray[j++] = 255;
            }
          }
          break;
        default:
          throw 'Unsupported color mode';
      }
    }
  };

  return constructor;
})();
module.exports = decode;

function decode(jpegData) {
  var arr = new Uint8Array(jpegData);
  var decoder = new JpegImage();
  decoder.parse(arr);

  var image = {
    width: decoder.width,
    height: decoder.height,
    data: new Buffer(decoder.width * decoder.height * 4)
  };
  
  decoder.copyToImageData(image);
  
  return image;
}

}).call(this,require("buffer").Buffer)
},{"buffer":194}],250:[function(require,module,exports){
(function (Buffer){
/*
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*
JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009

Basic GUI blocking jpeg encoder
*/

var btoa = btoa || function(buf) {
  return new Buffer(buf).toString('base64');
};

function JPEGEncoder(quality) {
  var self = this;
	var fround = Math.round;
	var ffloor = Math.floor;
	var YTable = new Array(64);
	var UVTable = new Array(64);
	var fdtbl_Y = new Array(64);
	var fdtbl_UV = new Array(64);
	var YDC_HT;
	var UVDC_HT;
	var YAC_HT;
	var UVAC_HT;
	
	var bitcode = new Array(65535);
	var category = new Array(65535);
	var outputfDCTQuant = new Array(64);
	var DU = new Array(64);
	var byteout = [];
	var bytenew = 0;
	var bytepos = 7;
	
	var YDU = new Array(64);
	var UDU = new Array(64);
	var VDU = new Array(64);
	var clt = new Array(256);
	var RGB_YUV_TABLE = new Array(2048);
	var currentQuality;
	
	var ZigZag = [
			 0, 1, 5, 6,14,15,27,28,
			 2, 4, 7,13,16,26,29,42,
			 3, 8,12,17,25,30,41,43,
			 9,11,18,24,31,40,44,53,
			10,19,23,32,39,45,52,54,
			20,22,33,38,46,51,55,60,
			21,34,37,47,50,56,59,61,
			35,36,48,49,57,58,62,63
		];
	
	var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
	var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
	var std_ac_luminance_values = [
			0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
			0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
			0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
			0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
			0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
			0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
			0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
			0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
			0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
			0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
			0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
			0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
			0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
			0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
			0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
			0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
			0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
			0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
			0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
			0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
			0xf9,0xfa
		];
	
	var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
	var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
	var std_ac_chrominance_values = [
			0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
			0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
			0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
			0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
			0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
			0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
			0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
			0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
			0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
			0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
			0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
			0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
			0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
			0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
			0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
			0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
			0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
			0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
			0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
			0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
			0xf9,0xfa
		];
	
	function initQuantTables(sf){
			var YQT = [
				16, 11, 10, 16, 24, 40, 51, 61,
				12, 12, 14, 19, 26, 58, 60, 55,
				14, 13, 16, 24, 40, 57, 69, 56,
				14, 17, 22, 29, 51, 87, 80, 62,
				18, 22, 37, 56, 68,109,103, 77,
				24, 35, 55, 64, 81,104,113, 92,
				49, 64, 78, 87,103,121,120,101,
				72, 92, 95, 98,112,100,103, 99
			];
			
			for (var i = 0; i < 64; i++) {
				var t = ffloor((YQT[i]*sf+50)/100);
				if (t < 1) {
					t = 1;
				} else if (t > 255) {
					t = 255;
				}
				YTable[ZigZag[i]] = t;
			}
			var UVQT = [
				17, 18, 24, 47, 99, 99, 99, 99,
				18, 21, 26, 66, 99, 99, 99, 99,
				24, 26, 56, 99, 99, 99, 99, 99,
				47, 66, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99,
				99, 99, 99, 99, 99, 99, 99, 99
			];
			for (var j = 0; j < 64; j++) {
				var u = ffloor((UVQT[j]*sf+50)/100);
				if (u < 1) {
					u = 1;
				} else if (u > 255) {
					u = 255;
				}
				UVTable[ZigZag[j]] = u;
			}
			var aasf = [
				1.0, 1.387039845, 1.306562965, 1.175875602,
				1.0, 0.785694958, 0.541196100, 0.275899379
			];
			var k = 0;
			for (var row = 0; row < 8; row++)
			{
				for (var col = 0; col < 8; col++)
				{
					fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
					fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
					k++;
				}
			}
		}
		
		function computeHuffmanTbl(nrcodes, std_table){
			var codevalue = 0;
			var pos_in_table = 0;
			var HT = new Array();
			for (var k = 1; k <= 16; k++) {
				for (var j = 1; j <= nrcodes[k]; j++) {
					HT[std_table[pos_in_table]] = [];
					HT[std_table[pos_in_table]][0] = codevalue;
					HT[std_table[pos_in_table]][1] = k;
					pos_in_table++;
					codevalue++;
				}
				codevalue*=2;
			}
			return HT;
		}
		
		function initHuffmanTbl()
		{
			YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
			UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
			YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
			UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
		}
	
		function initCategoryNumber()
		{
			var nrlower = 1;
			var nrupper = 2;
			for (var cat = 1; cat <= 15; cat++) {
				//Positive numbers
				for (var nr = nrlower; nr<nrupper; nr++) {
					category[32767+nr] = cat;
					bitcode[32767+nr] = [];
					bitcode[32767+nr][1] = cat;
					bitcode[32767+nr][0] = nr;
				}
				//Negative numbers
				for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
					category[32767+nrneg] = cat;
					bitcode[32767+nrneg] = [];
					bitcode[32767+nrneg][1] = cat;
					bitcode[32767+nrneg][0] = nrupper-1+nrneg;
				}
				nrlower <<= 1;
				nrupper <<= 1;
			}
		}
		
		function initRGBYUVTable() {
			for(var i = 0; i < 256;i++) {
				RGB_YUV_TABLE[i]      		=  19595 * i;
				RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
				RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
				RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
				RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
				RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
				RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
				RGB_YUV_TABLE[(i+1792)>>0] 	= - 5329 * i;
			}
		}
		
		// IO functions
		function writeBits(bs)
		{
			var value = bs[0];
			var posval = bs[1]-1;
			while ( posval >= 0 ) {
				if (value & (1 << posval) ) {
					bytenew |= (1 << bytepos);
				}
				posval--;
				bytepos--;
				if (bytepos < 0) {
					if (bytenew == 0xFF) {
						writeByte(0xFF);
						writeByte(0);
					}
					else {
						writeByte(bytenew);
					}
					bytepos=7;
					bytenew=0;
				}
			}
		}
	
		function writeByte(value)
		{
			//byteout.push(clt[value]); // write char directly instead of converting later
      byteout.push(value);
		}
	
		function writeWord(value)
		{
			writeByte((value>>8)&0xFF);
			writeByte((value   )&0xFF);
		}
		
		// DCT & quantization core
		function fDCTQuant(data, fdtbl)
		{
			var d0, d1, d2, d3, d4, d5, d6, d7;
			/* Pass 1: process rows. */
			var dataOff=0;
			var i;
			const I8 = 8;
			const I64 = 64;
			for (i=0; i<I8; ++i)
			{
				d0 = data[dataOff];
				d1 = data[dataOff+1];
				d2 = data[dataOff+2];
				d3 = data[dataOff+3];
				d4 = data[dataOff+4];
				d5 = data[dataOff+5];
				d6 = data[dataOff+6];
				d7 = data[dataOff+7];
				
				var tmp0 = d0 + d7;
				var tmp7 = d0 - d7;
				var tmp1 = d1 + d6;
				var tmp6 = d1 - d6;
				var tmp2 = d2 + d5;
				var tmp5 = d2 - d5;
				var tmp3 = d3 + d4;
				var tmp4 = d3 - d4;
	
				/* Even part */
				var tmp10 = tmp0 + tmp3;	/* phase 2 */
				var tmp13 = tmp0 - tmp3;
				var tmp11 = tmp1 + tmp2;
				var tmp12 = tmp1 - tmp2;
	
				data[dataOff] = tmp10 + tmp11; /* phase 3 */
				data[dataOff+4] = tmp10 - tmp11;
	
				var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
				data[dataOff+2] = tmp13 + z1; /* phase 5 */
				data[dataOff+6] = tmp13 - z1;
	
				/* Odd part */
				tmp10 = tmp4 + tmp5; /* phase 2 */
				tmp11 = tmp5 + tmp6;
				tmp12 = tmp6 + tmp7;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
				var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
				var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
				var z3 = tmp11 * 0.707106781; /* c4 */
	
				var z11 = tmp7 + z3;	/* phase 5 */
				var z13 = tmp7 - z3;
	
				data[dataOff+5] = z13 + z2;	/* phase 6 */
				data[dataOff+3] = z13 - z2;
				data[dataOff+1] = z11 + z4;
				data[dataOff+7] = z11 - z4;
	
				dataOff += 8; /* advance pointer to next row */
			}
	
			/* Pass 2: process columns. */
			dataOff = 0;
			for (i=0; i<I8; ++i)
			{
				d0 = data[dataOff];
				d1 = data[dataOff + 8];
				d2 = data[dataOff + 16];
				d3 = data[dataOff + 24];
				d4 = data[dataOff + 32];
				d5 = data[dataOff + 40];
				d6 = data[dataOff + 48];
				d7 = data[dataOff + 56];
				
				var tmp0p2 = d0 + d7;
				var tmp7p2 = d0 - d7;
				var tmp1p2 = d1 + d6;
				var tmp6p2 = d1 - d6;
				var tmp2p2 = d2 + d5;
				var tmp5p2 = d2 - d5;
				var tmp3p2 = d3 + d4;
				var tmp4p2 = d3 - d4;
	
				/* Even part */
				var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
				var tmp13p2 = tmp0p2 - tmp3p2;
				var tmp11p2 = tmp1p2 + tmp2p2;
				var tmp12p2 = tmp1p2 - tmp2p2;
	
				data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
				data[dataOff+32] = tmp10p2 - tmp11p2;
	
				var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
				data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
				data[dataOff+48] = tmp13p2 - z1p2;
	
				/* Odd part */
				tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
				tmp11p2 = tmp5p2 + tmp6p2;
				tmp12p2 = tmp6p2 + tmp7p2;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
				var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
				var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
				var z3p2 = tmp11p2 * 0.707106781; /* c4 */
	
				var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
				var z13p2 = tmp7p2 - z3p2;
	
				data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
				data[dataOff+24] = z13p2 - z2p2;
				data[dataOff+ 8] = z11p2 + z4p2;
				data[dataOff+56] = z11p2 - z4p2;
	
				dataOff++; /* advance pointer to next column */
			}
	
			// Quantize/descale the coefficients
			var fDCTQuant;
			for (i=0; i<I64; ++i)
			{
				// Apply the quantization and scaling factor & Round to nearest integer
				fDCTQuant = data[i]*fdtbl[i];
				outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
				//outputfDCTQuant[i] = fround(fDCTQuant);

			}
			return outputfDCTQuant;
		}
		
		function writeAPP0()
		{
			writeWord(0xFFE0); // marker
			writeWord(16); // length
			writeByte(0x4A); // J
			writeByte(0x46); // F
			writeByte(0x49); // I
			writeByte(0x46); // F
			writeByte(0); // = "JFIF",'\0'
			writeByte(1); // versionhi
			writeByte(1); // versionlo
			writeByte(0); // xyunits
			writeWord(1); // xdensity
			writeWord(1); // ydensity
			writeByte(0); // thumbnwidth
			writeByte(0); // thumbnheight
		}
	
		function writeSOF0(width, height)
		{
			writeWord(0xFFC0); // marker
			writeWord(17);   // length, truecolor YUV JPG
			writeByte(8);    // precision
			writeWord(height);
			writeWord(width);
			writeByte(3);    // nrofcomponents
			writeByte(1);    // IdY
			writeByte(0x11); // HVY
			writeByte(0);    // QTY
			writeByte(2);    // IdU
			writeByte(0x11); // HVU
			writeByte(1);    // QTU
			writeByte(3);    // IdV
			writeByte(0x11); // HVV
			writeByte(1);    // QTV
		}
	
		function writeDQT()
		{
			writeWord(0xFFDB); // marker
			writeWord(132);	   // length
			writeByte(0);
			for (var i=0; i<64; i++) {
				writeByte(YTable[i]);
			}
			writeByte(1);
			for (var j=0; j<64; j++) {
				writeByte(UVTable[j]);
			}
		}
	
		function writeDHT()
		{
			writeWord(0xFFC4); // marker
			writeWord(0x01A2); // length
	
			writeByte(0); // HTYDCinfo
			for (var i=0; i<16; i++) {
				writeByte(std_dc_luminance_nrcodes[i+1]);
			}
			for (var j=0; j<=11; j++) {
				writeByte(std_dc_luminance_values[j]);
			}
	
			writeByte(0x10); // HTYACinfo
			for (var k=0; k<16; k++) {
				writeByte(std_ac_luminance_nrcodes[k+1]);
			}
			for (var l=0; l<=161; l++) {
				writeByte(std_ac_luminance_values[l]);
			}
	
			writeByte(1); // HTUDCinfo
			for (var m=0; m<16; m++) {
				writeByte(std_dc_chrominance_nrcodes[m+1]);
			}
			for (var n=0; n<=11; n++) {
				writeByte(std_dc_chrominance_values[n]);
			}
	
			writeByte(0x11); // HTUACinfo
			for (var o=0; o<16; o++) {
				writeByte(std_ac_chrominance_nrcodes[o+1]);
			}
			for (var p=0; p<=161; p++) {
				writeByte(std_ac_chrominance_values[p]);
			}
		}
	
		function writeSOS()
		{
			writeWord(0xFFDA); // marker
			writeWord(12); // length
			writeByte(3); // nrofcomponents
			writeByte(1); // IdY
			writeByte(0); // HTY
			writeByte(2); // IdU
			writeByte(0x11); // HTU
			writeByte(3); // IdV
			writeByte(0x11); // HTV
			writeByte(0); // Ss
			writeByte(0x3f); // Se
			writeByte(0); // Bf
		}
		
		function processDU(CDU, fdtbl, DC, HTDC, HTAC){
			var EOB = HTAC[0x00];
			var M16zeroes = HTAC[0xF0];
			var pos;
			const I16 = 16;
			const I63 = 63;
			const I64 = 64;
			var DU_DCT = fDCTQuant(CDU, fdtbl);
			//ZigZag reorder
			for (var j=0;j<I64;++j) {
				DU[ZigZag[j]]=DU_DCT[j];
			}
			var Diff = DU[0] - DC; DC = DU[0];
			//Encode DC
			if (Diff==0) {
				writeBits(HTDC[0]); // Diff might be 0
			} else {
				pos = 32767+Diff;
				writeBits(HTDC[category[pos]]);
				writeBits(bitcode[pos]);
			}
			//Encode ACs
			var end0pos = 63; // was const... which is crazy
			for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};
			//end0pos = first element in reverse order !=0
			if ( end0pos == 0) {
				writeBits(EOB);
				return DC;
			}
			var i = 1;
			var lng;
			while ( i <= end0pos ) {
				var startpos = i;
				for (; (DU[i]==0) && (i<=end0pos); ++i) {}
				var nrzeroes = i-startpos;
				if ( nrzeroes >= I16 ) {
					lng = nrzeroes>>4;
					for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
						writeBits(M16zeroes);
					nrzeroes = nrzeroes&0xF;
				}
				pos = 32767+DU[i];
				writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
				writeBits(bitcode[pos]);
				i++;
			}
			if ( end0pos != I63 ) {
				writeBits(EOB);
			}
			return DC;
		}

		function initCharLookupTable(){
			var sfcc = String.fromCharCode;
			for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
				clt[i] = sfcc(i);
			}
		}
		
		this.encode = function(image,quality) // image data object
		{
			var time_start = new Date().getTime();
			
			if(quality) setQuality(quality);
			
			// Initialize bit writer
			byteout = new Array();
			bytenew=0;
			bytepos=7;
	
			// Add JPEG headers
			writeWord(0xFFD8); // SOI
			writeAPP0();
			writeDQT();
			writeSOF0(image.width,image.height);
			writeDHT();
			writeSOS();

	
			// Encode 8x8 macroblocks
			var DCY=0;
			var DCU=0;
			var DCV=0;
			
			bytenew=0;
			bytepos=7;
			
			
			this.encode.displayName = "_encode_";

			var imageData = image.data;
			var width = image.width;
			var height = image.height;

			var quadWidth = width*4;
			var tripleWidth = width*3;
			
			var x, y = 0;
			var r, g, b;
			var start,p, col,row,pos;
			while(y < height){
				x = 0;
				while(x < quadWidth){
				start = quadWidth * y + x;
				p = start;
				col = -1;
				row = 0;
				
				for(pos=0; pos < 64; pos++){
					row = pos >> 3;// /8
					col = ( pos & 7 ) * 4; // %8
					p = start + ( row * quadWidth ) + col;		
					
					if(y+row >= height){ // padding bottom
						p-= (quadWidth*(y+1+row-height));
					}

					if(x+col >= quadWidth){ // padding right	
						p-= ((x+col) - quadWidth +4)
					}
					
					r = imageData[ p++ ];
					g = imageData[ p++ ];
					b = imageData[ p++ ];
					
					
					/* // calculate YUV values dynamically
					YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
					UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
					VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
					*/
					
					// use lookup table (slightly faster)
					YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
					UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
					VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;

				}
				
				DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
				DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
				DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
				x+=32;
				}
				y+=8;
			}
			
			
			////////////////////////////////////////////////////////////////
	
			// Do the bit alignment of the EOI marker
			if ( bytepos >= 0 ) {
				var fillbits = [];
				fillbits[1] = bytepos+1;
				fillbits[0] = (1<<(bytepos+1))-1;
				writeBits(fillbits);
			}
	
			writeWord(0xFFD9); //EOI

      //return new Uint8Array(byteout);
      return new Buffer(byteout);

			var jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));
			
			byteout = [];
			
			// benchmarking
			var duration = new Date().getTime() - time_start;
    		//console.log('Encoding time: '+ duration + 'ms');
    		//
			
			return jpegDataUri			
	}
	
	function setQuality(quality){
		if (quality <= 0) {
			quality = 1;
		}
		if (quality > 100) {
			quality = 100;
		}
		
		if(currentQuality == quality) return // don't recalc if unchanged
		
		var sf = 0;
		if (quality < 50) {
			sf = Math.floor(5000 / quality);
		} else {
			sf = Math.floor(200 - quality*2);
		}
		
		initQuantTables(sf);
		currentQuality = quality;
		//console.log('Quality set to: '+quality +'%');
	}
	
	function init(){
		var time_start = new Date().getTime();
		if(!quality) quality = 50;
		// Create tables
		initCharLookupTable()
		initHuffmanTbl();
		initCategoryNumber();
		initRGBYUVTable();
		
		setQuality(quality);
		var duration = new Date().getTime() - time_start;
    	//console.log('Initialization '+ duration + 'ms');
	}
	
	init();
	
};
module.exports = encode;

function encode(imgData, qu) {
  if (typeof qu === 'undefined') qu = 50;
  var encoder = new JPEGEncoder(qu);
	var data = encoder.encode(imgData, qu);
  return {
    data: data,
    width: imgData.width,
    height: imgData.height
  };
}

// helper function to get the imageData of an existing image on the current page.
function getImageDataFromImage(idOrElement){
	var theImg = (typeof(idOrElement)=='string')? document.getElementById(idOrElement):idOrElement;
	var cvs = document.createElement('canvas');
	cvs.width = theImg.width;
	cvs.height = theImg.height;
	var ctx = cvs.getContext("2d");
	ctx.drawImage(theImg,0,0);
	
	return (ctx.getImageData(0, 0, cvs.width, cvs.height));
}

}).call(this,require("buffer").Buffer)
},{"buffer":194}],251:[function(require,module,exports){
(function (global,Buffer){
/*!

JSZip - A Javascript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";function d(a){if(a){this.data=a,this.length=this.data.length,this.index=0,this.zero=0;for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}}var e=a("./dataReader");d.prototype=new e,d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./dataReader":6}],2:[function(a,b,c){"use strict";var d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a,b){for(var c,e,f,g,h,i,j,k="",l=0;l<a.length;)c=a.charCodeAt(l++),e=a.charCodeAt(l++),f=a.charCodeAt(l++),g=c>>2,h=(3&c)<<4|e>>4,i=(15&e)<<2|f>>6,j=63&f,isNaN(e)?i=j=64:isNaN(f)&&(j=64),k=k+d.charAt(g)+d.charAt(h)+d.charAt(i)+d.charAt(j);return k},c.decode=function(a,b){var c,e,f,g,h,i,j,k="",l=0;for(a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");l<a.length;)g=d.indexOf(a.charAt(l++)),h=d.indexOf(a.charAt(l++)),i=d.indexOf(a.charAt(l++)),j=d.indexOf(a.charAt(l++)),c=g<<2|h>>4,e=(15&h)<<4|i>>2,f=(3&i)<<6|j,k+=String.fromCharCode(c),64!=i&&(k+=String.fromCharCode(e)),64!=j&&(k+=String.fromCharCode(f));return k}},{}],3:[function(a,b,c){"use strict";function d(){this.compressedSize=0,this.uncompressedSize=0,this.crc32=0,this.compressionMethod=null,this.compressedContent=null}d.prototype={getContent:function(){return null},getCompressedContent:function(){return null}},b.exports=d},{}],4:[function(a,b,c){"use strict";c.STORE={magic:"\x00\x00",compress:function(a,b){return a},uncompress:function(a){return a},compressInputType:null,uncompressInputType:null},c.DEFLATE=a("./flate")},{"./flate":9}],5:[function(a,b,c){"use strict";var d=a("./utils"),e=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var c="string"!==d.getTypeOf(a);"undefined"==typeof b&&(b=0);var f=0,g=0,h=0;b=-1^b;for(var i=0,j=a.length;j>i;i++)h=c?a[i]:a.charCodeAt(i),g=255&(b^h),f=e[g],b=b>>>8^f;return-1^b}},{"./utils":22}],6:[function(a,b,c){"use strict";function d(a){this.data=null,this.length=0,this.index=0,this.zero=0}var e=a("./utils");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||0>a)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo("string",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1)}},b.exports=d},{"./utils":22}],7:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!1,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],8:[function(a,b,c){"use strict";var d=a("./utils");c.string2binary=function(a){return d.string2binary(a)},c.string2Uint8Array=function(a){return d.transformTo("uint8array",a)},c.uint8Array2String=function(a){return d.transformTo("string",a)},c.string2Blob=function(a){var b=d.transformTo("arraybuffer",a);return d.arrayBuffer2Blob(b)},c.arrayBuffer2Blob=function(a){return d.arrayBuffer2Blob(a)},c.transformTo=function(a,b){return d.transformTo(a,b)},c.getTypeOf=function(a){return d.getTypeOf(a)},c.checkSupport=function(a){return d.checkSupport(a)},c.MAX_VALUE_16BITS=d.MAX_VALUE_16BITS,c.MAX_VALUE_32BITS=d.MAX_VALUE_32BITS,c.pretty=function(a){return d.pretty(a)},c.findCompression=function(a){return d.findCompression(a)},c.isRegExp=function(a){return d.isRegExp(a)}},{"./utils":22}],9:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,e=a("pako");c.uncompressInputType=d?"uint8array":"array",c.compressInputType=d?"uint8array":"array",c.magic="\b\x00",c.compress=function(a,b){return e.deflateRaw(a,{level:b.level||-1})},c.uncompress=function(a){return e.inflateRaw(a)}},{pako:25}],10:[function(a,b,c){"use strict";function d(a,b){return this instanceof d?(this.files={},this.comment=null,this.root="",a&&this.load(a,b),void(this.clone=function(){var a=new d;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a})):new d(a,b)}var e=a("./base64");d.prototype=a("./object"),d.prototype.load=a("./load"),d.support=a("./support"),d.defaults=a("./defaults"),d.utils=a("./deprecatedPublicUtils"),d.base64={encode:function(a){return e.encode(a)},decode:function(a){return e.decode(a)}},d.compressions=a("./compressions"),b.exports=d},{"./base64":2,"./compressions":4,"./defaults":7,"./deprecatedPublicUtils":8,"./load":11,"./object":14,"./support":18}],11:[function(a,b,c){"use strict";var d=a("./base64"),e=a("./utf8"),f=a("./utils"),g=a("./zipEntries");b.exports=function(a,b){var c,h,i,j;for(b=f.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:e.utf8decode}),b.base64&&(a=d.decode(a)),h=new g(a,b),c=h.files,i=0;i<c.length;i++)j=c[i],this.file(j.fileNameStr,j.decompressed,{binary:!0,optimizedBinaryString:!0,date:j.date,dir:j.dir,comment:j.fileCommentStr.length?j.fileCommentStr:null,unixPermissions:j.unixPermissions,dosPermissions:j.dosPermissions,createFolders:b.createFolders});return h.zipComment.length&&(this.comment=h.zipComment),this}},{"./base64":2,"./utf8":21,"./utils":22,"./zipEntries":23}],12:[function(a,b,c){(function(a){"use strict";b.exports=function(b,c){return new a(b,c)},b.exports.test=function(b){return a.isBuffer(b)}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],13:[function(a,b,c){"use strict";function d(a){this.data=a,this.length=this.data.length,this.index=0,this.zero=0}var e=a("./uint8ArrayReader");d.prototype=new e,d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./uint8ArrayReader":19}],14:[function(a,b,c){"use strict";var d=a("./support"),e=a("./utils"),f=a("./crc32"),g=a("./signature"),h=a("./defaults"),i=a("./base64"),j=a("./compressions"),k=a("./compressedObject"),l=a("./nodeBuffer"),m=a("./utf8"),n=a("./stringWriter"),o=a("./uint8ArrayWriter"),p=function(a){if(a._data instanceof k&&(a._data=a._data.getContent(),a.options.binary=!0,a.options.base64=!1,"uint8array"===e.getTypeOf(a._data))){var b=a._data;a._data=new Uint8Array(b.length),0!==b.length&&a._data.set(b,0)}return a._data},q=function(a){var b=p(a),c=e.getTypeOf(b);return"string"===c?!a.options.binary&&d.nodebuffer?l(b,"utf-8"):a.asBinary():b},r=function(a){var b=p(this);return null===b||"undefined"==typeof b?"":(this.options.base64&&(b=i.decode(b)),b=a&&this.options.binary?D.utf8decode(b):e.transformTo("string",b),a||this.options.binary||(b=e.transformTo("string",D.utf8encode(b))),b)},s=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this.options=c,this._initialMetadata={dir:c.dir,date:c.date}};s.prototype={asText:function(){return r.call(this,!0)},asBinary:function(){return r.call(this,!1)},asNodeBuffer:function(){var a=q(this);return e.transformTo("nodebuffer",a)},asUint8Array:function(){var a=q(this);return e.transformTo("uint8array",a)},asArrayBuffer:function(){return this.asUint8Array().buffer}};var t=function(a,b){var c,d="";for(c=0;b>c;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},u=function(a){return a=a||{},a.base64!==!0||null!==a.binary&&void 0!==a.binary||(a.binary=!0),a=e.extend(a,h),a.date=a.date||new Date,null!==a.compression&&(a.compression=a.compression.toUpperCase()),a},v=function(a,b,c){var d,f=e.getTypeOf(b);if(c=u(c),"string"==typeof c.unixPermissions&&(c.unixPermissions=parseInt(c.unixPermissions,8)),c.unixPermissions&&16384&c.unixPermissions&&(c.dir=!0),c.dosPermissions&&16&c.dosPermissions&&(c.dir=!0),c.dir&&(a=x(a)),c.createFolders&&(d=w(a))&&y.call(this,d,!0),c.dir||null===b||"undefined"==typeof b)c.base64=!1,c.binary=!1,b=null,f=null;else if("string"===f)c.binary&&!c.base64&&c.optimizedBinaryString!==!0&&(b=e.string2binary(b));else{if(c.base64=!1,c.binary=!0,!(f||b instanceof k))throw new Error("The data of '"+a+"' is in an unsupported format !");"arraybuffer"===f&&(b=e.transformTo("uint8array",b))}var g=new s(a,b,c);return this.files[a]=g,g},w=function(a){"/"==a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},x=function(a){return"/"!=a.slice(-1)&&(a+="/"),a},y=function(a,b){return b="undefined"!=typeof b?b:!1,a=x(a),this.files[a]||v.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},z=function(a,b,c){var d,g=new k;return a._data instanceof k?(g.uncompressedSize=a._data.uncompressedSize,g.crc32=a._data.crc32,0===g.uncompressedSize||a.dir?(b=j.STORE,g.compressedContent="",g.crc32=0):a._data.compressionMethod===b.magic?g.compressedContent=a._data.getCompressedContent():(d=a._data.getContent(),g.compressedContent=b.compress(e.transformTo(b.compressInputType,d),c))):(d=q(a),d&&0!==d.length&&!a.dir||(b=j.STORE,d=""),g.uncompressedSize=d.length,g.crc32=f(d),g.compressedContent=b.compress(e.transformTo(b.compressInputType,d),c)),g.compressedSize=g.compressedContent.length,g.compressionMethod=b.magic,g},A=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},B=function(a,b){return 63&(a||0)},C=function(a,b,c,d,h,i){var j,k,l,n,o=(c.compressedContent,i!==m.utf8encode),p=e.transformTo("string",i(b.name)),q=e.transformTo("string",m.utf8encode(b.name)),r=b.comment||"",s=e.transformTo("string",i(r)),u=e.transformTo("string",m.utf8encode(r)),v=q.length!==b.name.length,w=u.length!==r.length,x=b.options,y="",z="",C="";l=b._initialMetadata.dir!==b.dir?b.dir:x.dir,n=b._initialMetadata.date!==b.date?b.date:x.date;var D=0,E=0;l&&(D|=16),"UNIX"===h?(E=798,D|=A(b.unixPermissions,l)):(E=20,D|=B(b.dosPermissions,l)),j=n.getHours(),j<<=6,j|=n.getMinutes(),j<<=5,j|=n.getSeconds()/2,k=n.getFullYear()-1980,k<<=4,k|=n.getMonth()+1,k<<=5,k|=n.getDate(),v&&(z=t(1,1)+t(f(p),4)+q,y+="up"+t(z.length,2)+z),w&&(C=t(1,1)+t(this.crc32(s),4)+u,y+="uc"+t(C.length,2)+C);var F="";F+="\n\x00",F+=o||!v&&!w?"\x00\x00":"\x00\b",F+=c.compressionMethod,F+=t(j,2),F+=t(k,2),F+=t(c.crc32,4),F+=t(c.compressedSize,4),F+=t(c.uncompressedSize,4),F+=t(p.length,2),F+=t(y.length,2);var G=g.LOCAL_FILE_HEADER+F+p+y,H=g.CENTRAL_FILE_HEADER+t(E,2)+F+t(s.length,2)+"\x00\x00\x00\x00"+t(D,4)+t(d,4)+p+y+s;return{fileRecord:G,dirRecord:H,compressedObject:c}},D={load:function(a,b){throw new Error("Load method is not defined. Is the file jszip-load.js included ?")},filter:function(a){var b,c,d,f,g=[];for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],f=new s(d.name,d._data,e.extend(d.options)),c=b.slice(this.root.length,b.length),b.slice(0,this.root.length)===this.root&&a(c,f)&&g.push(f));return g},file:function(a,b,c){if(1===arguments.length){if(e.isRegExp(a)){var d=a;return this.filter(function(a,b){return!b.dir&&d.test(a)})}return this.filter(function(b,c){return!c.dir&&b===a})[0]||null}return a=this.root+a,v.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(e.isRegExp(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=y.call(this,b),d=this.clone();return d.root=c.name,d},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!=a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){a=e.extend(a||{},{base64:!0,compression:"STORE",compressionOptions:null,type:"base64",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:m.utf8encode}),e.checkSupport(a.type),"darwin"!==a.platform&&"freebsd"!==a.platform&&"linux"!==a.platform&&"sunos"!==a.platform||(a.platform="UNIX"),"win32"===a.platform&&(a.platform="DOS");var b,c,d=[],f=0,h=0,k=e.transformTo("string",a.encodeFileName(a.comment||this.comment||""));for(var l in this.files)if(this.files.hasOwnProperty(l)){var p=this.files[l],q=p.options.compression||a.compression.toUpperCase(),r=j[q];if(!r)throw new Error(q+" is not a valid compression method !");var s=p.options.compressionOptions||a.compressionOptions||{},u=z.call(this,p,r,s),v=C.call(this,l,p,u,f,a.platform,a.encodeFileName);f+=v.fileRecord.length+u.compressedSize,h+=v.dirRecord.length,d.push(v)}var w="";w=g.CENTRAL_DIRECTORY_END+"\x00\x00\x00\x00"+t(d.length,2)+t(d.length,2)+t(h,4)+t(f,4)+t(k.length,2)+k;var x=a.type.toLowerCase();for(b="uint8array"===x||"arraybuffer"===x||"blob"===x||"nodebuffer"===x?new o(f+h+w.length):new n(f+h+w.length),c=0;c<d.length;c++)b.append(d[c].fileRecord),b.append(d[c].compressedObject.compressedContent);for(c=0;c<d.length;c++)b.append(d[c].dirRecord);b.append(w);var y=b.finalize();switch(a.type.toLowerCase()){case"uint8array":case"arraybuffer":case"nodebuffer":return e.transformTo(a.type.toLowerCase(),y);case"blob":return e.arrayBuffer2Blob(e.transformTo("arraybuffer",y),a.mimeType);case"base64":return a.base64?i.encode(y):y;default:return y}},crc32:function(a,b){return f(a,b)},utf8encode:function(a){return e.transformTo("string",m.utf8encode(a))},utf8decode:function(a){return m.utf8decode(a)}};b.exports=D},{"./base64":2,"./compressedObject":3,"./compressions":4,"./crc32":5,"./defaults":7,"./nodeBuffer":12,"./signature":15,"./stringWriter":17,"./support":18,"./uint8ArrayWriter":20,"./utf8":21,"./utils":22}],15:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],16:[function(a,b,c){"use strict";function d(a,b){this.data=a,b||(this.data=f.string2binary(this.data)),this.length=this.data.length,this.index=0,this.zero=0}var e=a("./dataReader"),f=a("./utils");d.prototype=new e,d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./dataReader":6,"./utils":22}],17:[function(a,b,c){"use strict";var d=a("./utils"),e=function(){this.data=[]};e.prototype={append:function(a){a=d.transformTo("string",a),this.data.push(a)},finalize:function(){return this.data.join("")}},b.exports=e},{"./utils":22}],18:[function(a,b,c){(function(a){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof a,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var b=new ArrayBuffer(0);try{c.blob=0===new Blob([b],{type:"application/zip"}).size}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;f.append(b),c.blob=0===f.getBlob("application/zip").size}catch(d){c.blob=!1}}}}).call(this,"undefined"!=typeof Buffer?Buffer:void 0)},{}],19:[function(a,b,c){"use strict";function d(a){a&&(this.data=a,this.length=this.data.length,this.index=0,this.zero=0)}var e=a("./arrayReader");d.prototype=new e,d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"./arrayReader":1}],20:[function(a,b,c){"use strict";var d=a("./utils"),e=function(a){this.data=new Uint8Array(a),this.index=0};e.prototype={append:function(a){0!==a.length&&(a=d.transformTo("uint8array",a),this.data.set(a,this.index),this.index+=a.length)},finalize:function(){return this.data}},b.exports=e},{"./utils":22}],21:[function(a,b,c){"use strict";for(var d=a("./utils"),e=a("./support"),f=a("./nodeBuffer"),g=new Array(256),h=0;256>h;h++)g[h]=h>=252?6:h>=248?5:h>=240?4:h>=224?3:h>=192?2:1;g[254]=g[254]=1;var i=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=e.uint8array?new Uint8Array(i):new Array(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},j=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+g[a[c]]>b?c:b},k=function(a){var b,c,e,f,h=a.length,i=new Array(2*h);for(c=0,b=0;h>b;)if(e=a[b++],128>e)i[c++]=e;else if(f=g[e],f>4)i[c++]=65533,b+=f-1;else{for(e&=2===f?31:3===f?15:7;f>1&&h>b;)e=e<<6|63&a[b++],f--;f>1?i[c++]=65533:65536>e?i[c++]=e:(e-=65536,i[c++]=55296|e>>10&1023,i[c++]=56320|1023&e)}return i.length!==c&&(i.subarray?i=i.subarray(0,c):i.length=c),d.applyFromCharCode(i)};c.utf8encode=function(a){return e.nodebuffer?f(a,"utf-8"):i(a)},c.utf8decode=function(a){if(e.nodebuffer)return d.transformTo("nodebuffer",a).toString("utf-8");a=d.transformTo(e.uint8array?"uint8array":"array",a);for(var b=[],c=0,f=a.length,g=65536;f>c;){var h=j(a,Math.min(c+g,f));e.uint8array?b.push(k(a.subarray(c,h))):b.push(k(a.slice(c,h))),c=h}return b.join("")}},{"./nodeBuffer":12,"./support":18,"./utils":22}],22:[function(a,b,c){"use strict";function d(a){return a}function e(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function f(a){var b=65536,d=[],e=a.length,f=c.getTypeOf(a),g=0,h=!0;try{switch(f){case"uint8array":String.fromCharCode.apply(null,new Uint8Array(0));break;case"nodebuffer":String.fromCharCode.apply(null,j(0))}}catch(i){h=!1}if(!h){for(var k="",l=0;l<a.length;l++)k+=String.fromCharCode(a[l]);return k}for(;e>g&&b>1;)try{"array"===f||"nodebuffer"===f?d.push(String.fromCharCode.apply(null,a.slice(g,Math.min(g+b,e)))):d.push(String.fromCharCode.apply(null,a.subarray(g,Math.min(g+b,e)))),g+=b}catch(i){b=Math.floor(b/2)}return d.join("")}function g(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];return b}var h=a("./support"),i=a("./compressions"),j=a("./nodeBuffer");c.string2binary=function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(255&a.charCodeAt(c));return b},c.arrayBuffer2Blob=function(a,b){c.checkSupport("blob"),b=b||"application/zip";try{return new Blob([a],{type:b})}catch(d){try{var e=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,f=new e;return f.append(a),f.getBlob(b)}catch(d){throw new Error("Bug : can't construct the Blob.")}}},c.applyFromCharCode=f;var k={};k.string={string:d,array:function(a){return e(a,new Array(a.length))},arraybuffer:function(a){return k.string.uint8array(a).buffer},uint8array:function(a){return e(a,new Uint8Array(a.length))},nodebuffer:function(a){return e(a,j(a.length))}},k.array={string:f,array:d,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(a)}},k.arraybuffer={string:function(a){return f(new Uint8Array(a))},array:function(a){return g(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:d,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return j(new Uint8Array(a))}},k.uint8array={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:d,nodebuffer:function(a){return j(a)}},k.nodebuffer={string:f,array:function(a){return g(a,new Array(a.length))},arraybuffer:function(a){return k.nodebuffer.uint8array(a).buffer},uint8array:function(a){return g(a,new Uint8Array(a.length))},nodebuffer:d},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=k[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":h.nodebuffer&&j.test(a)?"nodebuffer":h.uint8array&&a instanceof Uint8Array?"uint8array":h.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=h[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this browser")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(16>b?"0":"")+b.toString(16).toUpperCase();return d},c.findCompression=function(a){for(var b in i)if(i.hasOwnProperty(b)&&i[b].magic===a)return i[b];return null},c.isRegExp=function(a){return"[object RegExp]"===Object.prototype.toString.call(a)},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c}},{"./compressions":4,"./nodeBuffer":12,"./support":18}],23:[function(a,b,c){"use strict";function d(a,b){this.files=[],this.loadOptions=b,a&&this.load(a)}var e=a("./stringReader"),f=a("./nodeBufferReader"),g=a("./uint8ArrayReader"),h=a("./arrayReader"),i=a("./utils"),j=a("./signature"),k=a("./zipEntry"),l=a("./support");a("./object");d.prototype={checkSignature:function(a){var b=this.reader.readString(4);if(b!==a)throw new Error("Corrupted zip or bug : unexpected signature ("+i.pretty(b)+", expected "+i.pretty(a)+")")},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=l.uint8array?"uint8array":"array",c=i.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.versionMadeBy=this.reader.readString(2),this.versionNeeded=this.reader.readInt(2),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;d>e;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readString(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(j.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readString(4)===j.CENTRAL_FILE_HEADER;)a=new k({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(j.CENTRAL_DIRECTORY_END);if(0>a){var b=!this.isSignature(0,j.LOCAL_FILE_HEADER);throw b?new Error("Can't find end of central directory : is this a zip file ? If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip : can't find end of central directory")}this.reader.setIndex(a);var c=a;if(this.checkSignature(j.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(j.ZIP64_CENTRAL_DIRECTORY_LOCATOR),0>a)throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(a),this.checkSignature(j.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,j.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(j.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip : can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(j.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,j.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(0>e)throw new Error("Corrupted zip: missing "+Math.abs(e)+" bytes.")},prepareReader:function(a){var b=i.getTypeOf(a);if(i.checkSupport(b),"string"!==b||l.uint8array)if("nodebuffer"===b)this.reader=new f(a);else if(l.uint8array)this.reader=new g(i.transformTo("uint8array",a));else{if(!l.array)throw new Error("Unexpected error: unsupported type '"+b+"'");this.reader=new h(i.transformTo("array",a))}else this.reader=new e(a,this.loadOptions.optimizedBinaryString)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{"./arrayReader":1,"./nodeBufferReader":13,"./object":14,"./signature":15,"./stringReader":16,"./support":18,"./uint8ArrayReader":19,"./utils":22,"./zipEntry":24}],24:[function(a,b,c){"use strict";function d(a,b){this.options=a,this.loadOptions=b}var e=a("./stringReader"),f=a("./utils"),g=a("./compressedObject"),h=a("./object"),i=a("./support"),j=0,k=3;d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},prepareCompressedContent:function(a,b,c){return function(){var d=a.index;a.setIndex(b);var e=a.readData(c);return a.setIndex(d),e}},prepareContent:function(a,b,c,d,e){return function(){var a=f.transformTo(d.uncompressInputType,this.getCompressedContent()),b=d.uncompress(a);if(b.length!==e)throw new Error("Bug : uncompressed data size mismatch");return b}},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),-1==this.compressedSize||-1==this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize == -1 || uncompressedSize == -1)");if(b=f.findCompression(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+f.pretty(this.compressionMethod)+" unknown (inner file : "+f.transformTo("string",this.fileName)+")");if(this.decompressed=new g,this.decompressed.compressedSize=this.compressedSize,this.decompressed.uncompressedSize=this.uncompressedSize,this.decompressed.crc32=this.crc32,this.decompressed.compressionMethod=this.compressionMethod,this.decompressed.getCompressedContent=this.prepareCompressedContent(a,a.index,this.compressedSize,b),this.decompressed.getContent=this.prepareContent(a,a.index,this.compressedSize,b,this.uncompressedSize),this.loadOptions.checkCRC32&&(this.decompressed=f.transformTo("string",this.decompressed.getContent()),
h.crc32(this.decompressed)!==this.crc32))throw new Error("Corrupted zip : CRC32 mismatch")},readCentralPart:function(a){if(this.versionMadeBy=a.readInt(2),this.versionNeeded=a.readInt(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4),this.fileNameLength=a.readInt(2),this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");this.fileName=a.readData(this.fileNameLength),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===j&&(this.dosPermissions=63&this.externalFileAttributes),a===k&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=new e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index;for(this.extraFields=this.extraFields||{};a.index<e+this.extraFieldsLength;)b=a.readInt(2),c=a.readInt(2),d=a.readString(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=i.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=h.utf8decode(this.fileName),this.fileCommentStr=h.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=new e(a.value);return 1!==b.readInt(1)?null:h.crc32(this.fileName)!==b.readInt(4)?null:h.utf8decode(b.readString(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=new e(a.value);return 1!==b.readInt(1)?null:h.crc32(this.fileComment)!==b.readInt(4)?null:h.utf8decode(b.readString(a.length-5))}return null}},b.exports=d},{"./compressedObject":3,"./object":14,"./stringReader":16,"./support":18,"./utils":22}],25:[function(a,b,c){"use strict";var d=a("./lib/utils/common").assign,e=a("./lib/deflate"),f=a("./lib/inflate"),g=a("./lib/zlib/constants"),h={};d(h,e,f,g),b.exports=h},{"./lib/deflate":26,"./lib/inflate":27,"./lib/utils/common":28,"./lib/zlib/constants":31}],26:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);b.header&&h.deflateSetHeader(this.strm,b.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a("./zlib/deflate"),i=a("./utils/common"),j=a("./utils/strings"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,"string"==typeof a?e.input=j.string2buf(a):"[object ArrayBuffer]"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||("string"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d===r?(this.onEnd(p),e.avail_out=0,!0):!0},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{"./utils/common":28,"./utils/strings":29,"./zlib/deflate":33,"./zlib/messages":38,"./zlib/zstream":40}],27:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg;return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a("./zlib/inflate"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/constants"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=a("./zlib/gzheader"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l=this.strm,m=this.options.chunkSize,o=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,"string"==typeof a?l.input=i.binstring2buf(a):"[object ArrayBuffer]"===n.call(a)?l.input=new Uint8Array(a):l.input=a,l.next_in=0,l.avail_in=l.input.length;do{if(0===l.avail_out&&(l.output=new h.Buf8(m),l.next_out=0,l.avail_out=m),c=g.inflate(l,j.Z_NO_FLUSH),c===j.Z_BUF_ERROR&&o===!0&&(c=j.Z_OK,o=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;l.next_out&&(0!==l.avail_out&&c!==j.Z_STREAM_END&&(0!==l.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||("string"===this.options.to?(e=i.utf8border(l.output,l.next_out),f=l.next_out-e,k=i.buf2string(l.output,e),l.next_out=f,l.avail_out=m-f,f&&h.arraySet(l.output,l.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(l.output,l.next_out)))),0===l.avail_in&&0===l.avail_out&&(o=!0)}while((l.avail_in>0||0===l.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d===j.Z_SYNC_FLUSH?(this.onEnd(j.Z_OK),l.avail_out=0,!0):!0},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{"./utils/common":28,"./utils/strings":29,"./zlib/constants":31,"./zlib/gzheader":34,"./zlib/inflate":36,"./zlib/messages":38,"./zlib/zstream":40}],28:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;c>b;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;c>b;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;d>f;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],29:[function(a,b,c){"use strict";function d(a,b){if(65537>b&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;b>d;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;256>j;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;h>f;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=128>c?1:2048>c?2:65536>c?3:4;for(b=new e.Buf8(i),g=0,f=0;i>g;f++)c=a.charCodeAt(f),55296===(64512&c)&&h>f+1&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),128>c?b[g++]=c:2048>c?(b[g++]=192|c>>>6,b[g++]=128|63&c):65536>c?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;d>c;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;h>c;)if(f=a[c++],128>f)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&h>c;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:65536>f?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return 0>c?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":28}],30:[function(a,b,c){"use strict";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0}b.exports=d},{}],31:[function(a,b,c){"use strict";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],32:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;256>c;c++){a=c;for(var d=0;8>d;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;g>h;h++)a=a>>>8^e[255&(a^b[h])];return-1^a}var f=d();b.exports=e},{}],33:[function(a,b,c){"use strict";function d(a,b){return a.msg=H[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(D.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){E._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,D.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=F(a.adler,b,e,c):2===a.state.wrap&&(a.adler=G(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-ka?a.strstart-(a.w_size-ka):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ja,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&m>f);if(d=ja-(m-f),f=m-ja,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-ka)){D.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ia)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ia-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ia)););}while(a.lookahead<ka&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===I)return ta;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ta;if(a.strstart-a.block_start>=a.w_size-ka&&(h(a,!1),0===a.strm.avail_out))return ta}return a.insert=0,b===L?(h(a,!0),0===a.strm.avail_out?va:wa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ta:ta}function o(a,b){for(var c,d;;){if(a.lookahead<ka){if(m(a),a.lookahead<ka&&b===I)return ta;if(0===a.lookahead)break}if(c=0,a.lookahead>=ia&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ia-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-ka&&(a.match_length=l(a,c)),a.match_length>=ia)if(d=E._tr_tally(a,a.strstart-a.match_start,a.match_length-ia),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ia){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ia-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=E._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ta}return a.insert=a.strstart<ia-1?a.strstart:ia-1,b===L?(h(a,!0),0===a.strm.avail_out?va:wa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ta:ua}function p(a,b){for(var c,d,e;;){if(a.lookahead<ka){if(m(a),a.lookahead<ka&&b===I)return ta;if(0===a.lookahead)break}if(c=0,a.lookahead>=ia&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ia-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ia-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-ka&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===T||a.match_length===ia&&a.strstart-a.match_start>4096)&&(a.match_length=ia-1)),a.prev_length>=ia&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ia,d=E._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ia),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ia-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ia-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ta}else if(a.match_available){if(d=E._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ta}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=E._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ia-1?a.strstart:ia-1,b===L?(h(a,!0),0===a.strm.avail_out?va:wa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ta:ua}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ja){if(m(a),a.lookahead<=ja&&b===I)return ta;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ia&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ja;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&f>e);a.match_length=ja-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ia?(c=E._tr_tally(a,1,a.match_length-ia),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=E._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ta}return a.insert=0,b===L?(h(a,!0),0===a.strm.avail_out?va:wa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ta:ua}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===I)return ta;break}if(a.match_length=0,c=E._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ta}return a.insert=0,b===L?(h(a,!0),0===a.strm.avail_out?va:wa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ta:ua}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=C[a.level].max_lazy,a.good_match=C[a.level].good_length,a.nice_match=C[a.level].nice_length,a.max_chain_length=C[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ia-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new D.Buf16(2*ga),this.dyn_dtree=new D.Buf16(2*(2*ea+1)),this.bl_tree=new D.Buf16(2*(2*fa+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new D.Buf16(ha+1),this.heap=new D.Buf16(2*da+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new D.Buf16(2*da+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Y,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?ma:ra,a.adler=2===b.wrap?0:1,b.last_flush=I,E._tr_init(b),N):d(a,P)}function w(a){var b=v(a);return b===N&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?P:(a.state.gzhead=b,N):P}function y(a,b,c,e,f,g){if(!a)return P;var h=1;if(b===S&&(b=6),0>e?(h=0,e=-e):e>15&&(h=2,e-=16),1>f||f>$||c!==Z||8>e||e>15||0>b||b>9||0>g||g>W)return d(a,P);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ia-1)/ia),i.window=new D.Buf8(2*i.w_size),i.head=new D.Buf16(i.hash_size),i.prev=new D.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new D.Buf8(i.pending_buf_size),i.d_buf=i.lit_bufsize>>1,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,Z,_,aa,X)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>M||0>b)return a?d(a,P):P;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===sa&&b!==L)return d(a,0===a.avail_out?R:P);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===ma)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=U||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=G(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=na):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=U||h.level<2?4:0),i(h,xa),h.status=ra);else{var m=Z+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=U||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=la),m+=31-m%31,h.status=ra,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===na)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=G(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=G(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=oa)}else h.status=oa;if(h.status===oa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=G(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=G(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=G(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=G(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=qa)}else h.status=qa;if(h.status===qa&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=ra)):h.status=ra),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,N}else if(0===a.avail_in&&e(b)<=e(c)&&b!==L)return d(a,R);if(h.status===sa&&0!==a.avail_in)return d(a,R);if(0!==a.avail_in||0!==h.lookahead||b!==I&&h.status!==sa){var o=h.strategy===U?r(h,b):h.strategy===V?q(h,b):C[h.level].func(h,b);if(o!==va&&o!==wa||(h.status=sa),o===ta||o===va)return 0===a.avail_out&&(h.last_flush=-1),N;if(o===ua&&(b===J?E._tr_align(h):b!==M&&(E._tr_stored_block(h,0,0,!1),b===K&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,N}return b!==L?N:h.wrap<=0?O:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?N:O)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==ma&&b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa?d(a,P):(a.state=null,b===ra?d(a,Q):N)):P}var C,D=a("../utils/common"),E=a("./trees"),F=a("./adler32"),G=a("./crc32"),H=a("./messages"),I=0,J=1,K=3,L=4,M=5,N=0,O=1,P=-2,Q=-3,R=-5,S=-1,T=1,U=2,V=3,W=4,X=0,Y=2,Z=8,$=9,_=15,aa=8,ba=29,ca=256,da=ca+1+ba,ea=30,fa=19,ga=2*da+1,ha=15,ia=3,ja=258,ka=ja+ia+1,la=32,ma=42,na=69,oa=73,pa=91,qa=103,ra=113,sa=666,ta=1,ua=2,va=3,wa=4,xa=3;C=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":28,"./adler32":30,"./crc32":32,"./messages":38,"./trees":39}],34:[function(a,b,c){"use strict";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=d},{}],35:[function(a,b,c){"use strict";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg="invalid literal/length code",c.mode=d;break a}x=65535&v,w&=15,w&&(w>q&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),15>q&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",c.mode=d;break a}if(y=65535&v,w&=15,w>q&&(p+=B[f++]<<q,q+=8,w>q&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg="invalid distance too far back",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(w>n){if(z+=l+n-w,w-=n,x>w){x-=w;do C[h++]=o[z++];while(--w);if(z=0,x>n){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,x>w){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(g>f&&j>h);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=g>f?5+(g-f):5-(f-g),a.avail_out=j>h?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],36:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new r.Buf16(320),this.work=new r.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=K,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new r.Buf32(oa),b.distcode=b.distdyn=new r.Buf32(pa),b.sane=1,b.back=-1,C):F}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):F}function h(a,b){var c,d;return a&&a.state?(d=a.state,0>b?(c=0,b=-b):(c=(b>>4)+1,48>b&&(b&=15)),b&&(8>b||b>15)?F:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):F}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==C&&(a.state=null),c):F}function j(a){return i(a,ra)}function k(a){if(sa){var b;for(p=new r.Buf32(512),q=new r.Buf32(32),b=0;144>b;)a.lens[b++]=8;for(;256>b;)a.lens[b++]=9;for(;280>b;)a.lens[b++]=7;for(;288>b;)a.lens[b++]=8;for(v(x,a.lens,0,288,p,0,a.work,{bits:9}),b=0;32>b;)a.lens[b++]=5;v(y,a.lens,0,32,q,0,a.work,{bits:5}),sa=!1}a.lencode=p,a.lenbits=9,a.distcode=q,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new r.Buf8(f.wsize)),d>=f.wsize?(r.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),r.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(r.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,oa,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new r.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return F;c=a.state,c.mode===V&&(c.mode=W),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=C;a:for(;;)switch(c.mode){case K:if(0===c.wrap){c.mode=W;break}for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=t(c.check,Ba,2,0),m=0,n=0,c.mode=L;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=la;break}if((15&m)!==J){a.msg="unknown compression method",c.mode=la;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg="invalid window size",c.mode=la;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?T:V,m=0,n=0;break;case L:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==J){a.msg="unknown compression method",c.mode=la;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=la;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=t(c.check,Ba,2,0)),m=0,n=0,c.mode=M;case M:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=t(c.check,Ba,4,0)),m=0,n=0,c.mode=N;case N:for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=t(c.check,Ba,2,0)),m=0,n=0,c.mode=O;case O:if(1024&c.flags){for(;16>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=t(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=P;case P:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),r.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=Q;case Q:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=R;case R:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&i>q);if(512&c.flags&&(c.check=t(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=S;case S:if(512&c.flags){for(;16>n;){
if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=la;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=V;break;case T:for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=U;case U:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,E;a.adler=c.check=1,c.mode=V;case V:if(b===A||b===B)break a;case W:if(c.last){m>>>=7&n,n-=7&n,c.mode=ia;break}for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=X;break;case 1:if(k(c),c.mode=ba,b===B){m>>>=2,n-=2;break a}break;case 2:c.mode=$;break;case 3:a.msg="invalid block type",c.mode=la}m>>>=2,n-=2;break;case X:for(m>>>=7&n,n-=7&n;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=la;break}if(c.length=65535&m,m=0,n=0,c.mode=Y,b===B)break a;case Y:c.mode=Z;case Z:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;r.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=V;break;case $:for(;14>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=la;break}c.have=0,c.mode=_;case _:for(;c.have<c.ncode;){for(;3>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=v(w,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid code lengths set",c.mode=la;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(n>=qa);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(16>sa)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;za>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg="invalid bit length repeat",c.mode=la;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;za>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;za>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=la;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===la)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=la;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=v(x,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid literal/lengths set",c.mode=la;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=v(y,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg="invalid distances set",c.mode=la;break}if(c.mode=ba,b===B)break a;case ba:c.mode=ca;case ca:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,u(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===V&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(n>=qa);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(n>=ta+qa);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ha;break}if(32&ra){c.back=-1,c.mode=V;break}if(64&ra){a.msg="invalid literal/length code",c.mode=la;break}c.extra=15&ra,c.mode=da;case da:if(c.extra){for(za=c.extra;za>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=ea;case ea:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(n>=qa);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(n>=ta+qa);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg="invalid distance code",c.mode=la;break}c.offset=sa,c.extra=15&ra,c.mode=fa;case fa:if(c.extra){for(za=c.extra;za>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=la;break}c.mode=ga;case ga:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=la;break}q>c.wnext?(q-=c.wnext,oa=c.wsize-q):oa=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,oa=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[oa++];while(--q);0===c.length&&(c.mode=ca);break;case ha:if(0===j)break a;f[h++]=c.length,j--,c.mode=ca;break;case ia:if(c.wrap){for(;32>n;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?t(c.check,f,p,h-p):s(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=la;break}m=0,n=0}c.mode=ja;case ja:if(c.wrap&&c.flags){for(;32>n;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=la;break}m=0,n=0}c.mode=ka;case ka:xa=D;break a;case la:xa=G;break a;case ma:return H;case na:default:return F}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<la&&(c.mode<ia||b!==z))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=ma,H):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?t(c.check,f,p,a.next_out-p):s(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===V?128:0)+(c.mode===ba||c.mode===Y?256:0),(0===o&&0===p||b===z)&&xa===C&&(xa=I),xa)}function n(a){if(!a||!a.state)return F;var b=a.state;return b.window&&(b.window=null),a.state=null,C}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?F:(c.head=b,b.done=!1,C)):F}var p,q,r=a("../utils/common"),s=a("./adler32"),t=a("./crc32"),u=a("./inffast"),v=a("./inftrees"),w=0,x=1,y=2,z=4,A=5,B=6,C=0,D=1,E=2,F=-2,G=-3,H=-4,I=-5,J=8,K=1,L=2,M=3,N=4,O=5,P=6,Q=7,R=8,S=9,T=10,U=11,V=12,W=13,X=14,Y=15,Z=16,$=17,_=18,aa=19,ba=20,ca=21,da=22,ea=23,fa=24,ga=25,ha=26,ia=27,ja=28,ka=29,la=30,ma=31,na=32,oa=852,pa=592,qa=15,ra=qa,sa=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":28,"./adler32":30,"./crc32":32,"./inffast":35,"./inftrees":37}],37:[function(a,b,c){"use strict";var d=a("../utils/common"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;e>=D;D++)P[D]=0;for(E=0;o>E;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;G>F&&0===P[F];F++);for(F>H&&(H=F),K=1,D=1;e>=D;D++)if(K<<=1,K-=P[D],0>K)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;e>D;D++)Q[D+1]=Q[D]+P[D];for(E=0;o>E;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(var T=0;;){T++,z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;G>I+J&&(K-=P[I+J],!(0>=K));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":28}],38:[function(a,b,c){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],39:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return 256>a?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;W>=f;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,c=a.heap_max+1;V>c;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;for(d=1;W>=d;d++)f[d]=g=g+c[d-1]<<1;for(e=0;b>=e;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;Q-1>d;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;16>d;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;T>d;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;W>=b;b++)g[b]=0;for(a=0;143>=a;)ga[2*a+1]=8,a++,g[8]++;for(;255>=a;)ga[2*a+1]=9,a++,g[9]++;for(;279>=a;)ga[2*a+1]=7,a++,g[7]++;for(;287>=a;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;T>a;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;S>b;b++)a.dyn_ltree[2*b]=0;for(b=0;T>b;b++)a.dyn_dtree[2*b]=0;for(b=0;U>b;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;i>c;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=2>j?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;c>=d;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(j>h?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):10>=h?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;c>=d;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(l>h){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):10>=h?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;d>e;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;31>=b;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;R>b;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,e>=f&&(e=f)):e=f=c+5,e>=c+4&&-1!==b?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a("../utils/common"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));d(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{"../utils/common":28}],40:[function(a,b,c){"use strict";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}]},{},[10])(10)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":194}],252:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],253:[function(require,module,exports){
(function (Buffer){
'use strict';


const jpeg = require('jpeg-js');

function getPixel(x, y, channel, width, buff) {
	return buff[(x + y * width) * 4 + channel];
}

function convertPixelsToHistogram(img) {
	const createHistogramArray = function () {
		const ret = new Array(256);
		for (let i = 0; i < ret.length; i++) {
			ret[i] = 0;
		}
		return ret;
	};

	const width = img.width;
	const height = img.height;

	const histograms = [
		createHistogramArray(),
		createHistogramArray(),
		createHistogramArray()
	];

	for (let channel = 0; channel < histograms.length; channel++) {
		for (let i = 0; i < width; i++) {
			for (let j = 0; j < height; j++) {
				const pixelValue = getPixel(i, j, channel, width, img.data);

				// Erase pixels considered as white
				if (getPixel(i, j, 0, width, img.data) < 249 &&
						getPixel(i, j, 1, width, img.data) < 249 &&
						getPixel(i, j, 2, width, img.data) < 249) {
					histograms[channel][pixelValue]++;
				}
			}
		}
	}

	return histograms;
}

function synthesizeWhiteFrame(frames) {
	const firstImageData = jpeg.decode(frames[0].getImage());
	const width = firstImageData.width;
	const height = firstImageData.height;

	const frameData = new Buffer(width * height * 4);
	let i = 0;
	while (i < frameData.length) {
		frameData[i++] = 0xFF; // red
		frameData[i++] = 0xFF; // green
		frameData[i++] = 0xFF; // blue
		frameData[i++] = 0xFF; // alpha - ignored in JPEGs
	}

	var jpegImageData = jpeg.encode({
		data: frameData,
		width: width,
		height: height
	});
	return jpegImageData.data;
}

const screenshotTraceCategory = 'disabled-by-default-devtools.screenshot';
function extractFramesFromTimeline(timeline) {
	let trace;
	trace = typeof timeline === 'string' ? fs.readFileSync(timeline, 'utf-8') : timeline;
	try {
		trace = typeof trace === 'string' ? JSON.parse(trace) : trace;
	} catch (e) {
		throw new Error('Speedline: Invalid JSON' + e.message);
	}
	let events = trace.traceEvents || trace;
	events = events.sort((a, b) => a.ts - b.ts).filter(e => e.ts !== 0);

	const startTs = events[0].ts / 1000;
	const endTs = events[events.length - 1].ts / 1000;

	const rawScreenshots = events.filter(e => e.cat.includes(screenshotTraceCategory));
	const frames = rawScreenshots.map(function (evt) {
		const base64img = evt.args && evt.args.snapshot;
		const timestamp = evt.ts / 1000;

		const imgBuff = new Buffer(base64img, 'base64');
		return frame(imgBuff, timestamp);
	});

	if (frames.length === 0) {
		return Promise.reject(new Error('No screenshots found in trace'));
	}
	// add white frame to beginning of trace
	const fakeWhiteFrame = frame(synthesizeWhiteFrame(frames), startTs);
	frames.unshift(fakeWhiteFrame);

	const data = {
		startTs,
		endTs,
		frames: frames
	};
	return Promise.resolve(data);
}

function frame(imgBuff, ts) {
	let _histogram = null;
	let _progress = null;
	let _perceptualProgress = null;
	let _parsedImage = null;

	return {
		getHistogram: function () {
			if (_histogram) {
				return _histogram;
			}

			const pixels = this.getParsedImage();
			_histogram = convertPixelsToHistogram(pixels);
			return _histogram;
		},

		getTimeStamp: function () {
			return ts;
		},

		setProgress: function (progress) {
			_progress = progress;
		},

		setPerceptualProgress: function (progress) {
			_perceptualProgress = progress;
		},

		getImage: function () {
			return imgBuff;
		},

		getParsedImage: function () {
			if (!_parsedImage) {
				_parsedImage = jpeg.decode(imgBuff);
			}
			return _parsedImage;
		},

		getProgress: function () {
			return _progress;
		},

		getPerceptualProgress: function () {
			return _perceptualProgress;
		}
	};
}

module.exports = {
	extractFramesFromTimeline,
	create: frame
};

}).call(this,require("buffer").Buffer)
},{"buffer":194,"jpeg-js":248}],254:[function(require,module,exports){
'use strict';

const frame = require('./frame');
const speedIndex = require('./speed-index');

function calculateValues(frames, data) {
	const indexes = speedIndex.calculateSpeedIndexes(frames, data);
	const duration = Math.floor(data.endTs - data.startTs);
	const first = Math.floor(indexes.firstPaintTs - data.startTs);
	const complete = Math.floor(indexes.visuallyCompleteTs - data.startTs);

	return {
		beginning: data.startTs,
		end: data.endTs,
		frames,
		first,
		complete,
		duration,
		speedIndex: indexes.speedIndex,
		perceptualSpeedIndex: indexes.perceptualSpeedIndex
	};
}

/**
 * Retrieve speed index informations
 * @param  {string|Array|DevtoolsTimelineModel} timeline
 * @return {Promise} resolving with an object containing the speed index informations
 */
module.exports = function (timeline) {
	return frame.extractFramesFromTimeline(timeline).then(function (data) {
		const frames = data.frames;
		speedIndex.calculateVisualProgress(frames);
		speedIndex.calculatePerceptualProgress(frames);
		return calculateValues(frames, data);
	});
};

},{"./frame":253,"./speed-index":255}],255:[function(require,module,exports){
'use strict';

const imageSSIM = require('image-ssim');

function calculateFrameProgress(current, initial, target) {
	let total = 0;
	let match = 0;

	const currentHist = current.getHistogram();
	const initialHist = initial.getHistogram();
	const targetHist = target.getHistogram();

	for (let channel = 0; channel < 3; channel++) {
		for (let pixelVal = 0; pixelVal < 256; pixelVal++) {
			const currentCount = currentHist[channel][pixelVal];
			const initialCount = initialHist[channel][pixelVal];
			const targetCount = targetHist[channel][pixelVal];

			const currentDiff = Math.abs(currentCount - initialCount);
			const targetDiff = Math.abs(targetCount - initialCount);

			match += Math.min(currentDiff, targetDiff);
			total += targetDiff;
		}
	}

	let progress;
	if (match === 0 && total === 0) {	// All images are the same
		progress = 100;
	} else {													// When images differs
		progress = Math.floor(match / total * 100);
	}
	return progress;
}

function calculateVisualProgress(frames) {
	const initial = frames[0];
	const target = frames[frames.length - 1];

	frames.forEach(function (frame) {
		const progress = calculateFrameProgress(frame, initial, target);
		frame.setProgress(progress);
	});

	return frames;
}

function calculateFrameSimilarity(frame, target) {
	const defaultImageConfig = {
		channels: 3
	};

	const frameData = Object.assign(frame.getParsedImage(), defaultImageConfig);
	const targetData = Object.assign(target.getParsedImage(), defaultImageConfig);

	const diff = imageSSIM.compare(frameData, targetData);
	return diff.ssim;
}

function calculatePerceptualProgress(frames) {
	const target = frames[frames.length - 1];

	// Calculate frames simliarity between each frames and the final
	const framesSimilarity = frames
		.map(frame => calculateFrameSimilarity(frame, target));

	// Get the min frame similarity value
	const minPreceptualProgress = framesSimilarity
		.reduce((min, progress) => Math.min(min, progress), Infinity);

	// Remap the values from [minPreceptualProgress, 1], to [0, 100] interval
	// to be consistent with the standard visual progress
	const normalizedSimilarity = framesSimilarity
		.map(progress => {
			if (progress === minPreceptualProgress) { // Images are the same
				return 0;
			}
			const oldRange = 1 - minPreceptualProgress;
			return ((progress - minPreceptualProgress) * 100) / oldRange;
		});

	normalizedSimilarity
		.forEach((progress, index) => frames[index].setPerceptualProgress(progress));

	return frames;
}

function calculateSpeedIndexes(frames, data) {
	const startTs = data.startTs;
	let visuallyCompleteTs;
	let firstPaintTs;

	// find first paint
	for (let i = 0; i < frames.length && !firstPaintTs; i++) {
		if (frames[i].getProgress() > 0) {
			firstPaintTs = frames[i].getTimeStamp();
		}
	}

	// find visually complete
	for (let i = 0; i < frames.length && !visuallyCompleteTs; i++) {
		if (frames[i].getProgress() >= 100) {
			visuallyCompleteTs = frames[i].getTimeStamp();
		}
	}

	let prevFrameTs = frames[0].getTimeStamp();
	let prevProgress = frames[0].getProgress();
	let prevPerceptualProgress = frames[0].getPerceptualProgress();

	// SI = firstPaint + sum(fP to VC){1-VC%}
	//     github.com/pmdartus/speedline/issues/28#issuecomment-244127192
	let speedIndex = firstPaintTs - startTs;
	let perceptualSpeedIndex = firstPaintTs - startTs;

	frames.forEach(function (frame) {
		// skip frames from 0 to fP
		if (frame.getTimeStamp() > firstPaintTs) {
			const elapsed = frame.getTimeStamp() - prevFrameTs;
			speedIndex += elapsed * (1 - prevProgress);
			perceptualSpeedIndex += elapsed * (1 - prevPerceptualProgress);
		}

		prevFrameTs = frame.getTimeStamp();
		prevProgress = frame.getProgress() / 100;
		prevPerceptualProgress = frame.getPerceptualProgress() / 100;
	});

	return {
		firstPaintTs,
		visuallyCompleteTs,
		speedIndex,
		perceptualSpeedIndex
	};
}

module.exports = {
	calculateVisualProgress,
	calculatePerceptualProgress,
	calculateSpeedIndexes
};

},{"image-ssim":247}],256:[function(require,module,exports){
module.exports={
  "name": "lighthouse",
  "version": "1.1.6",
  "description": "Lighthouse",
  "main": "./lighthouse-core/index.js",
  "bin": {
    "lighthouse": "./lighthouse-cli/index.js",
    "chrome-debug": "lighthouse-core/scripts/launch-chrome.sh"
  },
  "engines": {
    "node": ">=5"
  },
  "scripts": {
    "lint": "[ \"$CI\" = true ] && eslint --quiet . || eslint .",
    "smoke": "lighthouse-cli/test/smokehouse/offline-local/run-tests.sh",
    "coverage": "node $__node_harmony $(npm bin)/istanbul cover -x \"**/third_party/**\" _mocha -- $(find */test -name '*-test.js') --timeout 10000 --reporter progress",
    "coveralls": "npm run coverage && cat ./coverage/lcov.info | coveralls",
    "start": "node ./lighthouse-cli/index.js",
    "test": "npm run lint --silent && npm run unit",
    "cli-unit": "lighthouse-core/scripts/run-mocha.sh --cli",
    "unit": "lighthouse-core/scripts/run-mocha.sh --default",
    "closure": "cd lighthouse-core && closure/closure-type-checking.js",
    "watch": "lighthouse-core/scripts/run-mocha.sh --watch",
    "chrome": "lighthouse-core/scripts/launch-chrome.sh",
    "dbw": "npm run start -- --config-path=lighthouse-core/config/dobetterweb.json --mobile=false --output=html --output-path=results.html",
    "smokehouse": "node $__node_harmony lighthouse-cli/test/smokehouse/smokehouse.js"
  },
  "devDependencies": {
    "babel-core": "^6.16.0",
    "babel-plugin-transform-es2015-destructuring": "^6.9.0",
    "coveralls": "^2.11.9",
    "eslint": "^2.4.0",
    "eslint-config-google": "^0.4.0",
    "google-closure-compiler": "^20160517.0.0",
    "gulp": "^3.9.1",
    "gulp-replace": "^0.5.4",
    "gulp-util": "^3.0.7",
    "istanbul": "^0.4.3",
    "jsdom": "^9.0.0",
    "mkdirp": "^0.5.1",
    "mocha": "^2.3.3",
    "request": "^2.69.0",
    "walk": "^2.3.9"
  },
  "dependencies": {
    "axe-core": "^1.1.1",
    "chrome-devtools-frontend": "1.0.422034",
    "debug": "^2.2.0",
    "devtools-timeline-model": "1.1.6",
    "gl-matrix": "2.3.2",
    "handlebars": "^4.0.5",
    "json-stringify-safe": "^5.0.1",
    "jszip": "2.6.0",
    "mkdirp": "^0.5.1",
    "rimraf": "^2.2.8",
    "semver": ">=4.3.3",
    "speedline": "1.0.3",
    "ws": "^1.1.1",
    "yargs": "3.30.0"
  },
  "repository": "googlechrome/lighthouse",
  "keywords": [
    "google",
    "chrome",
    "devtools"
  ],
  "author": "The Chromium Authors",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/googlechrome/lighthouse/issues"
  },
  "homepage": "https://github.com/googlechrome/lighthouse#readme"
}

},{}]},{},[191]);
