{"version":3,"sources":["html/html-parser.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;AAEH,+BAA0D;AAC1D,mCAA0C;AAE1C,oCAAuC;AAKvC,mDAAmD;AAEnD;IACE;;;;;OAKG;IACH,KAAK,CAAC,QAAgB,EAAE,GAAgB,EAAE,UAA+B;QAEvE,MAAM,GAAG,GAAG,cAAS,CAAC,QAAQ,EAAE,EAAC,YAAY,EAAE,IAAI,EAAC,CAAC,CAAC;QAEtD,2EAA2E;QAC3E,MAAM,OAAO,GAAG,YAAK,CACjB,GAAG,EACH,iBAAC,CAAC,GAAG,CACD,iBAAC,CAAC,aAAa,CAAC,iBAAC,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,EACrC,iBAAC,CAAC,UAAU,CAAC,MAAM,CAAC,EACpB,iBAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAE5B,IAAI,OAAO,CAAC;QACZ,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;YACZ,MAAM,QAAQ,GAAG,mBAAY,CAAC,OAAO,EAAE,MAAM,CAAqB,CAAC;YACnE,OAAO,GAAG,qBAAa,CAAC,UAAU,CAAC,GAAG,EAAE,QAAQ,CAAuB,CAAC;QAC1E,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,OAAO,GAAG,GAAG,CAAC;QAChB,CAAC;QAED,MAAM,QAAQ,GAAG,CAAC,CAAC,UAAU,CAAC;QAC9B,UAAU,GAAG,UAAU,IAAI,EAAE,CAAC;QAC9B,MAAM,CAAC,IAAI,kCAAkB,CAAC;YAC5B,GAAG;YACH,OAAO;YACP,QAAQ;YACR,GAAG;YACH,cAAc,EAAE,UAAU,CAAC,cAAc;YACzC,OAAO,EAAE,UAAU,CAAC,OAAO,EAAE,QAAQ;SACtC,CAAC,CAAC;IACL,CAAC;CACF;AAtCD,gCAsCC","file":"html-parser.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {getAttribute, predicates as p, query} from 'dom5';\nimport {parse as parseHtml} from 'parse5';\n\nimport {ScannedImport} from '../index';\nimport {InlineDocInfo} from '../model/model';\nimport {FileRelativeUrl, ResolvedUrl} from '../model/url';\nimport {Parser} from '../parser/parser';\n\nimport {ParsedHtmlDocument} from './html-document';\n\nexport class HtmlParser implements Parser<ParsedHtmlDocument> {\n  /**\n   * Parse html into ASTs.\n   *\n   * @param {string} htmlString an HTML document.\n   * @param {string} href is the path of the document.\n   */\n  parse(contents: string, url: ResolvedUrl, inlineInfo?: InlineDocInfo<any>):\n      ParsedHtmlDocument {\n    const ast = parseHtml(contents, {locationInfo: true});\n\n    // There should be at most one <base> tag and it must be inside <head> tag.\n    const baseTag = query(\n        ast,\n        p.AND(\n            p.parentMatches(p.hasTagName('head')),\n            p.hasTagName('base'),\n            p.hasAttr('href')));\n\n    let baseUrl;\n    if (baseTag) {\n      const baseHref = getAttribute(baseTag, 'href')! as FileRelativeUrl;\n      baseUrl = ScannedImport.resolveUrl(url, baseHref) as any as ResolvedUrl;\n    } else {\n      baseUrl = url;\n    }\n\n    const isInline = !!inlineInfo;\n    inlineInfo = inlineInfo || {};\n    return new ParsedHtmlDocument({\n      url,\n      baseUrl,\n      contents,\n      ast,\n      locationOffset: inlineInfo.locationOffset,\n      astNode: inlineInfo.astNode, isInline,\n    });\n  }\n}\n"]}