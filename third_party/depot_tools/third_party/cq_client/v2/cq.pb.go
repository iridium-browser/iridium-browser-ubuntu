// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cq.proto

/*
Package cq is a generated protocol buffer package.

It is generated from these files:
	cq.proto

It has these top-level messages:
	Config
	SharedConfig
	Rietveld
	Gerrit
	Verifiers
*/
package cq

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// This message describes a Commit Queue configuration for an entire project.
// The config file cq.cfg should be stored in the project's config directory.
type Config struct {
	// Required. Version of the config format.
	Version *int32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// The actual configurations, shared across multiple repositories.
	Configs          []*SharedConfig `protobuf:"bytes,2,rep,name=configs" json:"configs,omitempty"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Config) GetVersion() int32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Config) GetConfigs() []*SharedConfig {
	if m != nil {
		return m.Configs
	}
	return nil
}

// This message describes a shared configuration for multiple repositories.
type SharedConfig struct {
	// At least one required. List repositories which share this CQ configuration.
	Repos []*SharedConfig_Repository `protobuf:"bytes,1,rep,name=repos" json:"repos,omitempty"`
	// List of verifiers that verify if the CL is ready to be committed.
	Verifiers *Verifiers `protobuf:"bytes,2,opt,name=verifiers" json:"verifiers,omitempty"`
	// URL of the CQ status app to push updates to.
	CqStatusUrl *string `protobuf:"bytes,3,opt,name=cq_status_url,json=cqStatusUrl" json:"cq_status_url,omitempty"`
	// Delay between commit bursts in seconds. Default value is 480.
	CommitBurstDelay *int32 `protobuf:"varint,4,opt,name=commit_burst_delay,json=commitBurstDelay" json:"commit_burst_delay,omitempty"`
	// Maximum number of commits done sequentially, before waiting for
	// commit_burst_delay. Default value is 4.
	MaxCommitBurst *int32 `protobuf:"varint,5,opt,name=max_commit_burst,json=maxCommitBurst" json:"max_commit_burst,omitempty"`
	// Configuration options for Rietveld code review.
	// DEPRECATED, will be removed.
	Rietveld *Rietveld `protobuf:"bytes,6,opt,name=rietveld" json:"rietveld,omitempty"`
	// Configuration options for Gerrit code review.
	Gerrit *Gerrit `protobuf:"bytes,7,opt,name=gerrit" json:"gerrit,omitempty"`
	// If present, the CQ will refrain from processing any CLs which CQ was
	// triggered after this time. Setting this time very far in the past will
	// effectively make CQ not process any CLs.
	//
	// This is an UTC RFC3339 (stiptime(tm)) string representing the time.
	// For example, "2017-12-23T15:47:58Z" and Z is required.
	DrainingStartTime *string `protobuf:"bytes,8,opt,name=draining_start_time,json=drainingStartTime" json:"draining_start_time,omitempty"`
	XXX_unrecognized  []byte  `json:"-"`
}

func (m *SharedConfig) Reset()                    { *m = SharedConfig{} }
func (m *SharedConfig) String() string            { return proto.CompactTextString(m) }
func (*SharedConfig) ProtoMessage()               {}
func (*SharedConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SharedConfig) GetRepos() []*SharedConfig_Repository {
	if m != nil {
		return m.Repos
	}
	return nil
}

func (m *SharedConfig) GetVerifiers() *Verifiers {
	if m != nil {
		return m.Verifiers
	}
	return nil
}

func (m *SharedConfig) GetCqStatusUrl() string {
	if m != nil && m.CqStatusUrl != nil {
		return *m.CqStatusUrl
	}
	return ""
}

func (m *SharedConfig) GetCommitBurstDelay() int32 {
	if m != nil && m.CommitBurstDelay != nil {
		return *m.CommitBurstDelay
	}
	return 0
}

func (m *SharedConfig) GetMaxCommitBurst() int32 {
	if m != nil && m.MaxCommitBurst != nil {
		return *m.MaxCommitBurst
	}
	return 0
}

func (m *SharedConfig) GetRietveld() *Rietveld {
	if m != nil {
		return m.Rietveld
	}
	return nil
}

func (m *SharedConfig) GetGerrit() *Gerrit {
	if m != nil {
		return m.Gerrit
	}
	return nil
}

func (m *SharedConfig) GetDrainingStartTime() string {
	if m != nil && m.DrainingStartTime != nil {
		return *m.DrainingStartTime
	}
	return ""
}

type SharedConfig_Repository struct {
	// Required. URL to repository and also its identifier.
	Url *string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// Refs to follow for the repository.
	// If this field is left unspecified, refs/heads/master will be used.
	Refs             []string `protobuf:"bytes,2,rep,name=refs" json:"refs,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *SharedConfig_Repository) Reset()                    { *m = SharedConfig_Repository{} }
func (m *SharedConfig_Repository) String() string            { return proto.CompactTextString(m) }
func (*SharedConfig_Repository) ProtoMessage()               {}
func (*SharedConfig_Repository) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

func (m *SharedConfig_Repository) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *SharedConfig_Repository) GetRefs() []string {
	if m != nil {
		return m.Refs
	}
	return nil
}

type Rietveld struct {
	// Required. URL of the codereview site.
	Url              *string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Rietveld) Reset()                    { *m = Rietveld{} }
func (m *Rietveld) String() string            { return proto.CompactTextString(m) }
func (*Rietveld) ProtoMessage()               {}
func (*Rietveld) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Rietveld) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

// Unlike Rietveld, Gerrit doesn't need a separate url.
// Instead, the Repository url must be specified on the Gerrit instance,
// and CQ will deduce Gerrit url from it.
// Also, gerrit_cq_ability verifier must be defined in case of Gerrit.
//
// For example, if https://chromium.googlesource.com/infra/infra.git is your
// repo url provided in `git_repo_url` above, then
// https://chromium-review.googlesource.com/#/admin/projects/infra/infra should
// show general properties of your project.
//
// Also,
// https://chromium-review.googlesource.com/#/admin/projects/infra/infra,access
// should show ACLs for refs in your project, but you may need to be admin to
// see it. This will come handy to enable and customize the CQ-related workflows
// for your project.
type Gerrit struct {
	// Optional. If set, tells CQ to vote on a given label to mark result of CQ
	// run.  The vote is either -1 if failed or 1 on success, and will be given on
	// non-dry runs only.
	// This vote can then be used in Gerrit's rule for submitting issues, so as to
	// require CQ run. CQ will attempt to submit issue only after setting this
	// label.
	CqVerifiedLabel *string `protobuf:"bytes,1,opt,name=cq_verified_label,json=cqVerifiedLabel" json:"cq_verified_label,omitempty"`
	// Optional and only allowed if cq_verified_label is set. Default: False.
	// If set, tells CQ to vote on the Verified label even on dry run.
	// This is useful if CQ has no presubmit builders, as dry run would be
	// totally equivalent to full run, except that CQ won't try to actually submit
	// the code.
	DryRunSetsCqVerifiedLabel *bool  `protobuf:"varint,2,opt,name=dry_run_sets_cq_verified_label,json=dryRunSetsCqVerifiedLabel" json:"dry_run_sets_cq_verified_label,omitempty"`
	XXX_unrecognized          []byte `json:"-"`
}

func (m *Gerrit) Reset()                    { *m = Gerrit{} }
func (m *Gerrit) String() string            { return proto.CompactTextString(m) }
func (*Gerrit) ProtoMessage()               {}
func (*Gerrit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Gerrit) GetCqVerifiedLabel() string {
	if m != nil && m.CqVerifiedLabel != nil {
		return *m.CqVerifiedLabel
	}
	return ""
}

func (m *Gerrit) GetDryRunSetsCqVerifiedLabel() bool {
	if m != nil && m.DryRunSetsCqVerifiedLabel != nil {
		return *m.DryRunSetsCqVerifiedLabel
	}
	return false
}

// Verifiers are various types of checks that a Commit Queue performs on a CL.
// All verifiers must pass in order for a CL to be landed. Configuration file
// describes types of verifiers that should be applied to each CL and their
// parameters.
type Verifiers struct {
	// [Rietveld only] This verifier is used to ensure that an LGTM was posted to
	// the code review site from a valid project committer. It also validates
	// ability of non-committers to trigger CQ, which for Gerrit is done by
	// GerritCQAbilityVerifier.
	ReviewerLgtm *Verifiers_ReviewerLgtmVerifier `protobuf:"bytes,1,opt,name=reviewer_lgtm,json=reviewerLgtm" json:"reviewer_lgtm,omitempty"`
	// [Gerrit only] GerritCQAbilityVerifier ensures that a user who triggered
	// this CQ attempt has actually rights to do so based on 3 factors:
	//  * membership of the user in committers & dryrunners group,
	//  * the state of CL/patchset on which CQ is triggered,
	//  * relationship of the user to the CL.
	// This verifier must be specified for Gerrit.
	GerritCqAbility *Verifiers_GerritCQAbilityVerifier `protobuf:"bytes,5,opt,name=gerrit_cq_ability,json=gerritCqAbility" json:"gerrit_cq_ability,omitempty"`
	// This verifier is used to check tree status before committing a CL. If the
	// tree is closed, then the verifier will wait until it is reopened.
	TreeStatus *Verifiers_TreeStatusLgtmVerifier `protobuf:"bytes,2,opt,name=tree_status,json=treeStatus" json:"tree_status,omitempty"`
	// This verifier triggers a set of tryjobs that are to be run on builders on
	// Buildbot. It automatically retries failed try-jobs and only allows CL to
	// land if each builder has succeeded in the latest retry. If a given tryjob
	// result is too old (>1 day) it is ignored.
	TryJob *Verifiers_TryJobVerifier `protobuf:"bytes,3,opt,name=try_job,json=tryJob" json:"try_job,omitempty"`
	// This verifier is used to ensure that the author has signed Google's
	// Contributor License Agreement.
	SignCla          *Verifiers_SignCLAVerifier `protobuf:"bytes,4,opt,name=sign_cla,json=signCla" json:"sign_cla,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *Verifiers) Reset()                    { *m = Verifiers{} }
func (m *Verifiers) String() string            { return proto.CompactTextString(m) }
func (*Verifiers) ProtoMessage()               {}
func (*Verifiers) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Verifiers) GetReviewerLgtm() *Verifiers_ReviewerLgtmVerifier {
	if m != nil {
		return m.ReviewerLgtm
	}
	return nil
}

func (m *Verifiers) GetGerritCqAbility() *Verifiers_GerritCQAbilityVerifier {
	if m != nil {
		return m.GerritCqAbility
	}
	return nil
}

func (m *Verifiers) GetTreeStatus() *Verifiers_TreeStatusLgtmVerifier {
	if m != nil {
		return m.TreeStatus
	}
	return nil
}

func (m *Verifiers) GetTryJob() *Verifiers_TryJobVerifier {
	if m != nil {
		return m.TryJob
	}
	return nil
}

func (m *Verifiers) GetSignCla() *Verifiers_SignCLAVerifier {
	if m != nil {
		return m.SignCla
	}
	return nil
}

type Verifiers_ReviewerLgtmVerifier struct {
	// Required. Name of the chrome-infra-auth group, which contains the list of
	// identities authorized to approve (lgtm) a CL and trigger CQ run or dry
	// run.
	CommitterList *string `protobuf:"bytes,1,opt,name=committer_list,json=committerList" json:"committer_list,omitempty"`
	// Number of seconds to wait for LGTM on CQ. Default value is 0.
	MaxWaitSecs *int32 `protobuf:"varint,2,opt,name=max_wait_secs,json=maxWaitSecs" json:"max_wait_secs,omitempty"`
	// Message to be posted to code review site when no LGTM is found. Default
	// value is "No LGTM from a valid reviewer yet. Only full committers are "
	// "accepted.\nEven if an LGTM may have been provided, it was from a "
	// "non-committer,\n_not_ a full super star committer.\nSee "
	// "http://www.chromium.org/getting-involved/become-a-committer\nNote that "
	// "this has nothing to do with OWNERS files."
	NoLgtmMsg *string `protobuf:"bytes,3,opt,name=no_lgtm_msg,json=noLgtmMsg" json:"no_lgtm_msg,omitempty"`
	// Optional, but recommended. Name of the chrome-infra-auth group,
	// which contains the list of identities authorized to trigger CQ dry run.
	// This is usually the same group as tryjob-access.
	DryRunAccessList *string `protobuf:"bytes,4,opt,name=dry_run_access_list,json=dryRunAccessList" json:"dry_run_access_list,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Verifiers_ReviewerLgtmVerifier) Reset()         { *m = Verifiers_ReviewerLgtmVerifier{} }
func (m *Verifiers_ReviewerLgtmVerifier) String() string { return proto.CompactTextString(m) }
func (*Verifiers_ReviewerLgtmVerifier) ProtoMessage()    {}
func (*Verifiers_ReviewerLgtmVerifier) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

func (m *Verifiers_ReviewerLgtmVerifier) GetCommitterList() string {
	if m != nil && m.CommitterList != nil {
		return *m.CommitterList
	}
	return ""
}

func (m *Verifiers_ReviewerLgtmVerifier) GetMaxWaitSecs() int32 {
	if m != nil && m.MaxWaitSecs != nil {
		return *m.MaxWaitSecs
	}
	return 0
}

func (m *Verifiers_ReviewerLgtmVerifier) GetNoLgtmMsg() string {
	if m != nil && m.NoLgtmMsg != nil {
		return *m.NoLgtmMsg
	}
	return ""
}

func (m *Verifiers_ReviewerLgtmVerifier) GetDryRunAccessList() string {
	if m != nil && m.DryRunAccessList != nil {
		return *m.DryRunAccessList
	}
	return ""
}

type Verifiers_GerritCQAbilityVerifier struct {
	// Required. Name of the chrome-infra-auth group, which contains the list of
	// identities authorized to trigger CQ runs on any CLs in this project.
	CommitterList *string `protobuf:"bytes,1,opt,name=committer_list,json=committerList" json:"committer_list,omitempty"`
	// Optional, but strongly recommended. Name of the chrome-infra-auth group,
	// which contains the list of identities authorized to trigger CQ dry run
	// on Gerrit CLs they own (not to be confused with OWNER files) even if CL
	// hasn't been approved.
	// This is usually the same group as tryjob-access.
	DryRunAccessList *string `protobuf:"bytes,4,opt,name=dry_run_access_list,json=dryRunAccessList" json:"dry_run_access_list,omitempty"`
	// Optional. allow_submit_with_open_deps controls how CQ full run behaves
	// when current Gerrit CL has open dependencies (not yet submitted CLs on
	// which *this* CL depends).
	//
	// If set to false (default), CQ will abort full run attempt immediately if
	// open dependencies are detected.
	//
	// If set to true, then CQ will not abort full run and upon passing all
	// other verifiers, CQ will attempt to submit the CL regardless of open
	// dependencies. In turn, if Gerrit project config allows this, Gerrit will
	// execute submit all dependent CLs first and then this CL.
	AllowSubmitWithOpenDeps *bool  `protobuf:"varint,5,opt,name=allow_submit_with_open_deps,json=allowSubmitWithOpenDeps" json:"allow_submit_with_open_deps,omitempty"`
	XXX_unrecognized        []byte `json:"-"`
}

func (m *Verifiers_GerritCQAbilityVerifier) Reset()         { *m = Verifiers_GerritCQAbilityVerifier{} }
func (m *Verifiers_GerritCQAbilityVerifier) String() string { return proto.CompactTextString(m) }
func (*Verifiers_GerritCQAbilityVerifier) ProtoMessage()    {}
func (*Verifiers_GerritCQAbilityVerifier) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 1}
}

func (m *Verifiers_GerritCQAbilityVerifier) GetCommitterList() string {
	if m != nil && m.CommitterList != nil {
		return *m.CommitterList
	}
	return ""
}

func (m *Verifiers_GerritCQAbilityVerifier) GetDryRunAccessList() string {
	if m != nil && m.DryRunAccessList != nil {
		return *m.DryRunAccessList
	}
	return ""
}

func (m *Verifiers_GerritCQAbilityVerifier) GetAllowSubmitWithOpenDeps() bool {
	if m != nil && m.AllowSubmitWithOpenDeps != nil {
		return *m.AllowSubmitWithOpenDeps
	}
	return false
}

type Verifiers_TreeStatusLgtmVerifier struct {
	// Required. URL of the project tree status app.
	TreeStatusUrl    *string `protobuf:"bytes,1,opt,name=tree_status_url,json=treeStatusUrl" json:"tree_status_url,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Verifiers_TreeStatusLgtmVerifier) Reset()         { *m = Verifiers_TreeStatusLgtmVerifier{} }
func (m *Verifiers_TreeStatusLgtmVerifier) String() string { return proto.CompactTextString(m) }
func (*Verifiers_TreeStatusLgtmVerifier) ProtoMessage()    {}
func (*Verifiers_TreeStatusLgtmVerifier) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 2}
}

func (m *Verifiers_TreeStatusLgtmVerifier) GetTreeStatusUrl() string {
	if m != nil && m.TreeStatusUrl != nil {
		return *m.TreeStatusUrl
	}
	return ""
}

type Verifiers_TryJobVerifier struct {
	// Buckets on which tryjobs are triggered/watched.
	Buckets []*Verifiers_TryJobVerifier_Bucket `protobuf:"bytes,1,rep,name=buckets" json:"buckets,omitempty"`
	// Provides project specific trybot retry configuration. This overrides the
	// defaults used in the CQ.
	TryJobRetryConfig *Verifiers_TryJobVerifier_TryJobRetryConfig `protobuf:"bytes,2,opt,name=try_job_retry_config,json=tryJobRetryConfig" json:"try_job_retry_config,omitempty"`
	XXX_unrecognized  []byte                                      `json:"-"`
}

func (m *Verifiers_TryJobVerifier) Reset()                    { *m = Verifiers_TryJobVerifier{} }
func (m *Verifiers_TryJobVerifier) String() string            { return proto.CompactTextString(m) }
func (*Verifiers_TryJobVerifier) ProtoMessage()               {}
func (*Verifiers_TryJobVerifier) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 3} }

func (m *Verifiers_TryJobVerifier) GetBuckets() []*Verifiers_TryJobVerifier_Bucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

func (m *Verifiers_TryJobVerifier) GetTryJobRetryConfig() *Verifiers_TryJobVerifier_TryJobRetryConfig {
	if m != nil {
		return m.TryJobRetryConfig
	}
	return nil
}

type Verifiers_TryJobVerifier_EquivalentBuilder struct {
	// Required. Bucket name of this builder.
	Bucket *string `protobuf:"bytes,1,opt,name=bucket" json:"bucket,omitempty"`
	// Required. Name of this builder.
	Builder *string `protobuf:"bytes,2,opt,name=builder" json:"builder,omitempty"`
	// Percentage expressing probability of CQ requiring this builder
	// instead of the builder to which this builder is equilvanet to.
	//
	// If not specified, defaults to 50.
	//
	// A choice itself is made deterministicly based on CL alone, hereby
	// all CQ attempts on all patchsets of a given CL will require the same
	// builder, assuming CQ config doesn't change in the mean time.
	//
	// Note that if `owner_whitelist_group` is also specified, the choice over
	// two builders will be made only for CLs owned by whitelisted group.
	//
	// To illustrate, suppose percentage=10. Then,
	//   Without owner_whitelist_group,
	//      ~10% of all CQ attempts will choose this builder.
	//   With owner_whitelist_group set and, suppose, 1/5 of CQ attempts are
	//      ran on CLs owned by this group, then only ~(1/10)*(1/5) or
	//      ~2% of all CQ attempts will choose this builder.
	Percentage *int32 `protobuf:"varint,3,opt,name=percentage" json:"percentage,omitempty"`
	// If not specified, limits the builder to CL owners in this group.
	OwnerWhitelistGroup *string `protobuf:"bytes,4,opt,name=owner_whitelist_group,json=ownerWhitelistGroup" json:"owner_whitelist_group,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *Verifiers_TryJobVerifier_EquivalentBuilder) Reset() {
	*m = Verifiers_TryJobVerifier_EquivalentBuilder{}
}
func (m *Verifiers_TryJobVerifier_EquivalentBuilder) String() string {
	return proto.CompactTextString(m)
}
func (*Verifiers_TryJobVerifier_EquivalentBuilder) ProtoMessage() {}
func (*Verifiers_TryJobVerifier_EquivalentBuilder) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 3, 0}
}

func (m *Verifiers_TryJobVerifier_EquivalentBuilder) GetBucket() string {
	if m != nil && m.Bucket != nil {
		return *m.Bucket
	}
	return ""
}

func (m *Verifiers_TryJobVerifier_EquivalentBuilder) GetBuilder() string {
	if m != nil && m.Builder != nil {
		return *m.Builder
	}
	return ""
}

func (m *Verifiers_TryJobVerifier_EquivalentBuilder) GetPercentage() int32 {
	if m != nil && m.Percentage != nil {
		return *m.Percentage
	}
	return 0
}

func (m *Verifiers_TryJobVerifier_EquivalentBuilder) GetOwnerWhitelistGroup() string {
	if m != nil && m.OwnerWhitelistGroup != nil {
		return *m.OwnerWhitelistGroup
	}
	return ""
}

type Verifiers_TryJobVerifier_Builder struct {
	// Name of the builder.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Optionally specify a builder name that triggers the given builder.
	// Otherwise, CQ will trigger this builder (default). If in doubt, you
	// probably won't need this.
	TriggeredBy *string `protobuf:"bytes,2,opt,name=triggered_by,json=triggeredBy" json:"triggered_by,omitempty"`
	// When this field is present, it marks given builder as experimental. It
	// is only executed on a given percentage of the CLs and the outcome does
	// not affect the decicion whether a CL can land or not. This is typically
	// used to test new builders and estimate their capacity requirements.
	ExperimentPercentage *float32 `protobuf:"fixed32,4,opt,name=experiment_percentage,json=experimentPercentage" json:"experiment_percentage,omitempty"`
	// Optionally specified alternative builder for CQ to choose instead.
	// If provided, CQ will choose only one of the equivalent builders as
	// required based purely on given CL and CL's owner and **regardless** of
	// the possibly already completed try jobs.
	//
	// Note: none of the equivalent builders should be part of triggered_by
	//  chain, although CQ may eventually relax this requirement somewhat.
	EquivalentTo     *Verifiers_TryJobVerifier_EquivalentBuilder `protobuf:"bytes,5,opt,name=equivalent_to,json=equivalentTo" json:"equivalent_to,omitempty"`
	XXX_unrecognized []byte                                      `json:"-"`
}

func (m *Verifiers_TryJobVerifier_Builder) Reset()         { *m = Verifiers_TryJobVerifier_Builder{} }
func (m *Verifiers_TryJobVerifier_Builder) String() string { return proto.CompactTextString(m) }
func (*Verifiers_TryJobVerifier_Builder) ProtoMessage()    {}
func (*Verifiers_TryJobVerifier_Builder) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 3, 1}
}

func (m *Verifiers_TryJobVerifier_Builder) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Verifiers_TryJobVerifier_Builder) GetTriggeredBy() string {
	if m != nil && m.TriggeredBy != nil {
		return *m.TriggeredBy
	}
	return ""
}

func (m *Verifiers_TryJobVerifier_Builder) GetExperimentPercentage() float32 {
	if m != nil && m.ExperimentPercentage != nil {
		return *m.ExperimentPercentage
	}
	return 0
}

func (m *Verifiers_TryJobVerifier_Builder) GetEquivalentTo() *Verifiers_TryJobVerifier_EquivalentBuilder {
	if m != nil {
		return m.EquivalentTo
	}
	return nil
}

type Verifiers_TryJobVerifier_Bucket struct {
	// Name of the bucket. This is typically the same as a master name without
	// the 'master.' prefix, e.g. 'chromium.linux' or 'tryserver.webrtc'. CQ
	// will automatically add 'master.' prefix if not there.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Builders on which tryjobs should be triggered.
	Builders         []*Verifiers_TryJobVerifier_Builder `protobuf:"bytes,2,rep,name=builders" json:"builders,omitempty"`
	XXX_unrecognized []byte                              `json:"-"`
}

func (m *Verifiers_TryJobVerifier_Bucket) Reset()         { *m = Verifiers_TryJobVerifier_Bucket{} }
func (m *Verifiers_TryJobVerifier_Bucket) String() string { return proto.CompactTextString(m) }
func (*Verifiers_TryJobVerifier_Bucket) ProtoMessage()    {}
func (*Verifiers_TryJobVerifier_Bucket) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 3, 2}
}

func (m *Verifiers_TryJobVerifier_Bucket) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *Verifiers_TryJobVerifier_Bucket) GetBuilders() []*Verifiers_TryJobVerifier_Builder {
	if m != nil {
		return m.Builders
	}
	return nil
}

type Verifiers_TryJobVerifier_TryJobRetryConfig struct {
	// Retry quota for a single tryjob.
	TryJobRetryQuota *int32 `protobuf:"varint,1,opt,name=try_job_retry_quota,json=tryJobRetryQuota" json:"try_job_retry_quota,omitempty"`
	// Retry quota for all tryjobs in a CL.
	GlobalRetryQuota *int32 `protobuf:"varint,2,opt,name=global_retry_quota,json=globalRetryQuota" json:"global_retry_quota,omitempty"`
	// The weight assigned to each tryjob failure.
	FailureRetryWeight *int32 `protobuf:"varint,3,opt,name=failure_retry_weight,json=failureRetryWeight" json:"failure_retry_weight,omitempty"`
	// The weight assigned to each transient failure.
	TransientFailureRetryWeight *int32 `protobuf:"varint,4,opt,name=transient_failure_retry_weight,json=transientFailureRetryWeight" json:"transient_failure_retry_weight,omitempty"`
	// The weight assigned to tryjob timeouts.
	TimeoutRetryWeight *int32 `protobuf:"varint,5,opt,name=timeout_retry_weight,json=timeoutRetryWeight" json:"timeout_retry_weight,omitempty"`
	XXX_unrecognized   []byte `json:"-"`
}

func (m *Verifiers_TryJobVerifier_TryJobRetryConfig) Reset() {
	*m = Verifiers_TryJobVerifier_TryJobRetryConfig{}
}
func (m *Verifiers_TryJobVerifier_TryJobRetryConfig) String() string {
	return proto.CompactTextString(m)
}
func (*Verifiers_TryJobVerifier_TryJobRetryConfig) ProtoMessage() {}
func (*Verifiers_TryJobVerifier_TryJobRetryConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 3, 3}
}

func (m *Verifiers_TryJobVerifier_TryJobRetryConfig) GetTryJobRetryQuota() int32 {
	if m != nil && m.TryJobRetryQuota != nil {
		return *m.TryJobRetryQuota
	}
	return 0
}

func (m *Verifiers_TryJobVerifier_TryJobRetryConfig) GetGlobalRetryQuota() int32 {
	if m != nil && m.GlobalRetryQuota != nil {
		return *m.GlobalRetryQuota
	}
	return 0
}

func (m *Verifiers_TryJobVerifier_TryJobRetryConfig) GetFailureRetryWeight() int32 {
	if m != nil && m.FailureRetryWeight != nil {
		return *m.FailureRetryWeight
	}
	return 0
}

func (m *Verifiers_TryJobVerifier_TryJobRetryConfig) GetTransientFailureRetryWeight() int32 {
	if m != nil && m.TransientFailureRetryWeight != nil {
		return *m.TransientFailureRetryWeight
	}
	return 0
}

func (m *Verifiers_TryJobVerifier_TryJobRetryConfig) GetTimeoutRetryWeight() int32 {
	if m != nil && m.TimeoutRetryWeight != nil {
		return *m.TimeoutRetryWeight
	}
	return 0
}

type Verifiers_SignCLAVerifier struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *Verifiers_SignCLAVerifier) Reset()                    { *m = Verifiers_SignCLAVerifier{} }
func (m *Verifiers_SignCLAVerifier) String() string            { return proto.CompactTextString(m) }
func (*Verifiers_SignCLAVerifier) ProtoMessage()               {}
func (*Verifiers_SignCLAVerifier) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 4} }

func init() {
	proto.RegisterType((*Config)(nil), "Config")
	proto.RegisterType((*SharedConfig)(nil), "SharedConfig")
	proto.RegisterType((*SharedConfig_Repository)(nil), "SharedConfig.Repository")
	proto.RegisterType((*Rietveld)(nil), "Rietveld")
	proto.RegisterType((*Gerrit)(nil), "Gerrit")
	proto.RegisterType((*Verifiers)(nil), "Verifiers")
	proto.RegisterType((*Verifiers_ReviewerLgtmVerifier)(nil), "Verifiers.ReviewerLgtmVerifier")
	proto.RegisterType((*Verifiers_GerritCQAbilityVerifier)(nil), "Verifiers.GerritCQAbilityVerifier")
	proto.RegisterType((*Verifiers_TreeStatusLgtmVerifier)(nil), "Verifiers.TreeStatusLgtmVerifier")
	proto.RegisterType((*Verifiers_TryJobVerifier)(nil), "Verifiers.TryJobVerifier")
	proto.RegisterType((*Verifiers_TryJobVerifier_EquivalentBuilder)(nil), "Verifiers.TryJobVerifier.EquivalentBuilder")
	proto.RegisterType((*Verifiers_TryJobVerifier_Builder)(nil), "Verifiers.TryJobVerifier.Builder")
	proto.RegisterType((*Verifiers_TryJobVerifier_Bucket)(nil), "Verifiers.TryJobVerifier.Bucket")
	proto.RegisterType((*Verifiers_TryJobVerifier_TryJobRetryConfig)(nil), "Verifiers.TryJobVerifier.TryJobRetryConfig")
	proto.RegisterType((*Verifiers_SignCLAVerifier)(nil), "Verifiers.SignCLAVerifier")
}

func init() { proto.RegisterFile("cq.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1057 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0x5b, 0x6f, 0x1b, 0x45,
	0x14, 0x96, 0x73, 0xf1, 0xe5, 0x38, 0x6e, 0xec, 0x69, 0xda, 0x6e, 0x5d, 0x94, 0xa6, 0x96, 0x00,
	0x73, 0xb3, 0x2a, 0x23, 0x5e, 0x10, 0x48, 0xc4, 0x2e, 0x54, 0x82, 0x00, 0xed, 0x3a, 0x25, 0x0f,
	0x20, 0x8d, 0xc6, 0xeb, 0x93, 0xcd, 0xc0, 0x5e, 0xec, 0x99, 0xd9, 0x38, 0xfe, 0x09, 0xbc, 0xf7,
	0xa5, 0x3f, 0x02, 0x89, 0x7f, 0xc1, 0xdf, 0x42, 0x73, 0xd9, 0xf5, 0xba, 0x49, 0x2a, 0x78, 0xdb,
	0x3d, 0xdf, 0xf7, 0xcd, 0x39, 0x73, 0xce, 0x37, 0x33, 0x50, 0x0f, 0x16, 0x83, 0xb9, 0x48, 0x55,
	0xda, 0xfb, 0x01, 0xaa, 0xe3, 0x34, 0x39, 0xe7, 0x21, 0xf1, 0xa0, 0x76, 0x89, 0x42, 0xf2, 0x34,
	0xf1, 0x2a, 0x47, 0x95, 0xfe, 0xae, 0x9f, 0xff, 0x92, 0x0f, 0xa1, 0x16, 0x18, 0x8e, 0xf4, 0xb6,
	0x8e, 0xb6, 0xfb, 0xcd, 0x61, 0x6b, 0x30, 0xb9, 0x60, 0x02, 0x67, 0x56, 0xe9, 0xe7, 0x68, 0xef,
	0xf5, 0x36, 0xec, 0x95, 0x11, 0x32, 0x80, 0x5d, 0x81, 0xf3, 0x54, 0x7a, 0x15, 0xa3, 0xf3, 0x36,
	0x74, 0x03, 0x5f, 0x43, 0x5c, 0xa5, 0x62, 0xe5, 0x5b, 0x1a, 0xe9, 0x43, 0xe3, 0x12, 0x05, 0x3f,
	0xe7, 0x28, 0x74, 0xae, 0x4a, 0xbf, 0x39, 0x84, 0xc1, 0x2f, 0x79, 0xc4, 0x5f, 0x83, 0xa4, 0x07,
	0xad, 0x60, 0x41, 0xa5, 0x62, 0x2a, 0x93, 0x34, 0x13, 0x91, 0xb7, 0x7d, 0x54, 0xe9, 0x37, 0xfc,
	0x66, 0xb0, 0x98, 0x98, 0xd8, 0x2b, 0x11, 0x91, 0x4f, 0x81, 0x04, 0x69, 0x1c, 0x73, 0x45, 0xa7,
	0x99, 0x90, 0x8a, 0xce, 0x30, 0x62, 0x2b, 0x6f, 0xc7, 0x6c, 0xae, 0x6d, 0x91, 0x91, 0x06, 0x9e,
	0xe9, 0x38, 0xe9, 0x43, 0x3b, 0x66, 0x57, 0xb4, 0xac, 0xf0, 0x76, 0x0d, 0xf7, 0x4e, 0xcc, 0xae,
	0xc6, 0x6b, 0x3a, 0xf9, 0x08, 0xea, 0x82, 0xa3, 0xba, 0xc4, 0x68, 0xe6, 0x55, 0x4d, 0x91, 0x8d,
	0x81, 0xef, 0x02, 0xa3, 0x2d, 0xaf, 0xe2, 0x17, 0x30, 0x79, 0x0c, 0xd5, 0x10, 0x85, 0xe0, 0xca,
	0xab, 0x19, 0x62, 0x6d, 0xf0, 0xdc, 0xfc, 0xfa, 0x2e, 0x4c, 0x06, 0x70, 0x77, 0x26, 0x18, 0x4f,
	0x78, 0x12, 0xea, 0xdd, 0x08, 0x45, 0x15, 0x8f, 0xd1, 0xab, 0x9b, 0xdd, 0x74, 0x72, 0x68, 0xa2,
	0x91, 0x53, 0x1e, 0x63, 0x77, 0x08, 0xb0, 0x6e, 0x1b, 0x69, 0xc3, 0xb6, 0xde, 0x7b, 0xc5, 0xb0,
	0xf5, 0x27, 0x21, 0xb0, 0x23, 0xf0, 0xdc, 0x0e, 0xaa, 0xe1, 0x9b, 0xef, 0xde, 0x7b, 0x50, 0xcf,
	0xcb, 0xbb, 0xae, 0xe8, 0x2d, 0xa1, 0x6a, 0x6b, 0x22, 0x1f, 0x43, 0x27, 0x58, 0x50, 0xd7, 0xe3,
	0x19, 0x8d, 0xd8, 0x14, 0x73, 0xe6, 0x7e, 0xb0, 0x70, 0x63, 0x98, 0x9d, 0xe8, 0x30, 0x39, 0x86,
	0xc3, 0x99, 0x58, 0x51, 0x91, 0x25, 0x54, 0xa2, 0x92, 0xf4, 0xba, 0x50, 0x8f, 0xaf, 0xee, 0x3f,
	0x9c, 0x89, 0x95, 0x9f, 0x25, 0x13, 0x54, 0x72, 0xbc, 0xb9, 0x44, 0xef, 0x75, 0x0b, 0x1a, 0xc5,
	0x6c, 0xc9, 0x33, 0x68, 0x09, 0xbc, 0xe4, 0xb8, 0x44, 0x41, 0xa3, 0x50, 0xc5, 0x26, 0x71, 0x73,
	0xf8, 0x78, 0x3d, 0xfe, 0x81, 0xef, 0xf0, 0x93, 0x50, 0xc5, 0x79, 0xd4, 0xdf, 0x13, 0xa5, 0x28,
	0xf9, 0x09, 0x3a, 0xb6, 0xb1, 0xba, 0x20, 0x36, 0xe5, 0x11, 0x57, 0x2b, 0x33, 0xc5, 0xe6, 0xb0,
	0x57, 0x5a, 0xc9, 0x6e, 0x78, 0xfc, 0xf2, 0xd8, 0x32, 0x8a, 0xc5, 0xf6, 0xad, 0x78, 0xbc, 0x70,
	0x00, 0x19, 0x41, 0x53, 0x09, 0x44, 0x67, 0x34, 0x67, 0xc9, 0x27, 0xa5, 0x95, 0x4e, 0x05, 0xa2,
	0x75, 0xdc, 0x46, 0x55, 0xa0, 0x8a, 0x38, 0x19, 0x42, 0x4d, 0x89, 0x15, 0xfd, 0x3d, 0x9d, 0x1a,
	0x93, 0x36, 0x87, 0x0f, 0x37, 0xf4, 0xab, 0xef, 0xd3, 0x69, 0xa1, 0xab, 0x2a, 0xf3, 0x4f, 0xbe,
	0x80, 0xba, 0xe4, 0x61, 0x42, 0x83, 0x88, 0x19, 0xc3, 0x36, 0x87, 0xdd, 0x92, 0x68, 0xc2, 0xc3,
	0x64, 0x7c, 0x72, 0x5c, 0xa8, 0x6a, 0x9a, 0x3b, 0x8e, 0x58, 0xf7, 0xef, 0x0a, 0x1c, 0xdc, 0xd4,
	0x25, 0xf2, 0x3e, 0xdc, 0xb1, 0xc6, 0x56, 0xba, 0xbd, 0x5c, 0x2a, 0x37, 0xd7, 0x56, 0x11, 0x3d,
	0xe1, 0x52, 0xe9, 0x53, 0xa5, 0xcf, 0xc0, 0x92, 0x71, 0x45, 0x25, 0x06, 0x76, 0xc3, 0xbb, 0x7e,
	0x33, 0x66, 0x57, 0x67, 0x8c, 0xab, 0x09, 0x06, 0x92, 0x1c, 0x42, 0x33, 0x49, 0xcd, 0x88, 0x68,
	0x2c, 0x43, 0x77, 0xee, 0x1a, 0x49, 0xaa, 0xf3, 0xfd, 0x28, 0x43, 0xf2, 0x99, 0x76, 0xb4, 0x75,
	0x06, 0x0b, 0x02, 0x94, 0xd2, 0xe6, 0xdb, 0x31, 0xbc, 0xb6, 0xb5, 0xc3, 0xb1, 0x01, 0x74, 0xca,
	0xee, 0x5f, 0x15, 0x78, 0x70, 0xcb, 0x38, 0xfe, 0x6b, 0xd5, 0xff, 0x2f, 0x23, 0xf9, 0x0a, 0x1e,
	0xb1, 0x28, 0x4a, 0x97, 0x54, 0x66, 0x53, 0x7d, 0xd4, 0x97, 0x5c, 0x5d, 0xd0, 0x74, 0x8e, 0x09,
	0x9d, 0xe1, 0x5c, 0x1a, 0xb7, 0xd4, 0xfd, 0x07, 0x86, 0x32, 0x31, 0x8c, 0x33, 0xae, 0x2e, 0x7e,
	0x9e, 0x63, 0xf2, 0x0c, 0xe7, 0xb2, 0xfb, 0x0d, 0xdc, 0xbf, 0x79, 0xe6, 0xe4, 0x03, 0xd8, 0x2f,
	0x79, 0x85, 0xae, 0x8f, 0x59, 0x6b, 0x6d, 0x86, 0x57, 0x22, 0xea, 0xfe, 0x59, 0x83, 0x3b, 0x9b,
	0x63, 0x27, 0x5f, 0x42, 0x6d, 0x9a, 0x05, 0x7f, 0xa0, 0xca, 0x6f, 0xca, 0xa3, 0x5b, 0x2d, 0x32,
	0x18, 0x19, 0xa2, 0x9f, 0x0b, 0xc8, 0x6f, 0x70, 0xe0, 0xec, 0x45, 0x05, 0xea, 0x2f, 0x7b, 0x1b,
	0x3b, 0xaf, 0x7e, 0x72, 0xfb, 0x42, 0xf6, 0xd7, 0xd7, 0x1a, 0x77, 0x91, 0x77, 0xd4, 0xdb, 0xa1,
	0xee, 0x9b, 0x0a, 0x74, 0xbe, 0x5d, 0x64, 0xfc, 0x92, 0x45, 0x98, 0xa8, 0x51, 0xc6, 0xa3, 0x19,
	0x0a, 0x72, 0x1f, 0xaa, 0x36, 0xbd, 0xdb, 0xa1, 0xfb, 0xd3, 0x6f, 0xc8, 0xd4, 0x52, 0x4c, 0xfa,
	0x86, 0x9f, 0xff, 0x92, 0x43, 0x80, 0x39, 0x8a, 0x00, 0x13, 0xc5, 0x42, 0x34, 0xa6, 0xd9, 0xf5,
	0x4b, 0x11, 0x32, 0x84, 0x7b, 0xe9, 0x32, 0x41, 0x41, 0x97, 0x17, 0x5c, 0xa1, 0x9e, 0x1f, 0x0d,
	0x45, 0x9a, 0xcd, 0xdd, 0x14, 0xef, 0x1a, 0xf0, 0x2c, 0xc7, 0x9e, 0x6b, 0xa8, 0xfb, 0x4f, 0x05,
	0x6a, 0x79, 0x45, 0x04, 0x76, 0x12, 0x16, 0xa3, 0xab, 0xc7, 0x7c, 0x93, 0x27, 0xb0, 0xa7, 0x04,
	0x0f, 0x43, 0x14, 0x38, 0xa3, 0xd3, 0x95, 0x2b, 0xa9, 0x59, 0xc4, 0x46, 0x2b, 0xf2, 0x39, 0xdc,
	0xc3, 0xab, 0x39, 0x0a, 0x1e, 0x63, 0xa2, 0x68, 0xa9, 0x42, 0x9d, 0x76, 0xcb, 0x3f, 0x58, 0x83,
	0x2f, 0xd6, 0xb5, 0xbe, 0x80, 0x16, 0x16, 0x2d, 0xa1, 0x2a, 0x75, 0x17, 0xcc, 0x3b, 0x5a, 0x7d,
	0xad, 0x83, 0xfe, 0xde, 0x7a, 0x85, 0xd3, 0xb4, 0xfb, 0x2b, 0x54, 0xed, 0x58, 0x6f, 0xdc, 0xc7,
	0xd7, 0x50, 0x77, 0x6d, 0xcc, 0x1f, 0xe0, 0x27, 0xef, 0xb2, 0x87, 0x4d, 0x50, 0x48, 0xba, 0x6f,
	0xb6, 0xa0, 0x73, 0x6d, 0xd6, 0xfa, 0xd0, 0x6c, 0xda, 0x66, 0x91, 0xa5, 0x8a, 0xb9, 0xa7, 0xbf,
	0x5d, 0x32, 0xc2, 0x4b, 0x1d, 0xd7, 0x6f, 0x69, 0x18, 0xa5, 0x53, 0x16, 0x6d, 0xb0, 0xed, 0xf5,
	0xd0, 0xb6, 0x48, 0x89, 0xfd, 0x14, 0x0e, 0xce, 0x19, 0x8f, 0x32, 0x81, 0x8e, 0xbe, 0x44, 0x1e,
	0x5e, 0x28, 0x37, 0x77, 0xe2, 0x30, 0x23, 0x38, 0x33, 0x08, 0x19, 0xc3, 0xa1, 0x12, 0x2c, 0x91,
	0x5c, 0xb7, 0xf4, 0x46, 0xad, 0x7d, 0xb7, 0x1f, 0x15, 0xac, 0xef, 0xae, 0x2f, 0xf2, 0x14, 0x0e,
	0xf4, 0xeb, 0x99, 0x66, 0x6a, 0x53, 0x6a, 0x9f, 0x71, 0xe2, 0xb0, 0x92, 0xa2, 0xdb, 0x81, 0xfd,
	0xb7, 0x2e, 0xd3, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf0, 0x53, 0x28, 0xaa, 0x1c, 0x09, 0x00,
	0x00,
}
